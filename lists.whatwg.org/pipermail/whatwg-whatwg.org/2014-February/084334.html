<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] hit regions: limited set of elements for fallback	content
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20hit%20regions%3A%20limited%20set%20of%20elements%20for%20fallback%0A%09content&In-Reply-To=%3CCAFz-FYw90%2BxqZUTKYkjpm%3D5fhMuge-_1WDFHXyXPxue_tUWx1Q%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="084304.html">
   <LINK REL="Next"  HREF="084346.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] hit regions: limited set of elements for fallback	content</H1>
<!--htdig_noindex-->
    <B>Dominic Mazzoni</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20hit%20regions%3A%20limited%20set%20of%20elements%20for%20fallback%0A%09content&In-Reply-To=%3CCAFz-FYw90%2BxqZUTKYkjpm%3D5fhMuge-_1WDFHXyXPxue_tUWx1Q%40mail.gmail.com%3E"
       TITLE="[whatwg] hit regions: limited set of elements for fallback	content">dmazzoni at google.com
       </A><BR>
    <I>Thu Feb 20 01:09:17 PST 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="084304.html">[whatwg] hit regions: limited set of elements for fallback content
</A></li>
        <LI>Next message: <A HREF="084346.html">[whatwg] hit regions: limited set of elements for fallback content
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#84334">[ date ]</a>
              <a href="thread.html#84334">[ thread ]</a>
              <a href="subject.html#84334">[ subject ]</a>
              <a href="author.html#84334">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>First a high-level thought.

I'm happy to keep chasing after &quot;legitimate&quot; use-cases instead of contrived
ones, but just because we can't think of one, doesn't mean it doesn't
exist. As Alan Perlis said, &quot;Every program has (at least) two purposes: the
one for which it was written and another for which it wasn't. Maybe the
vast majority of web apps that use canvas for a grid, or a slider, or a
list box would be better off using standard html5 objects. But what if
there's one app that can't, for some reason we haven't anticipated? If we
wait until that app appears to allow that control to have a hit region,
then it will be months or years before that app can be accessible.

More below:

On Tue, Feb 18, 2014 at 1:16 PM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:

&gt;<i> On Tue, 18 Feb 2014, Dominic Mazzoni wrote:
</I>&gt;<i> &gt; On Tue, Feb 18, 2014 at 10:51 AM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; I'm curious if it's possible to implement an accessible list box or
</I>&gt;<i> &gt; &gt; &gt; other select control in a canvas. Wouldn't it be possible to make it
</I>&gt;<i> &gt; &gt; &gt; accessible if the canvas lets you focus the list box by clicking on
</I>&gt;<i> &gt; &gt; &gt; its hit region, and then change the selection using the arrow keys?
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; What's the concrete use case?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; How can I get more concrete than there's a list box inside a canvas?
</I>&gt;<i>
</I>&gt;<i> Well for example, is the use case one of the controls on Bugzilla's
</I>&gt;<i> advanced search page?:
</I>&gt;<i>
</I>&gt;<i>    <A HREF="https://www.w3.org/Bugs/Public/query.cgi?format=advanced">https://www.w3.org/Bugs/Public/query.cgi?format=advanced</A>
</I>&gt;<i>
</I>&gt;<i> If so, I feel comfortable saying that we don't need to make &lt;canvas&gt;
</I>&gt;<i> support that, since that use case is already handled very well by the
</I>&gt;<i> &lt;select&gt; element.
</I>&gt;<i>
</I>
As I argued above, maybe we can't come up with a really good use-case, but
that doesn't mean one doesn't exist.

I'll try, though: what if I had a list of choices displayed as a pie chart?
Each slice of the pie is a focusable object that, when you click on it,
allows you to take an action on that pie slice.

Surely you'd agree that rendering a pie chart is a natural use-case for the
canvas element. I know it's technically possible in css, but it's quite
tricky - whereas it's simple and natural in canvas. And there are plenty of
shapes that are basically impossible in pure CSS.

But how should the list of pie slices behave if you were interacting with
the pie chart using the keyboard? Why not a list box? Conceptually you just
have a list of elements, one of which can be selected at a time.

&gt;<i> Whether or not we think it's a good idea, people are building entire UIs
</I>&gt;<i> &gt; using canvas. Sometimes it's in order to achieve pixel-perfect rendering
</I>&gt;<i> &gt; accuracy across browsers and platforms, sometimes it's for speed,
</I>&gt;<i> &gt; sometimes it's for visual effects that aren't possible in HTML,
</I>&gt;<i> &gt; sometimes it's because they're building a cross-platform UI.
</I>&gt;<i>
</I>&gt;<i> Just because people do it doesn't mean we need to design our APIs around
</I>&gt;<i> it, or otherwise endorse it. For example, people use &lt;table&gt; elements for
</I>&gt;<i> layout purposes, but this is expressively against the &lt;table&gt; conformance
</I>&gt;<i> requirements. People use &lt;blockquote&gt; for indenting, but instead of
</I>&gt;<i> providing a &lt;blockquote indent-depth&gt; attribute, we improve CSS to support
</I>&gt;<i> indenting. And so on.
</I>&gt;<i>
</I>
Even though you're not supposed to use &lt;table&gt; for layout, is there any
part of the HTML spec that forbids placing a certain element inside a table
cell because the only legitimate reason to do so would be if it was a
layout table? I'm not aware of one. Similarly, I think it'd be simplest to
just allow any element to be the target of a hit region. We can still
discourage it, but fail gracefully if authors decide to abuse it.

&gt;<i> Asking web developers not to build UIs in canvas is like asking Windows,
</I>&gt;<i> &gt; Mac, iOS, or Android developers to not build custom controls. It's not
</I>&gt;<i> &gt; going to happen.
</I>&gt;<i>
</I>&gt;<i> Sure, but that misses the point a little. We are developing technologies
</I>&gt;<i> for custom controls -- Web components. To support a &lt;select&gt; drop-down,
</I>&gt;<i> you need much more than just a canvas: you need a way to show a popup
</I>&gt;<i> window, you need a way to draw shadows over underlying content, etc.
</I>&gt;<i>
</I>
Yes, and people are building replacements for &lt;select&gt; using web components
now, like polymer-ui-menu:
<A HREF="http://www.polymer-project.org/components/polymer-ui-menu/smoke.html">http://www.polymer-project.org/components/polymer-ui-menu/smoke.html</A>

It should be easy to make something like polymer-ui-menu accessible using
role=listbox and role=option under the hood.

The question is, why shouldn't it be possible to implement a
polymer-ui-canvas-menu that works the same way but uses a canvas to render?

So this is why I ask for the precise use cases. We can only evaluate if
&gt;<i> the technologies are actually addressing needs by going through and seeing
</I>&gt;<i> how they do with precise use cases. If the use cases are very vague, we
</I>&gt;<i> can at best guess, and we might guess poorly.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; What if I do want a &lt;select&gt;, but I just want a canvas to render it
</I>&gt;<i> &gt; visually?
</I>&gt;<i>
</I>&gt;<i> Are Web Components and CSS unable to get the effects you need? Maybe we
</I>&gt;<i> should be improving those rather than &lt;canvas&gt;. It's hard to tell without
</I>&gt;<i> knowing precisely what you want to do.
</I>&gt;<i>
</I>
Is my pie chart example good? We can keep brainstorming, but just because
we can't think of something really compelling doesn't mean it's not out
there.

&gt;<i> Yes, but people are implementing text controls in canvas too. We can't
</I>&gt;<i> &gt; ignore that.
</I>&gt;<i>
</I>&gt;<i> We shouldn't ignore it; we should provide better solutions that make it so
</I>&gt;<i> they don't feel the need to do it.
</I>&gt;<i>
</I>&gt;<i> If a region has a car theft problem, you don't solve it by giving all the
</I>&gt;<i> thieves the car keys. You solve it by improving the economy so that
</I>&gt;<i> thieves have better things to do (like get an interesting job), and you
</I>&gt;<i> solve the remainder by improving law enforcement. The same applies here.
</I>&gt;<i> We solve it by providing better tools for custom text editing controls
</I>&gt;<i> (e.g. better contenteditable APIs), and by making it non-conforming to
</I>&gt;<i> abuse &lt;canvas&gt; for this purpose.
</I>&gt;<i>
</I>
I'd suggest a different analogy: suppose your company makes foam pipe
insulation and you discover people are buying your product and using it as
a swimming pool flotation device. Do you try to stop them from using your
product and try to get them to purchase other pool toys, or do you start
selling your pipe insulation directly to the sporting goods stores?

Of course we should improve contenteditable APIs so that people who just
want basic text editing don't write their own poor replacement. But I don't
see why we shouldn't also allow people to build feature-complete
alternative text editing controls with features that might never make it
into contenteditable - like discontiguous selections, or complex wrapping
around objects.

&gt;<i> That suggests we also need a lower-level API that associates an element
</I>&gt;<i> &gt; in fallback content with a region in canvas, even without making it a
</I>&gt;<i> &gt; &quot;hit&quot; region. I don't see how that's an argument against hit regions,
</I>&gt;<i> &gt; though.
</I>&gt;<i>
</I>&gt;<i> Not sure what you mean. What's the difference between a region and a hit
</I>&gt;<i> region, in this context?
</I>

A hit region is one that passes mouse events through to the element in
fallback content.

Instead, this would be a region that simply associates a region in the
canvas with an element in fallback content to indicate its accessible
bounds, not to propagate events.

Suppose you have some static text in your canvas. Associating the bounding
box of that text it with a &lt;p&gt; element containing an accessible version of
the same text could be very useful to screen magnifiers - ZoomText, for
example, lets you navigate to content that isn't focusable, and it will
optionally speak the text, even though it's not intended for totally blind
users.

&gt;<i> Browsers don't currently know what element has AT focus, but the browser
</I>&gt;<i> &gt; tells the AT if the coordinates of an element make it offscreen, and AT
</I>&gt;<i> &gt; can send a command telling the browser to scroll an element on-screen.
</I>&gt;<i> &gt; Currently browsers implement this automatically, without involving the
</I>&gt;<i> &gt; web author - but for completeness we may want canvas authors to have the
</I>&gt;<i> &gt; option to respond to a request to scroll a fallback content element into
</I>&gt;<i> &gt; view.
</I>&gt;<i>
</I>&gt;<i> What would such an API need? Do we need an event that fires on the
</I>&gt;<i> &lt;canvas&gt; indicating that the AT focus has moved to a specific region, the
</I>&gt;<i> same way we handle mouse events? (Should we just support this for all
</I>&gt;<i> elements, not just canvas, while we're at it?)
</I>&gt;<i>
</I>
Currently AT doesn't even tell the browser what has focus. This is partly
done on purpose - poorly-designed apps (not just web apps) will do things
like &quot;trap&quot; focus in a form control until you supply a valid response, and
AT needs to allow a user to explore the page without notifying the
underlying application where you are.

I think what's needed is a new event - &quot;scrollToMakeVisible&quot;. Perhaps
whenever an element gets focus, this event could fire on that element, and
the default implementation would do what's done now - but an author could
choose to preventDefault and implement their own scrolling logic. Then what
would happen is that AT would sometimes fire a scrollToMakeVisible on an
element that isn't necessarily focused.

Are there other questions we should be asking to support this grid use
&gt;<i> case?
</I>&gt;<i>
</I>&gt;<i> So far it seems like to support grids in canvas, we need:
</I>&gt;<i>
</I>&gt;<i>  - enable focusable &lt;td&gt; elements to be hit region controls
</I>&gt;<i>  - fire an event on an element when the AT focus moves to that element
</I>&gt;<i>  - when this event is fired on a canvas, include the region information
</I>&gt;<i>
</I>
I think a scrollToMakeVisible event would be better than a receivedATFocus
event.


&gt;<i> Anything else?
</I>&gt;<i>
</I>
I think AT would like to know the region corresponding to the &lt;table&gt;
element too, not just the focusable &lt;td&gt;.

So, some API that just associates a canvas region with a fallback element -
purely for AT - would be very useful.

Now I wonder if it wouldn't be simplest to just allow *any* fallback
content element to be the target of a hit region . It would be simpler to
spec.

Here's another argument in favor of this: it's not uncommon on the web for
objects to do something on hover, even if they're not focusable or
clickable. For example, a static image might have a caption that appears on
hover, or a static paragraph that's partially truncated might grow to show
its full content on hover.

Allowing hit regions to map to any element would allow for the same type of
thing to happen within a canvas. An author might simply want to track what
region the mouse cursor is over, *even when that region isn't focusable or
clickable*.

This solves the accessibility use case too - if you want AT to know the
bounding box of an element in fallback content, just give it a hit region.
That allows AT to know where it is on the screen, and also allows you to
track when the mouse hovers on it.

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="084304.html">[whatwg] hit regions: limited set of elements for fallback content
</A></li>
	<LI>Next message: <A HREF="084346.html">[whatwg] hit regions: limited set of elements for fallback content
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#84334">[ date ]</a>
              <a href="thread.html#84334">[ thread ]</a>
              <a href="subject.html#84334">[ subject ]</a>
              <a href="author.html#84334">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
