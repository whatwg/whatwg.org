<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Feedback on a variety of elements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Feedback%20on%20a%20variety%20of%20elements&In-Reply-To=%3CPine.LNX.4.64.1212132249290.9975%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="038275.html">
   <LINK REL="Next"  HREF="080759.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Feedback on a variety of elements</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Feedback%20on%20a%20variety%20of%20elements&In-Reply-To=%3CPine.LNX.4.64.1212132249290.9975%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] Feedback on a variety of elements">ian at hixie.ch
       </A><BR>
    <I>Fri Dec 14 12:59:59 PST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="038275.html">[whatwg] Paragraph with overlapping fallback content
</A></li>
        <LI>Next message: <A HREF="080759.html">[whatwg] Feedback on a variety of elements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#80624">[ date ]</a>
              <a href="thread.html#80624">[ thread ]</a>
              <a href="subject.html#80624">[ subject ]</a>
              <a href="author.html#80624">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
On Thu, 6 Sep 2012, Pierre Dubois wrote:
&gt;<i> 
</I>&gt;<i> I developed a javascript table parser based on my research. The parser 
</I>&gt;<i> is able to understand complex relationship in a data table. The 
</I>&gt;<i> relationship association is based on the current algorithm and take in 
</I>&gt;<i> consideration how the header cell (th) is structured, positioned and 
</I>&gt;<i> spanned. All of this is combined on how the column grouping (colgroup) 
</I>&gt;<i> and the row grouping (thead, tbody) is structured.
</I>&gt;<i> 
</I>&gt;<i> My research was based on usability and common use of table. My goal was 
</I>&gt;<i> to find how the HTML markup can be used to represent a complex table 
</I>&gt;<i> based on how a person would understand the complex table by viewing it 
</I>&gt;<i> in a user agent and on paper.
</I>&gt;<i> 
</I>&gt;<i> My research led me to extend the current definition of the table 
</I>&gt;<i> elements (table, caption, colgroup, col, thead, tbody, tfoot, tr, th, 
</I>&gt;<i> td) and I tried to understand the table without discriminating row and 
</I>&gt;<i> column.
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://wet-boew.github.com/wet-boew/demos/tableparser/ExtendedDefinition.html">http://wet-boew.github.com/wet-boew/demos/tableparser/ExtendedDefinition.html</A>
</I>&gt;<i>
</I>&gt;<i> [...]
</I>
On Fri, 28 Sep 2012, Pierre Dubois wrote:
&gt;<i> 
</I>&gt;<i> Proposal: Remove the headers attribute on the th element and td element
</I>&gt;<i> 
</I>&gt;<i> The Information, structure, and relationships conveyed through 
</I>&gt;<i> presentation of a table can be programmatically determined with the 
</I>&gt;<i> table usability algorithm provided below.
</I>&gt;<i> 
</I>&gt;<i> The HTML Table Validator show that by adding the id/headers attribute on 
</I>&gt;<i> the analyzed table the relationships are programmatically determined. 
</I>&gt;<i> (<A HREF="http://wet-boew.github.com/wet-boew/demos/tableparser/validator-htmltable.html">http://wet-boew.github.com/wet-boew/demos/tableparser/validator-htmltable.html</A>)
</I>&gt;<i>
</I>&gt;<i> Proposal: Remove the scope attribute on the th element
</I>&gt;<i> 
</I>&gt;<i> The Information, structure, and relationships conveyed through 
</I>&gt;<i> presentation of a table can be programmatically determined with the 
</I>&gt;<i> table usability algorithm provided below.
</I>&gt;<i> 
</I>&gt;<i> Currently, as per my understanding, the scope set to &quot;rowgroup&quot; or 
</I>&gt;<i> &quot;colgroup&quot; needs to be anchored in a rowgroup or a colgroup. So, the 
</I>&gt;<i> scope are just repeating the information about the grouping element. 
</I>&gt;<i> That are not providing any extra *useful* information on the concerned 
</I>&gt;<i> table.
</I>
I don't think this works for all tables. For example, the first example in 
the spec in the &lt;th&gt; element's section does not get handled correctly by 
your algorithm -- it treats the ID column as important, instead of the 
second column. Without the scope=&quot;&quot; attributes, I don't think that table 
would make much sense. Similarly, the &quot;Characteristics with positive and 
negative sides&quot; example used a number of times in the HTML spec works 
better with a few headers=&quot;&quot; attributes to define the mappings than 
without, as far as I can tell (though your algorithm does make a valiant 
attempt, I will grant you).


&gt;<i> Proposal: Table Usability API
</I>
This is a very elaborate and large API. What are the use cases against 
which to evaluate it? i.e. what problem does it solve?


&gt;<i> Proposal: Table Usability Parser Algorithm
</I>&gt;<i> <A HREF="https://github.com/duboisp/Table-Usability-Concept/tree/master/Algorithm">https://github.com/duboisp/Table-Usability-Concept/tree/master/Algorithm</A>
</I>
Can you elaborate on how this differs from the algorithm in the HTML spec, 
and in what ways it is better? (e.g. examples that your algorithm handles 
but that the HTML spec doesn't)

I'm all in favour of improving the spec, I just don't have a good frame of 
reference here by which to evaluate the proposal.


On Fri, 19 Oct 2012, Pierre Dubois wrote:
&gt;<i> 
</I>&gt;<i> Sometime the subsequent row grouping under the same data level and the 
</I>&gt;<i> subsequent column grouping under the same data level don't necessary 
</I>&gt;<i> mean a summary group but still a data group.
</I>
A summary group is just a group with a heading saying it's a summary 
group, no? I don't really understand what is special about a summary 
group. How should software treat it differently?


&gt;<i> To fix that the solution would be to have a new attribute set on the 
</I>&gt;<i> table element to know if the table contains summaries group.
</I>
I would be very surprised if such an attribute was used correctly a useful 
fraction of the time.


On Mon, 1 Oct 2012, Nicholas Shanks wrote:
&gt;<i>
</I>&gt;<i> <A HREF="http://www.w3.org/TR/html-markup/th.html#th.attrs.scope">http://www.w3.org/TR/html-markup/th.html#th.attrs.scope</A> Says nothing 
</I>&gt;<i> about what a UA should do by default, nor when scope can be omitted due 
</I>&gt;<i> to such defaults.
</I>
The HTML spec does:

   <A HREF="http://www.whatwg.org/specs/web-apps/current-work/#attr-th-scope">http://www.whatwg.org/specs/web-apps/current-work/#attr-th-scope</A>

In particular the &quot;auto&quot; value (the default) has a lot of the behaviour 
you describe. Does it do everything you want?


On Mon, 1 Oct 2012, Nicholas Shanks wrote:
&gt;<i> 
</I>&gt;<i> Are there use cases where the value of the scope attribute matters other 
</I>&gt;<i> than as an intermediary for computing the headers applicable to each 
</I>&gt;<i> cell?
</I>
Not to my knowledge...


&gt;<i> If not, are there use cases where either the data cell headers have not 
</I>&gt;<i> yet been computed or they are unavailable (perhaps while Javascript DOM 
</I>&gt;<i> tree walking?) where access to the scope attribute would be helpful?
</I>
I don't think there's any case where you have access to the scope 
attribute but not the cells, yet you could work out what the scope 
attribute's value should be to reflect the default behaviour.


On Fri, 5 Oct 2012, Mathew Marquis wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; Introducing new image formats is so rare (once every 20 years or so, 
</I>&gt;<i> &gt; so far) that I don't think we should optimise for it, certainly not at 
</I>&gt;<i> &gt; such a high cost. There are existing solutions (e.g. &lt;object&gt;) for 
</I>&gt;<i> &gt; handling that kind of thing.
</I>&gt;<i> 
</I>&gt;<i> Could you expand a bit more on the &#226;&#128;&#156;cost&#226;&#128;&#157; of an approach that might 
</I>&gt;<i> account for this?
</I>
It's the same cost as every new feature:

   <A HREF="http://wiki.whatwg.org/wiki/FAQ#Where.27s_the_harm_in_adding.E2.80.94">http://wiki.whatwg.org/wiki/FAQ#Where.27s_the_harm_in_adding.E2.80.94</A>


&gt;<i> &gt;&gt;&gt; Manipulating &lt;picture&gt; from script would be a huge pain -- you'd 
</I>&gt;<i> &gt;&gt;&gt; have to be manipulating lots of elements and attributes.
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; Well, is manipulating &lt;audio&gt; or &lt;video&gt; from script a huge pain?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Yes.
</I>&gt;<i> 
</I>&gt;<i> Certainly not more so than manipulating strings, having done both 
</I>&gt;<i> frequently myself.
</I>
I don't think manipulating strings is the harder of the two, but I 
wouldn't suggest anyone manipulate the srcset attribute either. If there's 
a use case for manipulating it, we should provide a dedicated API.


&gt;<i> &gt;&gt; I actually have one use case that would benefit from having separate 
</I>&gt;<i> &gt;&gt; elements instead of an attribute &#195;&#162;&#226;&#130;&#172;&#226;&#128;&#156; replacing &lt;source&gt; elements 
</I>&gt;<i> &gt;&gt; with links to their content for accessability purposes. I did 
</I>&gt;<i> &gt;&gt; something like this when I hacked elinks to (badly) support HTML5 
</I>&gt;<i> &gt;&gt; media elements 
</I>&gt;<i> &gt;&gt; &lt;<A HREF="http://blog.dieweltistgarnichtso.net/html5-media-elements-in-elinks">http://blog.dieweltistgarnichtso.net/html5-media-elements-in-elinks</A>&gt;.
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; Consider that any attribute microsynthax would introduce a burden on 
</I>&gt;<i> &gt;&gt; programmatic DOM manipulation, as the attribute would have to be 
</I>&gt;<i> &gt;&gt; parsed separately. &#195;&#162;&#226;&#130;&#172;&#197;&#190;Do X for every &lt;source&gt; child 
</I>&gt;<i> &gt;&gt; element&#195;&#162;&#226;&#130;&#172;&#197;&#147; is cognitively cheap in comparison to maintaining a 
</I>&gt;<i> &gt;&gt; mental model of the attribute in question &#195;&#162;&#226;&#130;&#172;&#226;&#128;&#156; different from 
</I>&gt;<i> &gt;&gt; other mental models used in HTML &#195;&#162;&#226;&#130;&#172;&#226;&#128;&#156; in your working memory.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; There are plenty of attributes with more complicated syntaxes, e.g. 
</I>&gt;<i> &gt; all the event handler attributes (whose syntax is JavaScript), or 
</I>&gt;<i> &gt; style=&quot;&quot; (whose syntax is CSS). See also &lt;meta content&gt; for many of 
</I>&gt;<i> &gt; the pragmas, the &lt;area coords&gt; attribute, &lt;ins datetime&gt;, media=&quot;&quot; 
</I>&gt;<i> &gt; attributes, etc.
</I>&gt;<i> 
</I>&gt;<i> Saying &#226;&#128;&#156;there are worse things&#226;&#128;&#157; doesn&#226;&#128;&#153;t make much of a case for a 
</I>&gt;<i> worse thing. Better that we focus on finding the best possible approach 
</I>&gt;<i> here and avoid our previous mistakes.
</I>
My point was just that this is a more common approach in the HTML language 
than is multiple elements for this kind of thing. I agree that 
manipulating strings isn't particularly nice, but at best that just means 
that the multi-element model is no worse for manipulation; it's still no 
better for that mechanism either, and still has the numerous other 
problems that have been brought up in the past (error handling, mutation 
handling, shadow tree handling, handling unexpected non-element nodes, 
parsing and event-loop coordination, etc).

<A HREF="http://lists.w3.org/Archives/Public/public-whatwg-archive/2012Aug/0070.html">http://lists.w3.org/Archives/Public/public-whatwg-archive/2012Aug/0070.html</A>


&gt;<i> &gt;&gt; This reminds me that ATOM &lt;enclosures&gt; have a byte length. Surfing 
</I>&gt;<i> &gt;&gt; via mobile, I certainly know that I would like images to show if they 
</I>&gt;<i> &gt;&gt; can be downloaded in a reasonable time &#195;&#162;&#226;&#130;&#172;&#226;&#128;&#156; but I want to skip 
</I>&gt;<i> &gt;&gt; 5MB photos.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Given that newer mobile networks are actually faster than the 
</I>&gt;<i> &gt; networking a lot of people in the US have to their house, I don't know 
</I>&gt;<i> &gt; how much of a lifetime such a feature would have.
</I>&gt;<i> 
</I>&gt;<i> This seems incredibly specific to privileged browsing contexts, and 
</I>&gt;<i> hardly a standpoint that accounts for the millions of users in 
</I>&gt;<i> developing countries accessing the Internet from mobile devices alone. 
</I>&gt;<i> Users with limited bandwidth and a per-kilobyte economic cost for access 
</I>&gt;<i> to a resource that&#226;&#128;&#148;by very design&#226;&#128;&#148;is meant to be open and accessible 
</I>&gt;<i> to users of any context. Tim Berners-Lee can speak to that far better 
</I>&gt;<i> than I ever could.
</I>
Tim's welcome to participate in the discussion if he likes. To your point, 
though, I agree that there are countries where bandwidth is at a premium. 
If browsers want to implement something along those lines and authors are 
going to use it, and if we can come up with a solution to the problem that 
actually works technically, then I'm all for it. I've gone into more depth 
on the problem with this before.

<A HREF="http://lists.w3.org/Archives/Public/public-whatwg-archive/2012May/0247.html">http://lists.w3.org/Archives/Public/public-whatwg-archive/2012May/0247.html</A>


&gt;<i> &gt; It's not at all clear to me that the &lt;picture&gt; proposals are more 
</I>&gt;<i> &gt; readable. It's certainly not an enormous enough difference to be 
</I>&gt;<i> &gt; relevant.
</I>&gt;<i> 
</I>&gt;<i> Perhaps, given the lack of clarity on this point, we might consult the 
</I>&gt;<i> opinion of authors.
</I>
One thing I learnt in the usability study we did for microdata is that 
what many authors think is simpler doesn't correlate to what they make 
fewer mistakes with, so unfortunately asking authors isn't necessarily a 
good way to answer this question (I also learnt that what I and other 
language designers think is a good idea sometimes isn't either). If we 
could, a usability study would be the best way to get this answer.


&gt;<i> &gt; I agree. Who manipulates &lt;img&gt;, though? Surely you just create the 
</I>&gt;<i> &gt; image with the image you need, and use it. No manipulation involved. 
</I>&gt;<i> &gt; For srcset=&quot;&quot;, it's at most a concatenation of a few strings. When 
</I>&gt;<i> &gt; would you _parse_ it?
</I>&gt;<i> 
</I>&gt;<i> Should we cite examples of sites that grab/manipulate the value of an 
</I>&gt;<i> img tag&#226;&#128;&#153;s src?
</I>
If it's more than just toggling between images, yes.

I would definitely like to know when srcset=&quot;&quot; is going to be parsed, 
because without knowing what the use cases are, it's impossible to 
evaluate the proposals to solve them.


&gt;<i> &gt;&gt; It is possible to address this by repeating the same image at a 
</I>&gt;<i> &gt;&gt; larger breakpoint, like:
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; &lt;img srcset=&quot;800.jpg 1x 1599w, 1600.jpg 2x 1599w, 1600.jpg 1x&quot;&gt;
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; However, this means you're duplicating data, and have a chance of 
</I>&gt;<i> &gt;&gt; failing to update all of the urls when you update one.  It also 
</I>&gt;<i> &gt;&gt; becomes more hostile as future screens arrive with higher 
</I>&gt;<i> &gt;&gt; resolutions. For example, if 3x screens showed up, one would have to 
</I>&gt;<i> &gt;&gt; write the following to serve things in the most ideal manner:
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; &lt;img srcset=&quot;800.jpg 1x 1599w, 1600.jpg 2x 1599w, 2400.jpg 3x 1599w, 
</I>&gt;<i> &gt;&gt; 1600.jpg 1x 2399w, 2400.jpg 1.5x 2399w, 2400.jpg 1x&quot;&gt;
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; At this point it's just silly, and very error-prone.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree, when there's 3x displays, this could get to the point where 
</I>&gt;<i> &gt; we need to solve it. :-)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; With the current displays, it's just not that big a deal, IMHO.
</I>&gt;<i> 
</I>&gt;<i> Perhaps we should skate to where the puck will be, rather than where it 
</I>&gt;<i> is now.
</I>
If we knew where the puck was going to be, I'd be all for that. The risk, 
however, is making elaborate solutions that have high costs (see the 
earlier link) but that never pay off, because the puck suddenly veered in 
a different direction than what we guessed.


On Thu, 11 Oct 2012, Markus Ernst wrote:
&gt;<i> 
</I>&gt;<i> My point is, that any device-specific notation, such as &quot;2x&quot;, forces the 
</I>&gt;<i> author to make decisions that the browser should actually make. The 
</I>&gt;<i> author does not know if in a few years the image will be viewed with 
</I>&gt;<i> 1.5x or 3x or 7x or whatever devices.
</I>
No, but the author does know what pixel density the image has.


&gt;<i> This is why I'd humbly suggest to put information on the image in 
</I>&gt;<i> @srcset rather than info on the device and media. Such as:
</I>&gt;<i> 
</I>&gt;<i> srcset=&quot;low.jpg 200w, hi.jpg 400w, huge.jpg 800w&quot;
</I>&gt;<i> 
</I>&gt;<i> Where &quot;200w&quot; is the actual image width and not the viewport width. Like 
</I>&gt;<i> that every browser can decide which source to load based on the display, 
</I>&gt;<i> and available bandwidth or user setting or whatever.
</I>
The problem is that the image's width doesn't help the user agent at all. 
How is the user agent supposed to know which image looks best on a 600 
pixel wide viewport? The image could be intended to be a small icon inline 
in the text, or a sidebar full-bleed image, or a photograph in the main 
flow of the text. I just don't see what the UA can do here.


On Sat, 13 Oct 2012, Fred Andrews wrote:
&gt;<i> 
</I>&gt;<i> This does seem to be an important point.  Would the follow be a 
</I>&gt;<i> correction understanding of your point: if there are a range of images 
</I>&gt;<i> each with a different declared size and the CSS pixel size of the image 
</I>&gt;<i> is not constrained then the browser must use the image pixel size to 
</I>&gt;<i> determine the CSS pixel size and without knowing the density then this 
</I>&gt;<i> can not be done uniquely?
</I>
I don't really see how this could work.

&gt;<i> Perhaps the 1x density image could be placed first in the list, and then 
</I>&gt;<i> the densities would all be defined.
</I>
That assumes the images are the same width, which doesn't handle the &quot;art&quot; 
use case, where the author wants a cropped image on a cell phone screen 
but a wide shot on a tablet.


On Fri, 19 Oct 2012, Fred Andrews wrote:
&gt;<i> 
</I>&gt;<i> If it is really necessary to support this case then perhaps both the 
</I>&gt;<i> image width and the the native pixel breakpoints could be specified in 
</I>&gt;<i> the srcset.
</I>&gt;<i> 
</I>&gt;<i> Then srcset=&quot;low.jpg 10w 20w, hi.jpg 20w 40w, huge.jpg 30w&quot; would mean:
</I>&gt;<i> 
</I>&gt;<i> low.jpg is 10 pixels wide and use it if the native pixel width of the 
</I>&gt;<i> image box is less than or equal to 20,
</I>&gt;<i> 
</I>&gt;<i> hi.jpg is 20 pixels wide and use it if the native pixel width of the 
</I>&gt;<i> image box is less than or equal to 40,
</I>&gt;<i> 
</I>&gt;<i> huge.jpg is 30 pixels wide and use it if the native pixel width of the 
</I>&gt;<i> image box is less than greater than 40 pixles
</I>&gt;<i> 
</I>&gt;<i> The default break points could be the image sizes, and would typically 
</I>&gt;<i> not be needed.
</I>&gt;<i> 
</I>&gt;<i> The first image could be the 1x density image, allowing the browser to 
</I>&gt;<i> determine the image box size if not otherwise specified and this could 
</I>&gt;<i> be done before loading the image.
</I>&gt;<i> 
</I>&gt;<i> This approach may be more natural for a fluid design.
</I>
Given how people are complaining that srcset=&quot;&quot; is complicated as it is, 
making it even worse doesn't seem like a winner to me. :-)


On Fri, 2 Nov 2012, Eric Portis wrote:
&gt;<i> On Tue May 15 00:28:54 PDT 2012, Ian Hickson wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; In practice, the only information regarding dimensions that can be 
</I>&gt;<i> &gt; usefully leveraged here is the viewport dimensions. This isn't the end 
</I>&gt;<i> &gt; of the world, though -- there's often going to be a direct correlation 
</I>&gt;<i> &gt; between the dimensions of the viewport and the dimensions of the 
</I>&gt;<i> &gt; images.
</I>&gt;<i> 
</I>&gt;<i> This relationship will be direct, however it will not often be simple 
</I>&gt;<i> and requires authors to bake information about their layout into their 
</I>&gt;<i> srcset declarations&#151;a potentially complex and error-prone process which 
</I>&gt;<i> results in fragile markup.
</I>
Agreed, but since it's the only information we have, it doesn't have to be 
ideal -- all we need is that it be possible.


&gt;<i> For stretchy images the only two variables that really matter (excepting 
</I>&gt;<i> bandwidth concerns) are 1) the device pixels the image is slotting into 
</I>&gt;<i> on the layout and 2) the resolution of the image files themselves. Given 
</I>&gt;<i> these, load the smallest image that is bigger than the device-pixel 
</I>&gt;<i> dimensions of its box, or, failing that, the biggest file.
</I>
Actually all you need is the pixel density, as far as I can tell. You 
don't need the dimensions at all, if you're not worried about the &quot;art&quot; 
case where the image content itself is changed.


&gt;<i> If the browser can handle figuring out the layout
</I>
Browser vendors have indicated that they cannot do this before they have 
to fetch the image.


&gt;<i> I realize that requiring browsers to figure out what size the image will 
</I>&gt;<i> end up rendering at on the layout before deciding which resource to load 
</I>&gt;<i> will break image pre-fetchers as they currently operate. And that 
</I>&gt;<i> pre-fetching is crucial to performance and therefore users. But it seems 
</I>&gt;<i> to me pre-fetchers have a lot more headroom to get smarter than authors 
</I>&gt;<i> do, and that we should strive to keep markup for content images as free 
</I>&gt;<i> from presentational concerns as possible.
</I>
It's not a matter of &quot;smarter&quot;. The browser parses the HTML file, gets the 
links to the CSS file, kicks off those loads, almost immediately comes 
across the &lt;img&gt; elements, and has to kick off those loads then too -- 
before the CSS file has returned.


&gt;<i> This pattern isn't mutually exclusive with the current srcset spec. What 
</I>&gt;<i> I'm proposing is that if authors want simpler, more robust, 
</I>&gt;<i> non-presentational markup, they should be able to opt into it and accept 
</I>&gt;<i> the performance penalties that result (hopefully only for a while, while 
</I>&gt;<i> browsers and pre-fetchers adapt).
</I>
If authors just want to do the pixel density case, they can just specify 
the 2x image in srcset=&quot;&quot; and the 1x image in src=&quot;&quot; and they're done.


On Tue, 6 Nov 2012, Pierre Dubois wrote:
&gt;<i> 
</I>&gt;<i> Use case: Draw a graphic based on a data table
</I>&gt;<i> * Like a pie chart, based on a sub-set of data contained in a data table.
</I>
This is an interesting use case. Do any sites actually try to do this 
today?

I tried writing an example to do this, and it's not clear to me that the 
API is particularly hard to use. Somewhat verbose, granted, but it only 
took a few lines of code, most of which is spent in canvas logic and in 
the CSS styles to make the table presentable:

   <A HREF="http://damowmow.com/playground/demos/tables/002.html">http://damowmow.com/playground/demos/tables/002.html</A>

That's an admittedly simple table; what kinds of tables are people 
generating pie charts out of? Are they more complex? Do you have any 
examples we could study?


&gt;<i> An issue can be when the header cell cover and/or represent more than 
</I>&gt;<i> one group (eg. multiple tbody from a column perspective and multiple 
</I>&gt;<i> colgroup from a row perspective)
</I>
Certainly that does make things more complex and the current API doesn't 
handle spanning cells well if you want to select a cell by grid position.


&gt;<i> Use case: Draw a graphic based on a data table
</I>
Can you be more elaborate? Examples of pages trying to do this, examples 
of tables that need to be charted client-side, etc, would go a long way 
towards helping flesh out the use case.


&gt;<i> Use case: Draw a pie chart based on a sub-set of data contained in a 
</I>&gt;<i> data table and retrieve heading cell content associated to the data 
</I>&gt;<i> cells.
</I>
In the example above, getting the heading cell is trivial (it's the first 
cell of the row/column). I didn't draw labels on the slices, but I'm 
pretty sure that drawing those labels would involve far more canvas code 
than table DOM code, currently. If this is a use case we want to address, 
I think it suggests that either we're already handling it fine, or we 
should work on making canvas easier before working on the table API.


On Wed, 29 Aug 2012, Steve Faulkner wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; Can you provide an example of how using a redundant role value can 
</I>&gt;<i> &gt; &gt; lead to conflicts?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sure. Support someone writes:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    &lt;input type=submit name=&quot;submit&quot; value=&quot;Submit My Form!&quot; role=button&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ...and then someone else copies and pastes it, and changes the type 
</I>&gt;<i> &gt; and name and value, but doesn't know what &quot;role&quot; is:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    &lt;input type=password name=&quot;password&quot; value=&quot;&quot; role=button&gt;
</I>&gt;<i> 
</I>&gt;<i> that has nothing to do with it being redundant, it's to do with people 
</I>&gt;<i> copying and pasting code, the same issue would occur for many other 
</I>&gt;<i> attributes.
</I>
It happens when there are redundant markup features that are copied and 
pasted and then only one half is changed, making them inconsistent.


&gt;<i> That's why we have conformance checkers to pick up such issues where 
</I>&gt;<i> they cause harm.
</I>
Conformance checkers help authors who use them catch mistakes they made, 
sure. But that doesn't give us license to make it more likely that authors 
will make mistakes.


&gt;<i> If the role and the input type do not match the role is no longer 
</I>&gt;<i> redundant, so you did not answer the question.
</I>
I'm sorry you feel the answer is unsatisfactory. However, it is the reason 
that allowing redundancy is bad.


&gt;<i> &gt;&gt; &gt; for example:
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; &lt;nav role=&quot;navigation&quot;&gt;
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; Under what circumstances can this example lead to 'conflicting 
</I>&gt;<i> &gt;&gt; &gt; information'?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; User copies-and-pastes this:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    &lt;nav class=&quot;fx-2&quot; data-rollup=&quot;2s streamB&quot;
</I>&gt;<i> &gt;         onclick=&quot;activateRollup(this)&quot; role=navigation&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ...and tweaks it for their sidebar, getting:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    &lt;aside class=&quot;fx-3&quot; data-rollup=&quot;3s streamC&quot;
</I>&gt;<i> &gt;           onclick=&quot;activateRollup(this)&quot; role=navigation&gt;
</I>&gt;<i> 
</I>&gt;<i> again you have changed the element so it is no longer redundant
</I>
Right, that's the whole point. Redundancy in the original markup leads to 
errors in the post-copy-and-paste markup.


&gt;<i> On Sun, 10 Jun 2012, Steve Faulkner wrote:
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; You don't clearly differentiate between roles, properties and 
</I>&gt;<i> &gt;&gt; &gt; states, ther are quite a few states and properties NOT provided in 
</I>&gt;<i> &gt;&gt; &gt; HTML5 that may have use cases for adding to an input element, for 
</I>&gt;<i> &gt;&gt; &gt; example aria-hapopup, aria-labelledby, aria-decirbedby, 
</I>&gt;<i> &gt;&gt; &gt; aria-controls etc
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Could you give an example of any of these in valid use?
</I>&gt;<i> 
</I>&gt;<i> the following input (gmail search box) uses aria-haspopup=true
</I>&gt;<i> 
</I>&gt;<i> &lt;input type=&quot;text&quot; value=&quot;&quot; autocomplete=&quot;off&quot; name=&quot;q&quot; class=&quot;gbqfif&quot;
</I>&gt;<i> id=&quot;gbqfq&quot; *aria-haspopup=&quot;true&quot;* style=&quot;border: medium none; padding: 0px;
</I>&gt;<i> margin: 0px; height: auto; width: 100%; background:
</I>&gt;<i> url(&quot;data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw%3D%3D&quot;)
</I>&gt;<i> repeat scroll 0% 0% transparent; position: absolute; z-index: 6; left:
</I>&gt;<i> 0px;&quot; dir=&quot;ltr&quot; spellcheck=&quot;false&quot;&gt;
</I>
Interesting. Can you elaborate on how this actually works? That is, 
aria-haspopup tells the AT that activating the element shows a popup, but 
what does activating the element mean? How does the AT expose this to the 
user? How does the user know what to do with this?


&gt;<i> the following link (from the gmail 'more' menu)  use aria-haspopup and 
</I>&gt;<i> aria-owns
</I>&gt;<i> 
</I>&gt;<i> &lt;a aria-owns=&quot;gbd&quot; aria-haspopup=&quot;true&quot; onclick=&quot;gbar.tg(event,this)&quot; href=&quot;
</I>&gt;<i> <A HREF="http://www.google.com/intl/en/options/">http://www.google.com/intl/en/options/</A>&quot; id=&quot;gbztm&quot; class=&quot;gbgt&quot;&gt;&lt;span
</I>&gt;<i> class=&quot;gbtb2&quot;&gt;&lt;/span&gt;&lt;span class=&quot;gbts gbtsa&quot; id=&quot;gbztms&quot;&gt;&lt;span
</I>&gt;<i> id=&quot;gbztms1&quot;&gt;More&lt;/span&gt;&lt;span class=&quot;gbma&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;
</I>
How does this manifest in an AT?


&gt;<i> the gmail search button  uses aria-label
</I>&gt;<i> 
</I>&gt;<i> &lt;button class=&quot;gbqfb&quot; aria-label=&quot;Google Search&quot; id=&quot;gbqfb&quot;&gt;&lt;span
</I>&gt;<i> class=&quot;gbqfi&quot;&gt;&lt;/span&gt;&lt;/button&gt;
</I>
That's somewhat bogus, IMHO, though not because of the ARIA aspects. It's 
a button with no label. It's unclear to me why only AT users and users of 
graphical CSS UAs should be able to get a label for the button.


&gt;<i> These are few examples in use, I don't know if you consider them 'valid 
</I>&gt;<i> use'.
</I>
These all seem allowed by the spec.


On Wed, 29 Aug 2012, Benjamin Hawkes-Lewis wrote:
&gt;<i> 
</I>&gt;<i> I think you're missing Ian's point. Authors copy-paste markup from 
</I>&gt;<i> deployed corpus. If linters throwing warnings/errors about &quot;redundant&quot; 
</I>&gt;<i> markup caused authors to remove it, that would reduce the amount of 
</I>&gt;<i> &quot;redundant&quot; markup in the corpus. Consequently, there would be fewer 
</I>&gt;<i> copy-paste errors involving misunderstandings of the &quot;redundant&quot; markup. 
</I>&gt;<i> The harm caused by &quot;using a role that matches the implied default role&quot; 
</I>&gt;<i> is the proliferation of markup likely to result in copy-paste errors.
</I>
Precisely.


&gt;<i> Having said that, I don't buy Ian's argument because:
</I>&gt;<i> 
</I>&gt;<i> 1. Informed authors are unlikely to reduce their own content's 
</I>&gt;<i> interoperability (backwards compatibility with today's client software 
</I>&gt;<i> that doesn't expose implicit semantics) in favor of making it easier for 
</I>&gt;<i> other authors to copy-paste their markup without errors.
</I>
Short-term band aids are hopefully a short-term concern, though. The idea 
here is to specify what authors need to do going forward.


&gt;<i> Assuming the linter gives accurate information about markup 
</I>&gt;<i> interoperability, such warnings/errors are unlikely to result in authors 
</I>&gt;<i> removing &quot;redundant&quot; markup. So an important effect of emitting these 
</I>&gt;<i> warnings/errors is to decrease the linter's signal-to-noise ratio.
</I>
It's quite legitimate for a linter or conformance checker to group errors 
that its author thinks are likely the result of specific short-term 
compatibility needs and label them as such or even hide them behind a 
twisty or some such. Indeed, Henri's validator already does this for some 
features (e.g. it warns about cite=&quot;&quot; usage -- incidentally, the spec 
changes on cite=&quot;&quot;, so that warning should probably change too).


&gt;<i> 2. Linter behaviour aside, I suspect more content will be enriched
</I>&gt;<i> with &quot;redundant&quot; ARIA markup than broken by copy-paste errors involved
</I>&gt;<i> in said markup.
</I>
Redundant ARIA markup doesn't enrich anything though, by definition (it 
wouldn't be redundant if it did).


&gt;<i> So long as we're talking about &quot;redundant&quot; ARIA markup motivated by 
</I>&gt;<i> implementations not exposing implicit native semantics, the Living 
</I>&gt;<i> Standard is trying to describe the behaviour on which implementations on 
</I>&gt;<i> converging, not what implementations do today. For client software 
</I>&gt;<i> implementors, what matters is implementor intention, not current browser 
</I>&gt;<i> behaviour.
</I>&gt;<i> 
</I>&gt;<i> However, useful linter behavior needs to be predicated on current 
</I>&gt;<i> browser behavior, because that's what authors care about. So I agree 
</I>&gt;<i> that Living Standard requirements for conformance checkers should be 
</I>&gt;<i> relaxed to take account of current browser behavior.
</I>
Conformance checkers really have quite wide latitude to present these 
issues in a variety of ways. I'm not sure really how much more latitude we 
can give. I don't think it makes much sense to make things we know will be 
non-conforming in the future conforming now, but I'm happy to look at 
specific cases if there is concrete data showing that some suboptimal 
markup is necessary for pragmatic reasons.


&gt;<i> &gt;&gt; Bugs should be fixed. We shouldn't warp the language to work around 
</I>&gt;<i> &gt;&gt; temporary bugs. We certainly shouldn't teach a new generation of 
</I>&gt;<i> &gt;&gt; authors to use bad authoring styles just because of a transitory 
</I>&gt;<i> &gt;&gt; issue with certain browsers.
</I>&gt;<i> 
</I>&gt;<i> What most authors want out of conformance checking is not &quot;authoring 
</I>&gt;<i> styles&quot; but interoperability, and they will need to keep using 
</I>&gt;<i> &quot;redundant&quot; markup to achieve that.
</I>
If there are concrete examples of this, that would be helpful.


On Wed, 5 Dec 2012, Cory Sand wrote:
&gt;<i>
</I>&gt;<i> The &quot;Paragraphs&quot; section (3.2.5.3) gives an interesting example where 
</I>&gt;<i> paragraphs can overlap when using an element, like &lt;object&gt;, that 
</I>&gt;<i> defines fallback content. To avoid the confusion of mixing the fallback 
</I>&gt;<i> paragraphs with the sentences of the surrounding paragraph in the case 
</I>&gt;<i> where the object resource is not supported, the spec suggests explicitly 
</I>&gt;<i> marking up the fallback paragraphs with &lt;p&gt; tags (which makes sense to 
</I>&gt;<i> me), but it also suggests marking the sentences before and after the 
</I>&gt;<i> object element as paragraphs. This latter suggestion doesn't make sense 
</I>&gt;<i> to me, because in the original example, those sentences constituted a 
</I>&gt;<i> single paragraph (since &lt;object&gt; is phrasing content). Wouldn't it be 
</I>&gt;<i> more correct to only mark the fallback paragraphs as paragraphs?
</I>
If you did that, you'd still have the confusion of an outer paragraph that 
somehow overlapped inner paragraphs. It would render a little better, but 
be just as semantically confusing.



There were also some more e-mails about &lt;main&gt;. I haven't replied to them 
explicitly because none of them introduce new material that hasn't already 
been discussed.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="038275.html">[whatwg] Paragraph with overlapping fallback content
</A></li>
	<LI>Next message: <A HREF="080759.html">[whatwg] Feedback on a variety of elements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#80624">[ date ]</a>
              <a href="thread.html#80624">[ thread ]</a>
              <a href="subject.html#80624">[ subject ]</a>
              <a href="author.html#80624">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
