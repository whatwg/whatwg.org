<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Peer-to-peer communication, video conferencing, &lt;device&gt;, and related topics
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Peer-to-peer%20communication%2C%20video%20conferencing%2C%20%3Cdevice%3E%2C%0A%20and%20related%20topics&In-Reply-To=%3CPine.LNX.4.64.1103141858460.19153%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="073271.html">
   <LINK REL="Next"  HREF="073217.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Peer-to-peer communication, video conferencing, &lt;device&gt;, and related topics</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Peer-to-peer%20communication%2C%20video%20conferencing%2C%20%3Cdevice%3E%2C%0A%20and%20related%20topics&In-Reply-To=%3CPine.LNX.4.64.1103141858460.19153%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] Peer-to-peer communication, video conferencing, &lt;device&gt;, and related topics">ian at hixie.ch
       </A><BR>
    <I>Thu Mar 17 21:45:06 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="073271.html">[whatwg] PeerConnection: encryption feedback
</A></li>
        <LI>Next message: <A HREF="073217.html">[whatwg] Peer-to-peer communication, video conferencing, &lt;device&gt;, and related topics
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30941">[ date ]</a>
              <a href="thread.html#30941">[ thread ]</a>
              <a href="subject.html#30941">[ subject ]</a>
              <a href="author.html#30941">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
When replying to this e-mail please only quote the parts to which you are 
responding, and adjust the subject line accordingly.

This e-mail is a reply to about a year's worth of feedback collected on 
the topics of peer-to-peer communication, video conferencing, the &lt;device&gt; 
element, and related topics. This feedback was used to update the spec 
recently, greatly expanding on the placeholder that had previously 
sketched a proposal for how these features should work. (This e-mail does 
not include replies to most of the feedback received after the change to 
the spec. I'll be replying to the bulk of this more recent feedback in a 
separate e-mail soonish.)

Here is a high-level overview of the changes; for specific rationales, 
please see the detailed responses to the e-mails below.

 * &lt;device&gt; has been replaced with a Geolocation-style API for requesting 
   user access to local media devices (such as cameras).

 * locally-generated streams can be paused and resumed.

 * the ConnectionPeer interface has been replaced with a PeerConnection 
   interface that interacts directly with ICE and its dependencies.

 * PeerConnection has been streamlined (compared to ConnectionPeer), e.g. 
   there is no longer a feature for direct file transfer or for reliable 
   text messaging.

 * the wire format for the unreliable data channel has been specified.

 * the spec has been brought up to date with recent developments in other 
   Web specs such as File API and WebIDL.


On Mon, 22 Mar 2010, Mark Frohnmayer wrote:
&gt;<i> 
</I>&gt;<i> I am currently engaged by InstantAction to develop a minimum-footprint 
</I>&gt;<i> web API prototype plugin for real-time networked games.  The purpose of 
</I>&gt;<i> this work is to propose to this standards process a path for real-time 
</I>&gt;<i> networked client/server and peer-to-peer games and applications to live 
</I>&gt;<i> as first-class citizens in the browser app sandbox.
</I>
With the introduction of PeerConnection and WebSockets, it looks like 
we'll soon be there!


On Mon, 3 May 2010, Mark Frohnmayer wrote:
&gt;<i> 
</I>&gt;<i> For the purposes of discussion there seem to be two distinct issues - 
</I>&gt;<i> peer introduction, where two clients establish a direct connection via 
</I>&gt;<i> some trusted third party, and data transmission protocol which could 
</I>&gt;<i> range from raw UDP to higher-level protocols like XML-RPC over HTTP.
</I>
I'm not sure how XML-RPC over HTTP would work in this context, but yes.

For peer introduction I've allowed scripts to use whatever existing 
mechanisms they would like to use (e.g. XMLHttpRequest) to communicate 
via a server component. For data transmission, I've used a combination of 
ICE and a custom trivial UDP-based format specified in the spec.


&gt;<i> For real-time games, specific concerns include flow control, protocol 
</I>&gt;<i> overhead and retransmission policy; thus most real-time games implement 
</I>&gt;<i> custom network protocols atop UDP.  Peer introduction is also important 
</I>&gt;<i> - responsiveness can often be improved and hosting bandwidth costs 
</I>&gt;<i> reduced by having peers connect directly.  For other p2p apps (chat, 
</I>&gt;<i> etc), specific control of flow and data retransmission may be less (or 
</I>&gt;<i> not) important, but peer introduction is still relevant.
</I>
Agreed.


&gt;<i> In reading of the current state of the spec's p2p section, it appears to 
</I>&gt;<i> be poorly suiting to real-time gaming applications, as well as 
</I>&gt;<i> potentially over-scoped for specific p2p applications.
</I>
Could you elaborate on the specific concerns you had and on whether the 
latest changes have addressed them?


&gt;<i> This leads me to wonder about (1) the viability of including peer 
</I>&gt;<i> introduction into WebSocket as an alternative to a high-level peer to 
</I>&gt;<i> peer interface in the spec
</I>
As far as I can tell, WebSockets isn't really relevant here. The wire 
format for WebSockets has a very different set of design criteria. The API 
for WebSockets is similar to the API I've used for PeerConnection, but 
that's just a matter of keeping Web APIs consistent and isn't really 
specific to PeerConnection or WebSockets.


&gt;<i> (2) including a lower-level unreliable protocol mode, either as part or 
</I>&gt;<i> distinct from WebSocket,
</I>
Done.


&gt;<i> and (3) who, if anyone, is currently driving the p2p section of the 
</I>&gt;<i> spec.
</I>
The browser vendors are always the people who drive all these things. 
Without implementations, specs are irrelevant.


On Tue, 4 May 2010, Erik M&#246;ller wrote:
&gt;<i> 
</I>&gt;<i> I'm an old gamedev recently turned browserdev so this is of particular 
</I>&gt;<i> interest to me, especially as I'm currently working on WebSockets. 
</I>&gt;<i> WebSockets is a nice step towards multiplayer games in browsers and will 
</I>&gt;<i> be even better once binary frames are speced out but as Mark says 
</I>&gt;<i> (depending on the nature of the game) gamedevs are most likely going to 
</I>&gt;<i> want to make their own UDP based protocol (in client-server models as 
</I>&gt;<i> well). Has there been any discussions on how this would fit under 
</I>&gt;<i> WebSockets?
</I>
There has not, as far as I'm aware.

PeerConnection could be used by a server as well, of course.


&gt;<i> Opera Unite can be mentioned as an interesting side note, it does peer 
</I>&gt;<i> introduction as well as subnet peer detection, but again that's TCP 
</I>&gt;<i> only.
</I>
I'm not familiar with Opera Unite; does it have anything to teach us here?


On Tue, 4 May 2010, Julien Cayzac wrote:
&gt;<i> 
</I>&gt;<i> I've been reading lately about the new proposed &lt;device&gt; element, and 
</I>&gt;<i> was wondering if it was needed at all.
</I>&gt;<i>
</I>&gt;<i> IMHO, a video originating from an attached camera is not different from 
</I>&gt;<i> a video originating from the network, so &lt;video&gt; could be used here.
</I>
&lt;video&gt; doesn't represent a video originating from the network, it 
represents the &quot;sink&quot; (as opposed to &quot;source&quot;) which displays the video. 
The video from the network is represented by a URL. URLs aren't the idea 
mechanism to manipulate objects in JS, which is why I went with &lt;device&gt; 
originally, and now getUserMedia().


&gt;<i> Displaying the webcam in a page could be done like this:
</I>&gt;<i> 
</I>&gt;<i> &lt;video autoplay controls&gt;
</I>&gt;<i>     &lt;source src=&quot;webcam:640,480,25&quot; /&gt; &lt;!-- 640x480, 25fps --&gt;
</I>&gt;<i>     &lt;source src=&quot;webcam:320,240,*&quot; /&gt; &lt;!-- will be tried if the webcam
</I>&gt;<i> doesn't support the above settings --&gt;
</I>&gt;<i>     &lt;source src=&quot;mire.mp4&quot; /&gt; &lt;!-- no webcam attached? show this video
</I>&gt;<i> instead --&gt;
</I>&gt;<i> &lt;/video&gt;
</I>
The problem with this is that it doesn't have very clear security 
properties. How do you get permission to use the webcam: protocol from 
the user? How do you pass such permissions to other origins?


&gt;<i> Same could be done with &lt;audio&gt; for adding microphone support
</I>
(Note that &lt;audio&gt; and &lt;video&gt; are the same element except for the minor 
detail of how they are rendered. Both can handle both audio and video.)


&gt;<i> in both cases the browser should notify the user the page is requesting 
</I>&gt;<i> permission to access these devices.
</I>
How?


&gt;<i> Now, I am aware HTMLMediaElement doesn't offer any methods to actually 
</I>&gt;<i> query the data it serves or to get notified as more incoming data gets 
</I>&gt;<i> received, which makes my proposal useless. Still, such methods could be 
</I>&gt;<i> used in other scenarios, like a browser-based video editing app, so 
</I>&gt;<i> adding them would make sense in my opinion.
</I>
Video editing is going to be an interesting case to deal with, but I think 
a convincing case could be made arguing that while &lt;video&gt; is the display 
component of such a use case, the editing component has to be a separate 
object that is then plugged into &lt;video&gt;. Otherwise, how can you display 
multiple views on the same edited video, for instance?


On Tue, 4 May 2010, Julien Cayzac wrote:
&gt;<i> 
</I>&gt;<i> It was in my message: &quot;in both cases the browser should notify the user 
</I>&gt;<i> the page is requesting permission to access these devices&quot;. The same is 
</I>&gt;<i> done today with the geolocation feature, for instance. The user has to 
</I>&gt;<i> give access permission to the page, in a browser-dependent way.
</I>
Geolocation works via a JS API, though, not a URL. I don't understand how 
they could be treated in equivalent ways.


On Fri, 21 May 2010, Nicklas Sandgren wrote:
&gt;<i>
</I>&gt;<i> As mentioned in the draft, the peer-to-peer API must rely on underlying 
</I>&gt;<i> protocols/mechanisms to establish the connections and to transport the 
</I>&gt;<i> streams. What are the thoughts regarding these protocols, and has there 
</I>&gt;<i> been any discussion around this topic?
</I>
Over the past year there has been remarkably little discussion on this 
topic on this list. From discussing the issue with various people, reading 
comments on lists such as rtc-web, and listening to comments at events 
such as the RTC workshop that Google hosted last year, I came to the 
conclusion that those with an opinion on the matter mostly wanted to see a 
model that was as close to SIP as makes sense, so as to enable gatewaying 
from the Web to legacy (and future) SIP devices. So I ended up going with 
ICE implemented pretty close to what SIP does, with some extension hooks 
for the future if we need them. This allows pretty straight-forward 
gatewaying to SIP while supporting the key use cases for the Web.


&gt;<i> An alternative approach could be to define APIs for managing streams 
</I>&gt;<i> only, and leave session set up as well as additional functionality 
</I>&gt;<i> (file, text, image share) to the application using the means already 
</I>&gt;<i> available such as XMLHttpRequest and WebSocket. The session set up would 
</I>&gt;<i> in this scenario not rely on a third party server, but rather be handled 
</I>&gt;<i> by the server that serves the current web application. This would remove 
</I>&gt;<i> the need for agreeing on formats for client and server configuration 
</I>&gt;<i> strings or protocols to talk to third-party servers.
</I>
Relaying through a server is both hugely expensive on the service 
provider, and introduces a high latency that is quite problematic. I think 
it's important that we support direct peer-to-peer video if we can.


&gt;<i> You could also debate how often peer-to-peer media streams will actually 
</I>&gt;<i> work. Aren't FWs and NATs going to give problems in many cases?
</I>
ICE + TURN handles most of these cases, thankfully.


&gt;<i> Maybe it would be better to design for a situation where the media 
</I>&gt;<i> always go via a server. Additional benefits are that WS could be used 
</I>&gt;<i> for media transport, and that the media could be transcoded if the codec 
</I>&gt;<i> capabilities of the clients do not match.
</I>
Transcoding is even more expensive and introduces even more latency.


On Thu, 27 May 2010, Mark Frohnmayer wrote:
&gt;<i> 
</I>&gt;<i> To answer the question of problem in p2p regarding FWs and NATs, the 
</I>&gt;<i> libjingle folks report that 92% of participants are able to connect 
</I>&gt;<i> directly: 
</I>&gt;<i> <A HREF="http://code.google.com/apis/talk/libjingle/important_concepts.html#connections">http://code.google.com/apis/talk/libjingle/important_concepts.html#connections</A> 
</I>&gt;<i> with the remainder using simple message relay servers.
</I>
That's very helpful data, thanks.


On Thu, 27 May 2010, James Salsman wrote:
&gt;<i> 
</I>&gt;<i> Why is relying on TCP for reliable delivery inferior to asking 
</I>&gt;<i> applications to re-implement reliable transmission?
</I>
For much of the data discussed here -- media streams and game data in 
particular -- reliable transmission is not a requirement. In fact, low 
latency is far more important, and TCP does not provide for optimally low 
latency compared to solutions based on UDP.


On Thu, 27 May 2010, James Salsman wrote:
&gt;<i> 
</I>&gt;<i> Would it be appropriate to allow selection between reliable delivery 
</I>&gt;<i> involving delay and unreliable delivery with the shorter delay 
</I>&gt;<i> characteristics of UDP by allowing the user to select between the 
</I>&gt;<i> TCP-based asynchronous HTTP/HTTPS multipart/form-encoded POST of input 
</I>&gt;<i> type=file accept=audio as per <A HREF="http://www.w3.org/TR/device-upload">http://www.w3.org/TR/device-upload</A> and use 
</I>&gt;<i> UDP for synchronous or asynchronous device element I/O?
</I>
On Sat, 29 May 2010, Mark Frohnmayer wrote:
&gt;<i> 
</I>&gt;<i> I can see use cases for both methods -- a voice mail, server based 
</I>&gt;<i> application could use a simple form submit upload, but a live voice 
</I>&gt;<i> conferencing app would need real-time access more like in the Capture 
</I>&gt;<i> API that the W3C DAP group has published: 
</I>&gt;<i> <A HREF="http://www.w3.org/TR/capture-api/">http://www.w3.org/TR/capture-api/</A> .  As they've laid it out, capture of 
</I>&gt;<i> audio/video is decoupled from the network transmission/streaming of the 
</I>&gt;<i> captured data, which makes sense.  The media file data captured could 
</I>&gt;<i> then be sliced into blobs and bounced off a server via WebSocket or sent 
</I>&gt;<i> to peers via the peer to peer API.  Again here it would make sense to me 
</I>&gt;<i> to pattern the p2p API more closely to WebSocket (i.e. send packets of 
</I>&gt;<i> bytes) than a higher level approach that tries to multiplex streams of 
</I>&gt;<i> data.
</I>
As the spec stands, both are indeed possible.


On Sun, 30 May 2010, James Salsman wrote:
&gt;<i>
</I>&gt;<i> It's hard for me to take <A HREF="http://www.w3.org/TR/capture-api/#formatdata">http://www.w3.org/TR/capture-api/#formatdata</A> 
</I>&gt;<i> seriously.  There are no references to open codecs or codec parameters; 
</I>&gt;<i> the only audio codec specified is audio/x-wav, which is a 
</I>&gt;<i> Microsoft-defined union type (RIFF) with a huge number of different 
</I>&gt;<i> possible instance types, including only a few poor quality open vocoders 
</I>&gt;<i> and audio codecs by contemporary performance/bandwidth standards.  
</I>&gt;<i> Where is speex or ogg vorbis?  Where are their quality and bit rate 
</I>&gt;<i> parameters?  Why is <A HREF="http://www.w3.org/TR/capture-api/#future">http://www.w3.org/TR/capture-api/#future</A> empty when 
</I>&gt;<i> most of the normative sections say, &quot;No exceptions&quot;?  Where is the 
</I>&gt;<i> compatibility with existing file transfer standards?  The security 
</I>&gt;<i> section doesn't contemplate permissions revocation.
</I>&gt;<i> 
</I>&gt;<i> If audio were segmented into separate files as per 
</I>&gt;<i> <A HREF="http://www.w3.org/TR/capture-api/#captureaudiooptions">http://www.w3.org/TR/capture-api/#captureaudiooptions</A> how would that 
</I>&gt;<i> affect real-time performance on mobile devices?  Are these files 
</I>&gt;<i> required to have sequence numbers?  With phase vocoder time shifting, 
</I>&gt;<i> UDP delivery as per <A HREF="http://dev.w3.org/html5/html-device/#stream-api">http://dev.w3.org/html5/html-device/#stream-api</A> 
</I>&gt;<i> would be far superior in quality and intelligibility under packet loss 
</I>&gt;<i> or delay, assuming they went with an open audio codec (or, even better, 
</I>&gt;<i> allowed a choice of speex or ogg vorbis.)
</I>
I fear the PeerConnection stuff doesn't mention phase vocoder time 
shifting, codecs (open or otherwise), or sequence numbers, so it may not 
meet your needs either! If there's anything specific you would like 
defined, please let me know. Bear in mind though that we currently cannot 
realistically mandate a specific modern codec, since user agent vendors 
are still in disagreement regarding which codec to implement.


On Mon, 31 May 2010, Robin Berjon wrote:
&gt;<i> 
</I>&gt;<i> When a specification is fully complete, mature, and stable, we tend to 
</I>&gt;<i> release it.
</I>
Do you keep it captive before then? :-)


On Mon, 31 May 2010, Mark Frohnmayer wrote:
&gt;<i> 
</I>&gt;<i> To be clear I'm not advocating for one particular capture API or codec; 
</I>&gt;<i> rather I'm advocating that capture and record not be tied to network 
</I>&gt;<i> transport, and separately that the p2p network transport be flexible, 
</I>&gt;<i> low-level, low-overhead and have a minimal attack surface (suitable for 
</I>&gt;<i> real-time game data as well as audio/video).
</I>
Does the new text address this to your satisfaction?


On Tue, 1 Jun 2010, Erik M&#246;ller wrote:
&gt;<i>
</I>&gt;<i> The majority of the on-line games of today use a client/server model 
</I>&gt;<i> over UDP and we should try to give game developers the tools they 
</I>&gt;<i> require to create browser based games. For many simpler games a TCP 
</I>&gt;<i> based protocol is exactly what's needed but for most real-time games a 
</I>&gt;<i> UDP based protocol is a requirement. Games typically send small updates 
</I>&gt;<i> to its server at 20-30Hz over UDP and can with the help of entity 
</I>&gt;<i> interpolation and if required entity extrapolation cope well with 
</I>&gt;<i> intermittent packet loss.
</I>
Does PeerConnection address this use case to your satisfaction?

Note that currently it does not support binary data, but I've built in an 
extension mechanism to make this easy to add in the future.


On Tue, 1 Jun 2010, John Tamplin wrote:
&gt;<i> 
</I>&gt;<i> But there is so much infrastructure that would have to be enabled to use 
</I>&gt;<i> UDP from a web app.  How would proxies be handled?  Even if specs were 
</I>&gt;<i> written and implementations available, how many years would it be before 
</I>&gt;<i> corporate proxies/firewalls supported WebSocket over UDP?
</I>&gt;<i>
</I>&gt;<i> I am all for finding a way to get datagram communication from a web app, 
</I>&gt;<i> but I think it will take a long time and shouldn't hold up current 
</I>&gt;<i> WebSocket work.
</I>
Agreed, the two are independent problems.


On Wed, 2 Jun 2010, Erik M&#246;ller wrote:
&gt;<i> 
</I>&gt;<i> No it can't be UDP, it'll have to be something layered on top of UDP. 
</I>&gt;<i> One of the game guys I spoke to last night said &quot;Honestly, I wish we 
</I>&gt;<i> just had real sockets.  It always seems like web coding comes down to 
</I>&gt;<i> reinventing a very old wheel in a far less convenient or efficient 
</I>&gt;<i> manner.&quot; To some extent I agree with him, but there's the security 
</I>&gt;<i> aspect we have to take into account or we'll see someone hacking the CNN 
</I>&gt;<i> website and injecting a little javascript and we'll have the DDOS attack 
</I>&gt;<i> of the century on our hands.
</I>
For the data UDP media stream in PeerConnection I tried to make it as pure 
UDP as I could, while still being safe and still being extensible. The 
packets are (doubly) obfuscated to prevent cross-protocol attacks, and you 
can only send data to an end-point that negotiated a key via SDP 
offer/answer and participated in ICE to select how the packets are routed, 
but beyond that it's as raw as I could make it. Hopefully it's enough.


&gt;<i> The reason I put down &quot;Socket is bound to one address&quot;, &quot;Reliable 
</I>&gt;<i> handshake&quot;, &quot;Reliable close handshake&quot; and &quot;Sockets open sequentially&quot; 
</I>&gt;<i> was for that exact reason, to try to make it &quot;DOS and tamper safe&quot;. The 
</I>&gt;<i> &quot;Sockets open sequentially&quot; means that if you allocate two sockets to 
</I>&gt;<i> the same server the second socket will wait for the first one to 
</I>&gt;<i> complete its handshake before attempting to connect.
</I>
I haven't done this, but since the other server has to participate in the 
ICE processing, and can delay the start of that indefinitely, it seems 
that we're safe here.


On Tue, 1 Jun 2010, Ben Garney wrote:
&gt;<i> 
</I>&gt;<i> To be clear, for games, the key win is the lossy delivery. That is what 
</I>&gt;<i> enables the game to make intelligent decisions about dealing with packet 
</I>&gt;<i> loss, out of order delivery, etc.
</I>
Specifically, the key win is low latency. Lossy delivery is just the 
acceptable cost that that implies.


On Tue, 1 Jun 2010, Philip Taylor wrote:
&gt;<i>
</I>&gt;<i> There are lots of features that seem very commonly desired in games: a
</I>&gt;<i> mixture of reliable and unreliable and reliable-but-unordered channels
</I>&gt;<i> (movement updates can be safely dropped but chat messages must never
</I>&gt;<i> be), automatic fragmentation of large messages, automatic aggregation
</I>&gt;<i> of small messages, flow control to avoid overloading the network,
</I>&gt;<i> compression, etc. And there's lots of libraries that build on top of
</I>&gt;<i> UDP to implement protocols halfway towards TCP in order to provide
</I>&gt;<i> those features:
</I>&gt;<i> <A HREF="http://msdn.microsoft.com/en-us/library/bb153248(VS.85">http://msdn.microsoft.com/en-us/library/bb153248(VS.85</A>).aspx,
</I>&gt;<i> <A HREF="http://opentnl.sourceforge.net/doxydocs/fundamentals.html,">http://opentnl.sourceforge.net/doxydocs/fundamentals.html,</A>
</I>&gt;<i> <A HREF="http://www.jenkinssoftware.com/raknet/manual/introduction.html,">http://www.jenkinssoftware.com/raknet/manual/introduction.html,</A>
</I>&gt;<i> <A HREF="http://enet.bespin.org/Features.html,">http://enet.bespin.org/Features.html,</A> etc.
</I>
I guess the question is how much of this do we want to build into the 
platform, vs allowing libraries to build on this again (as those above).


&gt;<i> UDP sockets seem like a pretty inadequate solution for the use case of 
</I>&gt;<i> realtime games - everyone would have to write their own higher-level 
</I>&gt;<i> networking libraries (probably poorly and incompatibly) in JS to provide 
</I>&gt;<i> the features that they really want. Browsers would lose the ability to 
</I>&gt;<i> provide much security, e.g. flow control to prevent 
</I>&gt;<i> intentional/accidental DOS attacks on the user's network, since they 
</I>&gt;<i> would be too far removed from the application level to understand what 
</I>&gt;<i> they should buffer or drop or notify the application about.
</I>
I've designed the UDP data channel to be extensible so that we can easily 
add this kind of thing in the future if we find that it would be useful in 
many cases, but I haven't added it yet because it seems premature to 
design a whole protocol for this kind of thing without having tested the 
basics first.


On Tue, 1 Jun 2010, Scott Hess wrote:
&gt;<i> 
</I>&gt;<i> Unix domain sockets allow you to pass file descriptors between 
</I>&gt;<i> processes.  It might be interesting to pass a WebSocket endpoint across 
</I>&gt;<i> a WebSocket.  If the clients can punch through NATs, it becomes a direct 
</I>&gt;<i> peer-to-peer connection, otherwise it gets proxied through the server.  
</I>&gt;<i> Probably makes implementations excessively complicated, though.  
</I>&gt;<i> UDP-style would be easier (no need to worry about data received by the 
</I>&gt;<i> server after it initiates pushing the endpoint to the other client - 
</I>&gt;<i> just drop it on the floor).
</I>
I don't really know how that would work, but it sounds intruiging. :-) 
Maybe in a future version we can work out a way to transmit a MessagePort 
object (from the MessageChannel feature) over the network...


On Thu, 3 Jun 2010, Erik M&#246;ller wrote:
&gt;<i> On Wed, 02 Jun 2010 19:48:05 +0200, Philip Taylor wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So they seem to suggest things like:
</I>&gt;<i> &gt; - many games need a combination of reliable and unreliable-ordered and
</I>&gt;<i> &gt; unreliable-unordered messages.
</I>&gt;<i> 
</I>&gt;<i> One thing to remember here is that browsers have other means for 
</I>&gt;<i> communication as well. I'm not saying we shouldn't support reliable 
</I>&gt;<i> messages over UDP, but just pointing out the option. I believe for 
</I>&gt;<i> example World of Warcraft uses this strategy and sends reliable traffic 
</I>&gt;<i> over TCP while movement and other real-time data goes over UDP.
</I>
That would indeed make sense.


&gt;<i> &gt; - many games need to send large messages (so the libraries do 
</I>&gt;<i> &gt; automatic fragmentation).
</I>&gt;<i> 
</I>&gt;<i> Again, this is probably because games have no other means of 
</I>&gt;<i> communication than the NW-library. I'd think these large reliable 
</I>&gt;<i> messages would mostly be files that need to be transferred 
</I>&gt;<i> asynchronously for which browsers already have the tried and tested 
</I>&gt;<i> XMLHttpRequest.
</I>
Are the large messages always reliable messages?


&gt;<i> &gt; - many games need to efficiently send tiny messages (so the libraries 
</I>&gt;<i> &gt; do automatic aggregation).
</I>&gt;<i> 
</I>&gt;<i> This is probably true for many other use-cases than games, but at least 
</I>&gt;<i> in my experience games typically use a bit-packer or range-coder to 
</I>&gt;<i> build the complete packet that needs to be sent. But again, it's a 
</I>&gt;<i> matter of what level you want to place the interface.
</I>
This seems relatively easy to layer on top of the current protocol in the 
spec, but if we find it commonly used we can also add it explicitly as an 
extension.


&gt;<i> &gt; Perhaps also:
</I>&gt;<i> &gt; - Cap or dynamic limit on bandwidth (you don't want a single web page
</I>&gt;<i> &gt; flooding the user's network connection and starving all the TCP
</I>&gt;<i> &gt; connections)
</I>
Not really sure what the spec should say about this.


&gt;<i> &gt; - Protection against session hijacking
</I>&gt;<i> 
</I>&gt;<i> Great
</I>
The spec uses an encryption mechanism to prevent this.


&gt;<i> &gt; - Protection against an attacker initiating a legitimate socket with a 
</I>&gt;<i> &gt; user and then redirecting it (with some kind of IP (un)hijacking) to a 
</I>&gt;<i> &gt; service behind the user's firewall (which isn't a problem when using 
</I>&gt;<i> &gt; TCP since the service will ignore packets when it hasn't done the TCP 
</I>&gt;<i> &gt; handshake; but UDP services might respond to a single packet from the 
</I>&gt;<i> &gt; middle of a websocket stream, so every single packet will have to be 
</I>&gt;<i> &gt; careful not to be misinterpreted dangerously by unsuspecting 
</I>&gt;<i> &gt; services).
</I>
The packets are masked so that you couldn't do anything but DOS attacks in 
this kind of scenario. (And you can do those already with TCP.)


On Fri, 4 Jun 2010, James May wrote:
&gt;<i>
</I>&gt;<i> Couldn't SCTP/DCCP (or a variant) over UDP (for NAT compatibility) work?
</I>&gt;<i> 
</I>&gt;<i> They seem both seem to be session oriented while loosening the other 
</I>&gt;<i> restrictions of TCP,
</I>
Wouldn't that be overkill? I guess it depends on what the use cases are 
exactly.


On Thu, 10 Jun 2010, Erik M&#246;ller wrote:
&gt;<i>
</I>&gt;<i> As discussed the following features/limitations are suggested: -Same API 
</I>&gt;<i> as WebSockets
</I>
I don't see how that would work. I've made them as similar as possible, 
but I don't think it makes sense to go further.


&gt;<i> with the possible addition of an attribute that allows the 
</I>&gt;<i> application developer to find the path MTU of a connected socket.
</I>
What's the use case?


&gt;<i> -Max allowed send size is 65,507 bytes.
</I>
Currently 65470, to handle the various headers used (see the spec).


&gt;<i> -Socket is bound to one remote address at creation and stays connected 
</I>&gt;<i> to that host for the duration of its lifetime.
</I>
I've specced it in such a way that ICE could rebind the connection later; 
is that ok?


&gt;<i> -IP Broadcast/Multicast addresses are not valid remote addresses and 
</I>&gt;<i> only a set range of ports are valid.
</I>
I've left this up to the ICE layer.


&gt;<i> -Reliable handshake with origin info (Connection timeout will trigger 
</I>&gt;<i> close event.)
</I>
Not sure what the handshake should do here. Could you elaborate?

Also there's currently no origin protection for peer-to-peer stuff (there 
is for the STUN/TURN part; the origin is the long-term credential). We 
could certainly add something; how should it work? What are the attack 
scenarios we should consider?


&gt;<i> -Automatic keep-alives (to detect force close at remote host and keep 
</I>&gt;<i> NAT traversal active)
</I>
I've left that up to the ICE layer.


&gt;<i> -Reliable close handshake
</I>
This can be done over the signaling layer independent of the UDP channel.


&gt;<i> -Sockets open sequentially (like current DOS protection in WebSockets) 
</I>&gt;<i> or perhaps have a limit of one socket per remote host.
</I>&gt;<i> -Cap on number of open sockets per host and global user-agent limit.
</I>
UDP doesn't really have sockets, so I don't really know how to do this.


&gt;<i> Some additional points that were suggested on this list were: -Key 
</I>&gt;<i> exchange and encryption If you do want to have key exchange and 
</I>&gt;<i> encryption you really shouldn't reinvent the wheel but rather use a 
</I>&gt;<i> secure WebSocket connection in addition to the UDP-WebSocket. Adding key 
</I>&gt;<i> exchange and encryption to the UDP-WebSocket is discouraged.
</I>
Not really sure what this means.


&gt;<i> -Client puzzles to reduce connection depletion/CPU depletion attacks to 
</I>&gt;<i> the handshake. If the goal is to prevent DOS attacks on the accepting 
</I>&gt;<i> server this seems futile. Client puzzles only raises the bar ever so 
</I>&gt;<i> slightly for an attacker so this is also discouraged.
</I>
Could you elaborate on this?


&gt;<i> -Packet delivery notification to be a part of the API. Again this is 
</I>&gt;<i> believed to be better left outside the UDP-WebSockets spec and 
</I>&gt;<i> implemented in javascript if the application developer requires it.
</I>
Agreed.


On Thu, 10 Jun 2010, Mark Frohnmayer wrote:
&gt;<i> 
</I>&gt;<i> I'd recommend doing some real-world testing for max packet size.  Back 
</I>&gt;<i> when the original QuakeWorld came out it started by sending a large 
</I>&gt;<i> connect packet (could be ~8K) and a good number of routers would just 
</I>&gt;<i> drop those packets unconditionally.  The solution (iirc) was to keep all 
</I>&gt;<i> packet sends below the Ethernet max of 1500 bytes.  I haven't verified 
</I>&gt;<i> this lately to see if that's still the case, but it seems real-world 
</I>&gt;<i> functionality should be considered.
</I>
Indeed. If there is a real-world limit to UDP packet size beyond what the 
specs suggest, then we should definitely adjust the spec accordingly.


&gt;<i> &gt; -Packet delivery notification to be a part of the API. &#160;Again this is 
</I>&gt;<i> &gt; believed to be better left outside the UDP-WebSockets spec and 
</I>&gt;<i> &gt; implemented in javascript if the application developer requires it.
</I>&gt;<i> 
</I>&gt;<i> I'd propose that doing this in the javascript level would result in 
</I>&gt;<i> unnecessary extra overhead (sequence numbering, acknowledgements) that 
</I>&gt;<i> could easily be a part of the underlying protocol.  Having implemented 
</I>&gt;<i> multiple iterations of a high-level networking API, the notification 
</I>&gt;<i> function is a critical, low-overhead tool for making effective 
</I>&gt;<i> higher-level data guarantees possible.
</I>
I don't understand why it makes a difference if it's part of the JS or the 
underlying protocol in this case.


On Fri, 11 Jun 2010, Erik M&#246;ller wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; I'd recommend doing some real-world testing for max packet size.  
</I>&gt;<i> &gt; Back when the original QuakeWorld came out it started by sending a 
</I>&gt;<i> &gt; large connect packet (could be ~8K) and a good number of routers would 
</I>&gt;<i> &gt; just drop those packets unconditionally.  The solution (iirc) was to 
</I>&gt;<i> &gt; keep all packet sends below the Ethernet max of 1500 bytes.  I haven't 
</I>&gt;<i> &gt; verified this lately to see if that's still the case, but it seems 
</I>&gt;<i> &gt; real-world functionality should be considered.
</I>&gt;<i> 
</I>&gt;<i> Absolutely, that's why the path-MTU attribute was suggested. The ~64k 
</I>&gt;<i> limit is an absolute limit though at which sends can be rejected 
</I>&gt;<i> immediately without even trying.
</I>
Could you elaborate on this use case?


&gt;<i> &gt; If WebSocket supports an encrypted and unencrypted mode, why would the 
</I>&gt;<i> &gt; real-time version not support data security and integrity?
</I>&gt;<i> 
</I>&gt;<i> The reasoning was that if you do need data security and integrity the secure
</I>&gt;<i> websocket over TCP uses the same state-of-the-art implementation as the
</I>&gt;<i> browsers already have implemented. Secure connections over UDP would either
</I>&gt;<i> require a full TCP over UDP implementation (to use TLS) or a second
</I>&gt;<i> implementation that would need to be maintained. That implementation would be
</I>&gt;<i> either a very complex piece or software or clearly inferior to that users are
</I>&gt;<i> accustomed to.
</I>&gt;<i> So what's a good use-case where you want a secure connection over UDP and
</I>&gt;<i> cannot use a second TLS connection?
</I>
Games, if you want to prevent some forms of cheating. I don't necessarily 
agree that we have to do anything as complex as TLS (or DTLS) though. 
Encrypting the data stream gets us a long way there; we can add some 
integrity protection and replay protection reasonably easily too. Since we 
have a (presumed secure) signaling channel, a lot of the complexity of 
(e.g.) DTLS is unnecessary.


On Wed, 9 Jun 2010, Rob Evans wrote:
&gt;<i>
</I>&gt;<i> We currently run a news service that requires users log on to access our 
</I>&gt;<i> data and market reports (practically all major banking institutions in 
</I>&gt;<i> the world use us). I could envisage either a thumb-print reader allowing 
</I>&gt;<i> us to authenticate the user biometrically, or providing each user with a 
</I>&gt;<i> USB thumb stick that contains a unique identifier of some sort that when 
</I>&gt;<i> read using the device element could be used to authenticate them like a 
</I>&gt;<i> sort-of &quot;web-dongle&quot;.
</I>&gt;<i> 
</I>&gt;<i> One of our big issues is plagiarism and password sharing amongst our 
</I>&gt;<i> clients. This type of access would allow us to lock down secure content 
</I>&gt;<i> without having to install applications on the client computers which as 
</I>&gt;<i> you can imagine, is a no-no when dealing with banks!
</I>
That's an interesting use case, but I'm not sure &lt;device&gt; would make sense 
as a way to address it. Probably best to do this as some kind of &lt;input 
type=password&gt; extension, or reuse the personal device features that some 
browsers have for user certs.


On Mon, 27 Dec 2010, Seth Brown wrote:
&gt;<i>
</I>&gt;<i> I'm currently working on integrating serial port connected hardware with 
</I>&gt;<i> a web application I'm developing. The only solution is for the user to 
</I>&gt;<i> install local adapter software. This defeats the purpose of using a web 
</I>&gt;<i> app over desktop software.
</I>&gt;<i> 
</I>&gt;<i> In order for web applications to be gain traction over desktop software, 
</I>&gt;<i> they must be able to interface with usb/RS232. I believe the security 
</I>&gt;<i> trade off is worth it.
</I>
I encourage you to try going through the process for adding features:

   <A HREF="http://wiki.whatwg.org/wiki/FAQ#Is_there_a_process_for_adding_new_features_to_a_specification.3F">http://wiki.whatwg.org/wiki/FAQ#Is_there_a_process_for_adding_new_features_to_a_specification.3F</A>

In particular, I'm not sure there is enough browser vendor interest in 
RS232 access currently to make it viable for the spec to support that 
case. (Much as I would personally love to see it.)


&gt;<i> I also believe that the working group should make the device element
</I>&gt;<i> spec a high priority. If you don't google will probably implement
</I>&gt;<i> their own version for chrome OS(it will be necessary in a browser
</I>&gt;<i> based OS model).
</I>
Actually browser extensions of that nature are an important part of the 
process. If Google's Chrome OS team do add such features, that would be 
very helpful in evaluating what the right direction is for the spec.


(I haven't included responses here for the many e-mails discussing various 
ways to expose devices to Web pages involving <A HREF="file://">file://</A> URLs, ACLS, and 
various other ideas. I strongly recommend following the steps in the wiki 
page above, starting with collecting use cases and following that up with 
getting some browsers to implement some experiments in this space. So 
far, it seems the browser vendors are quite reluctant.)


On Sat, 12 Jun 2010, Bjartur Thorlacius wrote:
&gt;<i>
</I>&gt;<i> What is the use case for &lt;device&gt;? I&#194;&#180;ve searched the archives, read a 
</I>&gt;<i> thread, Googled around and read a document on the subject, but still I 
</I>&gt;<i> haven&#194;&#180;t found a use case for it other than it is going to magically 
</I>&gt;<i> increase user privacy.
</I>&gt;<i> 
</I>&gt;<i> &lt;input type=file accept=&quot;audio/*&quot;&gt; is a standard and compatible way to 
</I>&gt;<i> request audio stream(s). I can&#194;&#180;t see any drawbacks to using &lt;input&gt; for 
</I>&gt;<i> audiovisual streams at least.
</I>
&lt;input type=file&gt; is something you can submit in a form submission. It has 
to be finite. I don't think that really works for video conferencing 
streams, which is the use case here.


On Wed, 16 Jun 2010, Bjartur Thorlacius wrote:
&gt;<i>
</I>&gt;<i> Are file inputs defined to be more buffered than &lt;device&gt;s? Where?
</I>
The &lt;input&gt; spec, by virtue of the way it is defined to return finite 
complete files, is entirely buffered. &lt;device&gt; is gone, but getUserMedia() 
is defined to return an infinite stream, which cannot be entirely 
buffered.


&gt;<i> IMO a streaming capability should rather be added to &lt;form&gt; than adding 
</I>&gt;<i> a brand-new &lt;device&gt; element.
</I>
I don't understand how this fits with &lt;form&gt;. It seems more similar to 
Geolocation; we tried adding that to &lt;form&gt; 5 or so years ago and ended up 
giving up and the use case was readdressed using an API.


On Tue, 6 Jul 2010, James Salsman wrote:
&gt;<i> 
</I>&gt;<i> Is there any reason not to protect both them with the same privacy and 
</I>&gt;<i> security authorization dialogs, and render them mostly the same, except 
</I>&gt;<i> for audio/* and video/* &lt;input&gt; you might have record/pause/play/submit 
</I>&gt;<i> while &lt;device&gt; would have record/pause?  For image/* the differences are 
</I>&gt;<i> less clear to me: perhaps &lt;input&gt; would have a viewfinder, (expandable 
</I>&gt;<i> on mobiles) shutter button, a filesystem browser button, and an 
</I>&gt;<i> (optional?) submit button, but an image/* &lt;device&gt; might only have a 
</I>&gt;<i> viewfinder and a shutter button. For the case of a camera, it would seem 
</I>&gt;<i> to me that the buffered approach is also superior, but the unbuffered 
</I>&gt;<i> &lt;device&gt; approach would allow audio and video teleconferencing.
</I>
In practice it seems authors would like more control over the UI than 
that. For example, video conferencing systems don't want to show any of 
those buttons, typically.


&gt;<i> Also, someone said it would be a good idea to mute audio input and 
</I>&gt;<i> output from any hidden tab.  I think this may be a reasonable user 
</I>&gt;<i> option (people who listen to podcasts might not like it), and wonder if 
</I>&gt;<i> microphone or other audio input should be muted from any window and tab 
</I>&gt;<i> without top-most focus and exposure.  Does anyone have thoughts on that 
</I>&gt;<i> question?
</I>
That seems like a UA UI issue.


On Tue, 6 Jul 2010, Bjartur Thorlacius wrote:
&gt;<i>
</I>&gt;<i> What about &lt;form autosubmit&gt; to request data to be automagically sent as 
</I>&gt;<i> soon as data is input and thus eliminate the buffering problem?
</I>
It's not clear to me how that would work. In a video conferencing 
environment, you really want to have the video stream be sent to the peer, 
not to a server.


On Wed, 15 Sep 2010, Nicklas Sandgren wrote:
&gt;<i> 
</I>&gt;<i> A typical video chat application would contain some view finder code 
</I>&gt;<i> similar to the example in the Working Draft document:
</I>&gt;<i> 
</I>&gt;<i> &lt;p&gt;To start chatting, select a video camera: &lt;device type=media onchange=&quot;update(this.data)&quot;&gt;&lt;/p&gt;
</I>&gt;<i> &lt;video autoplay&gt;&lt;/video&gt;
</I>&gt;<i> &lt;script&gt;
</I>&gt;<i> function update(stream) {
</I>&gt;<i>    document.getElementsByTagName('video')[0].src = stream.url;  }
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i> 
</I>&gt;<i> But assuming that the Stream is a combination of both audio and video media this is
</I>&gt;<i> actually not what you want in a video chat, because you will also play back your own 
</I>&gt;<i> audio to yourself.
</I>&gt;<i> 
</I>&gt;<i> To solve this in our implementation we defined two fragments, &quot;audio&quot; and &quot;video&quot;, 
</I>&gt;<i> for the Stream url. The application then can address a specific media component 
</I>&gt;<i> in the Stream like this:
</I>&gt;<i> 
</I>&gt;<i> document.getElementsByTagName('video')[0].src = stream.url + &quot;#video&quot;;
</I>&gt;<i> 
</I>&gt;<i> Is there some other way to solve this?
</I>
Just mute the &lt;video&gt; element.


On Thu, 16 Sep 2010, Jonathan Dixon wrote:
&gt;<i>
</I>&gt;<i> On a related note, another requirement for a view finder window in a 
</I>&gt;<i> chat application would be to horizontally flip the self view video 
</I>&gt;<i> stream, so the user sees a mirror image. I'm not sure where this might 
</I>&gt;<i> fit in the proposed APIs.
</I>
That's a rendering issue, not an API issue (style=&quot;transform:scaleX(-1)&quot; 
should do it once that spec is more widely implemented).


&gt;<i> Further, it could be useful to provide a way to query the video source 
</I>&gt;<i> as to whether the camera is oriented relative to the screen (if the 
</I>&gt;<i> underlying system knows; consider a phone device with both a main camera 
</I>&gt;<i> and self-view camera). This is needed to drive the decision on whether 
</I>&gt;<i> to do this horizontal flip or not. In fact, such an application may want 
</I>&gt;<i> to somehow indicate a preference for the self-view camera when multiple 
</I>&gt;<i> cameras are present in the selection list. c.f. a movie-making app which 
</I>&gt;<i> would prefer the outward facing camera.
</I>
Interesting.

In getUserMedia() the input is extensible; we could definitely add 
&quot;prefer-user-view&quot; or &quot;prefer-environment-view&quot; flags to the method (with 
better names, hopefully, but consider that 'rear' and 'front' are 
misleading terms -- the front camera on a DSLR faces outward from the 
user, the front camera on a mobile phone faces toward the user). The user 
still has to OK the use of the device, though, so maybe it should just be 
left up to the user to pick the camera? They'll need to be able to switch 
it on the fly, too, which again argues to make this a UA feature.

Similarly for exposing the kind of stream: we could add to GeneratedStream 
an attribute that reports this kind of thing. What is the most useful way 
of exposing this information?


On Wed, 22 Sep 2010, Rich Tibbett wrote:
&gt;<i>
</I>&gt;<i> Would it be possible to provide JS-based method to capture an individual 
</I>&gt;<i> frame from a &lt;video&gt; element?
</I>
This is possible via &lt;canvas&gt;.


On Tue, 23 Nov 2010, Anne van Kesteren wrote:
&gt;<i> On Fri, 19 Nov 2010 19:50:42 +0100, Per-Erik Brodin 
</I>&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">per-erik.brodin at ericsson.com</A>&gt; wrote:
</I>&gt;<i> &gt; We are about to start implementing stream.record() and StreamRecorder. 
</I>&gt;<i> &gt; The spec currently says that &#226;&#128;&#156;the file must be in a format supported 
</I>&gt;<i> &gt; by the user agent for use in audio and video elements&#226;&#128;&#157; which is a 
</I>&gt;<i> &gt; reasonable restriction. However, there is currently no way to set the 
</I>&gt;<i> &gt; output format of the resulting File that you get from recorder.stop(). 
</I>&gt;<i> &gt; It is unlikely that specifying a default format would be sufficient if 
</I>&gt;<i> &gt; you in addition to container formats and codecs consider resolution, 
</I>&gt;<i> &gt; color depth, frame rate etc. for video and sample size and rate, 
</I>&gt;<i> &gt; number of channels etc. for audio.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Perhaps an argument should be added to record() that specifies the 
</I>&gt;<i> &gt; output format from StreamRecorder as a MIME type with parameters? 
</I>&gt;<i> &gt; Since record() should probably throw when an unsupported type is 
</I>&gt;<i> &gt; supplied, it would perhaps be useful to have a canRecordType() or 
</I>&gt;<i> &gt; similar to be able to test for supported formats.
</I>&gt;<i> 
</I>&gt;<i> But if we want interoperability for streams, also taking into account 
</I>&gt;<i> P2P messaging, we need a single format. Otherwise users with different 
</I>&gt;<i> browsers could end up not being able to communicate.
</I>
We are indeed going to eventually need a single format. That's mostly why 
I haven't added anything regarding formats yet. (Well, we need at least 
one common format per browser pair, for every browser pair. If we get that 
instead of a single format, we would need to add something for sure.)


On Sat, 27 Nov 2010, Kevin Marks wrote:
&gt;<i>
</I>&gt;<i> For Audio at least, supporting uncompressed should be possible and 
</I>&gt;<i> uncontroversial, as there are clearly no patent issues here. Anyone 
</I>&gt;<i> serious about recording and processing audio would not consider 
</I>&gt;<i> recording compressed audio nowadays.
</I>
If you want to record audio, as opposed to streaming it, your best plan is 
probably the &lt;input type=file accept=audio/wave&gt; solution. Anything based 
on the streaming solution runs the very real risk of lost packets, at 
which point really how much compression you have is likely not that relevant.

However, we will probably end up supporting uncompressed recording using 
the getUserMedia() mechanism also, 


On Fri, 26 Nov 2010, Per-Erik Brodin wrote:
&gt;<i>
</I>&gt;<i> A Stream can be treated as an abstract representation of a media stream. 
</I>&gt;<i> When a Stream is to be transported over a peer-to-peer connection, the 
</I>&gt;<i> format can be negotiated between the peers. In the current 
</I>&gt;<i> ConnectionPeer API, such format negotiation would be transparent to the 
</I>&gt;<i> API. If we would specify a single resolution for video, for example, 
</I>&gt;<i> that resolution may be to high for some mobile devices to encode in 
</I>&gt;<i> real-time. A mismatch in supported formats is just one reason why a 
</I>&gt;<i> peer-to-peer transport may fail, but that doesn't mean that the peers 
</I>&gt;<i> can't communicate. When relaying through a server you can interoperate 
</I>&gt;<i> with anything.
</I>
Indeed. As specced, the PeerConnection API uses SDP Offer/Answer to 
negotiate this kind of thing.
 

&gt;<i> If you are referring to sendFile(file) on ConnectionPeer, the file may 
</I>&gt;<i> just as well come from the user's hard drive via &lt;input type=file&gt; and 
</I>&gt;<i> thus it will be up to the application to ensure that whatever is sent to 
</I>&gt;<i> the other peer is usable there.
</I>
Indeed. Incidentally, I dropped that feature for now, since you can just 
relay a file through the server, as latency in that case is far less 
important than reliability.


On Wed, 1 Dec 2010, Saurabh Jain wrote:
&gt;<i> 
</I>&gt;<i> We need access to Bluetooth devices using the Device element. Without 
</I>&gt;<i> Bluetooth access some of the use cases, specially in the mobile device 
</I>&gt;<i> domain would not be achievable.
</I>
On Thu, 2 Dec 2010, Diogo Resende wrote:
&gt;<i>
</I>&gt;<i> What about having the possibility to &quot;use&quot; a device other than a video? 
</I>&gt;<i> Maybe a specific hardware. I agree about not having a distinction on the 
</I>&gt;<i> hardware stack being used, but there should be a way for an app to be 
</I>&gt;<i> able to access an USBx/BT/FW device.
</I>
What is the use case you had in mind, specifically?


On Fri, 3 Dec 2010, Silvia Pfeiffer wrote:
&gt;<i>
</I>&gt;<i> IMO it's not so much about how the device is connected, but rather
</I>&gt;<i> what the device is: e.g. if it's a storage device then it should come
</I>&gt;<i> up as a storage device and not as a USB or FW device - the latter
</I>&gt;<i> doesn't really say what its use is.
</I>&gt;<i> 
</I>&gt;<i> It would be more interesting to hear more about what uses we are
</I>&gt;<i> seeing for the &lt;device&gt; element about what external devices it should
</I>&gt;<i> support than about what types of ports external devices should be able
</I>&gt;<i> to be hooked up through.
</I>&gt;<i> 
</I>&gt;<i> I can, e.g. think of input devices such as microphone, scanner,
</I>&gt;<i> camera, and output devices such as headphones/speakers (no need to
</I>&gt;<i> distinguish, probably), external displays, storage.
</I>&gt;<i> 
</I>&gt;<i> There probably are two dimensions to think about: is it an
</I>&gt;<i> input/output device, and what type of data does it provide/take.
</I>&gt;<i> Possibly also what format that data comes in/is given in.
</I>
On Thu, 2 Dec 2010, Anne van Kesteren wrote:
&gt;<i> 
</I>&gt;<i> That is only interesting for devices that are commonly used. For the 
</I>&gt;<i> long tail you need some kind of open-ended API.
</I>
As with the serial port suggestion earlier, I recommend experimenting with 
this in browsers. We need implementation experience before we can really 
say what the right way to do this is (and whether to do it at all).


On Thu, 2 Dec 2010, Diogo Resende wrote:
&gt;<i> 
</I>&gt;<i> For example, a medical device may have no interest to the OS but a web 
</I>&gt;<i> app (just like a desktop app) could get some interesting information and 
</I>&gt;<i> perhaps send some instructions. Maybe some API like the geolocation..
</I>
The Geolocation API is very geolocation-specific; it seems unlikely 
browsers would want to make a &quot;medical device API&quot;. How do we expose 
devices to the Web otherwise?


On Mon, 20 Dec 2010, Stephen Bannasch wrote:
&gt;<i> 
</I>&gt;<i> But I think I can make a powerful case that being able to create 
</I>&gt;<i> web-applications that can integrate easily with I/O devices that extend 
</I>&gt;<i> your senses is a wonderful area for innovation.
</I>
Agreed, if we can do this it would be great. It's not clear how to do it, 
though.


On Mon, 24 Jan 2011, Anne van Kesteren wrote:
&gt;<i> 
</I>&gt;<i> There is a plan of allowing direct assigning to IDL attributes besides 
</I>&gt;<i> creating URLs.
</I>&gt;<i> 
</I>&gt;<i> I.e. being able to do:
</I>&gt;<i> 
</I>&gt;<i>  audio.src = blob
</I>&gt;<i> 
</I>&gt;<i> (The src content attribute would then be something like &quot;about:objecturl&quot;.)
</I>&gt;<i> 
</I>&gt;<i> I am not sure if that API should work differently from creating URLs and 
</I>&gt;<i> assigning those, but we could consider it.
</I>
Could you elaborate on this plan?


On Tue, 25 Jan 2011, David Flanagan wrote:
&gt;<i> 
</I>&gt;<i> Adam's use case--to be able to download, play and cache audio data at 
</I>&gt;<i> the same time--seems like a pretty compelling one.  I think this is 
</I>&gt;<i> fundamentally an issue with the Blob API, not the URL API.  Blobs just 
</I>&gt;<i> seem like they ought to stream.  When you get a blob in the onprogress 
</I>&gt;<i> handler of an XHR2, you ought to be able to fire up a FileReader on it 
</I>&gt;<i> and have it automatically read from the blob as the XHR2 writes to the 
</I>&gt;<i> blob.  But currently (I think) you have to slice the blob to get only 
</I>&gt;<i> the new bytes and start a new FileReader each time onprogress is called.  
</I>&gt;<i> (Or wait for onload, of course.)
</I>
A Blob has a fixed size determined when the Blob is created. However, one 
could use Stream the way you describe, if we adjust XHR2 to expose a 
Stream as well.


On Wed, 26 Jan 2011, Patrik Persson J wrote:
&gt;<i>
</I>&gt;<i> We have done some experimentation with the ConnectionPeer API. We have 
</I>&gt;<i> an initial implementation of a subset of the API, using ICE (RFC 5245) 
</I>&gt;<i> for the peer-to-peer handshaking.  Our implementation is 
</I>&gt;<i> WebKit/GTK+/gstreamer-based, and we of course intend to submit it to 
</I>&gt;<i> WebKit, but the implementation is not quite ready for that yet.
</I>&gt;<i> 
</I>&gt;<i> More information about our work so far can be found here: 
</I>&gt;<i> <A HREF="https://labs.ericsson.com/developer-community/blog/beyond-html5-peer-peer-conversational-video">https://labs.ericsson.com/developer-community/blog/beyond-html5-peer-peer-conversational-video</A>
</I>
Great!


&gt;<i> However, we have bumped into some details that we'd like to discuss
</I>&gt;<i> here right away.  The following is our mix of proposals and questions.
</I>&gt;<i> 
</I>&gt;<i> 1. We propose adding a readyState attribute, to decouple the
</I>&gt;<i>    onconnect() callback from any observers (such as the UI).
</I>&gt;<i> 
</I>&gt;<i>       const unsigned short CONNECTING = 0;
</I>&gt;<i>       const unsigned short CONNECTED = 1;
</I>&gt;<i>       const unsigned short CLOSED = 2;
</I>&gt;<i>       readonly attribute unsigned short readyState;
</I>
Done, though with not quite the states you describe.


&gt;<i> 2. We propose replacing the onstream event with custom events of type
</I>&gt;<i>    RemoteStreamEvent, to distinguish between adding and removing
</I>&gt;<i>    streams.
</I>&gt;<i> 
</I>&gt;<i>       attribute Function onstreamadded;   // RemoteStreamEvent
</I>&gt;<i>       attribute Function onstreamremoved; // RemoteStreamEvent
</I>&gt;<i>       ...
</I>&gt;<i>       interface RemoteStreamEvent : Event {
</I>&gt;<i>          readonly attribute Stream stream;
</I>&gt;<i>       };
</I>&gt;<i> 
</I>&gt;<i>    The 'stream' attribute indicates which stream was added/removed.
</I>
Done.


&gt;<i> 3. We propose renaming addRemoteConfiguration to
</I>&gt;<i>    setRemoteConfiguration.  Our understanding of the ConnectionPeer is
</I>&gt;<i>    that it provides a single-point-to-single-point connection; hence,
</I>&gt;<i>    only one remote peer configuration is to be set, rather than many
</I>&gt;<i>    to be added.
</I>&gt;<i> 
</I>&gt;<i>       void setRemoteConfiguration(in DOMString configuration, in optional DOMString remoteOrigin);
</I>
ICE can send many messages over time, so it seems to make sense to support 
a more general signaling channel mechanic than either what the spec used 
to have or what you propose above. I've tried to make the spec more 
closely align with what ICE needs here.


&gt;<i> 4. We propose swapping the ConnectionPeerConfigurationCallback
</I>&gt;<i>    callback parameters. The current example seems to use only one (the
</I>&gt;<i>    second one).  Swapping them allows clients that care about 'server'
</I>&gt;<i>    to do so, and clients that ignore it (such as the current example)
</I>&gt;<i>    to do so too.
</I>&gt;<i> 
</I>&gt;<i>       [Callback=FunctionOnly, NoInterfaceObject]
</I>&gt;<i>       interface ConnectionPeerConfigurationCallback {
</I>&gt;<i>          void handleEvent(in DOMString configuration, in ConnectionPeer server);
</I>&gt;<i>       };
</I>
Done.


&gt;<i> 5. Should a size limit to text messages be specified? Text messages
</I>&gt;<i>    with UDP-like behavior (unimportant=true) can't really be reliably
</I>&gt;<i>    split into several UDP packets.  For such long chunks of data, file
</I>&gt;<i>    transfer seems like a better option anyway.
</I>
I've added a limit based on theoretical UDP limits, but I expect we will 
be bringing this down to match reality soon.


&gt;<i> In addition to the above there is a need to add support for identifying 
</I>&gt;<i> streams (so that the receiving end can use the right element for 
</I>&gt;<i> rendering)
</I>
Done.


&gt;<i> and for influencing the media format.
</I>
I have punted on this for now, but I expect we'll have to revisit this.


On Thu, 27 Jan 2011, Adam Malcontenti-Wilson wrote:
&gt;<i>
</I>&gt;<i> I was noticing how you were suggesting to change addRemoteConfiguration 
</I>&gt;<i> to setRemoteConfiguration as it appears as a 
</I>&gt;<i> single-point-to-single-point connection, is this part of the current 
</I>&gt;<i> specification or could single-point-to-multiple-points connections (or 
</I>&gt;<i> &quot;clouds&quot;) be implemented using the same API in the future? This would be 
</I>&gt;<i> a big bandwidth saver for users in &quot;group chats&quot; that would make some 
</I>&gt;<i> sense to use add rather than set (and perhaps have another optional 
</I>&gt;<i> parameter to replace rather than append or add).
</I>
Could you elaborate on your use case and possibly how you expect it to 
look like on the wire?


On Mon, 31 Jan 2011, Stefan H&#229;kansson LK wrote this use case:
&gt;<i>
</I>&gt;<i> A simple video chat service has been developed. In the service the users 
</I>&gt;<i> are logged on to the same chat web server. The web server publishes 
</I>&gt;<i> information about user login status, pushing updates to the web apps in 
</I>&gt;<i> the browsers. By clicking on an online peer user name, a 1-1 video chat 
</I>&gt;<i> session between the two browsers is initiated. The invited peer is 
</I>&gt;<i> presented with a choice of joining or rejecting the session.
</I>&gt;<i> 
</I>&gt;<i> The web author developing the application has decided to display a 
</I>&gt;<i> self-view as well as the video from the remote side in rather small 
</I>&gt;<i> windows, but the user can change the display size during the session. 
</I>&gt;<i> The application also supports if a participant (for a longer or shorter 
</I>&gt;<i> time) would like to stop sending audio (but keep video) or video (keep 
</I>&gt;<i> audio) to the other peer (&quot;mute&quot;).
</I>&gt;<i>
</I>&gt;<i> Any of the two participants can at any time end the chat by clicking a 
</I>&gt;<i> button.
</I>&gt;<i> 
</I>&gt;<i> In this specific case two users are using lap-tops in their respective 
</I>&gt;<i> homes. They are connected to the public Internet with a desktop browser 
</I>&gt;<i> using WiFi behind NATs. One of the users has an ADSL connection to the 
</I>&gt;<i> home, and the other fiber access. Most of the time headsets are used, 
</I>&gt;<i> but not always.
</I>
All of this except selectively muting audio vs video is currently 
possible in the proposed API.

The simplest way to make selective muting possible too would be to change 
how the pause/resume thing works in GeneratedStream, so that instead of 
pause() and resume(), we have individual controls for audio and video. 
Something like:

   void muteAudio();
   void resumeAudio();
   readonly attribute boolean audioMuted;
   void muteVideo();
   void resumeViduo();
   readonly attribute boolean videoMuted;

Alternatively, we could just have mutable attributes:

   attribute boolean audioEnabled;
   attribute boolean videoEnabled;

Any opinions on this?


&gt;<i> !Requirement. The user must:            !Comment                               !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !give explicit consent before a device  !                                      !
</I>&gt;<i> !can be used to capture audio or video  !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !be able to in an intuitive way revoke  !                                      !
</I>&gt;<i> !and change capturing permissions       !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !be able to easily understand that audio!                                      !
</I>&gt;<i> !or video is being captured             !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !be informed about that an invitation to!                                      !
</I>&gt;<i> !a peer video chat session has been     !                                      !
</I>&gt;<i> !received                               !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !be able to accept or reject an         !                                      !
</I>&gt;<i> !invitation to a peer video chat session!                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !be able to stop a media stream from    !                                      !
</I>&gt;<i> !being transmitted                      !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>
All of this seems possible in the current API.


&gt;<i> !It must be possible to update presence !Event. Out of scope for RTC-Web?      !
</I>&gt;<i> !info from web server and make web      !                                      !
</I>&gt;<i> !application aware.                     !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !It must be possible to propagate       !Out of scope for RTC-Web?             !
</I>&gt;<i> !intention to start a chat session from !                                      !
</I>&gt;<i> !one web app (via server), and make     !                                      !
</I>&gt;<i> !receiving web application aware.       !                                      !
</I>&gt;<i> !Likewise, the receiving web application!                                      !
</I>&gt;<i> !must be able to propagate its accept/  !                                      !
</I>&gt;<i> !reject to the initiating web app.      !                                      !
</I>
These seem out of scope for HTML, and more something the app would 
implement.


&gt;<i> !The web application must be able to use!Provided the user has given consent.  !
</I>&gt;<i> !cams and mics as input devices.        !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The web application must be able to    !I.e. how they are routed. To e.g. both!
</I>&gt;<i> !control how streams generated by input !a self-view and a peer                !
</I>&gt;<i> !devices are used                       !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The web application must be able to    !Use the audio and video elements?     !
</I>&gt;<i> !control how streams are rendered and   !                                      !
</I>&gt;<i> !displayed                              !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The web application must be able to    !                                      !
</I>&gt;<i> !initiate sending of streams to a peer  !                                      !
</I>
These are all supported.


&gt;<i> !The web application must be able to    !If the video is going to be displayed !
</I>&gt;<i> !define the media format to be used for !in a large window, use higher bit-    !
</I>&gt;<i> !the streams sent to a peer.            !rate/resolution. Should media settings!
</I>&gt;<i> !                                       !be allowed to be changed during a     !
</I>&gt;<i> !                                       !session (at e.g. window resize)?      !
</I>
Shouldn't this be automatic and renegotiated dynamically via SDP 
offer/answer?


&gt;<i> !The web application must be made aware !Event.                                !
</I>&gt;<i> !of whether set up of stream sending was!                                      !
</I>&gt;<i> !successful or not                      !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The web application must be made aware !Event. To be able to (with or without !
</I>&gt;<i> !when a stream from a peer is received  !user involvement) accept or reject,   !
</I>&gt;<i> !                                       !and to connect the stream to the right!
</I>&gt;<i> !                                       !display/rendering element.            !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The web application must be made aware !Event.                                !
</I>&gt;<i> !of when a stream from a peer is not    !                                      !
</I>&gt;<i> !received any more                      !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The web application in a session must  !                                      !
</I>&gt;<i> !be able to terminate all incoming and  !                                      !
</I>&gt;<i> !outgoing streams                       !                                      !
</I>
All possible.


&gt;<i> !The browser must be able to have an    !Out of scope for RTC-Web? Use WS or   !
</I>&gt;<i> !always on connection with the web      !S-SE?                                 !
</I>&gt;<i> !server to be able to receive presence  !                                      !
</I>&gt;<i> !updates and chat initiations           !                                      !
</I>
That's just &quot;AJAX&quot;.


&gt;<i> !The browser must be able to use mics   !                                      !
</I>&gt;<i> !and cams as input devices              !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The browser must be able to send       !                                      !
</I>&gt;<i> !streams (includes the associated       !                                      !
</I>&gt;<i> !processing like coding, framing, etc.) !                                      !
</I>&gt;<i> !to a peer in presence of NATs.         !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The browser must be able to receive    !                                      !
</I>&gt;<i> !streams (associated processing) from   !                                      !
</I>&gt;<i> !peers and render them                  !                                      !
</I>
That's all possible with the API.


&gt;<i> !Streams being transmitted must be      !Do not starve other traffic (e.g. on  !
</I>&gt;<i> !subject to rate control                !ADSL link)                            !
</I>
Not sure whether this requires any thing special. Could you elaborate?


&gt;<i> !When there is both incoming and        !Headsets not always used              !
</I>&gt;<i> !outgoing audio streams, echo           !                                      !
</I>&gt;<i> !cancellation must be provided to avoid !                                      !
</I>&gt;<i> !disturbing echo during conversation    !                                      !
</I>
That seems like a UA quality-of-implementation issue. I wouldn't want to 
require Web apps to have to implement this!


&gt;<i> !Synchronization between audio and video!                                      !
</I>&gt;<i> !must be supported                      !                                      !
</I>
If there's one stream, that's automatic, no?


&gt;<i> !The user must be informed that the     !                                      !
</I>&gt;<i> !communication has ceased               !                                      !
</I>
Both the UA and the Web app have the option to do this.


&gt;<i> !The web application must be made aware !To be able to inform user and take    !
</I>&gt;<i> !of that the connection with the server !action. Out of scope for RTC-Web?     !
</I>&gt;<i> !has been dropped                       !                                      !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The web application must be made aware !To be able to inform user and take    !
</I>&gt;<i> !of when streams from a peer are no     !action (one of the peers still has    !
</I>&gt;<i> !longer received                        !connection with the server)           !
</I>&gt;<i> --------------------------------------------------------------------------------
</I>&gt;<i> !The browser must detect when no streams!                                      !
</I>&gt;<i> !are received from a peer               !                                      !
</I>
These aren't really yet supported in the API, but I intend for us to add 
this kind of thing at the same time sa we add similar metrics to &lt;video&gt; 
and &lt;audio&gt;. To do this, though, it would really help to have a better 
idea what the requirements are. What information should be available? 
&quot;Packets received per second&quot; (and &quot;sent&quot;, maybe) seems like an obvious 
one, but what other information can we collect?


On Wed, 2 Feb 2011, Tab Atkins Jr. wrote:
&gt;<i>
</I>&gt;<i> The file input gained the @accept attribute a little while ago, to 
</I>&gt;<i> indicate what type of file should be accepted.  It has three special 
</I>&gt;<i> values, &quot;image/*&quot;, &quot;video/*&quot;, and &quot;audio/*&quot;.
</I>&gt;<i> 
</I>&gt;<i> I believe one intent of these special values is that browsers may offer 
</I>&gt;<i> the user the ability to capture an image/video/audio with the webcam/mic 
</I>&gt;<i> and automatically set it as the value of the &lt;input&gt;, without the user 
</I>&gt;<i> having to create an intermediary file themselves.
</I>&gt;<i> 
</I>&gt;<i> The spec doesn't give any indication of this, though, and I've surprised 
</I>&gt;<i> some people (browser devs, internally) when I tell them about @accept 
</I>&gt;<i> after they ask me about access the webcam/mic.
</I>&gt;<i> 
</I>&gt;<i> Could we get a note added to the File Input section describing this 
</I>&gt;<i> intention?
</I>
Done.


On Tue, 8 Feb 2011, Rich Tibbett wrote:
&gt;<i>
</I>&gt;<i> [1] <A HREF="http://www.w3.org/TR/capture-api/">http://www.w3.org/TR/capture-api/</A>
</I>
The parameter part of this seems unnecessary. Why would we not just always 
offer a camera?

The API part of this seems reasonable, but should probably be merged with 
the File API spec. Having lots of small specs makes the platform feel very 
fragmented and makes it much harder for us to update things consistently.


On Tue, 15 Feb 2011, Leandro Graci&#225; Gil wrote:
&gt;<i> 
</I>&gt;<i> Looking at the current state of the specification I see there is no 
</I>&gt;<i> mention about the expected lifetime of the stream objects, or to say it 
</I>&gt;<i> in another way, the period in which a page can access the selected 
</I>&gt;<i> device data. We would like to propose that the user can explicitly 
</I>&gt;<i> invalidate an existing stream so that any further access would require a 
</I>&gt;<i> new confirmation by the user.
</I>
The spec is hopefully clear that this is indeed allowed now.


On Wed, 16 Feb 2011, Anne van Kesteren wrote:
&gt;<i> 
</I>&gt;<i> This is just a thought. Instead of acquiring a Stream object 
</I>&gt;<i> asynchronously there always is one available showing transparent black 
</I>&gt;<i> or some such. E.g. navigator.cameraStream. It also inherits from 
</I>&gt;<i> EventTarget. Then on the Stream object you have methods to request 
</I>&gt;<i> camera access which triggers some asynchronous UI. Once granted an 
</I>&gt;<i> appropriately named event is dispatched on Stream indicating you now 
</I>&gt;<i> have access to an actual stream. When the user decides it is enough and 
</I>&gt;<i> turns of the camera (or something else happens) some other appropriately 
</I>&gt;<i> named event is dispatched on Stream again turning it transparent black 
</I>&gt;<i> again.
</I>
This is a very interesting idea.


On Wed, 16 Feb 2011, Andrei Popescu wrote:
&gt;<i> 
</I>&gt;<i> I thought we were all trying to avoid asynchronous UI (dialogs, 
</I>&gt;<i> infobars, popups, etc), which is a solution that does not scale very 
</I>&gt;<i> well when many different APIs require it. This was one of the main 
</I>&gt;<i> reasons for trying a different approach.
</I>
Whatever we do with this we'll have some sort of async UI, I think.


On Wed, 23 Feb 2011, John Knottenbelt wrote:
&gt;<i> 
</I>&gt;<i> I agree that clicking on the &lt;device&gt; element to bring up an async 
</I>&gt;<i> authorisation request works well because it corresponds strongly to the 
</I>&gt;<i> user's will to start and stop access to the device. However, I think 
</I>&gt;<i> that we should not be trying to save the user a click, because that 
</I>&gt;<i> would risk bothering the user with a dialog before they have made their 
</I>&gt;<i> intention to grant access to the device explicit. The principal 
</I>&gt;<i> application of &lt;device&gt; is to grant access to webcam devices which, I 
</I>&gt;<i> think, is sensitive enough to warrant the user having to initiate the 
</I>&gt;<i> authorisation process.
</I>
While I think this is in principle true (and is the original design behind 
&lt;device&gt;), in practice I think it makes UIs feel rather unnatural. Video 
conferencing systems today don't require the user to explicitly select the 
camera each time, for instance. Instead, the model of prompting the user 
with a non-modal bubble prompt (a la the Firefox 4 Geolocation prompt) 
allows the user to permanently grant a trusted site permission, while 
still allowing the user to ignore an annoying site's requests without 
having to click anywhere to dismiss the request.


(A number of people wrote e-mails with proposals but without providing 
rationales or use cases for particular design decisions. I examined the 
proposals, but have not included them here since I could not determine 
which parts of these proposals were intended to be substantial and which 
were intended to be merely supporting infrastructure. If there are 
specific ideas that were proposed that I have not addressed, please do 
reraise them, pointing out the relevant parts.)


On Mon, 28 Feb 2011, Harald Alvestrand wrote:
&gt;<i> 
</I>&gt;<i> I would very much want to avoid having the &quot;record to file/buffer&quot; be a 
</I>&gt;<i> fundamental part of the microphone abstraction, since it's irrelevant to 
</I>&gt;<i> my application (if anything should be recorded, it's the conversation, 
</I>&gt;<i> not the output from the microphone), so I think we should try to find a 
</I>&gt;<i> model where a microphone is an object that provides a data stream, and 
</I>&gt;<i> that data stream can be connected to a different object that acts as a 
</I>&gt;<i> recorder; if I don't need recording, I should not have to instantiate a 
</I>&gt;<i> recorder.
</I>
I have used this model in the spec (separating the recorder from the 
stream).


On Mon, 14 Mar 2011, Lachlan Hunt wrote:
&gt;<i> 
</I>&gt;<i> The IDL for GeneratedStream should indicate that it inherits from the 
</I>&gt;<i> Stream interface.
</I>
Thanks, fixed.


&gt;<i> The API includes both readystatechange event, as well as independent 
</I>&gt;<i> events for play, paused and ended.  This redundancy is unnecessary. This 
</I>&gt;<i> is also inconsistent with the design of the HTMLMediaElement API, which 
</I>&gt;<i> does not include a readystatechange event in favour on separate events 
</I>&gt;<i> only.
</I>
I've dropped readystatechange.

I expect to drop play and pause events if we move to the model described 
above that pauses and resumes audio and video separately.


&gt;<i> The API does not provide any way for the author to indicate a preferred 
</I>&gt;<i> camera.  Some devices include multiple cameras, particularly phones with 
</I>&gt;<i> front and rear facing cameras, and some use cases are better suited to 
</I>&gt;<i> one or the other.
</I>&gt;<i>
</I>&gt;<i> For example, an augmented reality application that takes advantage of 
</I>&gt;<i> geolocation and device orientation in order to overlay the video stream 
</I>&gt;<i> with things (e.g. push pins to identify points of interest, like on 
</I>&gt;<i> Google Street View). Such an application would be better suited for 
</I>&gt;<i> working with the rear facing camera.  But with a video conferencing 
</I>&gt;<i> application, the front facing camera would be more suitable.
</I>&gt;<i> 
</I>&gt;<i> It might therefore be useful for the author to provide a hint to this 
</I>&gt;<i> effect, which would allow the UA to more intelligently select the 
</I>&gt;<i> default camera for the user.
</I>
I've commented on this earlier in this mail. I would very much like to 
hear whether the proposal above is satisfactory for this use case.


&gt;<i> There are some use cases for which it would be useful to know the 
</I>&gt;<i> precise orientation of the camera, such as augmented reality 
</I>&gt;<i> applications.  The camera orientation may be independent of the device's 
</I>&gt;<i> orientation, and so the existing device orientation API may not be 
</I>&gt;<i> sufficient.
</I>&gt;<i> 
</I>&gt;<i> In the simple case, the front and rear cameras face in opposite 
</I>&gt;<i> directions, and so if an augmented reality application was built 
</I>&gt;<i> assuming it was using the rear camera, but the user instead granted 
</I>&gt;<i> access to the front camera, the calculations would be 180&#203;&#154; out.
</I>&gt;<i> 
</I>&gt;<i> Some devices may also provide cameras that may allow the camera to be 
</I>&gt;<i> rotated independently of the device itself, and so camera orientation 
</I>&gt;<i> information would need to allow for this.  I don't know the best way to 
</I>&gt;<i> provide this, and there likely to be issues about whether the camera 
</I>&gt;<i> orientation should be relative to the device itself, or relative to 
</I>&gt;<i> fixed Earth coordinates (North, East, Up), like the existing device 
</I>&gt;<i> orientation API.
</I>
It seems like the best way to extend this would be to have the Device 
Orientation API apply to GeneratedStream objects, either by just having 
the events also fire on GeneratedStream objects, or by having the API be 
based on a pull model rather than a push model and exposing an object on 
GeneratedStream objects as well as Window objects.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>











































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="073271.html">[whatwg] PeerConnection: encryption feedback
</A></li>
	<LI>Next message: <A HREF="073217.html">[whatwg] Peer-to-peer communication, video conferencing, &lt;device&gt;, and related topics
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30941">[ date ]</a>
              <a href="thread.html#30941">[ thread ]</a>
              <a href="subject.html#30941">[ subject ]</a>
              <a href="author.html#30941">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
