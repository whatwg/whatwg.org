<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg]  Peer-to-peer communication, video conferencing, and related topics (2)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%20Peer-to-peer%20communication%2C%20video%20conferencing%2C%0A%20and%20related%20topics%20%282%29&In-Reply-To=%3CPine.LNX.4.64.1103252005520.19153%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031057.html">
   <LINK REL="Next"  HREF="031060.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg]  Peer-to-peer communication, video conferencing, and related topics (2)</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%20Peer-to-peer%20communication%2C%20video%20conferencing%2C%0A%20and%20related%20topics%20%282%29&In-Reply-To=%3CPine.LNX.4.64.1103252005520.19153%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg]  Peer-to-peer communication, video conferencing, and related topics (2)">ian at hixie.ch
       </A><BR>
    <I>Mon Mar 28 18:00:53 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="031057.html">[whatwg]  Peer-to-peer communication, video conferencing, and related topics (3)
</A></li>
        <LI>Next message: <A HREF="031060.html">[whatwg] Peer-to-peer communication, video conferencing, and related topics (2)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31058">[ date ]</a>
              <a href="thread.html#31058">[ thread ]</a>
              <a href="subject.html#31058">[ subject ]</a>
              <a href="author.html#31058">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Tue, 15 Mar 2011, Lachlan Hunt wrote:
&gt;<i> 
</I>&gt;<i> In chat clients, like Skype, it's common for users to be able to adjust 
</I>&gt;<i> the microphone volume or mute the audio stream, or to enable or disable 
</I>&gt;<i> the video stream, without interupting the call.  However, the 
</I>&gt;<i> GeneratedStream interface only provides a very simple API to pause, 
</I>&gt;<i> resume or stop the entire stream, and not individual tracks within the 
</I>&gt;<i> stream.
</I>&gt;<i> 
</I>&gt;<i> e.g.
</I>&gt;<i> 
</I>&gt;<i> var stream;
</I>&gt;<i> navigator.getUserMedia(&quot;audio,video&quot;, success);
</I>&gt;<i> 
</I>&gt;<i> function success(s) {
</I>&gt;<i>   stream = s;
</I>&gt;<i>   // ... Code to make P2P connection for video chat
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> In this case, stream.pause() will pause both the audio and video 
</I>&gt;<i> streams, whereas the user, for example, may just temporarily want to 
</I>&gt;<i> pause the video stream, leaving the audio enabled.
</I>&gt;<i> 
</I>&gt;<i> While it may be possible for the browser to allow such control entirely 
</I>&gt;<i> from the browser chrome, independently of the page, the page author may 
</I>&gt;<i> wish to provide customised controls for these features.  I believe the 
</I>&gt;<i> API should be adjusted to allow the individual tracks within a stream to 
</I>&gt;<i> be paused or resumed independently of each other, and for there to be 
</I>&gt;<i> some way to adjust or mute the microphone volume.
</I>
On Fri, 25 Mar 2011, Per-Erik Brodin wrote:
&gt;<i>
</I>&gt;<i> On 2011-03-22 11:01, Stefan H&#229;kansson LK wrote:
</I>&gt;<i> &gt; On 2011-03-18 05:45, Ian Hickson wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; All of this except selectively muting audio vs video is currently 
</I>&gt;<i> &gt; &gt; possible in the proposed API.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; The simplest way to make selective muting possible too would be to 
</I>&gt;<i> &gt; &gt; change how the pause/resume thing works in GeneratedStream, so that 
</I>&gt;<i> &gt; &gt; instead of pause() and resume(), we have individual controls for 
</I>&gt;<i> &gt; &gt; audio and video. Something like:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt;     void muteAudio();
</I>&gt;<i> &gt; &gt;     void resumeAudio();
</I>&gt;<i> &gt; &gt;     readonly attribute boolean audioMuted;
</I>&gt;<i> &gt; &gt;     void muteVideo();
</I>&gt;<i> &gt; &gt;     void resumeViduo();
</I>&gt;<i> &gt; &gt;     readonly attribute boolean videoMuted;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Alternatively, we could just have mutable attributes:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt;     attribute boolean audioEnabled;
</I>&gt;<i> &gt; &gt;     attribute boolean videoEnabled;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Any opinions on this?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; We're looking into this and will produce a more elaborate input 
</I>&gt;<i> &gt; related to this.
</I>&gt;<i> 
</I>&gt;<i> Basically we would like to be able to address the Stream components 
</I>&gt;<i> individually and also not limit them to zero or one audio and zero or 
</I>&gt;<i> one video components per Stream. That way we could activate/deactivate 
</I>&gt;<i> them individually and also split out components and combine components 
</I>&gt;<i> from different Stream objects into a new Stream object.
</I>&gt;<i> 
</I>&gt;<i> One good use case is the multi-party video conference where you would 
</I>&gt;<i> like to record the audio from all participants using a StreamRecorder. 
</I>&gt;<i> This would be done by taking the audio component from the local 
</I>&gt;<i> GeneratedStream and combining it with the audio components from the 
</I>&gt;<i> remote streams to form a new Stream object which can then be recorded.
</I>&gt;<i> 
</I>&gt;<i> This could also be a way to handle multiple cameras such as front and 
</I>&gt;<i> back cameras of mobile devices that was mentioned in another thread. 
</I>&gt;<i> When playing a Stream containing several video components, the first 
</I>&gt;<i> active component (if any) would be shown. Active audio components would 
</I>&gt;<i> be mixed.
</I>
To address this use case I've taken the audioTracks and videoTracks 
features recently added to HTMLMediaElement and reused them on 
GeneratedStream. They control which of the available sources get used 
when generating the stream.


On Wed, 16 Mar 2011, Robert O'Callahan wrote:
&gt;<i>
</I>&gt;<i> Instead of creating new state signalling and control API for streams, 
</I>&gt;<i> what about the alternative approach of letting &lt;video&gt; and &lt;audio&gt; use 
</I>&gt;<i> sensors as sources, and a way to connect the output of &lt;video&gt; and 
</I>&gt;<i> &lt;audio&gt; to encoders? Then we'd get all the existing state machinery for 
</I>&gt;<i> free. We'd also get sensor input for audio processing (e.g. Mozilla or 
</I>&gt;<i> Chrome's audio APIs), and in-page video preview, and using &lt;canvas&gt; to 
</I>&gt;<i> take snapshots, and more...
</I>
I don't really understand how that would work. &lt;video&gt; is an output for a 
video stream, it doesn't generate a video stream. I completely agree that 
we should reuse &lt;video&gt; for playback. I don't really see that &lt;video&gt; gets 
us anything for generation, though.


On Wed, 16 Mar 2011, Lachlan Hunt wrote:
&gt;<i> 
</I>&gt;<i> We can already do in-page video preview with the existing design.
</I>&gt;<i> 
</I>&gt;<i> var v = querySelector(&quot;video&quot;);
</I>&gt;<i> navigator.getUserMedia(&quot;video&quot;, function(stream) {
</I>&gt;<i>   v.src = stream;
</I>&gt;<i> });
</I>&gt;<i> 
</I>&gt;<i> From there, taking snapshots with canvas is also possible.
</I>
Indeed there's an example of exactly that in the spec (search for the 
example that contains the text &quot;Snapshot Kiosk&quot;).


On Wed, 16 Mar 2011, Olli Pettay wrote:
&gt;<i> 
</I>&gt;<i> I think roc did suggest that.
</I>&gt;<i> Perhaps navigator.getUserMedia(&quot;audio,video&quot;, success, error);
</I>&gt;<i> could return an url to the device in the success callback, and that url
</I>&gt;<i> could be then set to video.src.
</I>
Indirectly, it does; you can pass a Stream to URL.getObjectURL(). This 
works the same as Blob objects, in fact.


&gt;<i> Audio (and video) data could be modified before encoding and streaming 
</I>&gt;<i> it using PeerConnection. That way one could for example reduce 
</I>&gt;<i> background noise from the audio stream, or 'crop' the video before 
</I>&gt;<i> sending it. Or if the camera doesn't support grayscale, the web page 
</I>&gt;<i> could convert the colorful video to grayscale in order to save network 
</I>&gt;<i> bandwidth.
</I>
I agree that (on the long term) we should support stream filters on 
streams, but I'm not sure I understand &lt;video&gt;'s role in this. Wouldn't it 
be more efficient to have something that takes a Stream on one side and 
outputs a Stream on the other, possibly running some native code or JS in 
the middle? Ideally you could then pass this down to a Worker and have it 
happen off the main thread.



On Thu, 17 Mar 2011, Lachlan Hunt wrote:
&gt;<i> 
</I>&gt;<i> The creation of a URL is unnecessary indirection.  It's easier to avoid 
</I>&gt;<i> creating special URLs entirely, and instead assign the the Stream object 
</I>&gt;<i> directly to video.src.
</I>&gt;<i> 
</I>&gt;<i> e.g.
</I>&gt;<i> 
</I>&gt;<i> navigator.getUserMedia(&quot;video&quot;, function(stream) {
</I>&gt;<i>   video.src = stream;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> This is then reflected in the src content attribute as 
</I>&gt;<i> &quot;about:streamurl&quot;, and is returned upon getting video.src.  This 
</I>&gt;<i> requires that the HTMLMediaElement src property definition needs to be 
</I>&gt;<i> changed from DOMString to any.
</I>
As far as this goes, my goal is to reuse whatever machinery we have for 
Blobs. I'm happy to change the way this is specced for Streams, but I do 
think it is important that we be consistent here.

(It seems that reusing URLs here is a lot easier than making everything in 
the platform that accepts a URL also accept an object. I mean, for 
instance, how do you propose to make CSS 'background-image' accept a 
Stream or Blob?)


On Thu, 17 Mar 2011, Olli Pettay wrote:
&gt;<i> 
</I>&gt;<i> Also, if getUserMedia would return just an URL, browser wouldn't need to 
</I>&gt;<i> create any stream object (unless someone then want to stream from 
</I>&gt;<i> &lt;video&gt; to PeerConnection).
</I>
Just returning a URL would leave us with no good way to control the 
generated stream, unfortunately.

Also, URLs can leak a lot easier than objects.


On Thu, 17 Mar 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> Sure, but instead one would have to mint URLs and keep a mapping between 
</I>&gt;<i> those URLs and the streams that they actually represent. If people copy 
</I>&gt;<i> those URLs around, how long are they supposed to work for?
</I>
This is all defined through the use of URL.getObjectURL().


On Thu, 17 Mar 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> I wasn't aware of this API, it's in 
</I>&gt;<i> <A HREF="http://www.w3.org/TR/FileAPI/#dfn-createObjectURL">http://www.w3.org/TR/FileAPI/#dfn-createObjectURL</A> for reference.
</I>&gt;<i> 
</I>&gt;<i> That API has an explicit revokeObjectURL to solve the lifetime issue, 
</I>&gt;<i> but there's no such thing for the Stream API.
</I>
It's the same API.


On Thu, 17 Mar 2011, Robert O'Callahan wrote:
&gt;<i> 
</I>&gt;<i> In Gecko, we allow seeking within cached segements of streamed video, 
</I>&gt;<i> and we could easily allow that for local devices too --- user-controlled 
</I>&gt;<i> &quot;instant replay&quot;.
</I>
That's entirely what we want, indeed. However, that seems distinct from 
the stream that we are sending to the other peer.


&gt;<i> So for an HTML video element, the following attributes could all make sense
</I>&gt;<i> for streaming from local devices, IMHO:
</I>&gt;<i> -- videoWidth/videoHeight
</I>&gt;<i> -- width/height (reflected to CSS)
</I>&gt;<i> -- poster (to show a placeholder before camera input becomes available)
</I>&gt;<i> -- controls (in-page controls for mute, start/stop)
</I>&gt;<i> -- src
</I>&gt;<i> -- readyState
</I>&gt;<i> -- currentTime (read and write)
</I>&gt;<i> -- paused
</I>&gt;<i> -- ended (the user turned off the camera)
</I>&gt;<i> -- duration
</I>&gt;<i> -- volume
</I>&gt;<i> -- seeking
</I>&gt;<i> -- seekable
</I>&gt;<i> -- buffered
</I>
All of these make sense as a &quot;sink&quot; for a stream, and that's entirely how 
this is specified. You would use &lt;video&gt; to display the local video (a 
GeneratedStream from getUserMedia()) and the remote video (a Stream from a 
PeerConnection). But that doesn't mean it makes sense for the &lt;video&gt; 
element to be the source.


&gt;<i> &gt; But that's not particularly useful for the audio element. It's rare 
</I>&gt;<i> &gt; that the user would want their microphone input to be echoed back to 
</I>&gt;<i> &gt; them via an audio element. In most cases, when a microphone stream is 
</I>&gt;<i> &gt; input into an audio element, the audio element itself would need to be 
</I>&gt;<i> &gt; muted to prevent unwanted and annoying echo or, worse, feedback loops.
</I>&gt;<i> 
</I>&gt;<i> Yes, direct audio output would have to be muted. This could be done 
</I>&gt;<i> automatically when input is coming directly from a local device. 
</I>&gt;<i> (Assuming that using your Web browser as a megaphone is not a valid 
</I>&gt;<i> use-case :-).)
</I>
It seems sensible to want to use an Audio object as a sink for a local 
audio source (microphone) which you can then rewind and play back, not 
muted. This seems like exactly the kind of thing authors should be in 
control of.


On Thu, 17 Mar 2011, Lachlan Hunt wrote:
&gt;<i> 
</I>&gt;<i> ----------     -------------------             -----------
</I>&gt;<i> | Camera | --&gt; | GeneratedStream | --+-------&gt; | &lt;video&gt; |
</I>&gt;<i> ----------     -------------------   |         -----------
</I>&gt;<i>                                      |
</I>&gt;<i>                                  ---------     -----------------
</I>&gt;<i>                                  | Codec | --&gt; | Recorded blob |
</I>&gt;<i>                                  ---------     -----------------
</I>&gt;<i>                                      |
</I>&gt;<i>                                      |         ------------------
</I>&gt;<i>                                      +-------&gt; | PeerConnection |
</I>&gt;<i>                                                ------------------
</I>
Indeed.


&gt;<i> The stated of the stream, in terms of what gets streamed over P2P or 
</I>&gt;<i> recorded locally, must be controlled at the GeneratedStream and given as 
</I>&gt;<i> input into the codec.  This includes things like controlling the input 
</I>&gt;<i> microphone volume, video height and width, etc.  In particular, the 
</I>&gt;<i> encoded height and width for streaming may differ significantly from the 
</I>&gt;<i> rendered height and width in the local video preview, so this is not 
</I>&gt;<i> something that can be controlled by the video element itself.
</I>
Indeed. The remote peer can indeed negotiate some of these settings using 
SDP offer/answer, too.


&gt;<i> &gt; In Gecko, we allow seeking within cached segements of streamed video, 
</I>&gt;<i> &gt; and we could easily allow that for local devices too --- 
</I>&gt;<i> &gt; user-controlled &quot;instant replay&quot;.
</I>&gt;<i> 
</I>&gt;<i> We don't buffer any streamed data in our initial device implementation 
</I>&gt;<i> and seeking is not possible.
</I>
:<i>-(
</I>

On Tue, 15 Mar 2011, <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jesperg at opera.com</A> wrote:
&gt;<i> 
</I>&gt;<i> I was really looking forward to start playing around with USB MIDI 
</I>&gt;<i> interfaces to control my synth and maybe even do really creative stuff 
</I>&gt;<i> the other way around. Just imagine being able to play on your synth (or 
</I>&gt;<i> any other device with MIDI output) and generate sound or graphics in a 
</I>&gt;<i> &lt;canvas&gt; web application or so!
</I>
For manipulation of audio, something more like what the Audio incubator 
group is working on seems more appropriate:

   <A HREF="http://lists.w3.org/Archives/Public/public-xg-audio/">http://lists.w3.org/Archives/Public/public-xg-audio/</A>

That API could then probably integrate with a MIDI device as a source.


&gt;<i> Or... be able to control other devices using serial connection. Maybe do 
</I>&gt;<i> lirc-alike stuff, using your IR based remote to control Youtube or other 
</I>&gt;<i> HTML5 &lt;video&gt; services, etc.
</I>
I'd love to do this (I myself have some RS232-driven hardware). I'm not 
sure it makes sense to use the same API as for video conferencing, though.


My recommendation for people who would like to follow up on 
non-audio/video-related use cases is to follow the steps described in the 
FAQ for handling new use cases:

   <A HREF="http://wiki.whatwg.org/wiki/FAQ#Is_there_a_process_for_adding_new_features_to_a_specification.3F">http://wiki.whatwg.org/wiki/FAQ#Is_there_a_process_for_adding_new_features_to_a_specification.3F</A>


On Tue, 15 Mar 2011, Rich Tibbett wrote:
&gt;<i> 
</I>&gt;<i> We noticed a number of deficiencies with the way a developer can obtain 
</I>&gt;<i> a GeneratedStream object. Hopefully I can explain those succinctly 
</I>&gt;<i> below.
</I>&gt;<i> 
</I>&gt;<i> A callback-based model fires a single success event. An events-based API 
</I>&gt;<i> allows for ongoing intermediate readyState changes to be fired at web 
</I>&gt;<i> pages following an initial success state change. With an events-based 
</I>&gt;<i> model we would be able to provide ongoing events such as 'disconnected' 
</I>&gt;<i> and, theoretically at least, extend that with events like 'unplugged', 
</I>&gt;<i> 'sleeping', etc.
</I>
I'm not sure I follow exactly what you mean here. Could you elaborate on 
which use cases you'd like to address?


&gt;<i> Secondly, getUserMedia is restricted to only handle audio/video streams. 
</I>&gt;<i> In the original proposal there was potential for us to connect and 
</I>&gt;<i> disconnect other device classes, such as USB or RS232 device types.
</I>
Indeed; see above for a discussion on this matter.


&gt;<i> Essentially, our proposal is to improve the device bootstrap mechanism
</I>&gt;<i> four-fold:
</I>&gt;<i> 
</I>&gt;<i> 1) Use an events-dispatch model instead of callbacks
</I>
It's not clear to me what you mean by callbacks here. The Stream object 
uses the DOM Events model. The only thing that uses callbacks is the 
getUserMedia() object, where success or failure are the only options. This 
is modelled on the geolocation API.


&gt;<i> 2) Allow for future device classes to inherit standard
</I>&gt;<i> connect/disconnect functionality from a standard bootstrap interface
</I>&gt;<i> called 'Device'.
</I>
What is the use case or design rationale for this?


&gt;<i> 3) Provide additional generic device state information in the 
</I>&gt;<i> events-dispatch model (a DISCONNECT readyState providing feedback to a 
</I>&gt;<i> web page that the device has been disconnected by the user and/or the 
</I>&gt;<i> connected device has been ripped out of the USB socket).
</I>
What is the use case for handling the removal of a microphone differently 
than the user revoking permission for that input device?


&gt;<i> 4) Allow developers to instantiate a particular device class (e.g. 
</I>&gt;<i> UserMedia) with constructor parameters applicable to that device class.
</I>
I don't understand what you mean here; could you elaborate?


On Wed, 16 Mar 2011, Lachlan Hunt wrote:
&gt;<i> 
</I>&gt;<i> For me, this event model approach seems more natural and fits with 
</I>&gt;<i> pre-existing design patterns used for other APIs, better than the 
</I>&gt;<i> callback approach does.
</I>
As far as I can tell, the only other API that asks for user permission in 
a blocking fashion the way that getUserMedia() does is geolocation, which 
uses a callback model. That was why I used a callback model here.


&gt;<i> The event model has the advantage of being able to scale up to handle 
</I>&gt;<i> more events in the future, such as handling disconnections or the user 
</I>&gt;<i> switching cameras or microphones.
</I>
Such events would fire on the GeneratedStream object in the current model. 
getUserMedia() is just a binary check for permission, not an interface to 
the underlying device(s).


&gt;<i> One problem with both models is that they don't easily distinguish 
</I>&gt;<i> between different input devices, which is a problem because both the 
</I>&gt;<i> proposed Device interface and the Stream/GeneratedStream interfaces can 
</I>&gt;<i> potentially represent multiple Devices/Streams (this is the case when 
</I>&gt;<i> &quot;audio,video&quot; is passed as the type).
</I>
GeneratedStream now has .audioTracks and .videoTracks to address this.


&gt;<i> This creates a problem when a user, for example, unplugs or revokes 
</I>&gt;<i> permission for one of the devices or streams but not the other, 
</I>&gt;<i> triggering either an error or disconnect event, it's not clear how the 
</I>&gt;<i> script can identify which specific device was disconnected.
</I>
Currently there isn't support in the API for only part of the granted 
device permissions being revoked (e.g. revoking just access to the 
microphone). However, if this is something user agents want to support, we 
can definitely add support for it pretty easily by just firing events at 
the GeneratedStream and updating the .videoTracks and .audioTracks lists.


&gt;<i> Finally, the object passed to the error callback/event currently only 
</I>&gt;<i> has a PERMISSION_DENIED error code. It might be worth investigating the 
</I>&gt;<i> need for other codes like PERMISSION_REVOKED, DEVICE_REMOVED, etc. as 
</I>&gt;<i> well, to handle the case where permission was granted, but then the user 
</I>&gt;<i> later changed their mind or unplugged the device.  (It's possible that 
</I>&gt;<i> the proposed ondisconnect event in the event model could be handled as 
</I>&gt;<i> an error event with an appropriate code, though I'm not sure if that's 
</I>&gt;<i> better or worse than separate event.)
</I>
Indeed. I made it an object in part for consistency with geolocation and 
in part because that gives us the ability to add more later if we find we 
need more. Currently it's not clear it's really necessary to have more.


On Thu, 24 Mar 2011, Robin Berjon wrote:
&gt;<i> 
</I>&gt;<i> Most notably, some devices might expose ways of controlling them and 
</I>&gt;<i> exposing those on a GeneratedStream seems clunky.
</I>
Could you elaborate on &quot;clunky&quot;?

We could rename &quot;GeneratedStream&quot; to &quot;LocalMediaDevice&quot; if that would make 
people feel better about it. It's both really.


&gt;<i> var device;
</I>&gt;<i> navigator.getUserMedia(&quot;whatever&quot;, function (d) { device = d; });
</I>&gt;<i> 
</I>&gt;<i> Once you have it, there are a couple improvements that can be made over 
</I>&gt;<i> GeneratedStream.
</I>&gt;<i> 
</I>&gt;<i> * It's an EventTarget.
</I>
So is GeneratedStream.


&gt;<i> This is primarily for the purpose of listening to devicemotion and 
</I>&gt;<i> deviceorientation events (they currently only target window, but that's 
</I>&gt;<i> not a big deal to change).
</I>
Yeah, I think it would make sense to put those events on this object. I 
haven't done it yet, mainly because the DeviceOrientation API doesn't seem 
particularly stable yet.


&gt;<i> This could work with GeneratedStream, but it seems more logical to have 
</I>&gt;<i> events for &quot;I moved the camera&quot; (and possibly others such as &quot;I changed 
</I>&gt;<i> the focal length&quot; or &quot;autofocus acquired at 2.77m&quot;) and for &quot;stream 
</I>&gt;<i> paused&quot; on different objects.
</I>
Why?


&gt;<i> * It provides an extension point for device control. Say you're 
</I>&gt;<i> streaming from a camera and you want to take a picture. The chances are 
</I>&gt;<i> high that the camera can take a much better picture than the frame you 
</I>&gt;<i> can grab off its view-finding video stream.
</I>&gt;<i> 
</I>&gt;<i> // device is a CameraDevice
</I>&gt;<i> device.captureStill(function (file) {
</I>&gt;<i>   // ... got my picture
</I>&gt;<i> });
</I>
What is the use case for this? Is it not handled by &lt;input type=file 
accept=image/*&gt;? If not, why not?

We can definitely add something like the above to GeneratedStream in the 
future, though.


&gt;<i> We might not be there yet and would probably want to wait a little, but 
</I>&gt;<i> there's plenty more that can be added there.
</I>&gt;<i> 
</I>&gt;<i> // silly examples
</I>&gt;<i> device.zoom = 2;
</I>&gt;<i> device.flash = true;
</I>&gt;<i> 
</I>&gt;<i> Again, these could go on GeneratedStream but it seems too conflated. 
</I>&gt;<i> Given that a device exposes a stream, the coding cost is a minimal 
</I>&gt;<i> switch to:
</I>&gt;<i>
</I>&gt;<i> video.src = device.stream;
</I>
Why would we want to split the device from the stream? I'm very wary of 
adding more 1:1 object mappings to the platform. They tend to make the API 
very verbose and annoying to use.


&gt;<i> Additionally, I wonder if it wouldn't be useful to make it possible for 
</I>&gt;<i> the getUserMedia callback to return an array of devices in one go. If 
</I>&gt;<i> you're making a 3D movie (or just 3D videoconferencing) you probably 
</I>&gt;<i> want multiple cameras returned at once (alternatively, it could be a 
</I>&gt;<i> single device exposing two streams).
</I>
I think we're getting a bit ahead of ourselves here, but there's no reason 
getUserMedia() couldn't be extended in the future to return a 
3DGeneratedStream if passed a &quot;3d&quot; argument, or some such. Or 
alternatively we could define specific &quot;left&quot; and &quot;right&quot; video tracks, or 
some such, exposed on .videoTracks; or we could just expose it as a 3D 
video stream. The latter would have the added bonus of automatically 
working in all the Web apps that had been written for 2D, without them 
having to change at all.


&gt;<i> Likewise if you have a sound setup more advanced than just the one mike. 
</I>&gt;<i> Of course, the user could effect multiple requests and grant access to 
</I>&gt;<i> each device one by one, but UI-wise, it's probably a lot simpler to 
</I>&gt;<i> allow her to do it all at once.
</I>
That's already possible in the existing API to some extent, but it's not 
clear to me what the use case is. Video conferencing is something that can 
apply today to many sites. Multitrack recording seems like something that 
people are not really looking for Web apps to solve. Even in the native 
app market it's still a very evolving area.


&gt;<i> Especially considering the following:
</I>&gt;<i> 
</I>&gt;<i>   1. User wants to add a camera, clicks a button that calls getUserMedia()
</I>&gt;<i>   2. Infobar of some kind shows, user picks camera source, checks [always allow]
</I>&gt;<i>   3. User wants to add second camera, clicks the same button: same camera is picked
</I>&gt;<i>   4. Failure
</I>
Instead of clicking the same button in the app, it seems the user should 
click a button in the browser chrome to change the permissions.


&gt;<i> Multiple simultaneous inputs isn't science fiction nor is it limited to 
</I>&gt;<i> professional contexts. I could easily want to use both back and front 
</I>&gt;<i> cameras on my phone, one with which to film what's going on around me in 
</I>&gt;<i> a documentary, the other to insert a small view of myself as I comment 
</I>&gt;<i> on what I'm seeing. 3D home videos are probably not that far around the 
</I>&gt;<i> corner (yes, it scares me too). It's likely that laptops will ship with 
</I>&gt;<i> arrays of mikes in order to better figure out where you're talking from 
</I>&gt;<i> (spatially) and eliminate all other sources &#151; accessing would be sweet.
</I>&gt;<i> 
</I>&gt;<i> I don't much care about the syntax, but I guess we could be looking at 
</I>&gt;<i> something like
</I>&gt;<i> 
</I>&gt;<i> navigator.getUserMedia(&quot;video multiple&quot;, function (devices) {
</I>&gt;<i>   // ... show each different view
</I>&gt;<i> });
</I>
This is supported with the .videoTracks feature now, though without 
change notification at the moment.


On Thu, 17 Mar 2011, Stefan H&#229;kansson LK wrote:
&gt;<i> 
</I>&gt;<i> It is not totally clear how the UI would work for granting access to use 
</I>&gt;<i> mics and cams, and furthermore how it would be possible to select 
</I>&gt;<i> several cameras (many terminals have both a front and a rear view 
</I>&gt;<i> camera) and then &quot;tell&quot; the web app which camera is which.
</I>
There's no current way to tell the app which camera is selected. I think 
what we might want to do is define some default labels for the video 
tracks, but I'm interested in implementation experience on that front 
before I spec that further.


&gt;<i> The spec says that the user-agent-specific prompt may allow user to 
</I>&gt;<i> select pre-recorded media. In that case, shouldn't it be possible to 
</I>&gt;<i> also create a Stream from a File/Blob object, containing media data?
</I>
What's the use case?


&gt;<i> Shouldn't the &quot;ended&quot; event be call simply &quot;end&quot; to match the present 
</I>&gt;<i> tempus of the other events (&quot;pause&quot;, &quot;play&quot;)?
</I>
Yes, but 'ended' is what we are using in &lt;video&gt;, so I stuck with it for 
consistency. (My bad when I was designing that API.)


&gt;<i> The green box describes an attribute called paused which is not present 
</I>&gt;<i> in the Stream idls.
</I>
That is gone now, but it was on GeneratedStream.


&gt;<i> The asynchronous StreamRecorder.getRecordedData should be void.
</I>
Fixed, thanks.


&gt;<i> Further, the StreamRecorder API doesn't seem to support stopping a 
</I>&gt;<i> recording without stopping the entire Stream.
</I>
StreamRecorder doesn't supporting stopping explicitly at all, but the uer 
agent can stop recording whenever the object is GC'ed. In practice we 
couldn't rely on the author saying when to stop anyway, so this is what 
browsers would have to implement regardless.


&gt;<i> a) We interpret the spec as &quot;addStream&quot; triggers a new ICE procedure 
</I>&gt;<i> that sets up a new &quot;channel&quot; (5-tuple) for the stream. Correct?
</I>
It invokes the ICE feature that adds a media stream (&quot;9.3.1.2.  New Media 
Stream&quot;), or at lesat that's my intent. It's hard to reference ICE 
sometimes because it doesn't provide very explicit hyperlinkable hooks.


&gt;<i> b) Also related to addStream: it is not clear if the SDP (to be 
</I>&gt;<i> transmitted to the other end at getting the callback) contains all 
</I>&gt;<i> descriptions for all streams set up (minus the removed ones) so far or 
</I>&gt;<i> just the new one. The former would simplify SIP interop (re-invite).
</I>
That's an ICE issue. This does whatever ICE says to do. (Since ICE is what 
SIP uses, it seems that means you're bound to be compatible assuming you 
have a PeerConnection/SIP gateway for the signaling channel).


&gt;<i> c) addStream is uni-directional, so in our interpretation the sdp-data 
</I>&gt;<i> transmitted from sender to receiver would indicate &quot;send-only&quot;. We guess 
</I>&gt;<i> (as mentioned above) from the description that a new ICE procedure would 
</I>&gt;<i> be deployed to set up a &quot;channel&quot; that is used for RTP (send direction) 
</I>&gt;<i> and RTCP (feedback). In many cases the service calls for symmetric 
</I>&gt;<i> flows, the two web apps would do &quot;addStream&quot; more or less 
</I>&gt;<i> simultaneously. Ideally, the &quot;channel&quot; (5-tuple) should be re-used. I am 
</I>&gt;<i> not sure how this can be accomplished.
</I>
The spec as written now does everything with &quot;sendonly&quot; streams. I'm open 
to changing that, but I don't really see how the API would work with 
&quot;sendrecv&quot; media streams, which is why I did it this way.


&gt;<i> d) As you already mention, it is not defined how the application could 
</I>&gt;<i> influence the media format selected. It could be discussed to what level 
</I>&gt;<i> this should be possible. But the very least should be some kind of 
</I>&gt;<i> connection between the rendering (e.g. large area at screen, small area, 
</I>&gt;<i> mono, 5.1) and the selected format.
</I>
That's basically up to the browser, currently. I'm open to adding some 
more control here, but I think it's the kind of thing for which 
implementation experience would be really useful, so I haven't added 
anything yet.


&gt;<i> Unclear how to protect the &quot;PeerConnection data UDP media stream&quot; to be 
</I>&gt;<i> used by &quot;send()&quot; messages (sent with &quot;send&quot;) and streams. dTLS? SRTP? 
</I>&gt;<i> How to set up and exchange keys?
</I>
The spec defines all this already, no?


&gt;<i> Unclear how to protect the new &quot;channel&quot; set up by an ICE procedure at 
</I>&gt;<i> &quot;addStream&quot;. dTLS? SRTP? How to set up and exchange keys?
</I>
The spec doesn't define what codec (H.263, WebM, whatever) or network 
transport (e.g. RTP) and encryption protocols to use. I'm happy to specify 
particular codec, transport, or encryption mechanisms if there are any 
codec, transport, or encryption mechanisms that everyone is going to 
implement.


&gt;<i> It is stated that the data size can be up to 65467 bytes in &quot;send()&quot;. 
</I>&gt;<i> Our network guys tell us that this is unrealistic to get over such big 
</I>&gt;<i> chunks using UDP.
</I>
Is that true? I thought they'd just get fragmented at the IP level, but 
would still make it through eventually, am I wrong?

Obviously you want to avoid fragmentation too if possible, but limiting 
all packets to a few bytes seems a bit extreme...


&gt;<i> The StreamEvent has a function called initCloseEvent.
</I>
Fixed, thanks.


On Thu, 17 Mar 2011, Glenn Maynard wrote:
&gt;<i>
</I>&gt;<i> PeerConnection defines packet encryption, but it uses AES-128-CTR 
</I>&gt;<i> without actually defining the counter.  It also generates a new AES key 
</I>&gt;<i> for each packet.  A major point of using CTR is to not have to do that; 
</I>&gt;<i> you have a single key and vary the counter.
</I>&gt;<i> 
</I>&gt;<i> The inputs to AES-128-CTR are a key, a counter and a message.  A single 
</I>&gt;<i> key is used for the whole connection[1].
</I>
This is UDP, there is no connection. Each packet is independent.


&gt;<i> Each counter value can only be used once.  A nonce isn't created for 
</I>&gt;<i> each packet; only once for the entire connection, as part of the key.
</I>

&gt;<i> The mechanism I'd recommend is: [...]
</I>
This proposal removes the payload type signature, which seems like an 
unrelated concern and would be a bad change since it removes an extension 
point, so I haven't removed this.

It also introduces a predictable set of bytes in each packet (the 
counter, which can be predicted because it increments monotonically with 
each packet). This fails to achieve the goal of making the packet payload 
completely random to a non-PeerConnection observer.


&gt;<i> The magic PeerConnection &quot;salt&quot; (DB 68 B5 FD 17 0E 15 77 56 AF 7A 3A 1A 
</I>&gt;<i> 57 75 02) seems unnecessary, replaced with the connection nonce, but 
</I>&gt;<i> could still be appended to the connection key if desired.
</I>
It's needed to make the data random even when interpreted by the 
implementation of another protocol that happens to have the same 
mechanism. By having a protocol-specific salt, we can ensure that 
different protocols that use this scheme can never be attacked either.


&gt;<i> There should also be a mechanism to support new hashes and ciphers in 
</I>&gt;<i> the future.  There's no need to actually specify other hashes at this 
</I>&gt;<i> point (except perhaps for testing purposes), just forward-compatibility 
</I>&gt;<i> for when AES and/or SHA-1 need to be replaced.
</I>
This is already possible over the signaling channel (we can just invent a 
new attribute when we need it).


&gt;<i> This protocol is reinventing the wheel, and I'm sure a cryptography
</I>&gt;<i> expert will find many more issues.  Can anyone more familiar with DTLS
</I>&gt;<i> say whether it fits here?
</I>
DTLS is inappropriate here because it does the handshake over the 
connection, which is unnecessary in this case. Also, if I understand it 
correctly, it uses TLS-style certificates which doesn't really make sense 
when you're communicating with another user agent (as opposed to a 
server).


On Thu, 17 Mar 2011, Adam Barth wrote:
&gt;<i> 
</I>&gt;<i> Theoretically, we could just use an initial counter value of zero for 
</I>&gt;<i> each message, but, as you point out, that would require re-keying AES 
</I>&gt;<i> for each message.  Rather than the scheme you propose, it's probably 
</I>&gt;<i> easier to just use the nonce as the initial counter value.  The chance 
</I>&gt;<i> of randomly choosing the same nonce twice is essentially zero.
</I>&gt;<i> 
</I>&gt;<i> Specifically, in 
</I>&gt;<i> &lt;<A HREF="http://www.whatwg.org/specs/web-apps/current-work/#the-data-stream">http://www.whatwg.org/specs/web-apps/current-work/#the-data-stream</A>&gt;:
</I>&gt;<i> 
</I>&gt;<i> - 3. Let key be the first 16 bytes of the HMAC-SHA1 of the
</I>&gt;<i> concatenation of the 16 nonce bytes, the 16 data UDP media stream salt
</I>&gt;<i> bytes, and the 16 ice-key bytes. [HMAC] [SHA1]
</I>&gt;<i> + 3. Let key be the first 16 bytes of the HMAC-SHA1 of the
</I>&gt;<i> concatenation of the 16 data UDP media stream salt bytes and the 16
</I>&gt;<i> ice-key bytes. [HMAC] [SHA1]
</I>&gt;<i> 
</I>&gt;<i> - 5. Let masked message be the result of encrypting typed raw message
</I>&gt;<i> using AES-128-CTR keyed with key. [AES128CTR]
</I>&gt;<i> + 5. Let masked message be the result of encrypting typed raw message
</I>&gt;<i> using AES-128-CTR keyed with key and using the 16 nonce bytes as the
</I>&gt;<i> initial counter value. [AES128CTR]
</I>
That makes sense. Done.


On Thu, 17 Mar 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> The issue isn't just making sure the sender doesn't reuse a counter 
</I>&gt;<i> (though that's also critical with CTR).  The issue is replay attacks: 
</I>&gt;<i> making sure an attacker can't replay a previously-sent packet later on.
</I>&gt;<i>
</I>&gt;<i> By using an increasing counter, the anti-replay algorithm from DTLS and 
</I>&gt;<i> IPsec ESP can be used.  It's very straightforward; see 
</I>&gt;<i> <A HREF="http://www.ietf.org/rfc/rfc4347">http://www.ietf.org/rfc/rfc4347</A> section 4.1.2.5, which explains it 
</I>&gt;<i> better than I can.  This requires an increasing sequence number--this 
</I>&gt;<i> algorithm won't work if the counter is a random value.
</I>
On Thu, 17 Mar 2011, Adam Barth wrote:
&gt;<i> 
</I>&gt;<i> Sure.  That's fine.  If you like, we can XOR a monotonically
</I>&gt;<i> increasing value with the nonce to provide the initial counter value.
</I>
On Thu, 17 Mar 2011, Glenn Maynard wrote:
&gt;<i>
</I>&gt;<i> Do you mean including both a random 16-byte nonce *and* a (say) 6-byte 
</I>&gt;<i> sequence number in each packet?
</I>
We wouldn't be able to do that since the sequence number isn't random in 
this situation.

If we want to prevent replay attacks, we're better off doing it by 
putting a packet identifier inside the packet data itself, IMHO. No need 
to make it part of the masking.

I've added a sequence number inside the data, and made out-of-order 
messages get discarded. I'm open to preserving out-of-order messages with 
some sort of receive window, if someone can make a compelling argument for 
what the window should be (either in terms of time or number of packets or 
both, possibly as a function of some other metric).


On Fri, 18 Mar 2011, Glenn Maynard wrote:
&gt;<i> On Thu, Mar 17, 2011 at 9:28 PM, Adam Barth &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">w3c at adambarth.com</A>&gt; wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; So, the salt and the nonce play different roles.  The salt is to make 
</I>&gt;<i> &gt; sure the message appears random if you haven't read the spec (and so 
</I>&gt;<i> &gt; don't know the salt).  The nonce is to prevent the attacker from 
</I>&gt;<i> &gt; crafting plaintexts that encrypt to a chosen ciphertext, even when the 
</I>&gt;<i> &gt; attacker sees both sides of the connection.  Picking a new nonce for 
</I>&gt;<i> &gt; each message means that the attack cannot choose the bytes sent on the 
</I>&gt;<i> &gt; wire.  The nonce can be communicated in-band, just like the IV for CBC 
</I>&gt;<i> &gt; mode.
</I>&gt;<i> 
</I>&gt;<i> If you can send messages to an arbitrary IP address and port, then this 
</I>&gt;<i> definitely matters: you don't want people to be able to send packets 
</I>&gt;<i> that look like DNS responses to arbitrary ports, for example.  However, 
</I>&gt;<i> here the communication is negotiated over STUN/TURN.  The protocol 
</I>&gt;<i> should have ensured that the port you're talking to is actually 
</I>&gt;<i> expecting to receive data using this protocol, and isn't, say, a DNS 
</I>&gt;<i> server.  You shouldn't be able to send data at all except to a peer that 
</I>&gt;<i> agreed to receive data on the port.
</I>&gt;<i> 
</I>&gt;<i> It's possible that ICE doesn't actually negotiate this securely, since 
</I>&gt;<i> the STUN server itself is untrusted.  Do you (or anyone else) know if 
</I>&gt;<i> STUN negotiation is secure under these circumstances?  Or do you think 
</I>&gt;<i> it doesn't matter?
</I>
It's defense-in-depth: it means we can introduce this protocol without 
first guaranteeing that ICE can't be tricked, because even if ICE is 
tricked somehow, you still can do nothing more than send a stream of 
random bytes to your victim.


&gt;<i> I don't mean to harp on this, but an additional 16 bytes of nonce per 
</I>&gt;<i> packet is significant for small payloads, so if it's necessary I'd like 
</I>&gt;<i> to understand why.
</I>
It's not _that_ expensive.


On Wed, 23 Mar 2011, Harald Alvestrand wrote:
&gt;<i> 
</I>&gt;<i> The potential attack we can't avoid is that a hostile webapp, possibly 
</I>&gt;<i> with the help of a hostile STUN server, can cause an ICE handshake 
</I>&gt;<i> request to be sent to an UDP IP+port of their choice. The browser can 
</I>&gt;<i> rate-limit such attacks easily, and may implement a port-number 
</I>&gt;<i> blocklist if that seems appropriate (not sending to port 53 seems 
</I>&gt;<i> reasonable).
</I>&gt;<i> 
</I>&gt;<i> That seems like a risk that's not unreasonable to accept, given that 
</I>&gt;<i> we've survived having the same problem for HTTP links since day one of 
</I>&gt;<i> the Web (any web page can dupe a client into launching a TCP session to 
</I>&gt;<i> any IP:port and sending &quot;GET /&lt;ASCII string of their choice&gt;&quot; to it).
</I>
On Wed, 23 Mar 2011, Matthew Kaufman wrote:
&gt;<i>
</I>&gt;<i> STUN connectivity check packets are already carefully crafted (with a 
</I>&gt;<i> very long initial magic number) to *not* look like anything else (SNMP 
</I>&gt;<i> queries, DNS queries, etc.) and so sending them at a limited rate to 
</I>&gt;<i> arbitrary addresses should be safe.
</I>
That's good to hear.


On Wed, 23 Mar 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> From a *cursory* (an hour or so) examination of the ICE and STUN 
</I>&gt;<i> protocols, it appears that even if the web server, STUN/TURN server(s) 
</I>&gt;<i> and a remote peer are hostile, it should not be possible to convince a 
</I>&gt;<i> user's browser (via its ICE agent) to send packets to an arbitrary IP 
</I>&gt;<i> and port.  It should only be possible to send packets to an IP which has 
</I>&gt;<i> handshaked a port via ICE.
</I>
That is my conclusion too, for what it's worth.


&gt;<i> *If* that's accurate, does that remove the masking requirement? 16 bytes 
</I>&gt;<i> per packet is significant overhead to pay if it's not needed.
</I>
Why do you consider 16 bytes expensive?


On Thu, 24 Mar 2011, Adam Barth wrote:
&gt;<i> 
</I>&gt;<i> Our experience with WebSockets indicates that masking is still important 
</I>&gt;<i> even when communicating between the browser and an attacker-controlled 
</I>&gt;<i> server.  The problem is that intermediaries attempt to &quot;sniff&quot; the 
</I>&gt;<i> protocol by looking at the bytes on the wire. For example, one could 
</I>&gt;<i> easily imagine an intermediary attempting to do &quot;helpful&quot; things to 
</I>&gt;<i> transiting UDP packets that look like DNS requests or responses.  
</I>&gt;<i> Rather than play whack-a-mole with these possibilities, we're better off 
</I>&gt;<i> building a protocol that's secure by design.
</I>
Indeed.


On Thu, 24 Mar 2011, Matthew Kaufman wrote:
&gt;<i> 
</I>&gt;<i> That goal is incompatible with legacy interoperability.
</I>
There is no legacy when it comes to UDP data media streams. This is a new 
protocol, no existing servers implement it.


&gt;<i> It is also probably unnecessary in the case where we use real encryption 
</I>&gt;<i> (DTLS / DTLS-SRTP) for the media flows.
</I>
It doesn't affect the media flows. The media flows should keep using 
whatever mechanisms already used for encrypting them.


On Thu, 24 Mar 2011, Harald Alvestrand wrote:
&gt;<i>
</I>&gt;<i> We know [that some intemediaries sniff the protocol]. Some of them are 
</I>&gt;<i> doing totally broken things (for instance looking for the bit pattern 
</I>&gt;<i> corresponding to 10.0.0.1 and changing it to a NAT's external address 
</I>&gt;<i> without regard for context - which is the excuse for some of the more 
</I>&gt;<i> baroque constructs of the STUN protocol).
</I>&gt;<i> 
</I>&gt;<i> There is also rumoured to be devices that look for packet streams with 
</I>&gt;<i> regular 20 ms spacing, and block them in an attempt to prevent people 
</I>&gt;<i> from using nonapproved VoIP devices.
</I>&gt;<i> 
</I>&gt;<i> At some point, we have to declare that there is breakage introduced by 
</I>&gt;<i> other people's incompetence where we accept that failure will result a 
</I>&gt;<i> certain percentage of the time until those devices are replaced.
</I>
It's probably reasonable to reach that conclusion when the workaround is 
worse than the breakage (e.g. with the 20ms spacing thing -- the 
workaround would introduce artefacts into the communication that might be 
worse than simply not using this channel at all). However, given the ease 
with which we can mask these game data packets, it seems we haven't 
reached that point yet with this particular subfeature.


&gt;<i> I believe that the STUN XOR-ing of addresses (RFC 5389 section 15.2) was 
</I>&gt;<i> an example of going too far (we should have detected the brokenness and 
</I>&gt;<i> signalled it rather than routing around it; we traded a clear &quot;doesn't 
</I>&gt;<i> work because of this kind of bogosity&quot; function for a &quot;will corrupt a 
</I>&gt;<i> known percentage of your traffic&quot; function.... but I digress).
</I>
Actually to me that seems like a pretty neat solution and a clear example 
of something where the minor pain of the solution is better than having 
the breakage.


&gt;<i> There's a cost to the complexity we're imposing too.
</I>
The cost seems minimal here, but I've been wrong before!


&gt;<i> I would like to get the facts straight and be able to think in terms of 
</I>&gt;<i> cost/benefit, rather than accepting blanket statements of requirement.
</I>
Absolutely.


On Thu, 24 Mar 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> It's expensive resilience: 16 bytes of added overhead for every 
</I>&gt;<i> datagram. That's overhead added to every PeerConnection datagram 
</I>&gt;<i> protocol, in order to help hide problems in something catastrophically 
</I>&gt;<i> broken and inherently insecure.
</I>
This is only 16 bytes added to the data channel, not to every protocol. 
For example, how media is sent is an issue for the media transport 
protocols (like RTP), and the 16 byte nonce mechanic described for the UDP 
data media stream doesn't apply there.


On Wed, 23 Mar 2011, Harald Alvestrand wrote:
&gt;<i>
</I>&gt;<i> Is there really an advantage to not using SRTP and reusing the RTP 
</I>&gt;<i> format for the data messages?
</I>
Could you elaborate on how (S)RTP would be used for this? I'm all in 
favour of defering as much of this to existing protocols as possible, but 
RTP seemed like massive overkill for sending game status packets.


On Wed, 23 Mar 2011, Matthew Kaufman wrote:
&gt;<i> 
</I>&gt;<i> I'd go one further... why not DTLS-SRTP for the media and DTLS with some 
</I>&gt;<i> other header shim for the data messages?
</I>
The spec doesn't say what should happen for the media; that's left up to 
the UAs to negotiate via SDP offer/answer (as done by ICE). Regarding DTLS 
around a shim for the data messages, DTLS seems inappropriate for the 
reasons discussed earlier in this reply.


&gt;<i> In particular, there are significant security advantages to end-to-end 
</I>&gt;<i> keying rather than transmitting keys over the signaling channel.
</I>
Could you elaborate on these?


On Thu, 17 Mar 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> The particulars of the AES-128-CTR algorithm should be defined--the NIST 
</I>&gt;<i> reference only defines AES itself, not the CTR mode.  It also needs to 
</I>&gt;<i> specify a padding method, eg. PKCS7 or ANSI X.923, to pad to AES's block 
</I>&gt;<i> size of 16 bytes.
</I>
On Fri, 18 Mar 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> Actually, I was wrong about padding: it's a CBC thing, CTR doesn't need 
</I>&gt;<i> it. With CTR, the length of the ciphertext determines the length of the 
</I>&gt;<i> plaintext directly.
</I>
So just to confirm, there's nothing to add for padding?


On Thu, 17 Mar 2011, Glenn Maynard wrote:
&gt;<i>
</I>&gt;<i> A hash should also be included in each packet, to prevent semi-random 
</I>&gt;<i> tampering with packets on the wire.
</I>
On Thu, 17 Mar 2011, Adam Barth wrote:
&gt;<i> 
</I>&gt;<i> &lt;<A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=12316">http://www.w3.org/Bugs/Public/show_bug.cgi?id=12316</A>&gt; is the bug on
</I>&gt;<i> file about that.  Rather than MACing the plaintext, as you suggest, we
</I>&gt;<i> should encrypt-then-mac, as recommended by this classic paper
</I>&gt;<i> &lt;<A HREF="http://cseweb.ucsd.edu/~mihir/papers/oem.pdf">http://cseweb.ucsd.edu/~mihir/papers/oem.pdf</A>&gt;.
</I>
I've added a hash for integrity checking.


These data packets now consist of:

   IPv4 or IPv6 header (20 or 40 bytes)
   UDP header (8 bytes)
   16 byte hash
   16 byte nonce
   8 byte sequence number
   4 byte payload description for future expansion


On Fri, 18 Mar 2011, Lachlan Hunt wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; In getUserMedia() the input is extensible; we could definitely add 
</I>&gt;<i> &gt; &quot;prefer-user-view&quot; or &quot;prefer-environment-view&quot; flags to the method 
</I>&gt;<i> &gt; (with better names, hopefully, but consider that 'rear' and 'front' 
</I>&gt;<i> &gt; are misleading terms -- the front camera on a DSLR faces outward from 
</I>&gt;<i> &gt; the user, the front camera on a mobile phone faces toward the user). 
</I>&gt;<i> &gt; The user still has to OK the use of the device, though, so maybe it 
</I>&gt;<i> &gt; should just be left up to the user to pick the camera? They'll need to 
</I>&gt;<i> &gt; be able to switch it on the fly, too, which again argues to make this 
</I>&gt;<i> &gt; a UA feature.
</I>&gt;<i> 
</I>&gt;<i> We could just add flags to the options string like this:
</I>&gt;<i> 
</I>&gt;<i> &quot;video;view=user, audio&quot; or &quot;video;view=environment, audio&quot;
</I>
That seems a bit complicated to parse. Instead I've just gone with having 
a space-separated list of tokens inside the comma-separated list of 
tokens, so the above examples would be &quot;video user, audio&quot; and &quot;video 
environment, audio&quot; respectively.


&gt;<i> It's worth pointing out that The HTML Media Capture draft from the DAP 
</I>&gt;<i> WG uses the terms &quot;camera&quot; and &quot;camcorder&quot; for this purpose, but I find 
</I>&gt;<i> these terms to be very ambiguous and inappropriate, and so we should not 
</I>&gt;<i> use them here.
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://dev.w3.org/2009/dap/camera/">http://dev.w3.org/2009/dap/camera/</A>
</I>
Pity that they didn't use better names. I agree that those names aren't 
good enough to warrant reuse here.


&gt;<i> &gt; Similarly for exposing the kind of stream: we could add to 
</I>&gt;<i> &gt; GeneratedStream an attribute that reports this kind of thing. What is 
</I>&gt;<i> &gt; the most useful way of exposing this information?
</I>&gt;<i> 
</I>&gt;<i> I'm not entirely clear about what the use cases are for knowing if the 
</I>&gt;<i> camera is either user-view or environment-view.  It seems the more 
</I>&gt;<i> useful information to know is the orientation of the camera.  If the 
</I>&gt;<i> user switches cameras, that could also be handled by firing orientation 
</I>&gt;<i> events.
</I>
Agreed.


&gt;<i> &gt; &gt; There are some use cases for which it would be useful to know the 
</I>&gt;<i> &gt; &gt; precise orientation of the camera, such as augmented reality 
</I>&gt;<i> &gt; &gt; applications.  The camera orientation may be independent of the 
</I>&gt;<i> &gt; &gt; device's orientation, and so the existing device orientation API may 
</I>&gt;<i> &gt; &gt; not be sufficient.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; It seems like the best way to extend this would be to have the Device 
</I>&gt;<i> &gt; Orientation API apply to GeneratedStream objects, either by just 
</I>&gt;<i> &gt; having the events also fire on GeneratedStream objects, or by having 
</I>&gt;<i> &gt; the API be based on a pull model rather than a push model and exposing 
</I>&gt;<i> &gt; an object on GeneratedStream objects as well as Window objects.
</I>&gt;<i> 
</I>&gt;<i> This could work.  But it would make more sense if there were an object 
</I>&gt;<i> representing the device itself, as in Rich's proposal, and for the 
</I>&gt;<i> events to be fired on that object instead of the stream.
</I>
Would renaming GeneratedStream address this? I don't really think it makes 
sense to have two objects that always have a 1:1 mapping. I guess in 
theory each GeneratedStream could have multiple devices attached (a camera 
and a microphone, in the simple case) but that just seems excessively 
complicated...


&gt;<i> &gt; On Mon, 24 Jan 2011, Anne van Kesteren wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; There is a plan of allowing direct assigning to IDL attributes besides
</I>&gt;<i> &gt; &gt; creating URLs.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I.e. being able to do:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt;   audio.src = blob
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; (The src content attribute would then be something like
</I>&gt;<i> &gt; &gt; &quot;about:objecturl&quot;.)
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I am not sure if that API should work differently from creating URLs and
</I>&gt;<i> &gt; &gt; assigning those, but we could consider it.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Could you elaborate on this plan?
</I>&gt;<i> 
</I>&gt;<i> This is basically what Philip and I were discussing in the other thread
</I>&gt;<i> yesterday, where we avoid the unnecessary overhead of creating a magic URL,
</I>&gt;<i> and instead just assign the object directly to the src property. This lets the
</I>&gt;<i> implementation handle all the magic transparently in the background, without
</I>&gt;<i> bothering to expose a URLs string to the author.
</I>&gt;<i> 
</I>&gt;<i> This is what we had implemented in our experimental implementation of the
</I>&gt;<i> &lt;device&gt; element, and now getUserMedia.
</I>&gt;<i> 
</I>&gt;<i> i.e.
</I>&gt;<i> 
</I>&gt;<i> &lt;video&gt;&lt;/video&gt;
</I>&gt;<i> &lt;script&gt;
</I>&gt;<i> var v = document.querySelector(&quot;video&quot;);
</I>&gt;<i> navigator.getUserMedia(&quot;video&quot;, function(stream) {
</I>&gt;<i>   v.src = stream;
</I>&gt;<i>   v.play();
</I>&gt;<i> });
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i> 
</I>&gt;<i> The getter for v.src then returns &quot;about:streamurl&quot;.
</I>&gt;<i> 
</I>&gt;<i> My understanding is that we don't really want to have to implement the
</I>&gt;<i> create/revokeObjectURL() methods for this.
</I>
I strongly recommend taking this up with the WebApps group. I think it 
would be far better for us to be consistent throughout than for the stream 
stuff to be different, especially over something like this.


&gt;<i> &gt; On Wed, 16 Feb 2011, Anne van Kesteren wrote:
</I>&gt;<i> &gt; &gt; This is just a thought. Instead of acquiring a Stream object 
</I>&gt;<i> &gt; &gt; asynchronously there always is one available showing transparent 
</I>&gt;<i> &gt; &gt; black or some such. E.g. navigator.cameraStream. It also inherits 
</I>&gt;<i> &gt; &gt; from EventTarget. Then on the Stream object you have methods to 
</I>&gt;<i> &gt; &gt; request camera access which triggers some asynchronous UI. Once 
</I>&gt;<i> &gt; &gt; granted an appropriately named event is dispatched on Stream 
</I>&gt;<i> &gt; &gt; indicating you now have access to an actual stream. When the user 
</I>&gt;<i> &gt; &gt; decides it is enough and turns of the camera (or something else 
</I>&gt;<i> &gt; &gt; happens) some other appropriately named event is dispatched on 
</I>&gt;<i> &gt; &gt; Stream again turning it transparent black again.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This is a very interesting idea.
</I>&gt;<i> 
</I>&gt;<i> This suggests that there would be a separate property available for the 
</I>&gt;<i> microphone, and any other input device.  This differs from the existing 
</I>&gt;<i> spec, which allowed a single stream to represent both audio and video.
</I>
My assumption is that if we did this we would implement it by just having 
getUserMedia() always return a stream straight away, not by deing quite 
what Anne describes -- what Anne describes would limit the user to 
exposing only one device of each type.


&gt;<i> &gt; On Mon, 14 Mar 2011, Lachlan Hunt wrote:
</I>&gt;<i> &gt; &gt; The API includes both readystatechange event, as well as independent 
</I>&gt;<i> &gt; &gt; events for play, paused and ended.  This redundancy is unnecessary. 
</I>&gt;<i> &gt; &gt; This is also inconsistent with the design of the HTMLMediaElement 
</I>&gt;<i> &gt; &gt; API, which does not include a readystatechange event in favour on 
</I>&gt;<i> &gt; &gt; separate events only.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I've dropped readystatechange.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I expect to drop play and pause events if we move to the model 
</I>&gt;<i> &gt; described above that pauses and resumes audio and video separately.
</I>&gt;<i> 
</I>&gt;<i> It may still be useful to have events for this, if the event object had 
</I>&gt;<i> a property that indicated which type of stream it applied to, or if 
</I>&gt;<i> there were separate objects for both the audio and video streams.
</I>
Separate objects seems awkward, especially for, e.g., video conferencing.


On Fri, 18 Mar 2011, Olli Pettay wrote:
&gt;<i> 
</I>&gt;<i> And I was arguing that we could avoid creating the probably somewhat 
</I>&gt;<i> heavy stream object if we could just assign the url, or perhaps some 
</I>&gt;<i> DOMURL object to video/audio.src.
</I>
I don't really see why a Stream object would be heavy. It's just a very 
light wrapper around what has to exist in the background anyway, no?


On Tue, 22 Mar 2011, Stefan H&#229;kansson LK wrote:
&gt;<i>
</I>&gt;<i> We've since produced an updated use case doc: 
</I>&gt;<i> &lt;<A HREF="http://www.ietf.org/id/draft-holmberg-rtcweb-ucreqs-01.txt">http://www.ietf.org/id/draft-holmberg-rtcweb-ucreqs-01.txt</A>&gt;
</I>
Are there any use cases you feel are not handled?


&gt;<i> &gt; &gt; !The web application must be able to    !If the video is going to be displayed !
</I>&gt;<i> &gt; &gt; !define the media format to be used for !in a large window, use higher bit-    !
</I>&gt;<i> &gt; &gt; !the streams sent to a peer.            !rate/resolution. Should media settings!
</I>&gt;<i> &gt; &gt; !                                       !be allowed to be changed during a     !
</I>&gt;<i> &gt; &gt; !                                       !session (at e.g. window resize)?      !
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Shouldn't this be automatic and renegotiated dynamically via SDP 
</I>&gt;<i> &gt; offer/answer?
</I>&gt;<i>
</I>&gt;<i> Yes, this should be (re)negotiated via SDP, but what is unclear is how 
</I>&gt;<i> the SDP is populated based on the application's preferences.
</I>
Why would the Web application have any say on this? Surely the user agent 
is in a better position to know what to negotiate, since it will be doing 
the encoding and decoding itself.


&gt;<i> &gt; &gt; !Streams being transmitted must be      !Do not starve other traffic (e.g. on  !
</I>&gt;<i> &gt; &gt; !subject to rate control                !ADSL link)                            !
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Not sure whether this requires any thing special. Could you elaborate?
</I>&gt;<i>
</I>&gt;<i> What I am after is that the RTP/UDP streams sent from one UA to the 
</I>&gt;<i> other must have some rate adaptation implemented. HTTP uses TCP 
</I>&gt;<i> transport, and TCP reduces the send rate when a packet does not arrive 
</I>&gt;<i> (so that flows share the available throughput in a fair way when there 
</I>&gt;<i> is a bottleneck). For UDP there is no such mechanism, so unless 
</I>&gt;<i> something is added in the RTP implementation it could starve other 
</I>&gt;<i> traffic. I don't think it should be visible in the API though, it is a 
</I>&gt;<i> requirment on the implemenation in the UA.
</I>
Ok. This seems like an issue for RTP, not the API, if it is a spec issue 
at all (as opposed to just an implementation detail as you suggest above).


&gt;<i> &gt; &gt; !The web application must be made aware !To be able to inform user and take   !
</I>&gt;<i> &gt; &gt; !of when streams from a peer are no     !action (one of the peers still has   !
</I>&gt;<i> &gt; &gt; !longer received                        !connection with the server)          !
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; !The browser must detect when no streams!                                     !
</I>&gt;<i> &gt; &gt; !are received from a peer               !                                     !
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; These aren't really yet supported in the API, but I intend for us to 
</I>&gt;<i> &gt; add this kind of thing at the same time sa we add similar metrics to 
</I>&gt;<i> &gt; &lt;video&gt; and &lt;audio&gt;. To do this, though, it would really help to have 
</I>&gt;<i> &gt; a better idea what the requirements are. What information should be 
</I>&gt;<i> &gt; available? &quot;Packets received per second&quot; (and &quot;sent&quot;, maybe) seems 
</I>&gt;<i> &gt; like an obvious one, but what other information can we collect?
</I>&gt;<i>
</I>&gt;<i> I think more studies are required to answer this one.
</I>
Any advice you may have in the future on this would definitely be welcome.


On Tue, 22 Mar 2011, Harald Alvestrand wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt;   * locally-generated streams can be paused and resumed.
</I>&gt;<i>
</I>&gt;<i> I believe this property should be moved up to the &quot;stream&quot; level (which 
</I>&gt;<i> I prefer to call &quot;StreamSource&quot;, because I think we also need an 
</I>&gt;<i> interface named &quot;StreamSink&quot;).
</I>
This is now on the GeneratedStream object's audioTracks and videoTracks 
objects.


&gt;<i> I also believe that the recording interface should be removed from this 
</I>&gt;<i> part of the specification; there should be no requirement that all 
</I>&gt;<i> streams be recordable.
</I>
Recording of streams is needed for some use cases unrelated to video 
conferencing, such as recording messages.


&gt;<i> The streams should be regarded as a control surface, not as a data channel; in
</I>&gt;<i> many cases, the question of &quot;what is the format of the stream at this point&quot;
</I>&gt;<i> is literally unanswerable; it may be represented as hardware states, memory
</I>&gt;<i> buffers, byte streams, or something completely different.
</I>
Agreed.


&gt;<i> Recording any of these requires much more specification than just 
</I>&gt;<i> &quot;record here&quot;.
</I>
Could you elaborate on what else needs specifying?


&gt;<i> &gt;   * the ConnectionPeer interface has been replaced with a PeerConnection
</I>&gt;<i> &gt;     interface that interacts directly with ICE and its dependencies.
</I>&gt;<i>
</I>&gt;<i> I disagree with a number of aspects of this interface. In particular, I 
</I>&gt;<i> believe the relationship between SDP and ICE is fundamentally misstated; 
</I>&gt;<i> it is possible, and often desirable, to use ICE without using SDP; there 
</I>&gt;<i> are other ways of encoding the information we need to pass.
</I>
Certainly, but for compatibility with SIP it seems easiest to just use SDP 
as ICE uses it, unmodified. One can then translate the SDP to other forms 
in a gateway if it is necessary to communicate with other ICE stacks that 
use a different format for the SDP data.

See also:

   <A HREF="http://tools.ietf.org/html/draft-rosenberg-mmusic-ice-nonsip-01">http://tools.ietf.org/html/draft-rosenberg-mmusic-ice-nonsip-01</A>


&gt;<i> In the RTCWEB IETF effort, the idea of mandating use of SDP is being 
</I>&gt;<i> pushed back on.
</I>
If there are technical reasons that another format would be superior, that 
would definitely be good information to have. What are the reasons for 
avoiding using the format described in SDP?


&gt;<i> I also believe the configuration string format is too simplistic and 
</I>&gt;<i> contains errors; at the very least, we need a keyword:value format 
</I>&gt;<i> (JSON?) so that we can extend the configuration string without breaking 
</I>&gt;<i> existing scripts
</I>
The format is designed to be extensible -- we can add anything we later 
find we need to add by just using a different prefix.


&gt;<i> and the STUN/TURN strings are incompletely defined (you can't specify 
</I>&gt;<i> that you're using TURN over TCP, for instance).
</I>
There are three transports defined by the STUN and TURN specifications: 
unencrypted UDP, unencrypted TCP, and TLS-over-TCP. The PeerConnection 
spec currently supports unencrypted UDP and TLS-over-TCP. What is the use 
case for supporting unencrypted TCP? We can easily add support for it if 
there is a compelling reason, but mere completeness is not really a 
compelling argument, which is why I haven't included it so far.


&gt;<i> &gt;   * the wire format for the unreliable data channel has been 
</I>&gt;<i> &gt;     specified.
</I>&gt;<i>
</I>&gt;<i> I agree that before this functionality is implementable, we need a 
</I>&gt;<i> specification for its format. However, I don't believe the current 
</I>&gt;<i> specification is reasonable; it has complexities (such as masking) that 
</I>&gt;<i> don't correspond to a known threat model (given the permission-to-send 
</I>&gt;<i> model of ICE, the idea of cross-channel attacks using an ICE channel is 
</I>&gt;<i> irrelevant).
</I>
This is discussed above. In general, I'm a strong advocate of defense-in- 
depth, and would be very skeptical of introducing a new format that is not 
masked. Cross-protocol attacks are notoriously hard to reason about.



On Wed, 23 Mar 2011, Erik Moller wrote:
&gt;<i>
</I>&gt;<i> (Amazingly &ouml; still seems to be causing troubles in 2011.)
</I>
Yeah, sorry about that. I use a mail client that is nigh perfect but has a 
couple of serious problems, one of which is its handling of encodings.


&gt;<i> &gt; Does PeerConnection address this use case to your satisfaction?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Note that currently it does not support binary data, but I've built in 
</I>&gt;<i> &gt; an extension mechanism to make this easy to add in the future.
</I>&gt;<i> 
</I>&gt;<i> It is looking very promising at least. I won't say yes because I know 
</I>&gt;<i> there will always be things missing once you start using it in the real 
</I>&gt;<i> world.
</I>
If you do come across anything missing, please let me know.


&gt;<i> I guess doing some extra investigation whether those additional 20 (?) 
</I>&gt;<i> bytes per packet are really necessary would be good. I'll have to leave 
</I>&gt;<i> that to someone with more expertise in that area though.
</I>
From a game developer's perspective, of the overhead, 16 bytes are used 
for integrity (the hash), which seems like it would be good if you don't 
want players to cheat; and 8 bytes are used for a sequence number, which 
seems like you'd need to add in the data if not in the header, again to 
prevent cheating. This leaves 16 bytes for the nonce which masks the data, 
a defence-in-depth strategy, and 4 bytes that provide expansion so we can 
support binary later. (I used 4 bytes for that rather than 1 so that it 
would align the data on a 32bit boundary.)


&gt;<i> &gt; &gt; &gt; - many games need to send large messages (so the libraries do 
</I>&gt;<i> &gt; &gt; &gt; automatic fragmentation).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Again, this is probably because games have no other means of 
</I>&gt;<i> &gt; &gt; communication than the NW-library. I'd think these large reliable 
</I>&gt;<i> &gt; &gt; messages would mostly be files that need to be transferred 
</I>&gt;<i> &gt; &gt; asynchronously for which browsers already have the tried and tested 
</I>&gt;<i> &gt; &gt; XMLHttpRequest.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Are the large messages always reliable messages?
</I>&gt;<i> 
</I>&gt;<i> I can of course only speak from my experience from the games I've worked 
</I>&gt;<i> on, but these large messages have typically been updated content. 
</I>&gt;<i> Textures, level data etc. More recently using a bit torrent system has 
</I>&gt;<i> been popular for distributing updated content. So, yeah, those large 
</I>&gt;<i> messages have always been reliable.
</I>
Ok. In that case it seems that you'd probably want to use some other 
mechanism; on the short run probably straight HTTP.


&gt;<i> &gt; &gt; &gt; - many games need to efficiently send tiny messages (so the 
</I>&gt;<i> &gt; &gt; &gt; libraries do automatic aggregation).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; This is probably true for many other use-cases than games, but at 
</I>&gt;<i> &gt; &gt; least in my experience games typically use a bit-packer or 
</I>&gt;<i> &gt; &gt; range-coder to build the complete packet that needs to be sent. But 
</I>&gt;<i> &gt; &gt; again, it's a matter of what level you want to place the interface.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This seems relatively easy to layer on top of the current protocol in 
</I>&gt;<i> &gt; the spec, but if we find it commonly used we can also add it 
</I>&gt;<i> &gt; explicitly as an extension.
</I>&gt;<i> 
</I>&gt;<i> I'd suggest just keeping the API as simple as possible. With JavaScript 
</I>&gt;<i> kicking ass and taking names in terms of performance the last couple of 
</I>&gt;<i> years it seems less necessary to build things like that into the API. 
</I>&gt;<i> Besides, it seems every NW-engineer have their own favourite bitpacker.
</I>
Agreed.


&gt;<i> &gt; &gt; with the possible addition of an attribute that allows the 
</I>&gt;<i> &gt; &gt; application developer to find the path MTU of a connected socket.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; What's the use case?
</I>&gt;<i> 
</I>&gt;<i> The use case is simply that intermediaries can have different MTUs and 
</I>&gt;<i> exceeding those may cause them to just unconditionally drop the packets. 
</I>&gt;<i> I haven't verified this recently though, that's just the way it used to 
</I>&gt;<i> be in the days...
</I>
I've heard a lot of people say this; can someone suggest a way I could 
test it? Are there specific routers that exhibit this?

I've heard 1500 bytes as being the lowest safe value; should we just block 
all packets above that on principle?


&gt;<i> &gt; Also there's currently no origin protection for peer-to-peer stuff 
</I>&gt;<i> &gt; (there is for the STUN/TURN part; the origin is the long-term 
</I>&gt;<i> &gt; credential). We could certainly add something; how should it work? 
</I>&gt;<i> &gt; What are the attack scenarios we should consider?
</I>&gt;<i> 
</I>&gt;<i> Not entirely sure, I suppose in the special case where one of the peers 
</I>&gt;<i> is the origin server you could do more?
</I>
Possibly. I'm not sure how you could tell, really.

A Web app could always ensure it's only talking to pages on its own origin 
by passing a per-instance secret on the signalling channel and verifying 
that it can be sent via the UDP channel, so we might not need to do 
anything directly in the API.


&gt;<i> &gt; &gt; -Cap on number of open sockets per host and global user-agent limit.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; UDP doesn't really have sockets, so I don't really know how to do 
</I>&gt;<i> &gt; this.
</I>&gt;<i> 
</I>&gt;<i> What about the ICE layer, is there anything that needs to be done to 
</I>&gt;<i> prevent flooding the server with requests there?
</I>
Possibly. For now I'm treating this as an ICE-spec-level issue, but we can 
definitely revisit this if the ICE spec does not support this and is not 
going to be updated to support it and user agents are going to need 
something to keep them interoperable.


On Thu, 24 Mar 2011, Harald Alvestrand wrote:
&gt;<i>
</I>&gt;<i> The proposal that I have put together, which is not detailed to the same 
</I>&gt;<i> level as the PeerConnection API, is here:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="https://sites.google.com/a/alvestrand.com/rtc-web/w3c-activity/api-proposals">https://sites.google.com/a/alvestrand.com/rtc-web/w3c-activity/api-proposals</A>
</I>
On Fri, 25 Mar 2011, Stefan H&#229;kansson LK wrote:
&gt;<i> 
</I>&gt;<i> A quick look at the API sets gives me the impression that they are on a 
</I>&gt;<i> top level quite similar. The model and the level of the two API sets 
</I>&gt;<i> seem to be more or less the same. The first set seem to me clearer, more 
</I>&gt;<i> thought through and better documented. The second one also lacks the 
</I>&gt;<i> possibility to send text peer-to-peer, something that can be very 
</I>&gt;<i> important for certain cases (e.g. gaming).
</I>&gt;<i> 
</I>&gt;<i> I could go on discussing details, but my main message is: given that the 
</I>&gt;<i> two API sets are, on a top level, quite similar, would we not be better 
</I>&gt;<i> off selecting one of them, and use this as a basis for further 
</I>&gt;<i> discussion, testing and refinement?
</I>&gt;<i> 
</I>&gt;<i> Working on two parallel tracks could waste implementation efforts, lead 
</I>&gt;<i> to non converging parallel discussions and possibly end up in a 
</I>&gt;<i> fragmented situation.
</I>&gt;<i> 
</I>&gt;<i> My view is that a good way forward would be to use the API set in the 
</I>&gt;<i> spec as starting point, and propose enhancements/additions to it.
</I>
It's not immediately clear which differences are unintentional on 
unimportant -- merely artefacts of the designers having different 
backgrounds or styles -- and which are the result of mistakes on my part, 
areas where the HTML spec's proposal is incomplete or fails to take into 
account some important use case or constraint.


On Fri, 25 Mar 2011, Satish Sampath wrote:
&gt;<i> 
</I>&gt;<i> It would be useful if Harald could propose specific changes to that 
</I>&gt;<i> draft instead of a completely new proposal, so that we can discuss about 
</I>&gt;<i> individual issues than which proposal to use. This could either be a 
</I>&gt;<i> diff showing changes to the WHATWG proposal or individual discussions in 
</I>&gt;<i> this list for each proposed change.
</I>
Agreed. More helpful than merely a list of differences would be a list of 
specific constraints or rationales that led to those differences. I'm 
eager to change the HTML spec to address anything that I've missed.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>






<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031057.html">[whatwg]  Peer-to-peer communication, video conferencing, and related topics (3)
</A></li>
	<LI>Next message: <A HREF="031060.html">[whatwg] Peer-to-peer communication, video conferencing, and related topics (2)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31058">[ date ]</a>
              <a href="thread.html#31058">[ thread ]</a>
              <a href="subject.html#31058">[ subject ]</a>
              <a href="author.html#31058">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
