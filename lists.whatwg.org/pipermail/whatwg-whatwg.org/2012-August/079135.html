<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Real-time thread support for workers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Real-time%20thread%20support%20for%20workers&In-Reply-To=%3CCAJhzemUTP92Ln43drz4cvY8C-ukngFhPDH4Ny3BYfs-3A2k-nQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="079133.html">
   <LINK REL="Next"  HREF="079147.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Real-time thread support for workers</H1>
<!--htdig_noindex-->
    <B>Jussi Kalliokoski</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Real-time%20thread%20support%20for%20workers&In-Reply-To=%3CCAJhzemUTP92Ln43drz4cvY8C-ukngFhPDH4Ny3BYfs-3A2k-nQ%40mail.gmail.com%3E"
       TITLE="[whatwg] Real-time thread support for workers">jussi.kalliokoski at gmail.com
       </A><BR>
    <I>Thu Aug  9 09:46:13 PDT 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="079133.html">[whatwg] Real-time thread support for workers
</A></li>
        <LI>Next message: <A HREF="079147.html">[whatwg] Real-time thread support for workers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#79135">[ date ]</a>
              <a href="thread.html#79135">[ thread ]</a>
              <a href="subject.html#79135">[ subject ]</a>
              <a href="author.html#79135">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Thu, Aug 9, 2012 at 6:09 PM, David Bruant &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">bruant.d at gmail.com</A>&gt; wrote:

&gt;<i>  Le 09/08/2012 09:59, Jussi Kalliokoski a &#233;crit :
</I>&gt;<i>
</I>&gt;<i> Hello David,
</I>&gt;<i>
</I>&gt;<i> Hi Jussi,
</I>&gt;<i>
</I>&gt;<i> On Thu, Aug 9, 2012 at 3:54 PM, David Bruant &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">bruant.d at gmail.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;<i>  * The last source is your own content competing with itself for CPU.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> *snip*
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> One question I have is whether different parts of your own content (like
</I>&gt;&gt;<i> different workers) should declare which priority should be given or whether
</I>&gt;&gt;<i> the application should be written in a way that is resistant to high CPU
</I>&gt;&gt;<i> stress (e.g. doing few work besides audio work).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I'm sorry, not entirely sure I follow... :)
</I>&gt;<i>
</I>&gt;<i> No worries, it wasn't really clear, I admit :-)
</I>&gt;<i> Your proposal draws an API between the developer and the system that is
</I>&gt;<i> based on assigning a priority and letting the system judge what to do with
</I>&gt;<i> that. I was suggesting that more (not all, but more) should be put on the
</I>&gt;<i> developer shoulders rather than letting the computer guess.
</I>&gt;<i>
</I>
Owkay... How, exactly, do you mean?

&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Since the only relevant case for priorities is the third one, I'd like to
</I>&gt;&gt;<i> question the relevance of the use case.
</I>&gt;&gt;<i> Is implementing per-browsing-content web worker priority worth the
</I>&gt;&gt;<i> result? Will we be able to really notice an improvement in the audio
</I>&gt;&gt;<i> quality that often?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yes. Especially in mobile devices it makes a world of difference when for
</I>&gt;<i> example on a single-core phone you have an audio app in the foreground, and
</I>&gt;<i> a Twitter client in the background. If the Twitter client decides to update
</I>&gt;<i> its content, the audio is most likely to glitch and this is most likely not
</I>&gt;<i> the way the user wanted it to go.
</I>&gt;<i>
</I>&gt;<i> We're back to the case of 2 competing content. An API shouldn't be able to
</I>&gt;<i> influence that for the reason cited in the previous message (which you said
</I>&gt;<i> you were worried about)
</I>&gt;<i> I know Firefox is doing work currently to reduce the work done by
</I>&gt;<i> background tabs (short setTimeouts are clamped to 1s when in background for
</I>&gt;<i> instance. There is other work going on).
</I>&gt;<i>
</I>
Yes, I was actually referring to a non-web-app Twitter client. Or a web-app
Twitter client in another browser/wrapper. :)


&gt;<i> Prioritizing between background and foreground tasks is an implementation
</I>&gt;<i> issue, not an issue that should requires a web content API IMHO.
</I>&gt;<i>
</I>&gt;<i> Once again, the only use case being discussed here is likely content
</I>&gt;<i> competing against itself for CPU.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>   Here's the discussion thread on AudioWG [1] and a good article
</I>&gt;<i> exploring the subject of interaction between audio and the rest of the
</I>&gt;<i> system [2].
</I>&gt;<i>
</I>&gt;<i> I haven't fully read the AudioWG thread (I will. Meanwhile, if the thread
</I>&gt;<i> addresses my point, can you link to specific messages?),
</I>&gt;<i>
</I>
Sure, I'll try to!


&gt;<i> but I have read the article.
</I>&gt;<i> Most points either don't apply to the web or are on the developer
</I>&gt;<i> shoulders already.
</I>&gt;<i> * Blocking
</I>&gt;<i> =&gt; Except for a couple of pathological exceptions (alert, prompt, sync
</I>&gt;<i> xhr), JavaScript has a non-blocking model
</I>&gt;<i>
</I>&gt;<i> * Poor worst-case complexity algorithms
</I>&gt;<i> =&gt; That's almost fully on developer shoulders. The web platform
</I>&gt;<i> implementers try to avoid such algorithms already (which is a dilemma in
</I>&gt;<i> text-layout algorithms I heard)
</I>&gt;<i>
</I>&gt;<i> * Locking
</I>&gt;<i> =&gt; The message passing model has no notion of locking.
</I>&gt;<i>
</I>&gt;<i> * Memory allocation
</I>&gt;<i> =&gt; On developer shoulders mostly.
</I>&gt;<i>
</I>&gt;<i> * Invisible things: garbage collection
</I>&gt;<i> =&gt; GC could be &quot;controlled&quot; by a priority actually, but this needs to be
</I>&gt;<i> discussed with the JS engine folks.
</I>&gt;<i>
</I>&gt;<i> * page faults
</I>&gt;<i> =&gt; You can't do anything against that on the web.
</I>&gt;<i>
</I>&gt;<i> One thing that isn't explicitely written is that when doing audio in C,
</I>&gt;<i> you have shared-memory in threads (hence locking) and my guess is that it's
</I>&gt;<i> a good source of. You however don't have shared memory in JS with web
</I>&gt;<i> workers. Transferables are a good step forward, maybe a better thing to
</I>&gt;<i> discuss would be to move further in that direction.
</I>&gt;<i>
</I>&gt;<i> According to this article, it seems that the web platform is well-suited
</I>&gt;<i> (no lock, no blocking) for audio actually, isn't it?
</I>&gt;<i>
</I>
I agree! A lot of people on the AudioWG don't, however.


&gt;<i>   The gain for audio is so significant
</I>&gt;<i>
</I>&gt;<i> Did someone do research on that? Do we have benchmarks, numbers? Or is the
</I>&gt;<i> &quot;significant&quot; hypothetical?
</I>&gt;<i>
</I>
I'm not the best person to answer that question, unfortunately. This issue
against Android linked on the thread might be of interest though:
<A HREF="http://code.google.com/p/android/issues/detail?id=3434">http://code.google.com/p/android/issues/detail?id=3434</A> . What the issue
shapes up to focus on is having audio in a high-priority real-time thread.
A quick glance seems like the performance difference numbers thrown around
(are they to be trusted?) suggest latencies of even a half a second when
audio is run in a normal-priority thread, which is quite unacceptable
(recent studies show that the brain is able to sync a connection between a
visual cue and a sound up to at maximum 80ms).


&gt;<i>  that a lot of the working group seems to think it's a good idea to have
</I>&gt;<i> a whole lot of (not very modular to be honest) native DSP nodes that can
</I>&gt;<i> run in a priority thread just to get the audio running in a priority
</I>&gt;<i> thread, and I think priority thread workers is a way better idea.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> I would be more in favor of browsers sharing with content how busy the
</I>&gt;&gt;<i> CPU is (in a way or another) so that the content shuts down things itself
</I>&gt;&gt;<i> and decides programmatically what is worth running and what isn't.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yes, that would be ideal. However I fear it's not good enough for audio.
</I>&gt;<i>
</I>&gt;<i> Purely based on the article, it seems that the web platform does a good
</I>&gt;<i> job at helping developers write good real-time code (no blocking, no
</I>&gt;<i> locking, no built-in poor worst-case complexity algorithms). The other
</I>&gt;<i> points (memory allocation, page faults) are either on the developer
</I>&gt;<i> shoulders or at the system level and priority would unlikely help with that
</I>&gt;<i> (if it does, I would be interested in reading the related research on the
</I>&gt;<i> topic). Priority could help with GC (not doing it under pressure), but at
</I>&gt;<i> the same time, GC are undergoing tremedous improvements (incremental GC in
</I>&gt;<i> Chrome and now in Firefox, Generational GC in Chrome and soon in FF)
</I>&gt;<i> lately, so it would need to be proven too that the difference would be that
</I>&gt;<i> substancial.
</I>&gt;<i> Not having shared memory may be a bottleneck. Transferable helps.
</I>&gt;<i>
</I>&gt;<i> All in all, the article you linked to makes me more confident that the web
</I>&gt;<i> is close to be ready for real-time code.
</I>&gt;<i> It would be nice (a requirement?) to see actual research on every
</I>&gt;<i> assumption on how a web worker priority mechanism would improve audio
</I>&gt;<i> quality.
</I>&gt;<i>
</I>
Indeed. I'll try and dig if I can find something.

There is actually at least one alternative possibility to the developer
being able to set the thread priority for his/her worker. With the current
audio API suggestions, it's pretty easy for the UA to determine whether a
worker is running audio which means it could automatically adjust the
thread priority accordingly. How does that sound? There's one severe
drawback with that approach though, as it gives no opt-out from running the
worker in a high-priority thread. As I say on the thread, it's not always
desirable for the audio to have priority over everything else, for example
on a single-core computer, running large-kernel convolution in a
high-priority thread can make the whole system virtually unusable. That's
always true for the native DSP node approach as well, which I think is a
bad idea.

Cheers,
Jussi

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="079133.html">[whatwg] Real-time thread support for workers
</A></li>
	<LI>Next message: <A HREF="079147.html">[whatwg] Real-time thread support for workers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#79135">[ date ]</a>
              <a href="thread.html#79135">[ thread ]</a>
              <a href="subject.html#79135">[ subject ]</a>
              <a href="author.html#79135">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
