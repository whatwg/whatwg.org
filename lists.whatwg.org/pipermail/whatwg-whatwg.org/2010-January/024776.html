<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] [foaf-protocols] keygen substitute for Windows?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%5Bfoaf-protocols%5D%20keygen%20substitute%20for%20Windows%3F&In-Reply-To=%3CCE9CE9E6-621B-4EDD-8BDF-CB56ACB25BFA%40bblfish.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024774.html">
   <LINK REL="Next"  HREF="024780.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] [foaf-protocols] keygen substitute for Windows?</H1>
<!--htdig_noindex-->
    <B>Story Henry</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%5Bfoaf-protocols%5D%20keygen%20substitute%20for%20Windows%3F&In-Reply-To=%3CCE9CE9E6-621B-4EDD-8BDF-CB56ACB25BFA%40bblfish.net%3E"
       TITLE="[whatwg] [foaf-protocols] keygen substitute for Windows?">henry.story at bblfish.net
       </A><BR>
    <I>Tue Jan 19 11:23:24 PST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="024774.html">[whatwg] [foaf-protocols] keygen substitute for Windows?
</A></li>
        <LI>Next message: <A HREF="024780.html">[whatwg] [foaf-protocols] keygen substitute for Windows?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24776">[ date ]</a>
              <a href="thread.html#24776">[ thread ]</a>
              <a href="subject.html#24776">[ subject ]</a>
              <a href="author.html#24776">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
On 19 Jan 2010, at 17:26, Bruno Harbulot wrote:

&gt;<i> Hello Henry,
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Story Henry wrote:
</I>&gt;&gt;&gt;<i> Whilst I'm very supportive of having a key-generation mechanism in the browser, I'm now not entirely sure the &lt;keygen&gt; tag, at least as a legacy of the Netscape &lt;keygen&gt; tag, is the correct approach.
</I>&gt;&gt;<i> I think that part of the html5 goals is to describe how browsers actually work, without going into endless debates about how they SHOULD work. Given that Netscape, Firefox, Opera and Safari implement the &lt;keygen&gt; tag - and have done so for a very long time - it seems quite reasonable to describe that behaviour in html5. 
</I>&gt;<i> 
</I>&gt;<i> As far as I understand, &lt;keygen&gt; was, if not officially deprecated, at least not recommended in Firefox, since the introduction of generateCRMFRequest.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I wouldn't say &lt;keygen&gt; is greatly implemented, even in Firefox.
</I>&gt;<i> Consider the following HTML document:
</I>&gt;<i> 
</I>&gt;<i> &lt;html&gt;
</I>&gt;<i> &lt;head&gt;
</I>&gt;<i> &lt;script type=&quot;text/javascript&quot;&gt;
</I>&gt;<i> function writeTagName() {
</I>&gt;<i>  document.getElementById(&quot;title&quot;).appendChild(
</I>&gt;<i>      document.createTextNode(document.getElementById(&quot;keygen&quot;).tagName));
</I>&gt;<i> }
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i> &lt;/head&gt;
</I>&gt;<i> &lt;body onload=&quot;writeTagName()&quot;&gt;
</I>&gt;<i> &lt;h1 id=&quot;title&quot;&gt;&lt;/h1&gt;&lt;keygen id=&quot;keygen&quot; /&gt;
</I>&gt;<i> &lt;/body&gt;
</I>&gt;<i> &lt;/html&gt;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> In Firefox, this prints &quot;SELECT&quot;: &lt;keygen&gt; is transformed on the fly into &lt;select&gt;, which breaks DOM usage. This is something that Opera and Safari don't do.
</I>
(( should not &lt;keygen&gt; be inside a &lt;form&gt; ? ))

&gt;<i> Even across Firefox, Opera and Safari, the behaviour of keygen isn't uniform.
</I>
I think they rarely are. This is why the WhatWG is documenting these inconsistencies...
The trick is to find overlaps in the behaviour, the differences, and the work out from there what options for development exist.

&gt;<i> The choice of &quot;High grade&quot; and &quot;Low grade&quot; is left to the appreciation of Firefox, whereas a proper CA would certainly require a bit more precision. In contrast, Opera offers a much longer list of key sizes, defaulting somewhere around 1500 bits (I don't have Opera on this machine).
</I>
That is not a problem if the browser user interface is different. Perhaps the different browsers have different expectations on their users abilities. Perhaps keygen can be later extended to make it possible to be more precise. It seems to me that keygen is there to produce a key in a form, and send it with the form. How it gets the key is a lot less important.


&gt;<i> One of the other points (which I think I've seen mentioned on this mailing list) is that &lt;keygen&gt; doesn't really fit as a form element. There's a number of parameters that can be set to generate a pair of keys. Why assume that the keysize (and only the keysize) is to be chosen by the user while all the others are set within the page? It might make sense, in some circumstances to have it all fixed on the page (by the service provider) or to let the user also chose whether to use RSA or RSA for example. (Along the same argument, why assume 'md5WithRSAEncryption' and not SHA-1?)
</I>&gt;<i> It just looks like it doesn't belong in a form this way.
</I>
But certainly that type of thing could be added to a &lt;keygen&gt; extension?


&gt;<i> I'd go even further that this in fact: why always *generate* a key-pair?
</I>&gt;<i> Whether it's used for an PKIX CA or FOAF+SSL, why not let the option to use an existing pair of key available in whatever key store the browser has access to? (That would in fact be quite useful for FOAF+SSL applications.)
</I>&gt;<i> If I send a CSR to a CA for signing, does it (even can it) know where those keys have been generated? Perhaps it might make more sense in some cases to re-use an existing pair of keys available in a smart-card or even some software key store.
</I>
Good idea. Since the private keys don't leave the store, the browser could ask the user to re-use a key. In fact I would say that if a browser vendor allowed a user to do this, he would not necessarily be going against the spirit of keygen.

&gt;&gt;<i> Once this is described it is then possible to find ways either to extend on the current behaviour or to find ways to improve it. Until now this topic was only something a few people could discuss.
</I>&gt;&gt;&gt;<i> More specifically:
</I>&gt;&gt;&gt;<i> 
</I>&gt;&gt;&gt;<i> 1. The more modern APIs (generateCRMFRequest [1] on Firefox or CertEnroll/XEnroll on Internet Explorer [2]) appear to offer more options in general, for example, where to store the private key, is it exportable, etc. (I haven't looked in details, but I suspect it could be envisaged to use some existing key material from a software store or smartcard too, for example.)
</I>&gt;&gt;&gt;<i> This raises the question as to whether a tag is sufficient or appropriate to express what's required for a CA, or if an API (and more programming) is required.
</I>&gt;&gt;<i> I think there should be a strong preference for declarative ways of doing things if possible, ie to use HTML tags. Moving over to javascript has always seemed to me to be breaking one foundational element of the web.
</I>&gt;<i> 
</I>&gt;<i> The problem is that there's only so much one can do declaratively in this field, precisely because some of this involves the security architecture of the overall system in which the browser runs, which by essence will have parts that do not belong within the browser, or at least ought to be outside the direct reach of what HTML can do (Windows certificate store, Apple Keychain...).
</I>
Why would using the Apple Keychain be a problem? Firefox could ask the Apple Keychain for a list of public certificates, and yet reuse a public key from there as you suggested above. Or Firefox could add a key to such a keychain. One would hope that would be possible at least. Indeed the nice thing about the declarative tag, is that it could hide all these implementation issues.

&gt;<i> 
</I>&gt;&gt;<i> As proof of the advantage of this way of working: the keygen tag has functioned across browser generations without change (I think).
</I>&gt;<i> 
</I>&gt;<i> Well, I haven't followed the complete history of generateCRMFRequest, but there must be a reason why it was invented as a successor of &lt;keygen&gt;. I have no idea what the ratio of modern CAs that still use &lt;keygen&gt; vs. those that use generateCRMFRequest is. The one I use regularly seems to use generateCRMFRequest.
</I>
It would be interesting indeed to learn about the reason for this. 
But it would not be surprising that generateCRMFRequest got adopted more recently, as it has been documented. Browser manufacturers seem to have a lot less problems with making special JavaScript functions and documenting those than they do creating new tag elements.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Microsoft's ActiveX component on the other hand (as I understand required the calling of a Windows specific binary technology! The naming of a dll. This meant that when they changed the dll code that was written for browsers also had to change!
</I>&gt;&gt;<i> <A HREF="http://msdn.microsoft.com/en-us/library/bb931379%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/bb931379%28VS.85%29.aspx</A>
</I>&gt;&gt;<i> [[
</I>&gt;&gt;<i> Prior to Windows Vista, the Certificate Enrollment Control was implemented in Xenroll.dll. The Xenroll.dll library has been removed from the operating system and replaced by CertEnroll..dll.]]
</I>&gt;&gt;<i> The web is described with no reference to CPU architecture. I am seriously against bringing such low level aspects into day to day web programming. 
</I>&gt;<i> 
</I>&gt;<i> As Adrian Bateman from Microsoft said in [5]: &quot;We are prepared to consider creating common APIs that allow interoperability across browsers and also address customers' real needs either in a future version of the spec or as a separate work item.&quot;
</I>&gt;<i> 
</I>&gt;<i> Perhaps that's the way to go, having a common API similar to what's done for XMLHttpRequest.
</I>&gt;<i> 
</I>&gt;<i> While I must admit it took me a while to figure out how to write [6] for CertEnroll.dll, this wasn't infeasible. Perhaps a similar example on MSDN would have helped.
</I>
I am not flattering you Bruno, if I say that you are extremely knowledgeable in cryptography. Knowing cryptography, javascript, html and more is a lot to ask people. Much simple really would be if we could all have &lt;keygen&gt; work across browsers, and even better an improved keygen. 

JavaScript is a problem just for one reason: it can be switched off.

&gt;<i> The change you're talking about isn't just a change of DLL, it's a more fundamental change in the handling of certificate in the overall infrastructure of the operating system. (Yes, a common API with sensible default values and what needs to be OS-specific customised there would help.)
</I>&gt;<i> 
</I>&gt;<i> You could say that Safari handles both &lt;keygen&gt; and the OSX's Keychain infrastructure, but this seems to come at the expense of certificates being almost unusable in the current implementation [7].
</I>
yes, that's a tricky problem of how to get a lower level to make use of an upper level User Interface to get the user to make a choice. But that is a problem at the connection level, when the user has to choose which certificate he wishes to use for client side certificate connection. 

This is not a problem at the certificate creation level which is what we are discussing here.

&gt;&gt;&gt;<i> 2. The SPKAC format seems to be a legacy format. It doesn't really allow to convey much information that CAs would expect, unlike other formats used by the more modern APIs [3][4]. Perhaps it would be better to use one of the newer formats instead. This might break the compatibility with the pre-HTML 5 use of &lt;keygen&gt; (maybe another name than &lt;keygen&gt; in HTML5 would be better?).
</I>&gt;&gt;<i> Perhaps extensions to keygen would be an interesting idea. At least it is document now.
</I>&gt;<i> 
</I>&gt;<i> I think it probably shouldn't be. Having a separate effort along the lines of that for XMLHttpRequest, involving CA implementors and security experts sounds like a better plan, rather than crippling HTML 5 with something that not quite fit for purpose.
</I>
I am still not convinced you have made the case that it is not fit for purpose. The &lt;keygen&gt; tag is currently very basic. You would have to prove that no way of extending it could make it fit for purpose. That is much more difficult to prove. Also it took us one year to find the solution you have put together, and there are many more browsers coming out there on the market every day. I really would rather we all started working on simplifying life, so that we can deal with real problems (and there are an infinity of those waiting for us), rather than artificial problems such as these. 

Furthermore you would need to show that the keygen tag with its current limitations is not at all fit for a very broad range of purposes. Seems to me that one can get a lot done with the current keygen and that it is very useful.

&gt;<i> 
</I>&gt;&gt;&gt;<i> Of course, the other big question is whether it's worth trying to standardise this &lt;keygen&gt; tag if there's no intent of support from major browser vendors (I have IE in mind here).
</I>&gt;&gt;<i> There are 3 browser vendors that have implemented it. That is enough of a precedent to standardise. If one browser vendor requires people to use binaries that tie people to their platform, it seems that it is quite clear what the reasons for that may be, and those reasons have in the past been deemed legally condemnable by both US and EU courts. Let us rather assume that that vendor decided to pursue that activity due to lack of standardisation in this space. 
</I>&gt;<i> 
</I>&gt;<i> I think you completely misunderstand the XEnroll vs. CertEnroll issue. This isn't about &quot;binaries that tie people to their platform&quot;, this is about a change of API that reflects new capabilities offered by the platforms. The introduction of more flexibility in CertEnroll may reflect some actual user requirements, rather than an evil will to tie users to the platform. Again, according to [5], MS doesn't seem against a standardisation effort in that domain.
</I>
Well good. 
But again if I look at [5] I don't see that this shows that one cannot enhance keygen to make it do all the things listed by it or by you. Those all seem to be requests for improvement which could easily be specified.

&gt;<i> (Talking about API evolution, as far as FOAF+SSL is concerned, if CertEnroll was able to generated a suitable key-pair produce a self-signed certificate with the attributes we want, that would be a more convenient way than the &lt;keygen&gt;/pseudo-CA approach.)
</I>
Yes, foaf+ssl can work with self signed certificates. So I am not defending keygen out of selfish reasons. On the other hand for foaf+ssl to work well, the public key needs to be published on a remote server in RDF. So the interaction with a server is necessary - even if the server is a local machine - for desktop machines with fixed ip addresses. 

&gt;<i> 
</I>&gt;<i> Whilst, like many others, I have expressed frustration with Internet Explorer's own interpretation of various web standards, I can't really blame MS on this one. I mostly agree with Adrian Bateman's comments in [5], in fact.
</I>&gt;<i> You had written down the ActiveX mechanism as a &quot;hack&quot; for MSIE on the ESW wiki page before I edited it, but frankly, I'd consider Netscape's &lt;keygen&gt; to be as much as a hack, just made by IE's competitor. I might get it wrong, but considering the earliest mention of PKCS#10 I've seen dates from 1993 [8] and the earliest mention of &lt;keygen&gt; seems to be in the 1998 Netscape doc [9], time by which PKCS#10 was in an RFC [10], perhaps Netscape could have followed that standard at the time too instead of using SPKAC.
</I>
yes, SPKAC seems a bit odd of a decision.

But at least it is a data format. ActiveX ties the browser to a CPU architecture. That is a different kind of bug.


&gt;<i> I'm not aware of the full history of these standards, but I find it hard to make a judgement on who's right and who's wrong here.
</I>&gt;<i> If IE doesn't support &lt;keygen&gt;, it would just be too easy to be anti-MS and claim &quot;they don't support standards as usual&quot; once this &lt;keygen&gt; is in HTML 5.
</I>
Blaming Microsoft if they don't implement standards before they are standard won't convince anyone of independent judgement. But clearly it is not a good reason not to find good standard solutions because one is worried that they have not implemented that non existent standard in the past. For all I know M$ may be quite happy with a good solution in this space...

&gt;<i> I'm quite happy to have &lt;keygen&gt; now, since it helps demonstrate our FOAF+SSL work works across browsers, but I have reservations regarding its appropriateness as a general certificate request tool for the HTML of the future.
</I>
yes, certainly it can be improved. We should leave that magic up to the WhatWG who have extensive experience in the space of taking incompatible behaviours and writing specs that work with usage towards a better future.

Thanks for all these pointers, 


	I am sure this will be of great help to this group.


	Henry

&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Best wishes,
</I>&gt;<i> 
</I>&gt;<i> Bruno.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> [1] <A HREF="https://developer.mozilla.org/en/GenerateCRMFRequest">https://developer.mozilla.org/en/GenerateCRMFRequest</A>
</I>&gt;&gt;&gt;<i> [2] <A HREF="http://msdn.microsoft.com/en-us/library/aa374863%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/aa374863%28VS.85%29.aspx</A>
</I>&gt;&gt;&gt;<i> [3] <A HREF="http://tools.ietf.org/html/rfc2986">http://tools.ietf.org/html/rfc2986</A>
</I>&gt;&gt;&gt;<i> [4] <A HREF="http://tools.ietf.org/html/rfc4211">http://tools.ietf.org/html/rfc4211</A>
</I>&gt;<i> 
</I>&gt;<i> [5] <A HREF="http://lists.w3.org/Archives/Public/public-html/2009Sep/0043.html">http://lists.w3.org/Archives/Public/public-html/2009Sep/0043.html</A>
</I>&gt;<i> [6] <A HREF="http://github.com/harbulot/keygenapp/blob/master/samplewebapp/src/main/webapp/crosskeygen.js">http://github.com/harbulot/keygenapp/blob/master/samplewebapp/src/main/webapp/crosskeygen.js</A>
</I>&gt;<i> [7] <A HREF="http://lists.apple.com/archives/apple-cdsa/2009/Apr/msg00041.html">http://lists.apple.com/archives/apple-cdsa/2009/Apr/msg00041.html</A>
</I>&gt;<i> [8] <A HREF="http://www.rsa.com/rsalabs/node.asp?id=2132">http://www.rsa.com/rsalabs/node.asp?id=2132</A>
</I>&gt;<i> [9] <A HREF="http://devedge-temp.mozilla.org/library/manuals/1998/htmlguide/tags10.html#1615503">http://devedge-temp.mozilla.org/library/manuals/1998/htmlguide/tags10.html#1615503</A>
</I>&gt;<i> [10] <A HREF="http://tools.ietf.org/html/rfc2314">http://tools.ietf.org/html/rfc2314</A>
</I>&gt;<i> 
</I>
</PRE>

















<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024774.html">[whatwg] [foaf-protocols] keygen substitute for Windows?
</A></li>
	<LI>Next message: <A HREF="024780.html">[whatwg] [foaf-protocols] keygen substitute for Windows?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24776">[ date ]</a>
              <a href="thread.html#24776">[ thread ]</a>
              <a href="subject.html#24776">[ subject ]</a>
              <a href="author.html#24776">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
