<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Forms-related feedback
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Forms-related%20feedback&In-Reply-To=%3Calpine.DEB.2.00.1312031839460.27766%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="083953.html">
   <LINK REL="Next"  HREF="083965.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Forms-related feedback</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Forms-related%20feedback&In-Reply-To=%3Calpine.DEB.2.00.1312031839460.27766%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] Forms-related feedback">ian at hixie.ch
       </A><BR>
    <I>Tue Dec  3 11:38:04 PST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="083953.html">[whatwg] OUTPUT tag: clarify purpose in spec?
</A></li>
        <LI>Next message: <A HREF="083965.html">[whatwg] Forms-related feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#41681">[ date ]</a>
              <a href="thread.html#41681">[ thread ]</a>
              <a href="subject.html#41681">[ subject ]</a>
              <a href="author.html#41681">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
On Wed, 2 Oct 2013, Jonas Sicking wrote:
&gt;<i> Hixie wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; That's not the only alternative. For example, a third alternative is 
</I>&gt;<i> &gt; that the user's selection (e.g. a directory) is returned quickly, not 
</I>&gt;<i> &gt; pre-expanded, and then any uploading happens in the background with 
</I>&gt;<i> &gt; the author script doing the walk and uploading the files.
</I>&gt;<i> 
</I>&gt;<i> It's unclear to me what you are proposing here. Can you elaborate?
</I>
On Wed, 2 Oct 2013, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> The same thing I did, I think: an API to navigate the directory tree as 
</I>&gt;<i> needed, and to never greedily recursing the directory tree.
</I>
On Wed, 2 Oct 2013, Jonas Sicking wrote:
&gt;<i> 
</I>&gt;<i> Unfortunately that's forbidden by current specs.
</I>
Right, my point is that this would be a new API.

I've filed this bug to track this feature request; if there are multiple 
implementors interested in this, I can add it:

   <A HREF="https://www.w3.org/Bugs/Public/show_bug.cgi?id=23988">https://www.w3.org/Bugs/Public/show_bug.cgi?id=23988</A>


On Wed, 2 Oct 2013, Jonas Sicking wrote:
&gt;<i> 
</I>&gt;<i> The first application that I could think of that is designed for opening 
</I>&gt;<i> or importing large number of files is iTunes. And indeed on windows 
</I>&gt;<i> where there is no native &quot;open file or directory&quot; widget, they use 
</I>&gt;<i> separate menu items for &quot;import file&quot; and &quot;import folder&quot;.
</I>
Wow, fascinating.

I guess on Windows then &lt;input type=file multiple&gt; should indeed expose 
two buttons.


&gt;<i> On OSX iTunes relies on the combined file-or-folder picker that's not 
</I>&gt;<i> available on windows.
</I>
Right, that picker is what I would have expected on all platforms.


On Wed, 2 Oct 2013, David Dailey wrote:
&gt;<i>
</I>&gt;<i> [...] ability to allow JavaScript, with user-consent, to insert an image 
</I>&gt;<i> file as the src of an &lt;img&gt; into a web page [...]
</I>&gt;<i> 
</I>&gt;<i> It all used to be easy and worked in the two relevant browsers at the 
</I>&gt;<i> time: Netscape and IE. Then someone decided it was a security risk and 
</I>&gt;<i> that it preserved the privacy of the end user more to force him or her 
</I>&gt;<i> to upload the image to the server, create a round-trip from server to 
</I>&gt;<i> client and thence to be able to view a local image in a local web page. 
</I>&gt;<i> The old functionality continued to work in Netscape until its demise, 
</I>&gt;<i> and in IE until maybe version 6. The other browsers viewed the security 
</I>&gt;<i> risk as too high and ultimately IE seems to have agreed, hence breaking 
</I>&gt;<i> previous functionality. [...]
</I>&gt;<i> 
</I>&gt;<i> Anyhow, as I recall, at the time, Hixie commented and someone else 
</I>&gt;<i> chimed in with details (that seemed rather convoluted at the time) 
</I>&gt;<i> saying that it was something people were working on. Has this effort led 
</I>&gt;<i> to fruition?
</I>
Yes, you can now read the image data without it being first uploaded to 
the server, via the HTMLInputElement.files API. You can take such a File 
and then display it in an &lt;img&gt; via the Blob API and createObjectURL.


On Wed, 2 Oct 2013, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> Assuming for now that we need separate modes for files and directories, 
</I>&gt;<i> I'd suggest &lt;input type=directory&gt;, which causes a directory picker to 
</I>&gt;<i> be shown, doesn't populate .files at all, and adds an API entry point to 
</I>&gt;<i> retrieve a filesystem.  If somebody suggests an implementable way to 
</I>&gt;<i> expose UI that doesn't need to separate files and directories then we 
</I>&gt;<i> may want something else, but that doesn't seem likely to me.
</I>
I think we want to support the Mac-style file+directory mode.


On Thu, 3 Oct 2013, Jonas Sicking wrote:
&gt;<i> 
</I>&gt;<i> I'd rather extend &lt;input type=file multiple&gt; such that platforms that 
</I>&gt;<i> have directories can expose those, and ones that don't just expose 
</I>&gt;<i> files.
</I>
Right.


&gt;<i> And on platforms that have combined file-or-directory pickers can render 
</I>&gt;<i> a single button, and platforms that use separate Widgets can render two 
</I>&gt;<i> buttons.
</I>
Right.


On Thu, 3 Oct 2013, Jan Tosovsky wrote:
&gt;<i> 
</I>&gt;<i> The missing access to the file system is a blocker now for replacing 
</I>&gt;<i> many client apps to their web counterparts. The basic question is 
</I>&gt;<i> whether web technologies should implement this functionality or not. I 
</I>&gt;<i> think it is a must, though limited to a trusted zone and OSes with file 
</I>&gt;<i> systems.
</I>&gt;<i>
</I>&gt;<i> By that trusted zone I mean a local network (local servers can access 
</I>&gt;<i> the client file system via user action) or Internet location authorized 
</I>&gt;<i> by a specific means (e.g. certificate like Java Applets).
</I>
There have been several proposals for doing this kind of thing. I think 
the main mailing list where they've been discussed most recently is 
<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">public-webapps at w3.org.</A> (In practice, there seems to be a lot of different 
things people want that all fall into the same general area, so not much 
progress has been made as far as I can tell. It's also hard to design a 
highly usable system that's also secure. You don't want a &quot;permissions&quot; 
dialog, since that's not very usable or safe, but it's hard to see how 
else you would grant a page access to a remote file system. The &lt;input 
type=file&gt; security model, which works great for reading single files, is 
not necessarily easy to extrapolate to read+write rights to filesystems.)

Anyway, I would recommend taking this up with the people already working 
on this in public-webapps.


On Tue, 15 Oct 2013, Cameron Jones wrote:
&gt;<i> On Mon, Oct 14, 2013 at 9:04 PM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; On Thu, 21 Feb 2013, Cameron Jones wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; <A HREF="http://cameronjones.github.com/form-http-extensions/index.html">http://cameronjones.github.com/form-http-extensions/index.html</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On Fri, 22 Feb 2013, Cameron Jones wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; The motivations are the same which support declarative over 
</I>&gt;<i> &gt; &gt; imperative programming, access to the HTTP protocol methods and 
</I>&gt;<i> &gt; &gt; headers (ETags, versioning), greater flexibility over payload 
</I>&gt;<i> &gt; &gt; binding and the ability to avoid using cookies for session 
</I>&gt;<i> &gt; &gt; continuation.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Can you elaborate? What are the end-user use cases that this proposal 
</I>&gt;<i> &gt; would enable, that are not possible today?
</I>&gt;<i> 
</I>&gt;<i> The direct enabler for the end-user is the ability to interact with web 
</I>&gt;<i> sites under the guarantees of HTTP method semantics without the need for 
</I>&gt;<i> them to be using a Javascript-enabled browser.
</I>
That's not really a use case, that's more a description of what it does.

What I mean is, can you illustrate an actual end-user scenario, without 
reference to the underlying technologies, that isn't possible today?

For example, a use case for &lt;input type=file&gt; would be &quot;A user wants to 
chnge their profile picture and has a file on their desktop that they 
would like to use for this&quot;. Without &lt;input type=file&gt;, this isn't really 
possible on the Web. So, the question is: what isn't possible without the 
feature proposed above?


&gt;<i> The HTTP idempotent methods (PUT, DELETE) guarantee that that multiple 
</I>&gt;<i> identical requests should have the same effect as a single request.
</I>
They don't guarantee it, in the same way that a speed limit sign doesn't 
guarantee that cars don't exceed the speed limit, or that the HTML 
comformance criteria guarantee that a &lt;p&gt; won't contain a &lt;div&gt;.


&gt;<i> This alleviates the end-user from potentially executing multiple 
</I>&gt;<i> requests either from hitting 'refresh' or the 'back button' when such 
</I>&gt;<i> requests would have unintended consequences.
</I>
Isn't this essentially a solved problem today? I mean, the same way that a 
PUT implementation can check to make sure it doesn't happen twice, a POST 
implementation can as well.


&gt;<i> The ability to set request headers (also without JS) provides a 
</I>&gt;<i> universal method for employing session continuation and request 
</I>&gt;<i> verification through the application of 'capability-based security' 
</I>&gt;<i> tokens as HTTP headers. This can be applied for GET requests without 
</I>&gt;<i> polluting URL queries.
</I>
Why is the lack of JS important here? I don't follow. Also, aren't session 
continuation and request verification solved problems by now?

I don't understand exactly how you expect to use this with capability 
tokens. Can you elaborate on this? How would the user interface work?


&gt;<i> The use of HTML declarations, as opposed to Javascript imperative 
</I>&gt;<i> statements, provides the structure of a website for static generation 
</I>&gt;<i> and analysis.
</I>
I don't understand what exactly it is you want to statically generate or 
analyse here. Can you elaborate? A concrete example of a real site cast 
into this new paradigm would help illustrate what you mean.


&gt;<i> Web crawlers, screen readers and other HTML tools will have the ability 
</I>&gt;<i> to read, validate or otherwise process the site which would otherwise be 
</I>&gt;<i> effectively impossible if required to define the structure in imperative 
</I>&gt;<i> form.
</I>
Can you give examples of sites that Web crawlers, screen readers and other 
HTML tools cannot handle today but that they could handle if this proposal 
was adopted, and how that would look?


&gt;<i> The extension specification also includes the ability to declare HTTP 
</I>&gt;<i> authentication forms, and the ability to 'logout' and clear the 
</I>&gt;<i> authentication cache. In lieu of a Javascript interface, this provides 
</I>&gt;<i> the only ability of this functionality.
</I>
Logout seems somewhat well supported today with cookie-based 
authentication, even without script.


On Fri, 18 Oct 2013, TAMURA, Kent wrote:
&gt;<i> On Tue, Sep 24, 2013 at 5:35 AM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; On Wed, 21 Aug 2013, TAMURA, Kent wrote:
</I>&gt;<i> &gt; &gt; On Sat, Jul 13, 2013 at 6:39 AM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; &gt; &gt; On Wed, 9 Jan 2013, TAMURA, Kent wrote:
</I>&gt;<i> &gt; &gt; &gt; &gt; On Wed, Nov 21, 2012 at 7:51 AM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; On Fri, 7 Sep 2012, TAMURA, Kent wrote:
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt; * For date, datetime, datetime-local, month, time, week, the 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt; attribute returns a string in a field. If a field is 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt; text-editable, it should return user-editing string like 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt; email and number.  If a field has a fixed localized 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt; date/time string chosen by a date/time picker, the attribute 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt; should return the localized string. [...]
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt; - We can enable text field selection APIs for email, number, 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; &gt; and other types
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; How would this work when the control isn't a text control? I 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; don't understand. For example, consider a date control that is 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; actually three separate text fields (year month day); how do 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; you envisage the selection API working and how would rawValue 
</I>&gt;<i> &gt; &gt; &gt; &gt; &gt; help with this?
</I>&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; I think it's ok that rawValue doesn't work with form controls 
</I>&gt;<i> &gt; &gt; &gt; &gt; without any text. One of use cases of rawValue would be to 
</I>&gt;<i> &gt; &gt; &gt; &gt; handle user input errors.  I think non-text form controls should 
</I>&gt;<i> &gt; &gt; &gt; &gt; be clever enough to avoid bad user input. For example, users 
</I>&gt;<i> &gt; &gt; &gt; &gt; can't set bad values to input[type=range].
</I>&gt;<i> &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt; I still don't understand how this would work. You suggest that it 
</I>&gt;<i> &gt; &gt; &gt; should work for type=date, but how? What happens when it's mutated 
</I>&gt;<i> &gt; &gt; &gt; by script, for instance? I really don't understand the purpose 
</I>&gt;<i> &gt; &gt; &gt; here or how it would work to achieve that purpose.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; As for type=date, rawValue should return what a user see.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; What if the user sees a calendar with a date circled? Or the string 
</I>&gt;<i> &gt; &quot;your birthday&quot;? (Exposing that would be a privacy violation.) Or what 
</I>&gt;<i> &gt; if the user doesn't see anything (because it's not a visual UA), but 
</I>&gt;<i> &gt; every time the user focuses it, the user agent plays a tune from one 
</I>&gt;<i> &gt; of Vivaldi's four seasons, followed by a trill to indicate how far 
</I>&gt;<i> &gt; into the season the date is?
</I>&gt;<i> 
</I>&gt;<i> I have no good idea for them.  However I don't think UA provides some of 
</I>&gt;<i> such UIs.
</I>
They should, though. At least the calendar UI for type=date. I think we 
should avoid doing anything that prevents user agents from making better 
UIs than we have now.


&gt;<i> The specification allows to implement any UI for form controls, but web 
</I>&gt;<i> authors won't accept UIs which are drastically different from existing 
</I>&gt;<i> implementations. For example, existing implementations of 
</I>&gt;<i> input[type=date] have about 1-line height by default. If a UA provided 
</I>&gt;<i> an inline-calendar-style implementation and it requires 300px height, 
</I>&gt;<i> web authors would have a hard time to design their pages.
</I>
Right, it would be like a &lt;select&gt;, which expands when tapped.


&gt;<i> &gt; &gt; Value set by script or not doesn't matter.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I mean, how would the user agent parse the script's new value.
</I>&gt;<i> 
</I>&gt;<i> It's implementation-specific even now, and unrelated to this proposal.
</I>
How is it implementation-specific now?

Today, there is a well-defined interface from scripts to the 
user-displayed value, regardless of how the user agent displays the value.

I think making parts of the API UA-specific would be really bad for 
interoperability.


&gt;<i> &gt; &gt; As for type=number, I heard a web author wanted to get invalid value 
</I>&gt;<i> &gt; &gt; typed by a user in order to show friendly error message without HTML 
</I>&gt;<i> &gt; &gt; interactive form validation.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The point of type=number is that the browser can do this, no need to 
</I>&gt;<i> &gt; reimplement it. (If an author does want to reimplement it, Web 
</I>&gt;<i> &gt; Components are presumably the long-term solution: reimplement the 
</I>&gt;<i> &gt; widget.)
</I>&gt;<i> 
</I>&gt;<i> I don't think Web Components becomes widely available in 10 years.
</I>
I sure hope it becomes widely available long before 2023.

But we certainly shouldn't spend effort on work arounds for the lack of 
Web Components rather than just work on Web Components. There's an 
opportunity cost here. The more we work on work-arounds, the longer it'll 
be til we have a real solution, and we desperately need a real solution 
for a lot more than just replacing built-in form validation UI.


&gt;<i> Web authors want to replace UA-builtin form validation UI now. Do you 
</I>&gt;<i> think web authors should not use new input types if they don't like 
</I>&gt;<i> builtin form validation UI?
</I>
I don't understand what behaviour you would want that you can't get today 
with the existing form validation API, that wouldn't be so drastic that 
you in fact would need a whole new widget.


&gt;<i> &gt; &gt; <A HREF="https://code.google.com/p/chromium/issues/detail?id=263910#c3">https://code.google.com/p/chromium/issues/detail?id=263910#c3</A> This 
</I>&gt;<i> &gt; &gt; is an actual case.  I talked with him, and he said &lt;datalist&gt; didn't 
</I>&gt;<i> &gt; &gt; work in his case because he wanted to show images on choices.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [...] If people want to reimplement widgets, then we should make sure 
</I>&gt;<i> &gt; Web Components can support their particular widget desires. I don't 
</I>&gt;<i> &gt; think it makes sense for us to make the default widgets be able to 
</I>&gt;<i> &gt; support every weird thing people want to do.
</I>&gt;<i> 
</I>&gt;<i> I understand such stance. However it's hard to know whether a request is 
</I>&gt;<i> weird or not.
</I>
That's a pretty weird request. I don't think it's hard to know.


&gt;<i> &gt; On Wed, 21 Aug 2013, Anne van Kesteren wrote:
</I>&gt;<i> &gt; &gt; If we start doing this (and other things you proposed) we'll 
</I>&gt;<i> &gt; &gt; constrain future implementation strategies for this control. And 
</I>&gt;<i> &gt; &gt; other implementations might be forced to follow particular 
</I>&gt;<i> &gt; &gt; conventions in order to not break sites. That doesn't seem exactly 
</I>&gt;<i> &gt; &gt; ideal.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Exactly.
</I>&gt;<i> 
</I>&gt;<i> It's too optimistic. We are already constrained.
</I>
Nowhere near as much as this would constrain us.


Brian Blakely wrote:
&gt;<i>
</I>&gt;<i> &quot;iPhone OS&quot; introduced the switch control 
</I>&gt;<i> (<A HREF="http://i.imgur.com/TA79fo2.png">http://i.imgur.com/TA79fo2.png</A>) in 2007.  Since then, there have been 
</I>&gt;<i> many attempts to recreate this on the Web Platform by hacking existing 
</I>&gt;<i> control types and using a lot of meaningless markup, to varying degrees 
</I>&gt;<i> of success.
</I>
This is just a checkbox with different styling.

We should definitely support it, though.


On Tue, 19 Nov 2013, Mikko Rantalainen wrote:
&gt;<i> 
</I>&gt;<i> I agree that the look and feel is different from checkbox but all the 
</I>&gt;<i> differences seem to be purely presentational. If you disagree, you need 
</I>&gt;<i> to elaborate a bit more.
</I>&gt;<i> 
</I>&gt;<i> I'd suggest pursuing something along the lines
</I>&gt;<i> 
</I>&gt;<i> input[type=&quot;checkbox&quot;].switch { appearance: lightswitch; }
</I>&gt;<i> 
</I>&gt;<i> instead.
</I>
Yes, this seems like the right approach.


&gt;<i> However, if you're requesting for more featured switch seen in e.g. 
</I>&gt;<i> newer Android applications where the switch has embedded text labels to 
</I>&gt;<i> declare the switch positions, there might be need for a new markup.
</I>&gt;<i> 
</I>&gt;<i> An example of such UI in ASCII graphics:
</I>&gt;<i> 
</I>&gt;<i> +----+---------------+
</I>&gt;<i> | &#176;C |========== &#176;F =| Temperature unit
</I>&gt;<i> +----+---------------+
</I>
That's basically a two-item &lt;select&gt;, no?

   select:matches(# &gt; option:first-child + option:last-child) {
     appearance: lightswitch;
   }


&gt;<i> The closest thing is allowing to allow rendering a &lt;select&gt; element with 
</I>&gt;<i> just options with a &quot;lightswitch&quot; appearance.
</I>
Yup.


On Tue, 19 Nov 2013, Jonas Sicking wrote:
&gt;<i>
</I>&gt;<i> Realistically speaking, I don't think this will help much at all. Few 
</I>&gt;<i> websites like using the default styling for form controls anyway and so 
</I>&gt;<i> people would be just as unhappy with the default switch rendering as 
</I>&gt;<i> they are with the default checkbox rendering.
</I>
Possibly.


&gt;<i> The real fix is to allow styling formcontrols. It's one of the most 
</I>&gt;<i> requested features from web developers, yet no one has taken the time to 
</I>&gt;<i> research what it would take to do it.
</I>
Isn't that what Web Components is for?


On Tue, 19 Nov 2013, Domenic Denicola wrote:
&gt;<i> 
</I>&gt;<i> Interestingly, Microsoft's Windows Store apps guidelines disagree. I 
</I>&gt;<i> find their reasoning somewhat compelling, although novel:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://msdn.microsoft.com/en-us/library/windows/apps/hh465475.aspx">http://msdn.microsoft.com/en-us/library/windows/apps/hh465475.aspx</A>
</I>&gt;<i> 
</I>&gt;<i> &quot;Use a toggle switch for binary settings when changes become effective 
</I>&gt;<i> immediately after the user changes them.&quot;
</I>&gt;<i> 
</I>&gt;<i> &quot;Use a checkbox when the user has to perform extra steps for changes to 
</I>&gt;<i> be effective.&quot;
</I>&gt;<i> 
</I>&gt;<i> These aren't exactly semantic differences, but I think they reveal 
</I>&gt;<i> different underlying semantics. Roughly, we have two controls which each 
</I>&gt;<i> have two states. But the meanings of those two states are completely 
</I>&gt;<i> different for switches vs. checkboxes; perhaps it could be boiled down 
</I>&gt;<i> to &quot;on vs. off for this thing&quot; and &quot;yes vs. no for this option.&quot;
</I>
On the Web there are checkboxes whose effects are immediate and there are 
checkboxes whose effects only engage when the form is committed; similarly 
for &lt;select&gt; and all the other controls. So on the Web I think this 
distinction is a lost cause.


On Tue, 19 Nov 2013, Michael Zajac wrote:
&gt;<i>
</I>&gt;<i> There is certainly a semantic difference between switches and 
</I>&gt;<i> checkboxes. As much of a difference as between buttons and links.
</I>
The difference between a button and a link is that a link has an address 
that you can copy and open in a diffferent browser, while a button 
triggers an action. This seems much more different than checkboxes vs 
switches vs &lt;select&gt;s.


&gt;<i> A checkbox is part of a checklist, something you use to indicate or 
</I>&gt;<i> track the states of things. You put a series of checkmarks on a form, 
</I>&gt;<i> then bring it to the reception desk.
</I>&gt;<i> 
</I>&gt;<i> A switch, like a button, is a mechanical control that actuates 
</I>&gt;<i> something. You flick a switch to turn the light on.
</I>
There's plenty of check boxes on the Web that turn lights on. I don't 
think this distinction is true on the Web.


On Tue, 19 Nov 2013, Jukka K. Korpela wrote:
&gt;<i> 
</I>&gt;<i> From the usability and accessibility point of view, this seems to 
</I>&gt;<i> address an important issue. Authors sometimes use checkboxes (or radio 
</I>&gt;<i> buttons) so that changing their state has an immediate effect, even 
</I>&gt;<i> submitting a form. This may violate normal user expectations and can be 
</I>&gt;<i> confusing. Normally, we enter some data, using various controls, and 
</I>&gt;<i> then click on a button (or do something equivalent) to request for an 
</I>&gt;<i> action. Checking a checkbox should not be a commitment, any more than 
</I>&gt;<i> typing text in a feedback form or selecting an item from a dropdown list 
</I>&gt;<i> in an order form should be a commitment.
</I>
The same applies to a switch. Toggling a switch shouldn't be irreversible 
either.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>





<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="083953.html">[whatwg] OUTPUT tag: clarify purpose in spec?
</A></li>
	<LI>Next message: <A HREF="083965.html">[whatwg] Forms-related feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#41681">[ date ]</a>
              <a href="thread.html#41681">[ thread ]</a>
              <a href="subject.html#41681">[ subject ]</a>
              <a href="author.html#41681">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
