<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Re: several messages
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Re%3A%20several%20messages&In-Reply-To=%3C4207929E.7090402%40earthlink.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="045335.html">
   <LINK REL="Next"  HREF="045348.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Re: several messages</H1>
<!--htdig_noindex-->
    <B>Matthew Raymond</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Re%3A%20several%20messages&In-Reply-To=%3C4207929E.7090402%40earthlink.net%3E"
       TITLE="[whatwg] Re: several messages">mattraymond at earthlink.net
       </A><BR>
    <I>Mon Feb  7 08:09:02 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="045335.html">[whatwg] Re: several messages
</A></li>
        <LI>Next message: <A HREF="045348.html">[whatwg] Re: several messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45346">[ date ]</a>
              <a href="thread.html#45346">[ thread ]</a>
              <a href="subject.html#45346">[ subject ]</a>
              <a href="author.html#45346">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Ian Hickson wrote:
&gt;<i> On Thu, 3 Feb 2005, Matthew Raymond wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>There's nothing in WF2 that requires a fundamental rewrite of existing 
</I>&gt;&gt;<i>HTML documents. Assuming most WF2 documents will be created from scratch 
</I>&gt;&gt;<i>is not a safe assumption.
</I>&gt;<i> 
</I>&gt;<i> If the majority of WF2 documents are existing documents, then we will have 
</I>&gt;<i> failed. It would mean that in the lifetime of the spec, more documents 
</I>&gt;<i> were created before WF2 and then upgraded to WF2, than were created after 
</I>&gt;<i> WF2. I don't think we should be designing the spec on the assumption that 
</I>&gt;<i> nobody will use it in new documents.
</I>
      That assumes significant continued growth of Internet content.
Perhaps you have figures I don't, but there would have to be some pretty
substantial growth to justify weak legacy support.

&gt;&gt;&gt;<i>There is no existing content. Authors would just do:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   &lt;idate name=&quot;date&quot;/&gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>...or some such, and be done with it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>First of all, why would they do such a thing unless they specifically 
</I>&gt;&gt;<i>didn't care about legacy browsers?
</I>&gt;<i> 
</I>&gt;<i> Why do authors not include alt=&quot;&quot; text?
</I>
    Not a fair question, considering the ratio of &lt;img&gt; elements to date
inputs. Poorly designed table-based layouts can have hundreds of images
on one page.

 &gt; Why do they not support browsers where JS is disabled?

    That's not a matter of leaving something out. That's a matter of
designing a page that requires minimal functionality. Some pages simply
can't be fully functional without Javascript. Granted, a good portion of
those pages could be made accessible with some work, but some can't. For
instance, I once saw a page where you could move a bird or the sun
around, and the shadow of the bird would change places accordingly. In
the best of circumstances, that would only be three static images on a
Javascript-disabled user agent.

 &gt; Why do they use IE extensions that don't work on non-IE browsers?

    Similar situation to Javascript. They want a specific feature, they
learn about one in IE, and they use it because most people have IE.
That's not the same as leaving support out. No legacy content in &lt;idate&gt;
is a pure decision not to include content. You're trying to confuse the
issue by citing examples that lack such purity.

 &gt; Why do they target 800x600 displays instead of being
 &gt; device-independent?

    Because it's a problem not immediately obvious at the markup level,
and because it requires significant effort and thought on the part of
the designer in some cases. Imagine trying to convert Amazon.com into a
standards compliant page that can easily be viewed on your cell phone's
browser. Does that sound as easy as &lt;input name=&quot;date1&quot;&gt;? It's not even
remotely the same level of difficulty.

 &gt; Why do they use &lt;font size=&quot;5&quot;&gt; instead of &lt;h1&gt;?

    It's probably the editor they're using (since most of the &lt;font&gt;
stuff I've seen looks like it was added by something with the IQ of a
toaster). Poorly designed editing and server software is likely the
cause of most standards conformance problems on websites.

&gt;&gt;<i>Furthermore, WF2 user agents will have little initial marketshare, so 
</I>&gt;&gt;<i>why would someone target them and leave out legacy support?
</I>&gt;<i> 
</I>&gt;<i> We have to at least plan for the eventuality of WF2 UAs not being in the 
</I>&gt;<i> minority. Designing the language on the assumption that it won't be used 
</I>&gt;<i> much seems rather defeatist (and self-fulfilling).
</I>
    But you've designed &lt;input type=&quot;date&gt; not be be used much until WF2 
becomes popular. The &lt;idate&gt; element has all the functionality of &lt;input 
type=&quot;date&quot;&gt;, and it was designed to be used in the majority of 
situations right now.

&gt;&gt;<i>Furthermore, although the markup doesn't have a built-in fallback, 
</I>&gt;&gt;<i>neither does &lt;datalist&gt; or the |data| attribute. In both situations, you 
</I>&gt;&gt;<i>can have critical content that you potentially can't use in legacy 
</I>&gt;&gt;<i>browsers.
</I>&gt;<i> 
</I>&gt;<i> &lt;datalist&gt; is never critical. It's an non-exclusive auto-complete list. 
</I>&gt;<i> Take the Google search field. Google's &quot;suggest&quot; version is the form with 
</I>&gt;<i> the &lt;datalist&gt;, Google regular is the form without. Google regular isn't 
</I>&gt;<i> missing any critical functionality.
</I>
    That doesn't explain |data|. How do you propose to keep people from
using &lt;select&gt; elements that take all their data from a file and have no
options in markup? If the &lt;select&gt; is required, what happens on submit
when the user doesn't have an option to select? How are you going to
enforce restrictions on &lt;select&gt; to prevent that even if you put them in
the WF2 spec???

&gt;&gt;<i>If they're new websites, marketshare should force most webmasters to add 
</I>&gt;&gt;<i>legacy support. Anyone remotely serious about legacy browsers is going 
</I>&gt;&gt;<i>to put it in anyway (especially since it only takes one &lt;input&gt; 
</I>&gt;&gt;<i>element).
</I>&gt;<i> 
</I>&gt;<i> And those that aren't? (Like those that don't support Lynx, Netscape, 
</I>&gt;<i> Opera, etc, today?
</I>
    I believe I answered that question in the first sentence. If most of
your visitors are going to be using legacy user agents, then anyone who
cares about the number of visitors on their site is going to include
legacy support. Those who don't care about the number of visitors
probably don't get that many visitors to begin with.

&gt;&gt;<i>Assuming that the default for an &lt;input&gt; with an unidentified |type| 
</I>&gt;&gt;<i>attribute is text, which is not specified in the HTML 4.01 spec. So, in 
</I>&gt;&gt;<i>theory, there may be browsers out there that will drop &lt;input 
</I>&gt;&gt;<i>type=&quot;date&quot;&gt; entirely, in which case there is no fallback.
</I>&gt;<i> 
</I>&gt;<i> Yes, but let's concentrate on the real world instead of the theoretical.
</I>&gt;<i> 
</I>&gt;<i> (And actually, it is defined, albeit informatively. See HTML4 B.1, third 
</I>&gt;<i> bullet point.)
</I>
|<i> * If a user agent encounters an attribute value it doesn't recognize,
</I>|<i>   it should use the default attribute value.
</I>
    Hmm. I would agree with your interpretation for the most part. I
would point out, though, that it says &quot;should&quot; and not &quot;must&quot;.

&gt;&gt;&gt;<i>Sure, the fallback isn't as ideal when the author is trying hard to 
</I>&gt;&gt;&gt;<i>provide fallback, but (as described elsewhere in this thread) I simply 
</I>&gt;&gt;&gt;<i>don't see that these particular features (date) will be interesting to 
</I>&gt;&gt;&gt;<i>authors of that caliber.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I think I can come up with a few features:
</I>[Snip!]
&gt;<i> 
</I>&gt;<i> None of these would matter to a &quot;category 1&quot; author (those who today use a 
</I>&gt;<i> simple text field, often with no format hints), which is the context in 
</I>&gt;<i> which I wrote the above comment.
</I>
    My mistake. I thought you were talking about category three. I now
realize that the &quot;caliber&quot; comment was meant in a negative way. I would
point out, once again, that if most of the tutorials use inheritance,
then most of the bottom tier webmasters will simply copy the tutorials
and include fallback.

&gt;&gt;&gt;<i>I still don't understand what is wrong with the short amount of 
</I>&gt;&gt;&gt;<i>black-box JavaScript I proposed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Another opportunity for a list!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>1) It didn't deal with default date values. Where would the script get 
</I>&gt;&gt;<i>the format string from if it wasn't in |value| attribute?
</I>&gt;<i> 
</I>&gt;<i> It could easily be adjusted, for example to take it from a title attribute 
</I>&gt;<i> or even have it hardcoded based on the type of the control.
</I>
    Which means, in Javascript disabled browsers, there would be no hint
at all, even when there's no default value.

&gt;<i> Alternatively, if you're generating the page in the first place (which 
</I>&gt;<i> you'd have to if you were going to prefill the value attribute to 
</I>&gt;<i> something) then you might as well generate different pages for HTML4 UAs 
</I>&gt;<i> as WF2 UAs. This isn't required, but is an option some authors might 
</I>&gt;<i> prefer in this context.
</I>
    How would you detect what the user agent supports? Many people 
disguise their browsers so that they can get around just such detection.

&gt;&gt;<i>2) It relied on a empty &lt;span&gt; element, which doesn't validate under 
</I>&gt;&gt;<i>HTML Strict.
</I>&gt;<i> 
</I>&gt;<i> I really have no idea where you get this from. There's nothing wrong with 
</I>&gt;<i> an empty &lt;span&gt; element.
</I>
    HTML Tidy chokes on it.

&gt;&gt;<i>3) With Javascript turned off, you have the problem of having to select 
</I>&gt;&gt;<i>and delete the format hint text in some situations.
</I>&gt;<i> 
</I>&gt;<i> This is not a big deal.
</I>
    Not if there's no hint at all, no.

&gt;&gt;<i>4) New webmasters, who don't understand how the script works, will 
</I>&gt;&gt;<i>easily break it.
</I>&gt;<i> 
</I>&gt;<i> I'm sure if they can manage 100+ line drop down menu scripts, they will be 
</I>&gt;<i> able to handle this kind of script.
</I>
    That doesn't mean the browser won't take a performance hit loading
the script on less capable machines. There are some computers I use at
work that have trouble running Firefox at a reasonable speed.

&gt;&gt;<i>5) The script takes up nearly as much space as the HTML!
</I>&gt;<i> 
</I>&gt;<i> Why is this a problem? (Especially considering we're talking about (a) an 
</I>&gt;<i> overly-designed script which could easily be simplified if it didn't have 
</I>&gt;<i> to be Jim-Ley-compliant, and (b) an overly-simply HTML page designed only 
</I>&gt;<i> to demo the script.)
</I>
    Imagine a travel web site feeding up a front page that's twice as
large as it needs to be every single time someone goes to the site.
Isn't that a roughly 2x increase in bandwidth for no reason with an
unnecessary increase in system requirements when it reaches the client?

&gt;&gt;<i>By contrast, my modified version using &lt;idate&gt; probably cut the size of 
</I>&gt;&gt;<i>the demo web page in half and supports the same features.
</I>&gt;<i> 
</I>&gt;<i> ...with a large number of problems you have not addressed.
</I>
    This comment is of no use to me or anyone else on this mailing list
unless you specify the nature of the problems you feel haven't been
addressed. It's just rhetoric.

&gt;&gt;&gt;<i>It handles more cases than your proposals with no work on the UA 
</I>&gt;&gt;&gt;<i>implementor's behalf.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Well, there's certainly not much of a case for that if you consider 
</I>&gt;&gt;<i>typing to be the work in question:
</I>&gt;&gt;<i>
</I>&gt;&gt;|<i> &lt;input type=&quot;date&quot; name=&quot;date1&quot;&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;|<i> &lt;idate&gt;&lt;input name=&quot;date1&quot;&gt;&lt;/idate&gt;
</I>&gt;<i> 
</I>&gt;<i> I said the UA implementor, not the author.
</I>
    Perhaps the question shouldn't be whether my proposal is more
complicated or has more cases than yours. Perhaps the question is
whether it's practical to implement. If it is, then the fact that your
suggestion is simpler doesn't matter in the face of its disadvantages.

&gt;&gt;<i>The best &lt;input&gt; can hope for is beating &lt;idate&gt; by three characters. If 
</I>&gt;&gt;<i>you add scripting into the picture, &lt;input type=&quot;date&quot;&gt; immediately 
</I>&gt;&gt;<i>takes longer to type.
</I>&gt;<i> 
</I>&gt;<i> Given the other problems with both proposals, the respective lengths of 
</I>&gt;<i> markup is largely irrelevant. More elements is a problem, more attributes 
</I>&gt;<i> too (although less so), but the length of tag names is irrelevant.
</I>
    It's _one_ more element, and &lt;idate&gt; has fewer attributes than
&lt;input type=&quot;date&quot;&gt;.

&gt;&gt;&gt;<i>Not to mention that many of the authors who fall into this &quot;1&quot; 
</I>&gt;&gt;&gt;<i>category simply don't provide formatting hints at all.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I want to see three URLs for examples of webmasters using textboxes for 
</I>&gt;&gt;<i>dates but not providing any kind of formatting hint anywhere on the 
</I>&gt;&gt;<i>site.
</I>&gt;<i> 
</I>&gt;<i> See:
</I>&gt;<i>    <A HREF="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2004-July/001247.html">http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2004-July/001247.html</A>
</I>&gt;<i> 
</I>&gt;<i> Most people do provide hints, but many don't.
</I>
     &quot;Many&quot; being five from that list of several dozen, and &lt;idate&gt;
doesn't prevent that kind of fallback. If anything, the list proves that
the majority of webmasters that use textboxes for input WANT format
hints. Your solution would increase all their sites by several kilobytes
to give them the same solution they already have on legacy browsers.

     (Granted, that was more than three, but that really wasn't the point
anyway. The point was to show that there weren't enough sites not using
hints in proportion to those that did to justify not having a fallback
solution for it.)

&gt;&gt;&gt;&gt;<i>nor did you explain how to handle legacy sites that use &lt;input&gt; + 
</I>&gt;&gt;&gt;&gt;<i>DHTML solutions.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>That would be category 3 below.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>What's your point? If &lt;idate&gt; easily handles category 3, then it's a 
</I>&gt;&gt;<i>more complete solution than you're offering.
</I>&gt;<i> 
</I>&gt;<i> It doesn't. For category 3, you don't need declarative fallback, because 
</I>&gt;<i> imperative fallback works fine.
</I>
       Except the script is still loaded and executed, slowing down the
browser. It also means additional requests for files to the server.

&gt;&gt;&gt;&gt;&gt;<i>    3. Complex JS widgets, for which declarative fallback is not
</I>&gt;&gt;&gt;&gt;&gt;<i>       needed.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>If they have complex JS widgets, they can implement the fallback in JS 
</I>&gt;&gt;&gt;<i>trivially. That's what I menat by &quot;_declarative_ fallback is not 
</I>&gt;&gt;&gt;<i>needed&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Javascript must be loaded and executed on all browsers unless it's 
</I>&gt;&gt;<i>content the browser recognizes as fallback. Therefore, with &lt;input 
</I>&gt;&gt;<i>type=&quot;date&quot;&gt;, a script will always have to be loaded and run regardless 
</I>&gt;&gt;<i>of whether or not the UA supports WF2. And you yourself have shot down 
</I>&gt;&gt;<i>any means of WF2 support detection.
</I>&gt;<i> 
</I>&gt;<i> Detecting whether a UA supports type=&quot;date&quot; is easy (I do so in the demo 
</I>&gt;<i> script). I don't really see what you mean here.
</I>
       You're cycling through all the &lt;input&gt; elements to find one that 
has type=&quot;date&quot;. Most of your script is involved in that very task, so 
clearly a good amount of script is loaded and executed beforehand. 
That's hardly an efficient means of detection.

&gt;&gt;<i>By contrast, &lt;idate&gt; can be used to prevent execution of a script:
</I>&gt;&gt;<i>
</I>&gt;&gt;|<i> &lt;idate name=&quot;date1&quot;&gt;
</I>&gt;&gt;|<i>  &lt;script type=&quot;text/javascript&quot; src=&quot;datepicker.js&quot;&gt;
</I>&gt;&gt;|<i> &lt;/idate&gt;
</I>&gt;<i> 
</I>&gt;<i> I hadn't realised that you meant &lt;idate&gt; to somehow affect script 
</I>&gt;<i> execution. That is definitely not happening. UA implementors have spent 
</I>&gt;<i> many an hour complaining about such required behaviour in specifications.
</I>
    Wouldn't &lt;datalist&gt; cause the exact same problem? For that matter, 
wouldn't &lt;object&gt; have the same problem? Both would involve the need for 
suppression of legacy script execution.

&gt;&gt;<i>I'm not following you. HTML 4.01 compliant legacy clients ignore 
</I>&gt;&gt;<i>unrecognized tags. WF2 clients will still be able to perform new event 
</I>&gt;&gt;<i>handling, et cetera, on &lt;idate&gt;. If &lt;idate&gt; isn't supported on a &quot;WF2&quot; 
</I>&gt;&gt;<i>client, then attributes can still be placed on the &lt;input&gt; (and, in 
</I>&gt;&gt;<i>fact, &lt;input type=&quot;date&quot;&gt; could be used in fallback, with its WF2 
</I>&gt;&gt;<i>attributes being inherited by &lt;idate&gt; on fully-compliant WF2 browsers). 
</I>&gt;&gt;<i>Can you give me a specific problem or conflict?
</I>&gt;<i> 
</I>&gt;<i> &lt;idate&gt; doesn't appear in the .elements array, so index-based dereference 
</I>&gt;<i> of .elements will be different in different UAs. Not a problem if we reuse 
</I>&gt;<i> &lt;input&gt;.
</I>
|<i> interface HTMLFormElement : HTMLElement {
</I>|<i>   readonly attribute HTMLCollection   elements;
</I>|<i>   [...]
</I>|<i> }
</I>
     Ah! Took me a while. My knowledge of DOM is still a bit limited. I
suppose it would be an issue for using multiple form controls within the
legacy content of &lt;idate&gt;, but that's going to happen in just about any
case that tries to replace a set of controls with a single date control.
Also, a simple check for &lt;idate&gt; can be written in to the script so that
it can select the correct index.

    Also, you have this exact same problem with &lt;datalist&gt;. If there's a 
&lt;select&gt; element that's a child of &lt;datalist&gt;, won't that element be 
part of the .elements collection?

&gt;<i> Support for new &lt;input&gt; attributes would be easy if all the new controls 
</I>&gt;<i> were &lt;input&gt; elements, yet will be hard if they are not.
</I>
     I presume you mean via an HTC?...

&gt;<i> Event targetting and bubbling will be different if the UA supports WF2 vs 
</I>&gt;<i> supporting &lt;idate&gt;, so scripts will have to check which is being used 
</I>&gt;<i> before registering event handlers.
</I>
     Perhaps an markup + script example is in order to show us exactly
how event targeting and bubbling cause a problem.

&gt;&gt;&gt;&gt;<i>Could you provide a use case where implementation would be an issue?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>I have no idea what you mean by this.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Can you give a specific situation where the way I've specified &lt;idate&gt; 
</I>&gt;&gt;<i>would cause a problem for implementation of &lt;idate&gt; as part of WF2?
</I>&gt;<i> 
</I>&gt;<i> &lt;idate&gt; could be _implemented_. It just would take longer.
</I>
     Then, to clarify, is this about a time table or is it a cost-benefit
analysis?

&gt;&gt;&gt;<i>See, part of the problem is that it _has_ an &quot;inheritance&quot; part. It 
</I>&gt;&gt;&gt;<i>just isn't simple.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>How so? I could write Javascript that could copy attributes for a 
</I>&gt;&gt;<i>child to a parent.
</I>&gt;<i> 
</I>&gt;<i> Attribute propagation is a bitch to get right. You have to handle all 
</I>&gt;<i> kinds of dynamic updates during DOM manipulations and so on.
</I>
     Interesting point. I'm not a browser programmer, so I'll leave this
to more qualified people to comment on.

&gt;&gt;&gt;<i>It has nothing to do with sanity. Why would any sane developer 
</I>&gt;&gt;&gt;<i>implement the CSS parser incorrectly? Why would any sane developer 
</I>&gt;&gt;&gt;<i>screw up the implementation of absolute positioning, or margin 
</I>&gt;&gt;&gt;<i>collapsing, or whatever?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I was under the impression we were providing our own HTC solution for 
</I>&gt;&gt;<i>Internet Explorer. In that case, we'd implement it correctly.
</I>&gt;<i> 
</I>&gt;<i> Just like &quot;we&quot; (as in, Opera, Mozilla, and Safari implementors) have 
</I>&gt;<i> implemented CSS and HTML and DOM &quot;correctly&quot;? You can't assume that UAs 
</I>&gt;<i> will implement everything correctly the first time, and so you can't 
</I>&gt;<i> design fallback behaviour on the principle that the UA will not screw up 
</I>&gt;<i> something, especially when that something is complicated.
</I>
     What exactly is it you expect them to screw up with regards to
fallback? The inheritance is the only issue I can see, and I only
introduced that to reduce the amount or redundant data. I could live
without it if I had to.

&gt;&gt;<i>If WF2 was to become popular enough for Microsoft to consider 
</I>&gt;&gt;<i>implementation, then breaking various sites caused by Microsoft's 
</I>&gt;&gt;<i>incorrect implementation would either result in an outcry that would 
</I>&gt;&gt;<i>force them to correct it, a major exodus from IE, or mass numbers of 
</I>&gt;&gt;<i>people refusing to upgrade their browsers to the newest IE version.
</I>&gt;<i> 
</I>&gt;<i> You have much more faith in people than I do.
</I>
      No I don't. Microsoft can't afford another poor standards
implementation on top of the ones they've already screwed up. Their
credibility is at the breaking point. They have to create a near-perfect
implementation of WF2 if they're going to support it at all, or they'll
end up looking like the monopolists they are and driving people from IE
faster.

      That said, it's entirely possible they'll create a proprietary set
of tags that steal many of our ideas, then trying to push THAT through
W3C as a standard. I'm far more afraid of that happening.

&gt;&gt;<i>It just doesn't make sense. If Microsoft wants to directly sabotage WF2, 
</I>&gt;&gt;<i>they could just implement a slightly different competing standard, and 
</I>&gt;&gt;<i>they would have to mess with the inheritance of &lt;idate&gt; at all.
</I>&gt;<i> 
</I>&gt;<i> Nobody is talking about sabotage...
</I>
      No, I suppose you're talking about outright incompetence. Even then,
it only remains so until they refuse to fix the bugs. Once they make a
choice to leave it that way, they've made a design choice.

&gt;&gt;&gt;&gt;<i>Perhaps the best solution is to leave &lt;input type=&quot;[timeunit]&quot;&gt; in 
</I>&gt;&gt;&gt;&gt;<i>the specification, add &lt;idate&gt; and it's siblings, and let the best 
</I>&gt;&gt;&gt;&gt;<i>element win in the implementation phase. Besides, there's no reason 
</I>&gt;&gt;&gt;&gt;<i>the two can't coexist, and they'd very likely share a lot of the 
</I>&gt;&gt;&gt;&gt;<i>same code.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>That's tantamount to the way UI developers who can't make their mind 
</I>&gt;&gt;&gt;<i>up throw in a pref. &quot;Let the user figure it out.&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Or perhaps it's like &lt;input type=&quot;button&gt; and &lt;button&gt;. Two similar 
</I>&gt;&gt;<i>solutions that each have their own benefits under certain conditions.
</I>&gt;<i> 
</I>&gt;<i> &lt;input type=&quot;button&quot;&gt; is a mistake, and only supported for historical 
</I>&gt;<i> reasons. There are no historical reasons when it comes to new controls.
</I>
     Curious. On browsers that don't support &lt;button&gt;, it degrades into
text. That's a worse fallback than &lt;idate&gt;, yet &lt;input type=&quot;button&quot;&gt; is
a mistake?

&gt;&gt;&gt;&gt;<i>Just thought of something. In XHTML, &lt;idate&gt; would actually take up 
</I>&gt;&gt;&gt;&gt;<i>less space than &lt;input&gt; when no legacy content is used:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;|<i> &lt;input type=&quot;date&quot; name=&quot;date1&quot;/&gt;
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;|<i> &lt;idate name=&quot;date1&quot;/&gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>The _huge_ difference here being that the former has legacy fallback, 
</I>&gt;&gt;&gt;<i>and the latter doesn't. That, for me, is a blocker.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>The problem is that the former provide next to no legacy fallback, where 
</I>&gt;&gt;<i>as the latter can provide whatever fallback you want. Ideal fallback for 
</I>&gt;&gt;<i>the least likely approach to date input is pointless. It's almost as bad 
</I>&gt;&gt;<i>as introducing a new element without the ability to provide fallback.
</I>&gt;<i> 
</I>&gt;<i> Next-to-no fallback is better than theoretically-good-yet-absent fallback.
</I>
      That's kinda like saying this one raisin is better than a
theoretical all-you-can-eat buffet. Even if sometimes the buffet has
been cleaned out, I'd still take my chances with it over the raisin.

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="045335.html">[whatwg] Re: several messages
</A></li>
	<LI>Next message: <A HREF="045348.html">[whatwg] Re: several messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45346">[ date ]</a>
              <a href="thread.html#45346">[ thread ]</a>
              <a href="subject.html#45346">[ subject ]</a>
              <a href="author.html#45346">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
