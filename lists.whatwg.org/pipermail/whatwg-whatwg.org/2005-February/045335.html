<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Re: several messages
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Re%3A%20several%20messages&In-Reply-To=%3CPine.LNX.4.61.0502031724420.26895%40dhalsim.dreamhost.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="045328.html">
   <LINK REL="Next"  HREF="045346.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Re: several messages</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Re%3A%20several%20messages&In-Reply-To=%3CPine.LNX.4.61.0502031724420.26895%40dhalsim.dreamhost.com%3E"
       TITLE="[whatwg] Re: several messages">ian at hixie.ch
       </A><BR>
    <I>Thu Feb  3 10:02:56 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="045328.html">[whatwg] Re: several messages
</A></li>
        <LI>Next message: <A HREF="045346.html">[whatwg] Re: several messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45335">[ date ]</a>
              <a href="thread.html#45335">[ thread ]</a>
              <a href="subject.html#45335">[ subject ]</a>
              <a href="author.html#45335">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Thu, 3 Feb 2005, Matthew Raymond wrote:
&gt;<i> 
</I>&gt;<i> There's nothing in WF2 that requires a fundamental rewrite of existing 
</I>&gt;<i> HTML documents. Assuming most WF2 documents will be created from scratch 
</I>&gt;<i> is not a safe assumption.
</I>
If the majority of WF2 documents are existing documents, then we will have 
failed. It would mean that in the lifetime of the spec, more documents 
were created before WF2 and then upgraded to WF2, than were created after 
WF2. I don't think we should be designing the spec on the assumption that 
nobody will use it in new documents.


&gt;<i> &gt; There is no existing content. Authors would just do:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;    &lt;idate name=&quot;date&quot;/&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ...or some such, and be done with it.
</I>&gt;<i> 
</I>&gt;<i> First of all, why would they do such a thing unless they specifically 
</I>&gt;<i> didn't care about legacy browsers?
</I>
Why do authors not include alt=&quot;&quot; text? Why do they not support browsers 
where JS is disabled? Why do they use IE extensions that don't work on 
non-IE browsers? Why do they target 800x600 displays instead of being 
device-independent? Why do they use &lt;font size=&quot;5&quot;&gt; instead of &lt;h1&gt;?


&gt;<i> Furthermore, WF2 user agents will have little initial marketshare, so 
</I>&gt;<i> why would someone target them and leave out legacy support?
</I>
We have to at least plan for the eventuality of WF2 UAs not being in the 
minority. Designing the language on the assumption that it won't be used 
much seems rather defeatist (and self-fulfilling).


&gt;<i> Furthermore, although the markup doesn't have a built-in fallback, 
</I>&gt;<i> neither does &lt;datalist&gt; or the |data| attribute. In both situations, you 
</I>&gt;<i> can have critical content that you potentially can't use in legacy 
</I>&gt;<i> browsers.
</I>
&lt;datalist&gt; is never critical. It's an non-exclusive auto-complete list. 
Take the Google search field. Google's &quot;suggest&quot; version is the form with 
the &lt;datalist&gt;, Google regular is the form without. Google regular isn't 
missing any critical functionality.


&gt;<i> If they're new websites, marketshare should force most webmasters to add 
</I>&gt;<i> legacy support. Anyone remotely serious about legacy browsers is going 
</I>&gt;<i> to put it in anyway (especially since it only takes one &lt;input&gt; 
</I>&gt;<i> element).
</I>
And those that aren't? (Like those that don't support Lynx, Netscape, 
Opera, etc, today?)


&gt;<i> &gt; &gt; The only issue here is whether or not a grandfather or soccer mom 
</I>&gt;<i> &gt; &gt; who knows virtually nothing about legacy support would put in the 
</I>&gt;<i> &gt; &gt; proper legacy content. For these individuals, you simply write a 
</I>&gt;<i> &gt; &gt; tutorial that tells them to do something like this:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; | &lt;idate&gt;&lt;input name=&quot;date&quot; value=&quot;2005-01-31&quot;&gt;&lt;/idate&gt;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; This can be explained to the user easily enough: &quot;Pretend you're 
</I>&gt;<i> &gt; &gt; going to enter the date as text, then slap &lt;idate&gt; tags around it.&quot; 
</I>&gt;<i> &gt; &gt; It's not rocket surgery.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; But it's more complicated than the current text, which works for both 
</I>&gt;<i> &gt; new and old browsers.
</I>&gt;<i> 
</I>&gt;<i> Assuming that the default for an &lt;input&gt; with an unidentified |type| 
</I>&gt;<i> attribute is text, which is not specified in the HTML 4.01 spec. So, in 
</I>&gt;<i> theory, there may be browsers out there that will drop &lt;input 
</I>&gt;<i> type=&quot;date&quot;&gt; entirely, in which case there is no fallback.
</I>
Yes, but let's concentrate on the real world instead of the theoretical.

(And actually, it is defined, albeit informatively. See HTML4 B.1, third 
bullet point.)


&gt;<i> &gt; Sure, the fallback isn't as ideal when the author is trying hard to 
</I>&gt;<i> &gt; provide fallback, but (as described elsewhere in this thread) I simply 
</I>&gt;<i> &gt; don't see that these particular features (date) will be interesting to 
</I>&gt;<i> &gt; authors of that caliber.
</I>&gt;<i> 
</I>&gt;<i> I think I can come up with a few features:
</I>&gt;<i> 
</I>&gt;<i> 1) Localization - Date is always formatted in a way the user understands.
</I>&gt;<i> 
</I>&gt;<i> 2) Stability - Webmasters don't have to worry about DHTML date controls
</I>&gt;<i> crashing on WF2 user agents.
</I>&gt;<i> 
</I>&gt;<i> 3) No Javascript - The date control will still work, even when the 
</I>&gt;<i> browser has Javascript turned off.
</I>&gt;<i> 
</I>&gt;<i> 4) Speed - A hardcoded widget will work faster than a DHTML version and 
</I>&gt;<i> require less memory on the host system.
</I>
None of these would matter to a &quot;category 1&quot; author (those who today use a 
simple text field, often with no format hints), which is the context in 
which I wrote the above comment.


&gt;<i> &gt; I still don't understand what is wrong with the short amount of 
</I>&gt;<i> &gt; black-box JavaScript I proposed.
</I>&gt;<i> 
</I>&gt;<i> Another opportunity for a list!
</I>&gt;<i> 
</I>&gt;<i> 1) It didn't deal with default date values. Where would the script get 
</I>&gt;<i> the format string from if it wasn't in |value| attribute?
</I>
It could easily be adjusted, for example to take it from a title attribute 
or even have it hardcoded based on the type of the control.

Alternatively, if you're generating the page in the first place (which 
you'd have to if you were going to prefill the value attribute to 
something) then you might as well generate different pages for HTML4 UAs 
as WF2 UAs. This isn't required, but is an option some authors might 
prefer in this context.


&gt;<i> 2) It relied on a empty &lt;span&gt; element, which doesn't validate under 
</I>&gt;<i> HTML Strict.
</I>
I really have no idea where you get this from. There's nothing wrong with 
an empty &lt;span&gt; element.


&gt;<i> 3) With Javascript turned off, you have the problem of having to select 
</I>&gt;<i> and delete the format hint text in some situations.
</I>
This is not a big deal.


&gt;<i> 4) New webmasters, who don't understand how the script works, will 
</I>&gt;<i> easily break it.
</I>
I'm sure if they can manage 100+ line drop down menu scripts, they will be 
able to handle this kind of script.


&gt;<i> 5) The script takes up nearly as much space as the HTML!
</I>
Why is this a problem? (Especially considering we're talking about (a) an 
overly-designed script which could easily be simplified if it didn't have 
to be Jim-Ley-compliant, and (b) an overly-simply HTML page designed only 
to demo the script.)


&gt;<i> By contrast, my modified version using &lt;idate&gt; probably cut the size of 
</I>&gt;<i> the demo web page in half and supports the same features.
</I>
...with a large number of problems you have not addressed.


&gt;<i> &gt; It handles more cases than your proposals with no work on the UA 
</I>&gt;<i> &gt; implementor's behalf.
</I>&gt;<i> 
</I>&gt;<i> Well, there's certainly not much of a case for that if you consider 
</I>&gt;<i> typing to be the work in question:
</I>&gt;<i> 
</I>&gt;<i> | &lt;input type=&quot;date&quot; name=&quot;date1&quot;&gt;
</I>&gt;<i> 
</I>&gt;<i> | &lt;idate&gt;&lt;input name=&quot;date1&quot;&gt;&lt;/idate&gt;
</I>
I said the UA implementor, not the author.


&gt;<i> The best &lt;input&gt; can hope for is beating &lt;idate&gt; by three characters. If 
</I>&gt;<i> you add scripting into the picture, &lt;input type=&quot;date&quot;&gt; immediately 
</I>&gt;<i> takes longer to type.
</I>
Given the other problems with both proposals, the respective lengths of 
markup is largely irrelevant. More elements is a problem, more attributes 
too (although less so), but the length of tag names is irrelevant.



&gt;<i> &gt; Not to mention that many of the authors who fall into this &quot;1&quot; 
</I>&gt;<i> &gt; category simply don't provide formatting hints at all.
</I>&gt;<i> 
</I>&gt;<i> I want to see three URLs for examples of webmasters using textboxes for 
</I>&gt;<i> dates but not providing any kind of formatting hint anywhere on the 
</I>&gt;<i> site.
</I>
See:
   <A HREF="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2004-July/001247.html">http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2004-July/001247.html</A>

Most people do provide hints, but many don't.


&gt;<i> &gt; &gt; nor did you explain how to handle legacy sites that use &lt;input&gt; + 
</I>&gt;<i> &gt; &gt; DHTML solutions.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; That would be category 3 below.
</I>&gt;<i> 
</I>&gt;<i> What's your point? If &lt;idate&gt; easily handles category 3, then it's a 
</I>&gt;<i> more complete solution than you're offering.
</I>
It doesn't. For category 3, you don't need declarative fallback, because 
imperative fallback works fine.


&gt;<i> I don't feel you've made your case. It may not be as simple in the best 
</I>&gt;<i> case scenario as &lt;input type=&quot;date&gt;, but it's still pretty darn simple. 
</I>&gt;<i> It's a lot more straight-forward in handling formatting hints than your 
</I>&gt;<i> demo script. It's a lot more effective in allowing legacy fallback.
</I>
I guess I don't feel like you've made your case either. :-)


&gt;<i> &gt; &gt; &gt;     3. Complex JS widgets, for which declarative fallback is not
</I>&gt;<i> &gt; &gt; &gt;        needed.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; If they have complex JS widgets, they can implement the fallback in JS 
</I>&gt;<i> &gt; trivially. That's what I menat by &quot;_declarative_ fallback is not 
</I>&gt;<i> &gt; needed&quot;.
</I>&gt;<i> 
</I>&gt;<i> Javascript must be loaded and executed on all browsers unless it's 
</I>&gt;<i> content the browser recognizes as fallback. Therefore, with &lt;input 
</I>&gt;<i> type=&quot;date&quot;&gt;, a script will always have to be loaded and run regardless 
</I>&gt;<i> of whether or not the UA supports WF2. And you yourself have shot down 
</I>&gt;<i> any means of WF2 support detection.
</I>
Detecting whether a UA supports type=&quot;date&quot; is easy (I do so in the demo 
script). I don't really see what you mean here.


&gt;<i> By contrast, &lt;idate&gt; can be used to prevent execution of a script:
</I>&gt;<i> 
</I>&gt;<i> | &lt;idate name=&quot;date1&quot;&gt;
</I>&gt;<i> |  &lt;script type=&quot;text/javascript&quot; src=&quot;datepicker.js&quot;&gt;
</I>&gt;<i> | &lt;/idate&gt;
</I>
I hadn't realised that you meant &lt;idate&gt; to somehow affect script 
execution. That is definitely not happening. UA implementors have spent 
many an hour complaining about such required behaviour in specifications.


&gt;<i> &gt; &gt; &gt; ...not to mention the extra complexity and the implementation 
</I>&gt;<i> &gt; &gt; &gt; difficulty compared to just using a new &quot;type&quot;.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Elements like &lt;idate&gt; are identical to &lt;input&gt; with respect to the 
</I>&gt;<i> &gt; &gt; widget they use, and they have the same attributes that &lt;input 
</I>&gt;<i> &gt; &gt; type=&quot;date&quot;&gt; would have without adding additional ones.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Yet they have a host of differences: They don't appear in the 
</I>&gt;<i> &gt; .elements array in legacy clients, they don't automatically get 
</I>&gt;<i> &gt; support for things like autofocus when UAs implement that, all kinds 
</I>&gt;<i> &gt; of event handling happens differently for legacy UAs than new UAs, etc 
</I>&gt;<i> &gt; etc etc.
</I>&gt;<i> 
</I>&gt;<i> I'm not following you. HTML 4.01 compliant legacy clients ignore 
</I>&gt;<i> unrecognized tags. WF2 clients will still be able to perform new event 
</I>&gt;<i> handling, et cetera, on &lt;idate&gt;. If &lt;idate&gt; isn't supported on a &quot;WF2&quot; 
</I>&gt;<i> client, then attributes can still be placed on the &lt;input&gt; (and, in 
</I>&gt;<i> fact, &lt;input type=&quot;date&quot;&gt; could be used in fallback, with its WF2 
</I>&gt;<i> attributes being inherited by &lt;idate&gt; on fully-compliant WF2 browsers). 
</I>&gt;<i> Can you give me a specific problem or conflict?
</I>
&lt;idate&gt; doesn't appear in the .elements array, so index-based dereference 
of .elements will be different in different UAs. Not a problem if we reuse 
&lt;input&gt;.

Support for new &lt;input&gt; attributes would be easy if all the new controls 
were &lt;input&gt; elements, yet will be hard if they are not.

Event targetting and bubbling will be different if the UA supports WF2 vs 
supporting &lt;idate&gt;, so scripts will have to check which is being used 
before registering event handlers.

And so on.


&gt;<i> &gt; &gt; Could you provide a use case where implementation would be an issue?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I have no idea what you mean by this.
</I>&gt;<i> 
</I>&gt;<i> Can you give a specific situation where the way I've specified &lt;idate&gt; 
</I>&gt;<i> would cause a problem for implementation of &lt;idate&gt; as part of WF2?
</I>
&lt;idate&gt; could be _implemented_. It just would take longer.


&gt;<i> &gt; &gt; If the user agent vendor doesn't want to implement the inheritance 
</I>&gt;<i> &gt; &gt; part of the spec
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; See, part of the problem is that it _has_ an &quot;inheritance&quot; part. It 
</I>&gt;<i> &gt; just isn't simple.
</I>&gt;<i> 
</I>&gt;<i> How so? I could write Javascript that could copy attributes for a 
</I>&gt;<i> child to a parent.
</I>
Attribute propagation is a bitch to get right. You have to handle all 
kinds of dynamic updates during DOM manipulations and so on.


&gt;<i> &gt; &gt; Now, I suppose a user agent might implement the non-inheritance 
</I>&gt;<i> &gt; &gt; version of &lt;idate&gt; without rendering the legacy content for 
</I>&gt;<i> &gt; &gt; inheriting markup, but why would any sane developer (aside from 
</I>&gt;<i> &gt; &gt; Microsoft, perhaps) do this? (I thought about an &quot;inherit&quot; attribute 
</I>&gt;<i> &gt; &gt; or something, but the only real use for this is to help user agents 
</I>&gt;<i> &gt; &gt; without inheritance support find elements that use inheritance.)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; It has nothing to do with sanity. Why would any sane developer 
</I>&gt;<i> &gt; implement the CSS parser incorrectly? Why would any sane developer 
</I>&gt;<i> &gt; screw up the implementation of absolute positioning, or margin 
</I>&gt;<i> &gt; collapsing, or whatever?
</I>&gt;<i> 
</I>&gt;<i> I was under the impression we were providing our own HTC solution for 
</I>&gt;<i> Internet Explorer. In that case, we'd implement it correctly.
</I>
Just like &quot;we&quot; (as in, Opera, Mozilla, and Safari implementors) have 
implemented CSS and HTML and DOM &quot;correctly&quot;? You can't assume that UAs 
will implement everything correctly the first time, and so you can't 
design fallback behaviour on the principle that the UA will not screw up 
something, especially when that something is complicated.


&gt;<i> If WF2 was to become popular enough for Microsoft to consider 
</I>&gt;<i> implementation, then breaking various sites caused by Microsoft's 
</I>&gt;<i> incorrect implementation would either result in an outcry that would 
</I>&gt;<i> force them to correct it, a major exodus from IE, or mass numbers of 
</I>&gt;<i> people refusing to upgrade their browsers to the newest IE version.
</I>
You have much more faith in people than I do.


&gt;<i> It just doesn't make sense. If Microsoft wants to directly sabotage WF2, 
</I>&gt;<i> they could just implement a slightly different competing standard, and 
</I>&gt;<i> they would have to mess with the inheritance of &lt;idate&gt; at all.
</I>
Nobody is talking about sabotage...


&gt;<i> &gt; &gt; Perhaps the best solution is to leave &lt;input type=&quot;[timeunit]&quot;&gt; in 
</I>&gt;<i> &gt; &gt; the specification, add &lt;idate&gt; and it's siblings, and let the best 
</I>&gt;<i> &gt; &gt; element win in the implementation phase. Besides, there's no reason 
</I>&gt;<i> &gt; &gt; the two can't coexist, and they'd very likely share a lot of the 
</I>&gt;<i> &gt; &gt; same code.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; That's tantamount to the way UI developers who can't make their mind 
</I>&gt;<i> &gt; up throw in a pref. &quot;Let the user figure it out.&quot;
</I>&gt;<i> 
</I>&gt;<i> Or perhaps it's like &lt;input type=&quot;button&gt; and &lt;button&gt;. Two similar 
</I>&gt;<i> solutions that each have their own benefits under certain conditions.
</I>
&lt;input type=&quot;button&quot;&gt; is a mistake, and only supported for historical 
reasons. There are no historical reasons when it comes to new controls.


&gt;<i> &gt; &gt; Just thought of something. In XHTML, &lt;idate&gt; would actually take up 
</I>&gt;<i> &gt; &gt; less space than &lt;input&gt; when no legacy content is used:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; | &lt;input type=&quot;date&quot; name=&quot;date1&quot;/&gt;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; | &lt;idate name=&quot;date1&quot;/&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The _huge_ difference here being that the former has legacy fallback, 
</I>&gt;<i> &gt; and the latter doesn't. That, for me, is a blocker.
</I>&gt;<i> 
</I>&gt;<i> The problem is that the former provide next to no legacy fallback, where 
</I>&gt;<i> as the latter can provide whatever fallback you want. Ideal fallback for 
</I>&gt;<i> the least likely approach to date input is pointless. It's almost as bad 
</I>&gt;<i> as introducing a new element without the ability to provide fallback.
</I>
Next-to-no fallback is better than theoretically-good-yet-absent fallback.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="045328.html">[whatwg] Re: several messages
</A></li>
	<LI>Next message: <A HREF="045346.html">[whatwg] Re: several messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45335">[ date ]</a>
              <a href="thread.html#45335">[ thread ]</a>
              <a href="subject.html#45335">[ subject ]</a>
              <a href="author.html#45335">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
