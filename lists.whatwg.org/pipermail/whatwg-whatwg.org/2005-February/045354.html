<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Re: several messages
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Re%3A%20several%20messages&In-Reply-To=%3CPine.LNX.4.61.0502071659250.24987%40dhalsim.dreamhost.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="045348.html">
   <LINK REL="Next"  HREF="045357.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Re: several messages</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Re%3A%20several%20messages&In-Reply-To=%3CPine.LNX.4.61.0502071659250.24987%40dhalsim.dreamhost.com%3E"
       TITLE="[whatwg] Re: several messages">ian at hixie.ch
       </A><BR>
    <I>Mon Feb  7 14:35:46 PST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="045348.html">[whatwg] Re: several messages
</A></li>
        <LI>Next message: <A HREF="045357.html">[whatwg] Re: several messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45354">[ date ]</a>
              <a href="thread.html#45354">[ thread ]</a>
              <a href="subject.html#45354">[ subject ]</a>
              <a href="author.html#45354">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Mon, 7 Feb 2005, Matthew Raymond wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; If the majority of WF2 documents are existing documents, then we will 
</I>&gt;<i> &gt; have failed. It would mean that in the lifetime of the spec, more 
</I>&gt;<i> &gt; documents were created before WF2 and then upgraded to WF2, than were 
</I>&gt;<i> &gt; created after WF2. I don't think we should be designing the spec on 
</I>&gt;<i> &gt; the assumption that nobody will use it in new documents.
</I>&gt;<i> 
</I>&gt;<i> That assumes significant continued growth of Internet content.
</I>
Yes; isn't this a safe assumption? The Web has only existed for fifteen 
years. I would imagine it will continue existing for many hundreds if not 
thousands of years. Obviously it's likely that at some point we will 
migrate to technologies no longer based on HTML or XHTML, but I don't see 
that happening any time soon. It would be a disaster on a global scale if 
the digital textual output of the human race in the last fifteen years was 
to outweigh digital textual output of the coming decades.


&gt;<i> &gt; &gt; &gt; There is no existing content. Authors would just do:
</I>&gt;<i> &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt;   &lt;idate name=&quot;date&quot;/&gt;
</I>&gt;<i> &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt; ...or some such, and be done with it.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; First of all, why would they do such a thing unless they 
</I>&gt;<i> &gt; &gt; specifically didn't care about legacy browsers?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Why do authors not include alt=&quot;&quot; text?
</I>&gt;<i> 
</I>&gt;<i> Not a fair question, considering the ratio of &lt;img&gt; elements to date 
</I>&gt;<i> inputs. Poorly designed table-based layouts can have hundreds of images 
</I>&gt;<i> on one page.
</I>
I don't see how that makes it an unfair question.



&gt;<i> &gt; Why do they not support browsers where JS is disabled?
</I>&gt;<i> 
</I>&gt;<i> That's not a matter of leaving something out. That's a matter of 
</I>&gt;<i> designing a page that requires minimal functionality. Some pages simply 
</I>&gt;<i> can't be fully functional without Javascript. Granted, a good portion of 
</I>&gt;<i> those pages could be made accessible with some work, but some can't. For 
</I>&gt;<i> instance, I once saw a page where you could move a bird or the sun 
</I>&gt;<i> around, and the shadow of the bird would change places accordingly. In 
</I>&gt;<i> the best of circumstances, that would only be three static images on a 
</I>&gt;<i> Javascript-disabled user agent.
</I>
Of course there are cases where JS is required. There are also many where 
it wouldn't be, for example in JS-driven site navigation scripts.


&gt;<i> &gt; Why do they use IE extensions that don't work on non-IE browsers?
</I>&gt;<i> 
</I>&gt;<i> Similar situation to Javascript. They want a specific feature, they 
</I>&gt;<i> learn about one in IE, and they use it because most people have IE. 
</I>&gt;<i> That's not the same as leaving support out. No legacy content in &lt;idate&gt; 
</I>&gt;<i> is a pure decision not to include content. You're trying to confuse the 
</I>&gt;<i> issue by citing examples that lack such purity.
</I>
I'm sorry but I have absolutely no doubt that to most authors, there is no 
difference here. It's not a matter of &quot;lacking purity&quot;, it's a matter of 
authors writing content, testing it in their browser, and assuming it 
works everywhere (which indeed it should, and that is why technologies 
aimed at being authored by everyone should IMHO be designed with automatic 
fallback).


&gt;<i> &gt; Why do they target 800x600 displays instead of being 
</I>&gt;<i> &gt; device-independent?
</I>&gt;<i> 
</I>&gt;<i> Because it's a problem not immediately obvious at the markup level,
</I>
Yes it is.

   &lt;table width=&quot;800&quot;&gt;

...is going to cause a problem. That's as obvious as you can get. It's a 
lot _more_ obvious than the fact that:

   &lt;idate/&gt;

...has a problem.


&gt;<i> &gt; Why do they use &lt;font size=&quot;5&quot;&gt; instead of &lt;h1&gt;?
</I>&gt;<i> 
</I>&gt;<i> It's probably the editor they're using (since most of the &lt;font&gt; stuff 
</I>&gt;<i> I've seen looks like it was added by something with the IQ of a 
</I>&gt;<i> toaster). Poorly designed editing and server software is likely the 
</I>&gt;<i> cause of most standards conformance problems on websites.
</I>
Whether it's the editor's fault, or the author's fault, the result is the 
same. I do not see why &lt;idate/&gt; would be exempt from these problems.

(For what it's worth, in my experience there is a huge amount of &lt;font&gt; 
markup that is written by hand. The fact that it &quot;looks like it was added 
by something with the IQ of a toaster&quot; does not imply it wasn't a human 
who did it.)


&gt;<i> &gt; &gt; Furthermore, WF2 user agents will have little initial marketshare, 
</I>&gt;<i> &gt; &gt; so why would someone target them and leave out legacy support?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; We have to at least plan for the eventuality of WF2 UAs not being in 
</I>&gt;<i> &gt; the minority. Designing the language on the assumption that it won't 
</I>&gt;<i> &gt; be used much seems rather defeatist (and self-fulfilling).
</I>&gt;<i> 
</I>&gt;<i> But you've designed &lt;input type=&quot;date&gt; not be be used much until WF2 
</I>&gt;<i> becomes popular.
</I>
No, I've designed it to not replace existing adequate solutions (three 
&lt;select&gt;s) until WF2 becomes popular. It could replace plain text inputs 
with no formatting hints straight away, and could augment JS-driven 
calendars as soon as the JS is updated. If the author is willing to use 
some boilerplate JS and follow some simple guidelines when writing the 
form, it could even replace plain text inputs with formatting hints.


&gt;<i> &gt; &gt; Furthermore, although the markup doesn't have a built-in fallback, 
</I>&gt;<i> &gt; &gt; neither does &lt;datalist&gt; or the |data| attribute. In both situations, 
</I>&gt;<i> &gt; &gt; you can have critical content that you potentially can't use in 
</I>&gt;<i> &gt; &gt; legacy browsers.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &lt;datalist&gt; is never critical. It's an non-exclusive auto-complete 
</I>&gt;<i> &gt; list. Take the Google search field. Google's &quot;suggest&quot; version is the 
</I>&gt;<i> &gt; form with the &lt;datalist&gt;, Google regular is the form without. Google 
</I>&gt;<i> &gt; regular isn't missing any critical functionality.
</I>&gt;<i> 
</I>&gt;<i> That doesn't explain |data|. How do you propose to keep people from 
</I>&gt;<i> using &lt;select&gt; elements that take all their data from a file and have no 
</I>&gt;<i> options in markup? If the &lt;select&gt; is required, what happens on submit 
</I>&gt;<i> when the user doesn't have an option to select? How are you going to 
</I>&gt;<i> enforce restrictions on &lt;select&gt; to prevent that even if you put them in 
</I>&gt;<i> the WF2 spec???
</I>
The form and select prefilling features have no fallback short of script. 
They are unfortunate exceptions to the design principle I mentioned. I did 
not see any other way to introduce those features. (replace=&quot;&quot; is another 
case, as are action=&quot;data:&quot; and action=&quot;file:&quot;, method=&quot;put&quot; and &quot;delete&quot;, 
and various other new features in WF2.)


&gt;<i> &gt; &gt; If they're new websites, marketshare should force most webmasters to 
</I>&gt;<i> &gt; &gt; add legacy support. Anyone remotely serious about legacy browsers is 
</I>&gt;<i> &gt; &gt; going to put it in anyway (especially since it only takes one 
</I>&gt;<i> &gt; &gt; &lt;input&gt; element).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; And those that aren't? (Like those that don't support Lynx, Netscape, 
</I>&gt;<i> &gt; Opera, etc, today?)
</I>&gt;<i> 
</I>&gt;<i> I believe I answered that question in the first sentence. If most of 
</I>&gt;<i> your visitors are going to be using legacy user agents, then anyone who 
</I>&gt;<i> cares about the number of visitors on their site is going to include 
</I>&gt;<i> legacy support. Those who don't care about the number of visitors 
</I>&gt;<i> probably don't get that many visitors to begin with.
</I>
CNN doesn't gcareabout Lynx users (that much is obvious from trying to 
read their site with Lynx). But the site still fundamentally works, 
because the technology is designed to be largely device- and media- 
independent, with fallback that Just Works (for example, &lt;table&gt;s fall 
back on a jumble of text, but it's still text).

So CNN is currently at least usable in Lynx, even though the authors 
clearly didn't make any effort to have it be.

With &lt;input type=&quot;date&quot;&gt;, this would continue. Today's Lynx today would be 
able to browse a site using that feature and it would work. But with 
&lt;idate/&gt;, if the author didn't specifically add in the legacy markup, 
today's lynx would instead see nothing at all.

When we have two options, both of which have problems, but one of which 
falls back poorly and the other falls back potentially not at all, it is 
IMHO almost always the case that the former is the better choice.


&gt;<i> I would point out, once again, that if most of the tutorials use 
</I>&gt;<i> inheritance, then most of the bottom tier webmasters will simply copy 
</I>&gt;<i> the tutorials and include fallback.
</I>
Tutorials often fail to provide good markup, sadly. But I agree that good 
tutorials would certainly help here.


&gt;<i> &gt; &gt; &gt; I still don't understand what is wrong with the short amount of 
</I>&gt;<i> &gt; &gt; &gt; black-box JavaScript I proposed.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Another opportunity for a list!
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 1) It didn't deal with default date values. Where would the script 
</I>&gt;<i> &gt; &gt; get the format string from if it wasn't in |value| attribute?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; It could easily be adjusted, for example to take it from a title 
</I>&gt;<i> &gt; attribute or even have it hardcoded based on the type of the control.
</I>&gt;<i> 
</I>&gt;<i> Which means, in Javascript disabled browsers, there would be no hint at 
</I>&gt;<i> all, even when there's no default value.
</I>
If it was in the title attribute it would appear as a tooltip. Also, the 
case we are talking about here is for when there is already a value in the 
control, in which case the user does have a hint, namely, the existing 
value.


&gt;<i> &gt; &gt; 2) It relied on a empty &lt;span&gt; element, which doesn't validate under 
</I>&gt;<i> &gt; &gt; HTML Strict.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I really have no idea where you get this from. There's nothing wrong 
</I>&gt;<i> &gt; with an empty &lt;span&gt; element.
</I>&gt;<i> 
</I>&gt;<i> HTML Tidy chokes on it.
</I>
I wouldn't recommend using HTML Tidy then. :-)


&gt;<i> &gt; &gt; 5) The script takes up nearly as much space as the HTML!
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Why is this a problem? (Especially considering we're talking about (a) 
</I>&gt;<i> &gt; an overly-designed script which could easily be simplified if it 
</I>&gt;<i> &gt; didn't have to be Jim-Ley-compliant, and (b) an overly-simply HTML 
</I>&gt;<i> &gt; page designed only to demo the script.)
</I>&gt;<i> 
</I>&gt;<i> Imagine a travel web site feeding up a front page that's twice as large 
</I>&gt;<i> as it needs to be every single time someone goes to the site. Isn't that 
</I>&gt;<i> a roughly 2x increase in bandwidth for no reason with an unnecessary 
</I>&gt;<i> increase in system requirements when it reaches the client?
</I>
I'm sorry but you are making up numbers here to make your argument sound 
stronger. We're talking about less than one kilobyte of content here, for 
pages that are often _hundreds_ of kilobytes long already.


&gt;<i> &gt; &gt; By contrast, my modified version using &lt;idate&gt; probably cut the size 
</I>&gt;<i> &gt; &gt; of the demo web page in half and supports the same features.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ...with a large number of problems you have not addressed.
</I>&gt;<i> 
</I>&gt;<i> This comment is of no use to me or anyone else on this mailing list 
</I>&gt;<i> unless you specify the nature of the problems you feel haven't been 
</I>&gt;<i> addressed. It's just rhetoric.
</I>
I've repeatedly given you problems that the &lt;idate&gt; proposal has, indeed 
you even replied to some of them in this very e-mail. I've listed some at 
the bottom of this e-mail for convenience.


&gt;<i> &gt; &gt; &gt; It handles more cases than your proposals with no work on the UA 
</I>&gt;<i> &gt; &gt; &gt; implementor's behalf.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Well, there's certainly not much of a case for that if you consider 
</I>&gt;<i> &gt; &gt; typing to be the work in question:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; | &lt;input type=&quot;date&quot; name=&quot;date1&quot;&gt;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; | &lt;idate&gt;&lt;input name=&quot;date1&quot;&gt;&lt;/idate&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I said the UA implementor, not the author.
</I>&gt;<i> 
</I>&gt;<i> Perhaps the question shouldn't be whether my proposal is more 
</I>&gt;<i> complicated or has more cases than yours. Perhaps the question is 
</I>&gt;<i> whether it's practical to implement. If it is, then the fact that your 
</I>&gt;<i> suggestion is simpler doesn't matter in the face of its disadvantages.
</I>
I don't follow. If the question is whether it is more practical to 
implement in UAs or not, then surely the fact that one proposal is simpler 
is of quite large importance.


&gt;<i> &gt; &gt; The best &lt;input&gt; can hope for is beating &lt;idate&gt; by three 
</I>&gt;<i> &gt; &gt; characters. If you add scripting into the picture, &lt;input 
</I>&gt;<i> &gt; &gt; type=&quot;date&quot;&gt; immediately takes longer to type.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Given the other problems with both proposals, the respective lengths 
</I>&gt;<i> &gt; of markup is largely irrelevant. More elements is a problem, more 
</I>&gt;<i> &gt; attributes too (although less so), but the length of tag names is 
</I>&gt;<i> &gt; irrelevant.
</I>&gt;<i> 
</I>&gt;<i> It's _one_ more element, and &lt;idate&gt; has fewer attributes than &lt;input 
</I>&gt;<i> type=&quot;date&quot;&gt;.
</I>
I may have lost track of the proposals you were making, but I thought 
&lt;idate&gt; potentially had many more elements, including &lt;submit/&gt;s, as well 
as multiple attributes to do with the formatting submission, etc.


&gt;<i> &gt; &gt; &gt; &gt; nor did you explain how to handle legacy sites that use &lt;input&gt; 
</I>&gt;<i> &gt; &gt; &gt; &gt; + DHTML solutions.
</I>&gt;<i> &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt; That would be category 3 below.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; What's your point? If &lt;idate&gt; easily handles category 3, then it's a 
</I>&gt;<i> &gt; &gt; more complete solution than you're offering.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; It doesn't. For category 3, you don't need declarative fallback, 
</I>&gt;<i> &gt; because imperative fallback works fine.
</I>&gt;<i> 
</I>&gt;<i> Except the script is still loaded and executed, slowing down the 
</I>&gt;<i> browser. It also means additional requests for files to the server.
</I>
We're talking about a few lines of code in an existing script. There is no 
significant cost to supporting imperative fallback here.


&gt;<i> &gt; Detecting whether a UA supports type=&quot;date&quot; is easy (I do so in the 
</I>&gt;<i> &gt; demo script). I don't really see what you mean here.
</I>&gt;<i> 
</I>&gt;<i> You're cycling through all the &lt;input&gt; elements to find one that has 
</I>&gt;<i> type=&quot;date&quot;. Most of your script is involved in that very task, so 
</I>&gt;<i> clearly a good amount of script is loaded and executed beforehand. 
</I>&gt;<i> That's hardly an efficient means of detection.
</I>
We're talking about less than 50 lines of very simple code, about half of 
which is just to handle UAs going back to NS3 or before and to provide the 
server with a timezone, something that wouldn't be necessary in most 
cases. Running this code is of negligable cost to UAs. By no means is it 
&quot;clearly a good amount&quot;. The actual algorithm consists of simply checking 
each &lt;input&gt; element in the document, a cheap process in all but the most 
obscenely complicated forms. The detection is done on a per-control basis 
to check that the UA supports that particular type of control, which is 
the most fine-grained method.


&gt;<i> &gt; I hadn't realised that you meant &lt;idate&gt; to somehow affect script 
</I>&gt;<i> &gt; execution. That is definitely not happening. UA implementors have 
</I>&gt;<i> &gt; spent many an hour complaining about such required behaviour in 
</I>&gt;<i> &gt; specifications.
</I>&gt;<i> 
</I>&gt;<i> Wouldn't &lt;datalist&gt; cause the exact same problem? For that matter, 
</I>&gt;<i> wouldn't &lt;object&gt; have the same problem? Both would involve the need for 
</I>&gt;<i> suppression of legacy script execution.
</I>
No, anything inside &lt;datalist&gt; will execute as per normal. There's nothing 
in WF2 that says that &lt;datalist&gt; contents don't execute -- in fact the 
only things that are said are that (a) the element shouldn't be displayed, 
and (b) any controls inside it must not be successful.


&gt;<i> &gt; &lt;idate&gt; doesn't appear in the .elements array, so index-based 
</I>&gt;<i> &gt; dereference of .elements will be different in different UAs. Not a 
</I>&gt;<i> &gt; problem if we reuse &lt;input&gt;.
</I>&gt;<i>
</I>&gt;<i> I suppose it would be an issue for using multiple form controls within 
</I>&gt;<i> the legacy content of &lt;idate&gt;, but that's going to happen in just about 
</I>&gt;<i> any case that tries to replace a set of controls with a single date 
</I>&gt;<i> control. Also, a simple check for &lt;idate&gt; can be written in to the 
</I>&gt;<i> script so that it can select the correct index.
</I>
It changes a script from:

   document.forms[0].elements[2].value = &quot;2005-04-02&quot;;

...to, er. *ponders*. I actually can't work out how you would handle this. 
The problem is that this (simplified markup for clarity):

   &lt;form&gt;
    &lt;input type=&quot;date&quot;/&gt;
    &lt;input type=&quot;time&quot;/&gt;
    &lt;input type=&quot;week&quot;/&gt;
   &lt;/form&gt;

...can always be addressed from script by using elements[0] to 
elements[2], whether the UA supports WF2 or not. But when you use &lt;idate&gt;, 
etc, you end up with:

   &lt;form&gt;
    &lt;idate&gt; &lt;input/&gt; &lt;/idate&gt;
    &lt;itime&gt; &lt;input/&gt; &lt;/itime&gt;
    &lt;iweek&gt; &lt;input/&gt; &lt;/iweek&gt;
   &lt;/form&gt;

...and now which index you use depends entirely on what the UA supports. 
If it supports &lt;idate&gt; only, you have to tweak elements 0, 2 and 3. If it 
supports &lt;itime&gt; only you have to tweak 0, 1, and 3. If it supports 
&lt;itime&gt; and &lt;idate&gt; but not &lt;iweek&gt; you have to tweak 0, 2, and 4. And so 
forth. It pretty much kills the use of indexes in the markup. Even using 
names you'd have to check each case to see if it was supported or not. 
Script would become significantly more complex.

(Actually, in the kind of case you're suggesting authors should use, 
namely:

   &lt;form&gt;
    &lt;idate&gt; &lt;select/&gt; &lt;select/&gt; &lt;select/&gt; &lt;/idate&gt;
    &lt;itime&gt; &lt;input/&gt; &lt;/time&gt;
    &lt;iweek&gt; &lt;select/&gt; &lt;input/&gt; &lt;/iweek&gt;
   &lt;/form&gt;

...you would end up with an even more complicated problem because the 
numbers of the controls would differ _in a different way_ based on what 
was supported -- for example, it could be 0, 4, 6 if everything in WF2 was 
supported, or it could be 1-3, 4, 6-7 if only &lt;itime&gt; was supported, etc.)


&gt;<i> Also, you have this exact same problem with &lt;datalist&gt;. If there's a 
</I>&gt;<i> &lt;select&gt; element that's a child of &lt;datalist&gt;, won't that element be 
</I>&gt;<i> part of the .elements collection?
</I>
&lt;datalist&gt; is not a control, so it doesn't appear in .elements. The 
contents of &lt;datalist&gt; always appear in .elements, so the index is the 
same whether or not the element is supported.


&gt;<i> &gt; Support for new &lt;input&gt; attributes would be easy if all the new 
</I>&gt;<i> &gt; controls were &lt;input&gt; elements, yet will be hard if they are not.
</I>&gt;<i> 
</I>&gt;<i> I presume you mean via an HTC?...
</I>
No, I mean in general. If all the controls are &lt;input&gt; elements, 
supporting autofocus=&quot;&quot; doesn't need to know anything except about 
&lt;input&gt;. As it is, it already applies to &lt;button&gt;, &lt;textarea&gt;, and 
&lt;select&gt;. Each new element increases the difficulty of implementing it, 
since the implementation then needs to know about the new control.


&gt;<i> &gt; Event targetting and bubbling will be different if the UA supports WF2 
</I>&gt;<i> &gt; vs supporting &lt;idate&gt;, so scripts will have to check which is being 
</I>&gt;<i> &gt; used before registering event handlers.
</I>&gt;<i> 
</I>&gt;<i> Perhaps an markup + script example is in order to show us exactly how 
</I>&gt;<i> event targeting and bubbling cause a problem.
</I>
Take:

   &lt;idate&gt;
    &lt;input&gt;
   &lt;/idate&gt;

If you have a WF2 UA you can do:

   document.getElementsByTagName('idate')[0].addEventListener('change', change, false)

But if you don't you must do:

   document.getElementsByTagName('input')[0].addEventListener('change', change, false)

...and in fact the former will either fail silently, or abort the script 
(depending on exactly how UAs parse unknown elements).


&gt;<i> &gt; &gt; &gt; &gt; Could you provide a use case where implementation would be an 
</I>&gt;<i> &gt; &gt; &gt; &gt; issue?
</I>&gt;<i> &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt; I have no idea what you mean by this.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Can you give a specific situation where the way I've specified 
</I>&gt;<i> &gt; &gt; &lt;idate&gt; would cause a problem for implementation of &lt;idate&gt; as part 
</I>&gt;<i> &gt; &gt; of WF2?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &lt;idate&gt; could be _implemented_. It just would take longer.
</I>&gt;<i> 
</I>&gt;<i> Then, to clarify, is this about a time table or is it a cost-benefit 
</I>&gt;<i> analysis?
</I>
Cost/benefit analysis. Implementing a slew of new elements for date 
controls would take a lot longer than implementing a set of new types, and 
the increase in cost is not outweighed by the few benefits (which are 
basically only better fallback, as far as I can tell).


&gt;<i> &gt; &gt; &gt; It has nothing to do with sanity. Why would any sane developer 
</I>&gt;<i> &gt; &gt; &gt; implement the CSS parser incorrectly? Why would any sane developer 
</I>&gt;<i> &gt; &gt; &gt; screw up the implementation of absolute positioning, or margin 
</I>&gt;<i> &gt; &gt; &gt; collapsing, or whatever?
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I was under the impression we were providing our own HTC solution 
</I>&gt;<i> &gt; &gt; for Internet Explorer. In that case, we'd implement it correctly.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Just like &quot;we&quot; (as in, Opera, Mozilla, and Safari implementors) have 
</I>&gt;<i> &gt; implemented CSS and HTML and DOM &quot;correctly&quot;? You can't assume that 
</I>&gt;<i> &gt; UAs will implement everything correctly the first time, and so you 
</I>&gt;<i> &gt; can't design fallback behaviour on the principle that the UA will not 
</I>&gt;<i> &gt; screw up something, especially when that something is complicated.
</I>&gt;<i> 
</I>&gt;<i> What exactly is it you expect them to screw up with regards to fallback? 
</I>
This argument was more relevant against the &lt;format&gt; proposal.


&gt;<i> &gt; &gt; If WF2 was to become popular enough for Microsoft to consider 
</I>&gt;<i> &gt; &gt; implementation, then breaking various sites caused by Microsoft's 
</I>&gt;<i> &gt; &gt; incorrect implementation would either result in an outcry that would 
</I>&gt;<i> &gt; &gt; force them to correct it, a major exodus from IE, or mass numbers of 
</I>&gt;<i> &gt; &gt; people refusing to upgrade their browsers to the newest IE version.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; You have much more faith in people than I do.
</I>&gt;<i> 
</I>&gt;<i> No I don't. Microsoft can't afford another poor standards implementation 
</I>&gt;<i> on top of the ones they've already screwed up. Their credibility is at 
</I>&gt;<i> the breaking point. They have to create a near-perfect implementation of 
</I>&gt;<i> WF2 if they're going to support it at all, or they'll end up looking 
</I>&gt;<i> like the monopolists they are and driving people from IE faster.
</I>
In my experience, the majority of the people don't care one iota about 
standards compliance. Even most _hand authors_ don't care much about it. 
There is a very vocal minority (of which I am a member!) who care about 
the issue, but at the end of the day, most users care more about flashy 
graphics, good advertising campaigns, slicker interfaces and less crashes 
than about standards compliance.


&gt;<i> That said, it's entirely possible they'll create a proprietary set of 
</I>&gt;<i> tags that steal many of our ideas, then trying to push THAT through W3C 
</I>&gt;<i> as a standard. I'm far more afraid of that happening.
</I>
That's already happened (except for the stealing our ideas bit). 
Microsoft's current Web strategy is based on .NET/Avalon/XAML, and they 
have already standardised many aspects of their .NET framework in much 
more prestigious standards organisations than the W3C.


&gt;<i> &gt; &gt; &gt; That's tantamount to the way UI developers who can't make their 
</I>&gt;<i> &gt; &gt; &gt; mind up throw in a pref. &quot;Let the user figure it out.&quot;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Or perhaps it's like &lt;input type=&quot;button&gt; and &lt;button&gt;. Two similar 
</I>&gt;<i> &gt; &gt; solutions that each have their own benefits under certain 
</I>&gt;<i> &gt; &gt; conditions.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &lt;input type=&quot;button&quot;&gt; is a mistake, and only supported for historical 
</I>&gt;<i> &gt; reasons. There are no historical reasons when it comes to new 
</I>&gt;<i> &gt; controls.
</I>&gt;<i> 
</I>&gt;<i> Curious. On browsers that don't support &lt;button&gt;, it degrades into text. 
</I>&gt;<i> That's a worse fallback than &lt;idate&gt;, yet &lt;input type=&quot;button&quot;&gt; is a 
</I>&gt;<i> mistake?
</I>
&lt;input type=&quot;submit&quot;&gt; is a mistake because when forms were originally 
introduced, it should have been &lt;button&gt; from the start, for i18n reasons. 
Sadly, at the time, i18n was of little concern to most people involved 
(not through malice, but because the issue simply hadn't come up).

There was no fallback problem with &lt;input type=&quot;submit&quot;&gt; though because it 
was introduced at the same time as &lt;input type=&quot;text&quot;&gt; and the latter was 
useless without the former. If &lt;button&gt; had been introduced at the same 
time, the same would apply there.

Of course, it wasn't, and had I been on the working group at the time 
&lt;button&gt; was introduced I would probably have tried to find a better 
solution. As you say, falling back on text is a poor solution at best.

I'm glad nobody suggested

   &lt;button&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/button&gt;

...though! ;-)


&gt;<i> &gt; Next-to-no fallback is better than theoretically-good-yet-absent 
</I>&gt;<i> &gt; fallback.
</I>&gt;<i> 
</I>&gt;<i> That's kinda like saying this one raisin is better than a theoretical 
</I>&gt;<i> all-you-can-eat buffet. Even if sometimes the buffet has been cleaned 
</I>&gt;<i> out, I'd still take my chances with it over the raisin.
</I>
I wouldn't. :-)


The problems with what I understand of your proposal are:

 * More complicated to implement:
    - more elements involved
    - interactions of elements and attributes that require
      dynamic updates (very bug prone)

 * More complicated to author for.
    - more elements involved
    - scripts have to be rewritten to handle the legacy content
      separately from the new content (elements array is different,
      event handling is different)

 * Fallback needs author involvement
    - easiest to simply not support legacy
    - server typically needs to handle different names for controls,
      not just different format

The drawback of the current proposal (new input types) is just that to get 
any sort of decent fallback in legacy UAs you need to use a script; 
without scripting the legacy fallback is a poor experience.

I agree that's a problem, but it's only one problem, and the solution 
doesn't suffer from the other problems I listed above. Also, that script 
could be prepackaged, and the demo script on the whatwg.org site certainly 
could be substantially improved so that using it is a lot easier and 
simpler. While the fallback is not ideal, even without JS there is still 
_some_ fallback.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="045348.html">[whatwg] Re: several messages
</A></li>
	<LI>Next message: <A HREF="045357.html">[whatwg] Re: several messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45354">[ date ]</a>
              <a href="thread.html#45354">[ thread ]</a>
              <a href="subject.html#45354">[ subject ]</a>
              <a href="author.html#45354">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
