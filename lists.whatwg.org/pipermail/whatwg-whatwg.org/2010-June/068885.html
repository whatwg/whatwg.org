<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Installable web apps
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Installable%20web%20apps&In-Reply-To=%3C676E0E73-B0F0-4D76-B45A-6EC0CF47228D%40iki.fi%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="068909.html">
   <LINK REL="Next"  HREF="068899.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Installable web apps</H1>
<!--htdig_noindex-->
    <B>Henri Sivonen</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Installable%20web%20apps&In-Reply-To=%3C676E0E73-B0F0-4D76-B45A-6EC0CF47228D%40iki.fi%3E"
       TITLE="[whatwg] Installable web apps">hsivonen at iki.fi
       </A><BR>
    <I>Fri Jun  4 04:58:33 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="068909.html">[whatwg] 'Main Part of the Content' Idiom
</A></li>
        <LI>Next message: <A HREF="068899.html">[whatwg] Installable web apps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#68885">[ date ]</a>
              <a href="thread.html#68885">[ thread ]</a>
              <a href="subject.html#68885">[ subject ]</a>
              <a href="author.html#68885">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On May 26, 2010, at 20:10, Aaron Boodman wrote:

&gt;<i> This isn't really the point of this mail, but I just want to point out
</I>&gt;<i> that there are more differences between wgt and crx than the format of
</I>&gt;<i> the manifest file. The most important is that the identify of a crx
</I>&gt;<i> file is a public key, and all crx files are self-signed by their key.
</I>&gt;<i> This makes a crx file's identity unforgeable.
</I>
.wgt supports signing, too, but as with Sun .jar or Mozilla .xpi the signing proves that the .wgt came from the entity that the private key belongs to as certified by PKI--as opposed to proving without PKI that it came from the same source as the previous version of the .wgt.

After googling around a bit, I was unable to find a signed .crx file for analysis. (I took apart 3 .crx files and gave up.) Is the signing mechanism documented somewhere? .wgt reinvents the .jar signing wheel by the basic idea of .jar signing with XML Signatures.

(Note that I am not in any way implying that PKI were better. If Google can actually get extension authors to sign their extensions on average and proving that extension updates came from the same source as the previous version, that's a pretty big win over the Firefox extension signing situation. In principle, Firefox extensions can be signed to the stronger level of proving who signed them as opposed to proving just &quot;same as before&quot;, but in practice, virtually no one--not even Mozilla Labs--signs Firefox extensions, so it doesn't help much that the level of proof would be stronger if signed.)

&gt;<i> The source of our support for packaged applications is that we have
</I>&gt;<i> gotten a lot of feedback from developers that find packages a very
</I>&gt;<i> convenient way to develop applications that work offline. I think the
</I>&gt;<i> reason is that packages are conceptually much simpler than app caches.
</I>&gt;<i> That said, I think this is mainly a lack of good tool support for app
</I>&gt;<i> cache and good documentation, and I think it can eventually be
</I>&gt;<i> overcome.
</I>
I see.

&gt;<i> For now, I would like to focus on live web apps, not packaged local apps.
</I>
Great.

&gt;&gt;<i> I think it follows that to install a Web app, you navigate to its URL and bookmark it. There is no need to have an icon in a zip file for this: HTML5 already provides &lt;link rel=icon sizes=... that the app can use to declare its icon, which can be pinned to cache upon bookmarking. So far, nothing new to design.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> A plain bookmark doesn't elevate the bookmarked app sufficiently to be special in the system app switcher (like Prism) or inside the tab system of the browser (like Firefox 4 application tabs). A plain bookmark also doesn't pre-grant any permissions or ensure that the app stays in the cache.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I think the Webby step to take from here is to introduce the concept of application bookmarks (still without zip files). To &quot;install&quot; a Web application, the user would navigate to the app's URL and create an application bookmark.
</I>&gt;<i> 
</I>&gt;<i> For Chrome this isn't the UX we want. We want users to click a link in
</I>&gt;<i> the content area and be presented with an install dialog. We think
</I>&gt;<i> that going to something in the browser to &quot;applicationify&quot; a web app
</I>&gt;<i> is too indirect and that many users will not get it.
</I>&gt;<i> 
</I>&gt;<i> That said, I think there is room to support multiple models of
</I>&gt;<i> installation (or bookmarking, or whatever you want to call it),
</I>&gt;<i> though.
</I>
Why don't you want the UX of the applicatinification process starting from browser chrome? Screen real estate reasons? Expectation or research showing that users don't understand the difference anyway?

Don't you need an annoying &quot;This site is trying to applicationify itself. Allow or Deny?&quot; piece of UI if the site can start the process?

&gt;&gt;<i> If it's still deemed useful to be able to pre-grant permissions, I think the app should, again instead of installed zip files, use &lt;link rel=something&gt; to point to a manifest that shows what the apps wishes to be pre-granted. When the features to be granted have obvious JavaScript entry points from the window object (e.g. navigator.geolocation), the JavaScript names of those entry points should be used to identify the features in the manifest in order to avoid having to standardize separate permission names.
</I>&gt;<i> 
</I>&gt;<i> We have a growing set of metadata you're trying to &lt;link&gt; to:
</I>&gt;<i> 
</I>&gt;<i> - Icons
</I>
Mobile Safari and, AFAIK, the default Android browser already use use &lt;link rel=apple-touch-icon&gt; for this, so it seems to me the &lt;link&gt; cat is already out of the bag.

&gt;<i> - Application name (you didn't mention this, but I think it is nice to
</I>&gt;<i> have distinct from the &lt;title&gt;, which is often overloaded with status
</I>&gt;<i> information)
</I>
As Lachy mentioned, there's already in-document syntax for this:
<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#meta-application-name">http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#meta-application-name</A>

I'm not aware of anyone implementing it, though.

&gt;<i> Another one that we would like in Chrome is a path prefix for the app.
</I>&gt;<i> This is to handle the case of applications like Google Reader which
</I>&gt;<i> are on <A HREF="http://www.google.com/reader.">http://www.google.com/reader.</A>
</I>
How does giving permissions to a prefixed application interact with the origin-based security model?

&gt;<i> Every URL in an application will have to &lt;link&gt; to this same
</I>&gt;<i> information. It seems like it would be better to just &lt;link&gt; to a
</I>&gt;<i> separate resource that contains the information.
</I>&gt;<i> 
</I>&gt;<i> To me, this all leads to the following proposal:
</I>&gt;<i> 
</I>&gt;<i> &lt;html&gt;
</I>&gt;<i> &lt;head&gt;
</I>&gt;<i> &lt;!-- for UAs that want a button in the browser chrome to appify --&gt;
</I>&gt;<i> &lt;link rel=&quot;application-description&quot; href=&quot;myapp.json&quot;&gt;
</I>&gt;<i> &lt;/head&gt;
</I>&gt;<i> &lt;body&gt;
</I>&gt;<i> &lt;!-- for UAs that want a button in the Chrome to appify --&gt;
</I>&gt;<i> &lt;button onclick=&quot;navigator.installApplication()&quot;&gt;install&lt;/button&gt;
</I>&gt;<i> &lt;/body&gt;
</I>&gt;<i> &lt;/html&gt;
</I>&gt;<i> 
</I>&gt;<i> // myapp.json
</I>&gt;<i> {
</I>&gt;<i>  &quot;name&quot;: &quot;My Application&quot;,
</I>&gt;<i>  &quot;icons&quot;: ...,
</I>&gt;<i>  &quot;urls&quot;: [
</I>&gt;<i>    &quot;reader/&quot;
</I>&gt;<i>  ],
</I>&gt;<i>  &quot;permissions&quot;: [
</I>&gt;<i>    ...
</I>&gt;<i>  ]
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> WDYT?
</I>
Makes sense to me (if you add sniffing for navigator.installApplication before showing a button that calls it), although I doubt you'll be able to avoid repeating a &lt;link&gt; to the icon anyway.

-- 
Henri Sivonen
<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">hsivonen at iki.fi</A>
<A HREF="http://hsivonen.iki.fi/">http://hsivonen.iki.fi/</A>



</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="068909.html">[whatwg] 'Main Part of the Content' Idiom
</A></li>
	<LI>Next message: <A HREF="068899.html">[whatwg] Installable web apps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#68885">[ date ]</a>
              <a href="thread.html#68885">[ thread ]</a>
              <a href="subject.html#68885">[ subject ]</a>
              <a href="author.html#68885">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
