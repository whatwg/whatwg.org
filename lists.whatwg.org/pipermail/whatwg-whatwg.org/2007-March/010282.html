<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] &lt;video&gt; element feedback
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%3Cvideo%3E%20element%20feedback&In-Reply-To=%3CPine.LNX.4.62.0703192322260.18081%40dhalsim.dreamhost.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010279.html">
   <LINK REL="Next"  HREF="010283.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] &lt;video&gt; element feedback</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%3Cvideo%3E%20element%20feedback&In-Reply-To=%3CPine.LNX.4.62.0703192322260.18081%40dhalsim.dreamhost.com%3E"
       TITLE="[whatwg] &lt;video&gt; element feedback">ian at hixie.ch
       </A><BR>
    <I>Tue Mar 20 02:25:25 PDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="010279.html">[whatwg] Comments on the &lt;video&gt; element
</A></li>
        <LI>Next message: <A HREF="010283.html">[whatwg] &lt;video&gt; element feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10282">[ date ]</a>
              <a href="thread.html#10282">[ thread ]</a>
              <a href="subject.html#10282">[ subject ]</a>
              <a href="author.html#10282">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
Thanks for all the feedback on &lt;video&gt;. There were several topics 
discussed. I'll cover the three most important ones first.

ON THE CODEC:

A number of people put forth many arguments for and against all kinds of 
codecs. However, very little of the feedback introduced any information 
that wasn't taken into account when I first drafted the proposal.

The spec can't require MPEG4 or other proprietary or patent-encumbered 
formats or suites of formats, because of the patent situation. Unless 
someone is willing to do the work and pay for licenses, or get MPEG-LA 
and/or similar groups to waive their rights for implementations of this 
spec, we can't require them, as it would require certain implementors to 
either expose themselves to known legal risks, or be non-conformant. This 
doesn't stop anyone from implementing such formats if they so desire, of 
course.

The spec doesn't require Dirac or any of the other freely implementable 
codecs and container formats other than Ogg, because requiring more than 
one would reduce the likelihood of any being implemented, and of those 
available, the Ogg family is more widely recognised and is arguably more 
mature.

The spec doesn't prohibit any codec from being implemented, because doing 
so would be an exercise in futility -- specifications are supposed to 
foster interoperability, not block innovation. After all, it is from 
extensions to specs that most of the HTML5 features were derived.



ON NATIVE UI:

A large portion of the feedback concerned the way that the current spec 
doesn't have any features for native browser-provided UI.

I completely agree that on the long term this is something we need to 
offer. However, we musn't bite off more than we can chew. There are 
several sets of use cases, some of which require browser-provided UI, and 
some of which need just video playback under the control of the author. If 
we want to have this implemented well, we need to focus the browser 
vendors' concentration on specific features. Since it is easier to 
implement first an API then a native UI, rather than first a native UI and 
then an API, the API has to come first. Similarly, because authors can 
make a UI with an API but can't sanely make an API with a native UI, 
providing an API provides authors with more options.

If LiveJournal on YouTube or some other site wanted to allow authors to 
embed video without requiring the authors to have to deal with JavaScript, 
they could create a page that contained just the video and video playback 
UI, with the video URI being taken out of the query parameters of the 
page, and then could give people markup that embedded the video using an 
&lt;iframe&gt;, as in:

   &lt;iframe src=&quot;<A HREF="http://video.example.com/video.html?src=http://example.net/v193&quot;">http://video.example.com/video.html?src=http://example.net/v193&quot;</A>&gt;&lt;/iframe&gt;

This would be a safe mechanism, and would be relatively easy to set up. 
(It doesn't even require server-side support.)



ON HANDLING OTHER MEDIA FORMATS:

A lot of feedback concerned the necessity of introducing an element 
specifically for &lt;video&gt; in the first place.

We could use &lt;object&gt; for this, adding multiple APIs to &lt;object&gt; for each 
kind of media file, defining the semantics for changing from one to the 
other, for content-negotiation, for disambiguating similar media types 
that have overlapping but not identical APIs, and so forth.

However, the browser vendors would hate us. Browser vendors have 
repeatedly and loudly stated that overloading elements leads to 
implementation difficulties, resulting in poor interoperability, edge 
cases with strange behaviour, security bugs, and the works. Good examples 
of this in existing HTML browsers are &lt;object&gt; and &lt;input&gt;, both of which 
have had huge interoperability problems over the years, and both of which 
still have big issues. When it takes more than 10 years to get an element 
implemented well in every single browser that has tried to implement it, 
you have to look at why that is, and you have to learn from the mistake. 
In this case, the mistake is adding too much functionality to one element.

Similarly, for backwards-compatibility reasons, adding anything to 
&lt;object&gt; is a nightmare. We'd have to carefully examine every addition to 
make sure it didn't clash with existing content, for instance.

Furthermore, overloading an element with various APIs results in 
difficulties for authors. An author dealing with audio doesn't want to 
think about aspect ratios, and an author dealing with video doesn't want 
to think about plugin parameters.

This doesn't mean we have to specify everything as its own element. There 
are media types that it doesn't make sense to support with a specific 
element (at least not yet); we don't want to have six dozen elements with 
each type having its own set of features (and bugs). We _do_ have a 
generic element, &lt;object&gt;, which does work for generic inclusion. It 
doesn't support media-specific features (like the Video API) but it works 
as a stop-gap until the media in question is important enough to deserve 
special treatment, if that happens.



On Thu, 15 Mar 2007, Bjoern Hoehrmann wrote:
&gt;<i> 
</I>&gt;<i> In case of video, there is no need to implement anything using style 
</I>&gt;<i> sheets, behaviors, or scripting, you can use it directly, right now, 
</I>&gt;<i> it's easy as pie,
</I>&gt;<i> 
</I>&gt;<i>   &lt;html xmlns:t=&quot;urn:schemas-microsoft-com:time&quot;&gt;
</I>&gt;<i>   &lt;?import namespace=&quot;t&quot; implementation=&quot;#default#time2&quot;&gt;
</I>&gt;<i>   &lt;body&gt;
</I>&gt;<i>     &lt;t:video src='example.video'&gt;&lt;/t:video&gt;
</I>&gt;<i>   &lt;/body&gt;
</I>
There are, unfortunately, a number of problems with doing this. The API is 
horrendously complicated. I have spoken to authors, as well as people who 
used to work on IE, who express nothing but muted horror when I ask about 
the HTML+TIME stuff (or SMIL). The HTML+TIME features have seen virtually 
no uptake with authors, despite having nearly the same market penetration 
as Flash for several years; even now, after more than 7 years of this 
feature being available, there are virtually no sites using &lt;t:video&gt; 
outside of tutorials or copies of MSDN.


&gt;<i> and based on an open W3C standard. No need for separate languages at 
</I>&gt;<i> all. It's not perfect, but the terrible design of XMLHttpRequest, 
</I>&gt;<i> &lt;canvas&gt;, and other features also did not prevent their inclusion in 
</I>&gt;<i> &quot;Web Applications 1.0&quot;.
</I>
(Could you elaborate on the problems you see in the &lt;canvas&gt; API? Also, 
note that XMLHttpRequest is now a W3C spec, not a WHATWG feature.)


&gt;<i> Don't you think the differences between the &lt;video&gt; features in IE5+, 
</I>&gt;<i> SMIL, SVG, and HTML should be minimized, and using them in IE be made as 
</I>&gt;<i> easy as technically feasible?
</I>
I don't see that attempting to get compatibility with SMIL is a good 
thing. Indeed, I think evidence suggests that we should avoid making the 
mistakes SMIL made, if we want to address author needs successfully.



On Sat, 17 Mar 2007, H&#229;kon Wium Lie wrote:
&gt;<i>
</I>&gt;<i> Also sprach Bjoern Hoehrmann [corrected by Ian Hickson]:
</I>&gt;<i> 
</I>&gt;<i>  &gt;   +----------------+-----------------+-----------------+---------------+
</I>&gt;<i>  &gt;   | SMIL           | SVG             | IE              | &quot;WHATWG&quot;      |
</I>&gt;<i>  &gt;   +----------------+-----------------+-----------------+---------------+
</I>&gt;<i>  &gt;     beginElement() | beginElement()  | beginElement()  | play()
</I>&gt;<i>  &gt;     endElement()   | endElement()    | endElement()    | stop()
</I>&gt;<i>  &gt;     -              | pauseElement()  | pauseElement()  | pause()
</I>&gt;<i>  &gt;     -              | resumeElement() | resumeElement() | play()
</I>&gt;<i>  &gt;     -              | isPaused        | isPaused        | state == PAUSED
</I>&gt;<i>  &gt;    ...
</I>&gt;<i> 
</I>&gt;<i> I personallay think play, stop and pause are better names.
</I>
Agreed.



On Sat, 17 Mar 2007, Bjoern Hoehrmann wrote:
&gt;<i> 
</I>&gt;<i> Do you really think using two different methods to trigger playback of 
</I>&gt;<i> svg:video and xhtml:video elements is better than using a single method?
</I>
Given authors' opinions of SMIL features, yes, avoiding using the SMIL 
APIs would be a good thing. It is not yet clear that SVG video playback is 
an especially important feature on the Web; it is possible that HTML video 
playback will be more important and SVG video playback may simply want to 
be abandoned or restricted to certain specialty markets.


&gt;<i>   &lt;t:video id='video'
</I>&gt;<i>            begin='play.click'
</I>&gt;<i>            end='stop.click'
</I>&gt;<i>            src='example.video'&gt;
</I>&gt;<i> 
</I>&gt;<i>     &lt;t:transitionFilter begin=&quot;video.begin&quot;
</I>&gt;<i>                         type='barnDoorWipe'
</I>&gt;<i>                         dur=&quot;5&quot; /&gt;
</I>&gt;<i> 
</I>&gt;<i>   &lt;/t:video&gt;
</I>&gt;<i>   &lt;p&gt;&lt;input type='button' value='Play!' id='play' /&gt;
</I>&gt;<i>      &lt;input type='button' value='Stop!' id='stop' /&gt;
</I>
This is a highly contrived use case -- most uses of video on the Web today 
do not come close to this level of complexity, and optimising for this 
kind of complexity is likely to result in the feature lacking adoption.


&gt;<i> Here the playback of the video begins when the play control is clicked, 
</I>&gt;<i> and the barnDoorWipe transition effect on the video will begin in turn 
</I>&gt;<i> when playback of the video begins. The begin attribute is quite flex- 
</I>&gt;<i> ible, I might change the example so playback of the video begins auto- 
</I>&gt;<i> matically 2 seconds after the document began:
</I>&gt;<i> 
</I>&gt;<i>   &lt;t:video id='video'
</I>&gt;<i>            begin='2s; play.click'
</I>&gt;<i>            end='stop.click'
</I>&gt;<i>            src='example.video'&gt;
</I>&gt;<i> 
</I>&gt;<i> or I might just drop the controls and just let it begin at 2s:
</I>&gt;<i> 
</I>&gt;<i>   &lt;t:video begin='2s' src='example.video' /&gt;
</I>&gt;<i> 
</I>&gt;<i> You said 'play' might be a better name, so let's just use that for a 
</I>&gt;<i> moment:
</I>&gt;<i> 
</I>&gt;<i>   &lt;t:video play='2s' src='example.video' /&gt;
</I>&gt;<i> 
</I>&gt;<i> That does not look so much better to me, I would think this plays for
</I>&gt;<i> two seconds, not to start playing after two seconds have elapsed.
</I>
I believe the argument was that play() is a better method name than 
beginElement(), not that the attribute for timeline alignment should be 
called play. Indeed, I would argue that we shouldn't have any features for 
timeline alignment. We already have technologies for that kind of thing -- 
such as SVG (using SMIL) -- and this is not what &lt;video&gt; is trying to 
address. Compatibility for compatibility's sake is pointless; features 
should be designed for the use cases they are trying to address and not to 
fit some theoretical uniform model.

With &lt;video&gt; we are trying to reduce the need for proprietary technologies 
(typically Flash) to be used for playback of video content, e.g. so that 
sites like YouTube, Vimeo, or Metacafe can transition from a Flash-based 
closed system to a more open system not dependent on a single vendor.


&gt;<i> I also would not consider a transition effect as I've used it above to 
</I>&gt;<i> &quot;play&quot;, and animation effects also don't really &quot;play&quot; for me.
</I>
I agree, but I wouldn't really consider transition effects to be in scope 
here.


&gt;<i> I do think that common timing control attributes and APIs are a good 
</I>&gt;<i> thing,
</I>
They're a good thing when you're designing an animation format like SVG 
arguably is, but that's not in scope here.


&gt;<i> It just plays the video back, where the video is positioned and scaled 
</I>&gt;<i> as the typical media player would do (it's scaled to fit the browser 
</I>&gt;<i> window while preserving the aspect ratio, and centered in the space left 
</I>&gt;<i> to fill). I would have given the &quot;HTML5&quot; equivalent but I could not 
</I>&gt;<i> think of a simple solution for this. It would probably be some- thing 
</I>&gt;<i> like [...]
</I>
Aspect ratio is automatically preserved. A page that displayed a video in 
the full frame (on visual UAs) with playback starting on load would look 
like:

   &lt;!DOCTYPE HTML&gt;
   &lt;title&gt;Example Video&lt;/title&gt;
   &lt;style&gt;
     video { position: absolute; top: 0; right: 0; bottom: 0; left: 0; }
   &lt;/style&gt;
   &lt;p&gt;&lt;video src=&quot;example.video&quot;&gt;Your browser does not support video.&lt;/video&gt;
   &lt;script&gt;
     document.getElementsByTagName('video')[0].play();
   &lt;/script&gt;

...although of course this supports things that the WPF example you gave 
would not (like having a title for bookmarking, like supporting user 
overrides of styles, and so forth).



On Sat, 17 Mar 2007, Kornel Lesinski wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt;   +----------------------------------+---------------------------------+
</I>&gt;<i> &gt;   | Flash/ActionScript               | &quot;WHATWG&quot;                        |
</I>&gt;<i> &gt;   +----------------------------------+---------------------------------+
</I>&gt;<i> &gt;     pause()                          | togglePause()
</I>&gt;<i> &gt;     pause(true)                      | pause()
</I>&gt;<i> &gt;     pause(false)                     | play()
</I>&gt;<i> &gt;     seek(s)                          | seek(1000 * s)
</I>&gt;<i> &gt;     time                             | position / 1000
</I>&gt;<i> 
</I>&gt;<i> This however is a good point - since Flash became de-facto standard for 
</I>&gt;<i> publishing video on the web, authors are likely to know Flash's API 
</I>&gt;<i> already. Having similar, but not exactly the same API may be source of 
</I>&gt;<i> mistakes.
</I>
I agree, in principle. All the differences are intentional, though; I 
studied the Flash API before writing this spec.

Specifically:

     pause()                          | togglePause()
     pause(true)                      | pause()
     pause(false)                     | play()

I try to avoid overloading methods, because when I overload them, I get 
told off by browser vendors and people trying to implement the APIs in 
languages that don't have overloading.

We just have pause(true) and pause(false), but then pause(false) is 
equivalent to play() anyway, so that pause(false) is redundant. So it 
makes more sense just to have pause(true) be written as pause(). But then 
we don't have pause() left for the toggling feature, which we presumably 
want to include since Flash found a need for it, so we need a new name for 
that. And that's how we end up with the three names in the spec.


     seek(s)                          | seek(1000 * s)
     time                             | position / 1000

I agree that it would be nice to do what Flash does, but the cost of using 
floats for this is high. Using integers doesn't reduce our range, and 
increases our precision within that range relative to floats. 
Unfortunately if we use integers we can't use seconds, hence the 
difference between Flash and this API.



On Sat, 17 Mar 2007, Keryx Web wrote:
&gt;<i> 
</I>&gt;<i> 1. That videos should never start to play without my consent. No more 
</I>&gt;<i> bgsound-hellish experiences. Advertisers will protest, but I'd say it is 
</I>&gt;<i> up to them to make their commercials so appealing that I'd want to play 
</I>&gt;<i> the video in question.
</I>
The spec already allows this.


&gt;<i> 1b. If not (1) That video does not play automatically in a window/tab 
</I>&gt;<i> that does not sit in the foreground. I tend to scroll wheel click on 
</I>&gt;<i> links a lot. if there is video content on the page that has just opened 
</I>&gt;<i> behind the one I am currently in and I would like to watch it, I'd 
</I>&gt;<i> definitely prefer to start it when I flip tabs.
</I>
The spec already allows for this too.


&gt;<i> 2. I would like greater control than just start, stop, pause, forward, back
</I>&gt;<i> and perhaps moving a slider. Looking at this:
</I>&gt;<i> <A HREF="http://video.yahoo.com/video/play?vid=cccd4aa02a3993ab06e56af731346f78.2006940">http://video.yahoo.com/video/play?vid=cccd4aa02a3993ab06e56af731346f78.2006940</A>
</I>&gt;<i> 
</I>&gt;<i> Would it not be great if I could *navigate* to different parts of the 
</I>&gt;<i> video according to some headlines:
</I>&gt;<i> 
</I>&gt;<i> - Douglas C: opening
</I>&gt;<i> - Chris Wilson on...
</I>&gt;<i> - Chris Wilson on...
</I>&gt;<i> ...
</I>&gt;<i> - H&#195;&#165;kon Wium Lie on ACID 2
</I>&gt;<i> - H&#195;&#165;kon Wium Lie on the proposed &lt;video&gt; element
</I>&gt;<i> Etc
</I>
The current API would allow sites to implement this. (That's one reason to 
start with an API and not a browser-provided UI.)


&gt;<i> Perhaps some sort of &quot;goto&quot; function with associated labels?
</I>
Well, the API can't really implement this directly since it would require 
support from the video itself. But nothing stops a site from including 
out-of-band metadata for this kind of thing.



On Mon, 19 Mar 2007, Simon Pieters wrote:
&gt;<i> 
</I>&gt;<i> Therefore (to ease authoring and thus help adoption) I would like to 
</I>&gt;<i> propose a new boolean attribute for &lt;video&gt;: autoplay=&quot;autoplay&quot;. It's 
</I>&gt;<i> presence would be equivalent to invocing play() on the video ASAP. 
</I>
I agree that this would be good, but I think we should wait for browsers 
to implement what we have so far before adding more features. :-)

I've added it to the v2 list.



On Mon, 19 Mar 2007, Maik Merten wrote:
&gt;<i>
</I>&gt;<i> This also sorta tangents the question if UAs should provide a default UI 
</I>&gt;<i> that does not depend on JavaScript being enabled to fire the control 
</I>&gt;<i> events. If there's no autostart feature and the user has disabled 
</I>&gt;<i> JavaScript then there's no way to access the video content if I 
</I>&gt;<i> understand the current draft correctly (correct me if I am wrong).
</I>
Browsers are allowed to provide UI (e.g. in context menus), just not UIs 
that show up inline, according to the current spec.



On Fri, 16 Mar 2007, Gareth Hay wrote:
&gt;<i>
</I>&gt;<i> This topic is worrying me slightly, as I can only see two possible outcomes :-
</I>&gt;<i> 
</I>&gt;<i> using &lt;object&gt; for everything,
</I>&gt;<i> 	images  &lt;object type=&quot;image/jpeg&quot; data=&quot;some.jpg&quot;&gt;
</I>&gt;<i> 	video     &lt;object type=&quot;application/ogg&quot; data=&quot;video.ogg&quot;&gt;
</I>&gt;<i> 
</I>&gt;<i> or defining separate tags for all possible content :-
</I>&gt;<i> 
</I>&gt;<i> &lt;image&gt;
</I>&gt;<i> &lt;video&gt;
</I>&gt;<i> &lt;sound&gt;
</I>&gt;<i> &lt;etc...&gt;
</I>&gt;<i>
</I>&gt;<i> As I can't see how it can be a mix and match of the two approaches.
</I>
Why not? A mix and match is exactly what we have today, and it works 
pretty well, considering.



On Fri, 16 Mar 2007, Gareth Hay wrote:
&gt;<i>
</I>&gt;<i> Ok, I could understand that approach, with things like &lt;img&gt;&lt;video&gt; 
</I>&gt;<i> handled internally. Is there then a case for doing &lt;object&gt; properly by 
</I>&gt;<i> specifying a replacement, something like &lt;plugin&gt; / &lt;extern&gt;?
</I>
&lt;embed&gt; is in HTML5 specifically for plugins.

However, for &lt;embed&gt;, &lt;object&gt;, &lt;iframe&gt;, and &lt;video&gt;, the spec doesn't 
require that UAs implement the features using plugins or using native 
code. For example, Mozilla natively supports SVG in &lt;embed&gt; (it doesn't 
require a plugin). Similarly, you could see &lt;video&gt; be implemented as a 
special-case plugin. That's an implementation detail and doesn't really 
affect the spec.



On Sat, 17 Mar 2007, Benjamin Hawkes-Lewis wrote:
&gt;<i> 
</I>&gt;<i> Should we have attributes to indicate whether &lt;video&gt; content has 
</I>&gt;<i> subtitles, captions, audio descriptions, and transcriptions embedded, so 
</I>&gt;<i> that videos are only downloaded and played if they are in fact going to 
</I>&gt;<i> be accessible to the user? Or to flag content that is NSFW, so UAs can 
</I>&gt;<i> be configured to not play it? Or to point to higher quality but higher 
</I>&gt;<i> bandwidth alternatives? Or maybe to indicate licencing, so that 
</I>&gt;<i> authoring tools could throw up a warning if one tried to mix up or 
</I>&gt;<i> deeplink to content with a restrictive licence. (I don't actually think 
</I>&gt;<i> authoring tools should prevent one doing so, because authoring tools 
</I>&gt;<i> aren't lawyers.) All of this is stuff one might very much wish to know 
</I>&gt;<i> /before/ downloading the video. Particularly on the accessibility front, 
</I>&gt;<i> when users with disabilities go through the palaver of downloading and 
</I>&gt;<i> opening content which could be made accessible, but hasn't been, it 
</I>&gt;<i> damages their faith in the relevant technology.
</I>
I don't think such metadata attributes would help. They would just be 
ignored by most authors and incorrectly set by many others.



On Sat, 17 Mar 2007, Marcos Caceres wrote:
&gt;<i> 
</I>&gt;<i> I also think &lt;video&gt; is a great idea, however I would like to see the 
</I>&gt;<i> ability to change the playback speed of the movie through the API (eg. 
</I>&gt;<i> x0.5, x1.5, x2, etc). I think there is a strong use case for usability 
</I>&gt;<i> in being able to change the playback rate.
</I>
I agree. However, in the interests of not overloading browser vendors on 
the first try, I'd rather keep this for a future version. I have it in the 
list of &quot;v2&quot; features in the spec as a comment.



On Sat, 17 Mar 2007, Matthew Ratzloff wrote:
&gt;<i> 
</I>&gt;<i> I thought the comments raised some valid points.  Do Flash videos use the
</I>&gt;<i> &lt;video&gt; element or the &lt;object&gt; element?
</I>
&lt;object&gt; (or &lt;embed&gt;), because they are really applications, not videos.


&gt;<i> Is there going to be an &lt;audio&gt; element as well?
</I>
This is something we could consider, yes, if a good set of use cases was 
provided for it, and if there was clear widespread use of audio on the 
Web the same way there is for video.


&gt;<i> Why not &lt;media&gt;, since the principles of video and audio are basically 
</I>&gt;<i> the same?
</I>
They're not the same. For example, you wouldn't really show visualisation 
for a video the way you would for audio. You wouldn't preserve aspect 
ratios for audio they way you do for video. They have similarities, for 
sure, but they are different nonetheless.


On Mon, 19 Mar 2007, Asbj&#195;&#184;rn Ulsberg wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; But the mechanism should always be extensible, to allow plugin vendors 
</I>&gt;<i> &gt; to add functionality of their own where it is not specified.
</I>&gt;<i> 
</I>&gt;<i> For &lt;object&gt;, sure. But with &lt;media&gt;, &lt;video&gt;, &lt;audio&gt; or whatever the 
</I>&gt;<i> element is going to be called, I think we should have a standard API 
</I>&gt;<i> with a standard way to extend, e.g. setParameter('name', 'value'). That 
</I>&gt;<i> way, the browser vendors will implement the required mechanisms to 
</I>&gt;<i> support the playback, and if plugin authors wants to extend it, they can 
</I>&gt;<i> do it with a standard mechanism that won't break in browser X because 
</I>&gt;<i> the plugin vendor didn't implement support for it there.
</I>
I don't really follow what you mean here. Could you give a concrete 
example?



On Thu, 15 Mar 2007, Benjamin West wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; I have added such an element and its corresponding API (influenced by 
</I>&gt;<i> &gt; the other feedback received) to the specification. Thank you for the 
</I>&gt;<i> &gt; proposal and implementation experience!
</I>&gt;<i> 
</I>&gt;<i> What are the events?
</I>
The events for the load status are:
   begin, progress, stalled, load, abort, error

The playback state events are:
   playing, paused, autopaused, stopped

They're all available by either onfoo=&quot;&quot; or addEventListener().


&gt;<i> I noticed the stop() method is used both to stop playback and to abort 
</I>&gt;<i> any pending download.  Is this a good idea?  Wouldn't it be simpler to 
</I>&gt;<i> add abort() to explicitly stop the download?
</I>
Well, to stop playback we have pause(). stop() just kills everything and 
resets it to the start.


&gt;<i> Are timeout's guaranteed to be in sync with the video?  For example:
</I>&gt;<i> // assume myvid.position = 0;
</I>&gt;<i> myvid.play();
</I>&gt;<i> myvid.setTimeout('alert(myvid.position);', 10);
</I>
No, this is not guarenteed to be in sync.


&gt;<i> I have a hunch most authors will care more about time till the end than 
</I>&gt;<i> time since the 0.  I don't have any evidence for this, and don't know 
</I>&gt;<i> why I think it.  Except for...
</I>
That's a fair point. I've added the idea of an &quot;ended&quot; event to the list 
of things to consider in v2 -- maybe this would be important enough to 
have in v1, though. What do people think?

You can currently catch the end like this:

   video.onautopaused = function () { if (video.ended) {
     // it's the end
     // ...
   } };


&gt;<i> (BTW, one thing that is really annoying is not knowing when resources 
</I>&gt;<i> [like images or scripts] failed to load.)
</I>
Doesn't onerror do this?


&gt;<i> What happens to the played range after we use seek()?
</I>
The video.played object returns a list of ranges.


&gt;<i> &gt; On Mon, 30 Oct 2006, Charles Iliya Krempeaux wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; #5: When to pre-fetch and when NOT to pre-fetch videos (and 
</I>&gt;<i> &gt; &gt; &quot;download&quot; it at the last possible minute).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Could you elaborate on this?
</I>&gt;<i> 
</I>&gt;<i> My previous example makes a lame attempt at pre-fetching.  If you change 
</I>&gt;<i> the src element to a previously dereferenced resource, how does the 
</I>&gt;<i> cache behave?  Will we need to clone and delete nodes instead?
</I>
Certainly cloning and deleting (or, better, just having several &lt;video&gt; 
elements and switching between them) will be better, because you can track 
the downloads separately. But caching should work, sure. It's an HTTP 
thing, though, out of scope for our spec.



&gt;<i> &gt; &gt; The frame capturing would be cool (and useful).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Could you elaborate on the use case for this? Since the author will 
</I>&gt;<i> &gt; have the complete data on his end, there doesn't seem much use for 
</I>&gt;<i> &gt; actual frame capture on the client.
</I>&gt;<i> 
</I>&gt;<i> Only thing I can think of is the initial screen cap shown (or is this
</I>&gt;<i> different?)  Perhaps for the image to show, you can just use an &lt;img&gt;
</I>&gt;<i> in the content of the &lt;video&gt;.
</I>
I think that's different.


&gt;<i> Do videos encode what size they are best displayed in?  I hate entering 
</I>&gt;<i> height and width for images.
</I>
Yes.



On Fri, 16 Mar 2007, Matthew Raymond wrote:
&gt;<i> &gt;&gt;&gt; .loop, .startpos
</I>&gt;<i> &gt;&gt;&gt; loop = false | true
</I>&gt;<i> &gt;&gt;&gt; autostart = true | false
</I>&gt;<i> &gt;&gt;&gt; startpos = 0 | specified pos
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Could you elaborate on the use cases for these?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Can't these be done in script?
</I>&gt;<i> 
</I>&gt;<i> Those attributes are basic values you'd want to use to initialize the 
</I>&gt;<i> video. For those that don't know Javascript very well and just want a 
</I>&gt;<i> video to play a certain way right away, it would be a real pain to only 
</I>&gt;<i> have access to these properties via scripting. Besides, I can't see the 
</I>&gt;<i> author wanting to set |autostart| and |startpos| dynamically, as they 
</I>&gt;<i> are clearly intended to be used when the page is loading. (The |loop| 
</I>&gt;<i> attribute might be set dynamically, but I can see situations where one 
</I>&gt;<i> would want the video to play in the background in a continuous loop from 
</I>&gt;<i> the moment the page is loaded. Granted, most of those uses are 
</I>&gt;<i> presentational.)
</I>
That doesn't answer the question, though, which is: what are the use 
cases? Especially for loop.



On Fri, 16 Mar 2007, Nicholas Shanks wrote:
&gt;<i> 
</I>&gt;<i> 1) If you specify both a width and a height, video content that doesn't 
</I>&gt;<i> match that gets distorted.
</I>
With the current spec, the content is never stretched, it'll get 
letterboxed instead.


&gt;<i> 2) If you want an element to have a fixed width, but variable height 
</I>&gt;<i> dependant on the aspect of the video, or fixed height and variable 
</I>&gt;<i> width, yet still have a non-zero initial value for the variable 
</I>&gt;<i> parameter (so that the &lt;video&gt; element occupies some screen area), you 
</I>&gt;<i> cannot achieve this without distorting the final image by setting both 
</I>&gt;<i> width and height.
</I>
You can achieve this with CSS, because the &lt;video&gt; element never distorts, 
but has intrinsic dimensions that CSS can hook into. (The rendering 
section, still to be written, will presumably talk about this in more 
detail.)



On Sat, 17 Mar 2007, Shadow2531 wrote:
&gt;<i> 
</I>&gt;<i> For example, every video page on a site might have a 400 x 400 video 
</I>&gt;<i> element (to fit with the layout for example), but the video that plays 
</I>&gt;<i> in it will range in size and aspect ratio. [...]
</I>
Yup, the spec supports that today. I don't think we need control over 
this, certainly not in v1 and probably not even in v2, though.



On Sat, 17 Mar 2007, Shadow2531 wrote:
&gt;<i> 
</I>&gt;<i> &quot;Video content must be rendered inside the element's playback area such 
</I>&gt;<i> that the video content is shown centered in the playback area at the 
</I>&gt;<i> largest possible size that fits completely within it, with the video 
</I>&gt;<i> content's aspect ratio being preserved. Thus, if the aspect ratio of the 
</I>&gt;<i> playback area does not match the aspect ratio of the video, the video 
</I>&gt;<i> will be shown letterboxed.&quot;
</I>&gt;<i> 
</I>&gt;<i> So, that also means that scaletofit in my examples is implied by that?
</I>
Yes.



On Fri, 16 Mar 2007, Stuart Langridge wrote:
&gt;<i> On 3/16/07, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Supporting only one encoding is not going to fly: you can't stop 
</I>&gt;<i> &gt; browser vendors from adding features; and you want to allow the 
</I>&gt;<i> &gt; standard to evolve over time.
</I>&gt;<i> 
</I>&gt;<i> I understand what you're saying here, but I think in practice that SVG's 
</I>&gt;<i> decision to mandate support for PNG and JPEG makes the raster format 
</I>&gt;<i> inclusions there useful.
</I>
But they don't prohibit other formats. The WHATWG spec requires Theora, 
but doesn't prohibit other formats. Which I think is what you're 
proposing...



On Fri, 16 Mar 2007, liorean wrote:
&gt;<i> &gt; On Mon, 30 Oct 2006, Charles Iliya Krempeaux wrote:
</I>&gt;<i> &gt; &gt; #3: Playlists.  (A single video file just won't cut it.)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; These were the only requests for playlists. Could you elaborate on the 
</I>&gt;<i> &gt; use cases for playlists? What are the needs for playlists?
</I>&gt;<i> 
</I>&gt;<i> I immediately though of uses like this: 
</I>&gt;<i> &lt;<A HREF="http://www.scribemedia.org/2006/12/04/javascript-redux-brendan-eich/">http://www.scribemedia.org/2006/12/04/javascript-redux-brendan-eich/</A>&gt; 
</I>&gt;<i> where the actual talk is split into 5 pieces for whatever reason, or 
</I>&gt;<i> Douglas Crockford's JavaScript talks videos, among many others.
</I>
Interesting. It's something to consider for v2, then.



&gt;<i> How about the case where you want to provide a low and a high bandwidth 
</I>&gt;<i> version, or a widescreen/normal screen aspect ratio version, or 
</I>&gt;<i> something similar.
</I>
Wouldn't a bunch of links be good enough? Anything more than that and we 
have to start defining negotiation protocols, which is a huge rathole.


&gt;<i> How about if a user wants to view the video in a separate window, 
</I>&gt;<i> separate tab or maybe fullscreen? Those are options where the size is 
</I>&gt;<i> not necessarily corresponding to the video size. Another aspect here is 
</I>&gt;<i> of course zooming/resizing/stretching and how to handle that.
</I>
The spec already handles these cases.


On Fri, 16 Mar 2007, Shadow2531 wrote:
&gt;<i> 
</I>&gt;<i> A video might be split into separate files (chapters). A playlist is 
</I>&gt;<i> needed to provide consecutive playback without user interaction and to 
</I>&gt;<i> provide view of your choices. If you've ever watched episodes in parts 
</I>&gt;<i> on youtube, you might see why this is important.
</I>
Does YouTube support this? I thought YouTube didn't support this, which 
would suggest it's not a high priority...


&gt;<i> One could use the events and states to determine when a video is done 
</I>&gt;<i> playing. Then, the src attribute could be changed to the next video. The 
</I>&gt;<i> list of videos could be gotten from a JS array or by parsing an xml 
</I>&gt;<i> playlist via self-written code or some playlist parsing JS library.
</I>
Yep.


&gt;<i> However, what if JS is turned off and you want to do playlists?
</I>
If JS is turned off, applications won't work. :-) Just like when you turn 
JS off and try to use Google Calendar, or turn off Flash and try to use 
YouTube. In v2 we can add UI features to handle this, though, such as:

&gt;<i> &lt;video src=&quot;playlist.xspf&quot;&gt;&lt;/video&gt;
</I>
...native XSPF support.


&gt;<i> &gt; &gt; .loop, .startpos
</I>&gt;<i> &gt; &gt; loop = false | true
</I>&gt;<i> &gt; &gt; autostart = true | false
</I>&gt;<i> &gt; &gt; startpos = 0 | specified pos
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Could you elaborate on the use cases for these?
</I>&gt;<i> 
</I>&gt;<i> &lt;video src=&quot;VideoIWasWatching.ogg&quot;&gt;
</I>&gt;<i>    &lt;param name=&quot;startpos&quot; value=&quot;value gotten from cookie where I left off
</I>&gt;<i> at&quot;&gt;
</I>&gt;<i> &lt;/video&gt;
</I>
If the data has to be gotten from a cookie, wouldn't a JS seek() not be 
better? You'll need JS to save the position anyway.


&gt;<i> &lt;video src=&quot;AwesomeMusicVideo.ogg&quot;&gt;
</I>&gt;<i>    &lt;param name=&quot;loop&quot; value=&quot;true&quot;&gt;
</I>&gt;<i> &lt;/video&gt;
</I>
Wouldn't the decision of whether to loop or not be a user decision? UAs 
can provide a loop option as a checkable item on a context menu. I'd hate 
to go to a site and have a video keep looping.


&gt;<i> Page where a user is expecting a video to play.
</I>&gt;<i> &lt;video src=&quot;file.ogg&quot;&gt;
</I>&gt;<i>    &lt;param name=&quot;autostart&quot; value=&quot;true&quot;&gt;
</I>&gt;<i> &lt;/video&gt;
</I>
We got a bunch of feedback from people saying &quot;never autoplay!&quot;. :-) 
Again, the spec allows users to control this now.


&gt;<i> However, if JS is needed for the video element to function at all, then 
</I>&gt;<i> the video element needs to fall back if JS is turned off.
</I>
Interesting point. You can do this with JS, of course (and that's the 
preferred way; hide the fallback when you have JS).


On Fri, 16 Mar 2007, Nicholas Shanks wrote:
&gt;<i>
</I>&gt;<i> For the above usage case, I don't see why &quot;remembering where you left 
</I>&gt;<i> off&quot; can't be a user-agent feature rather than part of the 
</I>&gt;<i> specification.
</I>
That's certainly an option too. The spec allows this (arguably).


&gt;<i> All said, it would be very useful if the startpos param could be 
</I>&gt;<i> returned to the server when starting the download, or when scrubbing 
</I>&gt;<i> forward into parts of the video that haven't yet downloaded. as that 
</I>&gt;<i> would help avoid using bandwidth unnecessarily.
</I>
HTTP requests with Range headers is the way the spec currently handles 
this. This may not be perfect, though. There are a number of other formats 
(as you point out). It's not clear to me what the best option is.



On Sat, 17 Mar 2007, H&#229;kon Wium Lie wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; For now, the spec says that UAs SHOULD support Theora for video and 
</I>&gt;<i> &gt; Vorbis for audio, and SHOULD support the Ogg container format (it's 
</I>&gt;<i> &gt; not a MUST because some vendors may have legal reasons why they can't 
</I>&gt;<i> &gt; or won't support it, and there's no point making them non-conforming 
</I>&gt;<i> &gt; when they have no choice in the matter).
</I>&gt;<i> 
</I>&gt;<i> I'd rather make &lt;video&gt; and &lt;audio&gt; optional so that those who cannot 
</I>&gt;<i> support these Ogg on these elements (for whatever reason) can still 
</I>&gt;<i> comply with the spec. They can also support proprietary codecs through 
</I>&gt;<i> &lt;object&gt;.
</I>
Why would we want to prevent the &lt;video&gt; API from being available to 
authors in walled gardens? Even if we make it legal to omit support for 
&lt;video&gt;, but require &lt;video&gt; to support Theora, UAs that don't want to 
implement Theora will still support &lt;video&gt;, they'll just do it without 
Theora, and be non-compliant. I don't see who wins here.



On Sun, 18 Mar 2007, Benjamin Hawkes-Lewis wrote:
&gt;<i> 
</I>&gt;<i> Well user-agent developers should follow UAAG, W3C's User Agent 
</I>&gt;<i> Accessibility Guidelines:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.w3.org/TR/WAI-USERAGENT/">http://www.w3.org/TR/WAI-USERAGENT/</A>
</I>&gt;<i> 
</I>&gt;<i> Guidelines 3 and 4 seem directly relevant. Really, UAAG compliance needs 
</I>&gt;<i> to become the basis of public sector and corporate procurement decisions 
</I>&gt;<i> to have much teeth, but any encouragement from WHATWG specs would help.
</I>
See the spec; it already does encourage that.



On Sun, 18 Mar 2007, Sander Tekelenburg wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; * If using Audio(), who's responsibility is it to provide that 
</I>&gt;<i> &gt; control/user interface?  UA? Authors?
</I>&gt;<i> 
</I>&gt;<i> The UA. Letting each and every content provider decide on the UI for their
</I>&gt;<i> content just creates usablity hell for end users.
</I>
Well for Audio() the whole point is that the UI is provided by the author 
(e.g. because the audio clips are being used as sound effects in a game).

However if we introduce &lt;audio&gt;, I agree; and I agree that &lt;video&gt; needs a 
standard UI (in v2, at least).



On Sun, 18 Mar 2007, Benjamin Hawkes-Lewis wrote:
&gt;<i> 
</I>&gt;<i> I suspect the fact that JS can't add to the context menu in browser 
</I>&gt;<i> environments more generally is a shame.
</I>
Look up &lt;menu&gt; in the spec.



On Fri, 16 Mar 2007, Anne van Kesteren wrote:
&gt;<i>
</I>&gt;<i> * INVALID_STATE_ERR needs &lt;code&gt; around it, not &lt;span&gt;. (This occurs 
</I>&gt;<i> more than once.)
</I>
Fixed. Thanks.


&gt;<i> * It's unclear if the user agent can start buffering before play() is 
</I>&gt;<i> invoked. Currently we do that although it doesn't delay the &lt;body&gt; load 
</I>&gt;<i> event in any way.
</I>
I've made the spec allow this.


&gt;<i> * The stop() method is not in the IDL.
</I>
Fixed.


&gt;<i> * If the video is shown &quot;letterboxes&quot; what does the surrounding space 
</I>&gt;<i> look like? Would that be the 'background' of the &lt;video&gt; element?
</I>
Black. Fixed.


&gt;<i> * I like how videoHeight and videoWidth work but are they not too 
</I>&gt;<i> different from how similar constructs work in HTML (such as &lt;img&gt;, 
</I>&gt;<i> &lt;object&gt;, &lt;embed&gt;, &lt;iframe&gt;)?
</I>
I don't think so; why would they be? They're different because we're 
introducing a new element and we don't have to make the same mistakes.



On Fri, 16 Mar 2007, Nicholas Shanks wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; * I like how videoHeight and videoWidth work but are they not too 
</I>&gt;<i> &gt; different from how similar constructs work in HTML (such as &lt;img&gt;, 
</I>&gt;<i> &gt; &lt;object&gt;, &lt;embed&gt;, &lt;iframe&gt;)?
</I>&gt;<i> 
</I>&gt;<i> how about inherentW/H or nativeW/H &#151; then the same DOM attributes can be 
</I>&gt;<i> reused on &lt;img&gt; too.
</I>
I think videoWidth/videoHeight is clearer than inherentWidth or 
nativeWidth. Is there really a use case for the equivalent on &lt;img&gt;?



On Sun, 18 Mar 2007, Alexey Feldgendler wrote:
&gt;<i> 
</I>&gt;<i> A compromise solution that I propose is to include a standard set of 
</I>&gt;<i> browser-provided controls, displayed by default and styleable through 
</I>&gt;<i> CSS pseudo-elements and pseudo-classes:
</I>
That's not a bad idea necessarily, but it would be something to suggest to 
the CSSWG.


On Sun, 18 Mar 2007, Kornel Lesinski wrote:
&gt;<i> 
</I>&gt;<i> How about controls overlaid on top of video, which are visible only when 
</I>&gt;<i> mouse hovers it? Something like fullscreen controls in QuickTime Pro or 
</I>&gt;<i> iTunes 7.
</I>
That's already allowed by the spec.



On Sun, 18 Mar 2007, Anne van Kesteren wrote:
&gt;<i> 
</I>&gt;<i> I just played some more with our internal implementation (Opera's) and 
</I>&gt;<i> noticed that our pause() really is like togglePause() in the HTML5 
</I>&gt;<i> proposal. Looking at the specification I don't see much need for pause() 
</I>&gt;<i> there. Perhaps togglePause() should just become pause() and pause() be 
</I>&gt;<i> removed?
</I>
Having pause() always pause is better because it means that you're not 
likely to end up in state where the UI says one thing but the UA does 
another (especially when you combine this with UA-provided UI). I only 
included togglePause() because Flash supports it and some people asked for 
it; I'm not convinced we should keep it.



On Sun, 18 Mar 2007, Mihai Sucan wrote:
&gt;<i> 
</I>&gt;<i> 1. I would suggest renaming &quot;length&quot; to &quot;duration&quot;, because &quot;length&quot; is 
</I>&gt;<i> a rather general term. &quot;length&quot; is also used for arrays in JavaScript, 
</I>&gt;<i> and other languages. &quot;duration&quot; (or simply &quot;dur&quot;) is more specific to 
</I>&gt;<i> videos.
</I>
Changed.


&gt;<i> 2. Should the type attribute be added? It would be a good hint, anchors 
</I>&gt;<i> have it, links have it, scripts have it, etc. Type would be useful for 
</I>&gt;<i> UAs running on systems with limited bandwidth and/or limited resources, 
</I>&gt;<i> they could choose not to download the video if the type is unrecognized.
</I>
Video types are extremely inadequate. I don't really see how it would 
work. Unless someone can suggest a precise processing model for it, I'd 
rather not include it.



If I missed any points people made, please let me know. I didn't 
explicitly quote and reply to every e-mail because a lot of them simply 
repeated the same arguments.

Cheers,
-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010279.html">[whatwg] Comments on the &lt;video&gt; element
</A></li>
	<LI>Next message: <A HREF="010283.html">[whatwg] &lt;video&gt; element feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10282">[ date ]</a>
              <a href="thread.html#10282">[ thread ]</a>
              <a href="subject.html#10282">[ subject ]</a>
              <a href="author.html#10282">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
