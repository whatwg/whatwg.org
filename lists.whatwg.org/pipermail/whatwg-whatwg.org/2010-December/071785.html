<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Timed tracks: feedback compendium
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Timed%20tracks%3A%20feedback%20compendium&In-Reply-To=%3CPine.LNX.4.64.1012132206340.26618%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029330.html">
   <LINK REL="Next"  HREF="071851.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Timed tracks: feedback compendium</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Timed%20tracks%3A%20feedback%20compendium&In-Reply-To=%3CPine.LNX.4.64.1012132206340.26618%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] Timed tracks: feedback compendium">ian at hixie.ch
       </A><BR>
    <I>Fri Dec 24 22:39:02 PST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="029330.html">[whatwg] WebSRT examples for review
</A></li>
        <LI>Next message: <A HREF="071851.html">[whatwg] Timed tracks: feedback compendium
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#71785">[ date ]</a>
              <a href="thread.html#71785">[ thread ]</a>
              <a href="subject.html#71785">[ subject ]</a>
              <a href="author.html#71785">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
Summary of major changes:

 + I've changed the selector syntax for styling cues in CSS to use full 
   selectors rather than the earlier shallow syntax.
 + I've changed the Voice syntax to allow multiple voices per cue and
   to use names rather than numbers for voices.
 + I've added a &lt;c&gt; cue span construct to which classes can be applied,
   to allow greater styling control.
 + I've also allowed classes to be specified on all other constructs in 
   the timed track language. It's a terser syntax than HTML:
    &lt;c.sfx&gt;Boom&lt;/c&gt;
    &lt;v Hippo Hero&gt;Hello Sir. I'm dropping now.&lt;/v&gt;
    &lt;v Policeman&gt;&lt;b.loud&gt;The road is &lt;i.stress&gt;that&lt;/i&gt; way!&lt;/b&gt;
    &lt;c.credit.author&gt;Written by Foo&lt;/c&gt; &lt;c.credit.editor&gt;Edited by Bar&lt;/c&gt;
 + I've made &lt;track&gt; have a feature whereby a track can be enabled by 
   default so that users who would otherwise not have any tracks enabled 
   will get it enabled (without overriding the preferences of users who 
   would have some other track enabled by default).
 + I've added some non-normative text to &lt;track&gt;'s definition of kind=&quot;&quot;
   to explain the implications of the attribute.
 + I've renamed WebSRT to WebVTT after receiving feedback from people 
   regarding two separate issues: one, on this list, that the spec isn't 
   really compatible with legacy SRT and that making it fully compatible 
   would likely not be a good direction to go in, so we should have a name 
   that reflects that, and two, in private, that the name &quot;SRT&quot; has 
   negative connotations with certain content companies and that changing 
   the name would be a trivial way of increasing the likely reach of the 
   technology. WebVTT stands for &quot;Web Video Text Track format&quot;.
 + I've also updated the extension and MIME type of the format to .vtt and 
   text/vtt respectively.
 + I've added a magic string that is required on the format to make it 
   recognisable in environments with no or unreliable type labeling.
 + I've required that content after the magic string and before the first 
   blank line be ignored, for future extensibility.
 + I've dropped the charset=&quot;&quot; attribute on &lt;track&gt; since it was only 
   needed to support legacy SRT files.
 + I've removed aspects of the parser that were only useful for parsing 
   legacy SRT files (specifically, the complex timestamp parsing).


On Wed, 24 Nov 2010, Eric Winkelman wrote:
&gt;<i>
</I>&gt;<i> I'm investigating how TimedTracks can be used for in-band-data-tracks 
</I>&gt;<i> within MPEG transport streams (used for cable television).
</I>&gt;<i> 
</I>&gt;<i> In this format, the number and types of in-band-data-tracks can change 
</I>&gt;<i> over time.  So, for example, when the programming switches from a 
</I>&gt;<i> football game to a movie, an alternate language track may appear that 
</I>&gt;<i> wasn't there before.  Later, when the programming changes again, that 
</I>&gt;<i> language track may be removed.
</I>&gt;<i> 
</I>&gt;<i> It's not clear to me how these changes are exposed by the proposed Media 
</I>&gt;<i> Element events.
</I>&gt;<i> 
</I>&gt;<i> The &quot;loadedmetadata&quot; event is used to indicate that the TimedTracks are 
</I>&gt;<i> ready, but it appears that it is only fired before playback begins.  Is 
</I>&gt;<i> this event fired again whenever a new track is discovered?  Is there 
</I>&gt;<i> another event that is intended for this situation?
</I>&gt;<i> 
</I>&gt;<i> Similarly, is there an event that indicates when a track has been 
</I>&gt;<i> removed?  Or is this also handled by the &quot;loadedmetadata&quot; event somehow?
</I>
Is the number of text timed tracks in such a situation capped to a 
particular maximum, or is it truly unbounded?


On Fri, 5 Nov 2010, Bruce Lawson wrote:
&gt;<i>
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#sourcing-in-band-timed-tracks">http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#sourcing-in-band-timed-tracks</A> 
</I>&gt;<i> says to create TimedTrack objects etc for in-band tracks which are then 
</I>&gt;<i> exposed in the API - so captions/subtitles etc that are contained in the 
</I>&gt;<i> media container file are exposed, as well as those tracks pointed to by 
</I>&gt;<i> the &lt;track&gt; element.
</I>&gt;<i> 
</I>&gt;<i> But 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#timed-track-api">http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#timed-track-api</A> 
</I>&gt;<i> implies that the array is only of tracks in the track element:
</I>&gt;<i> 
</I>&gt;<i> &quot;media . tracks . length
</I>&gt;<i> 
</I>&gt;<i> Returns the number of timed tracks associated with the media element 
</I>&gt;<i> (e.g. from track elements). This is the number of timed tracks in the 
</I>&gt;<i> media element's list of timed tracks.&quot;
</I>
I don't understand why you interpret this as implying anything about the 
track element. Are you interpreting &quot;e.g.&quot; as &quot;i.e.&quot;?


&gt;<i> Suggestion: amend to say &quot;Returns the number of timed tracks associated 
</I>&gt;<i> with the media element (e.g.  from track elements and any in-band track 
</I>&gt;<i> files inside the media container file)&quot; or some such.
</I>
I'd rather avoid talking about the in-band ones here, in part because I 
think it's likely to confuse authors at least as much as help them, and in 
part because the terminology around in-band timed tracks is a little 
unclear to me and so I'd rather not talk about them in informative text. :-)

If you disagree, though, let me know. I can find a way to make it work.


On Thu, 7 Oct 2010, James Graham wrote:
&gt;<i> 
</I>&gt;<i> One more from me: the spec is unusually hard to follow here since it 
</I>&gt;<i> makes extensive use of goto for flow control. Could it not be 
</I>&gt;<i> restructured as a state machine or something so it is easier to follow 
</I>&gt;<i> what is going on?
</I>
I'm happy to make it easier to read, if you have any concrete suggestions 
for how to do it. In general I have found that structured loops translate 
very poorly to English. I try to keep my &quot;gotos&quot; equivalent to structured 
loops so that they turn into sane code, FWIW.


On Wed, 8 Sep 2010, Sam Dutton wrote:
&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Also -- is trackgroup out of the spec?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; What is trackgroup?
</I>&gt;<i> 
</I>&gt;<i> I'd seen this in the Media TextAssociations documentation:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.w3.org/WAI/PF/HTML/wiki/Media_TextAssociations#Examples">http://www.w3.org/WAI/PF/HTML/wiki/Media_TextAssociations#Examples</A>
</I>
The feature is mostly there, it's just expressed differently (it's done in 
a way similar to how &lt;link&gt; works: you specify all the relevant attributes 
on each &lt;track&gt;).


On Wed, 8 Sep 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i>
</I>&gt;<i> In the discussion on public-html-a11y &lt;trackgroup&gt; was suggested to 
</I>&gt;<i> group together mutually exclusive tracks, so that enabling one 
</I>&gt;<i> automatically disables the others in the same trackgroup.
</I>&gt;<i> 
</I>&gt;<i> I guess it's up to the UA how to enable and disable &lt;track&gt;s now, but 
</I>&gt;<i> the only option is making them all mutually exclusive (as existing 
</I>&gt;<i> players do) or a weird kind of context menu where it's possible to 
</I>&gt;<i> enable and disable tracks completely independently. Neither options is 
</I>&gt;<i> great, but as a user I would almost certainly prefer all tracks being 
</I>&gt;<i> mutually exclusive and requiring scripts to enable several at once.
</I>
It's not clear to me what the use case is for having multiple groups of 
mutually exclusive tracks.

The intent of the spec as written was that a browser would by default just 
have a list of all the subtitle and caption tracks (the latter with 
suitable icons next to them, e.g. the [CC] icon in US locales), and the 
user would pick one (or none) from the list. One could easily imagine a UA 
allowing the user to enable multiple tracks by having the user ctrl-click 
a menu item, though, or some similar solution, much like with the commonly 
seen select box UI.


&gt;<i> &gt; On Fri, 6 Aug 2010, Philip J&#195;&#164;genstedt wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I'm not particularly fond of the current voice markup, mainly for 2 
</I>&gt;<i> &gt; &gt; reasons:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; First, a cue can only have 1 voice, which makes it impossible to 
</I>&gt;<i> &gt; &gt; style cues spoken/sung simultaneously by 2 or more voices. There's a 
</I>&gt;<i> &gt; &gt; karaoke example of this in 
</I>&gt;<i> &gt; &gt; &lt;<A HREF="http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA#Multiple_voices">http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA#Multiple_voices</A>&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; That's just two cues.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure what you're saying. The male singer's cues are in blue, the 
</I>&gt;<i> female singer's are in red and the part sung together is in green. Are 
</I>&gt;<i> you saying that the last cue should be made into two cues, or something 
</I>&gt;<i> else?
</I>
I would just have the three be labeled as three different voices. (I 
thought you were referring to two people saying two different things on 
the screen at the same time, which would be two cues.)


&gt;<i> &gt; &gt; I would prefer if voices could be mixed, as such:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 00:01.000 --&gt; 00:02.000
</I>&gt;<i> &gt; &gt; &lt;1&gt; Speaker 1
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 00:03.000 --&gt; 00:04.000
</I>&gt;<i> &gt; &gt; &lt;2&gt; Speaker 2
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 00:05.000 --&gt; 00:06.000
</I>&gt;<i> &gt; &gt; &lt;1&gt;&lt;2&gt; Speaker 1+2
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; What's the use case?
</I>&gt;<i> 
</I>&gt;<i> To use a different style for the cues that are sung together, so that 
</I>&gt;<i> you know when it's your turn to sing.
</I>
It's not clear whether multiple voices is really necessary. Can't you just 
do (using the new syntax):

 00:01.000 --&gt; 00:02.000
 &lt;v Bob&gt; Speaker 1
 
 00:03.000 --&gt; 00:04.000
 &lt;v Jim&gt; Speaker 2
 
 00:05.000 --&gt; 00:06.000
 &lt;v Bob and Jim&gt; Speaker 1+2

...where &quot;Bob and Jim&quot; is a third name?


&gt;<i> &gt; &gt; Second, it makes it impossible to target a smaller part of the cue 
</I>&gt;<i> &gt; &gt; for styling. We have &lt;i&gt; and &lt;b&gt;, but there are also cases where 
</I>&gt;<i> &gt; &gt; part of the cue should be in a different color, see 
</I>&gt;<i> &gt; &gt; &lt;<A HREF="http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA#Multiple_colors">http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA#Multiple_colors</A>&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Well you can always restyle &lt;i&gt; or &lt;b&gt;.
</I>&gt;<i> 
</I>&gt;<i> That would be quite an abuse of &lt;i&gt; and &lt;b&gt; and would give bogus 
</I>&gt;<i> italics/bold text in standalone players.
</I>
I'm not sure I'd call it bogus, but yes.

I've added a feature to enable such styling, though (&lt;c&gt; and classes).


&gt;<i> Yes, that would be better than numerical voices IMO. Unless there's a 
</I>&gt;<i> very good reason for making voices always apply to the whole cue, could 
</I>&gt;<i> we not use the same parsing for voices and other tags (i, b, ruby, rt)?
</I>
I've changed it to &lt;v speaker name&gt;.


&gt;<i> Ideally, the CSS extensions 
</I>&gt;<i> (<A HREF="http://wiki.whatwg.org/wiki/Timed_tracks#CSS_extensions">http://wiki.whatwg.org/wiki/Timed_tracks#CSS_extensions</A>) should also 
</I>&gt;<i> work the same for voices and tags, using the normal child selectors 
</I>&gt;<i> would work. Something like video::cue(narrator &gt; i) to style the 
</I>&gt;<i> following cue:
</I>&gt;<i> 
</I>&gt;<i> 00:01.000 --&gt; 00:02.000
</I>&gt;<i> &lt;narrator&gt;&lt;i&gt;The story begins
</I>&gt;<i> 
</I>&gt;<i> I'm not sure what constraints CSS syntax puts on the prefix for custom 
</I>&gt;<i> voices, is : safe? Other options might be &lt;@philip&gt; (Twitter style) or 
</I>&gt;<i> &lt;-philip&gt; (vendor prefix style).
</I>
This:

  00:01.000 --&gt; 00:02.000
  &lt;v narrator&gt;&lt;i&gt;The story begins&lt;/i&gt;

...can now be styled as follows:

  ::cue-part([voice=&quot;narrator&quot;] &gt; i) { ... }

That is, the name of the speaker is exposed as a &quot;voice&quot; attribute on the 
&quot;v&quot; node. (Thanks to Tab for that idea.)


&gt;<i> &gt; On Tue, 24 Aug 2010, Philip J&#195;&#164;genstedt wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Here's the SRT research I promised:
</I>&gt;<i> &gt; &gt; <A HREF="http://blog.foolip.org/2010/08/20/srt-research/">http://blog.foolip.org/2010/08/20/srt-research/</A>
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Awesome! Thanks for this.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Addressing points in the same order:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; - charset: resolved by introducing a charset override.
</I>&gt;<i> 
</I>&gt;<i> Oh well, that's better than sniffing the encoding or trusting 
</I>&gt;<i> Content-Type I guess.
</I>
Based on the additional research you and others provided, I've removed the 
charset=&quot;&quot; attribute again, and given up on the idea of supporting legacy 
content unmodified.


&gt;<i> &gt; - blank lines not separating cues: I couldn't find a client that
</I>&gt;<i> &gt;   supported missing the blank line, so I didn't support that. It's a
</I>&gt;<i> &gt;   small number of files, and a small number of cues within those files,
</I>&gt;<i> &gt;   I presume, so I'm not too worried.
</I>&gt;<i> 
</I>&gt;<i> Indeed, I couldn't find one either, the players I tested instead 
</I>&gt;<i> rendered the timing line and following cue text together with the 
</I>&gt;<i> previous cue, just like a WebSRT implementation would. What we could do 
</I>&gt;<i> to slightly improve the situation is to make --&gt; invalid in the cue 
</I>&gt;<i> text, so that validators could warn about this. That would require 
</I>&gt;<i> adding a &gt; escape for &gt;, so I'm not sure it's worth it. Perhaps 
</I>&gt;<i> validators could warn about it regardless of the spec.
</I>
Certainly if the rest of the line matches a timing line, a warning 
wouldn't be a bad idea, but I don't know that it should be invalid.


&gt;<i> &gt; - overlapping cues: supporting these is pretty important, so files with
</I>&gt;<i> &gt;   overlapping cues will just have some weird artefects on playback.
</I>&gt;<i> 
</I>&gt;<i> OK, tools to fix SRT timings already exist, so I guess this is 
</I>&gt;<i> manageable.
</I>
This would be something that an SRT-to-VTT convertor could support.



&gt;<i> &gt; On Wed, 25 Aug 2010, Philip J&#195;&#164;genstedt wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; The main reason to care about the MIME type is some kind of &quot;doing 
</I>&gt;<i> &gt; &gt; the right thing&quot; by not letting people get away with misconfigured 
</I>&gt;<i> &gt; &gt; servers. Sometimes I feel it's just a waste of everyone's time 
</I>&gt;<i> &gt; &gt; though, it would generally be less work for both browsers and 
</I>&gt;<i> &gt; &gt; authors to not bother.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Agreed. Not sure what to do for WebSRT though, since there's no good 
</I>&gt;<i> &gt; way to recognise a WebSRT file as opposed to some other format.
</I>&gt;<i> 
</I>&gt;<i> In a &lt;track&gt; context, ignoring Content-Type is certainly the simplest 
</I>&gt;<i> and removes the need to require any specific file extension for local 
</I>&gt;<i> use. Sniffing isn't really an issue since in a top-level context you 
</I>&gt;<i> can't do much of anything interesting with SRT except display it as text 
</I>&gt;<i> (which text/plain would achieve).
</I>
Having given up on the goal of strict backwards compatibility, I've added 
a magic string which can help with identification.


On Thu, 9 Sep 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> [...] some text cues will be fairly long and thus certain users cannot 
</I>&gt;<i> read them within the allocated time for the cue. So, making a 
</I>&gt;<i> pauseOnExit() available is a good thing for accessibility.
</I>
I would recommend that as a user interface feature, I don't think it makes 
sense to use pauseOnExit() for this feature.


(Note: The citing for the next few pages of quotes is incomplete. I 
apologise for not fully citing everyone.)

&gt;<i> &gt; &gt; &gt; On Fri, 31 Jul 2009, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; * It is unclear, which of the given alternative text tracks in 
</I>&gt;<i> &gt; &gt; &gt; &gt; different languages should be displayed by default when loading 
</I>&gt;<i> &gt; &gt; &gt; &gt; an &lt;itext&gt; resource. A @default attribute has been added to the 
</I>&gt;<i> &gt; &gt; &gt; &gt; &lt;itext&gt; elements to allow for the Web content author to tell the 
</I>&gt;<i> &gt; &gt; &gt; &gt; browser which &lt;itext&gt; tracks he/she expects to be displayed by 
</I>&gt;<i> &gt; &gt; &gt; &gt; default. If the Web author does not specify such tracks, the 
</I>&gt;<i> &gt; &gt; &gt; &gt; display depends on the user agent (UA - generally the Web 
</I>&gt;<i> &gt; &gt; &gt; &gt; browser): for accessibility reasons, there should be a field 
</I>&gt;<i> &gt; &gt; &gt; &gt; that allows users to always turn display of certain &lt;itext&gt; 
</I>&gt;<i> &gt; &gt; &gt; &gt; categories on. Further, the UA is set to a default language and 
</I>&gt;<i> &gt; &gt; &gt; &gt; it is this default language that should be used to select which 
</I>&gt;<i> &gt; &gt; &gt; &gt; &lt;itext&gt; track should be displayed.
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; It's not clear to me that we need a way to do this; by default 
</I>&gt;<i> &gt; &gt; &gt; presumably tracks would all be off unless the user wants them, in 
</I>&gt;<i> &gt; &gt; &gt; which case the user's preferences are paramount. That's what I've 
</I>&gt;<i> &gt; &gt; &gt; specced currently. However, it's easy to override this from 
</I>&gt;<i> &gt; &gt; &gt; script.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; It seems to me that this is much like &lt;video autoplay&gt; in that if we 
</I>&gt;<i> &gt; &gt; don't provide a markup solution, everyone will use scripts and it 
</I>&gt;<i> &gt; &gt; will be more difficult for the UA to override with user prefs.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; What would we need for this then? Just a way to say &quot;by the way, in 
</I>&gt;<i> &gt; addition to whatever the user said, also turn this track on&quot;? Or do we 
</I>&gt;<i> &gt; need something to say &quot;by default, override the user's preferences for 
</I>&gt;<i> &gt; this video and instead turn on this track and turn off all others&quot;? Or 
</I>&gt;<i> &gt; something else? It's not clear to me what the use case is where this 
</I>&gt;<i> &gt; would be useful declaratively.
</I>&gt;<i> 
</I>&gt;<i> You have covered all the user requirements and that is good. They should 
</I>&gt;<i> dominate all other settings. But I think we have neglected the authors. 
</I>&gt;<i> What about tracks that the author has defined and wants activated by 
</I>&gt;<i> default for those users that don't have anything else specified in their 
</I>&gt;<i> user requirements? For example, if an author knows that the audio on 
</I>&gt;<i> their video is pretty poor and they want the subtitles to be on by 
</I>&gt;<i> default (because otherwise a user may miss that they are available and 
</I>&gt;<i> they may miss what is going on), then currently they have to activate it 
</I>&gt;<i> with script.
</I>
Ah, so not the two options I listed, but instead &quot;if the user's preference 
is to not have any captions showing, then instead, show this caption&quot;? I 
guess that makes sense. I've added such a feature.


&gt;<i> A user whose preferences are not set will thus see this track. For a 
</I>&gt;<i> user whose preferences are set, the browser will turn on the appropriate 
</I>&gt;<i> tracks additionally or alternatively if there is a more appropriate 
</I>&gt;<i> track in the same language (e.g. a caption track over the default 
</I>&gt;<i> subtitle track). If we do this with script, will it not have the wrong 
</I>&gt;<i> effect and turn off what the browser has selected, so is not actually 
</I>&gt;<i> expressing author preferences, but is doing an author override?
</I>
Well there's no &quot;not set&quot; for preferences as far as I can tell -- you 
either prefer a particular track or you prefer no track at all. Either 
way, you have a preference. But yes, script would override that 
preference.


&gt;<i> &gt; &gt; &gt; On Thu, 15 Apr 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; Further, SRT has no way to specify which language it is written 
</I>&gt;<i> &gt; &gt; &gt; &gt; in
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; What's the use case?
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; As hints for font selection
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Are independent SRT processors really going to do per-language font 
</I>&gt;<i> &gt; selection? How do they do it today?
</I>&gt;<i> 
</I>&gt;<i> In VLC there is an &quot;Advanced Open File...&quot; option in which you can open a
</I>&gt;<i> subtitle file with the video and set the following parameters:
</I>&gt;<i> * FPS
</I>&gt;<i> * delay
</I>&gt;<i> * font size
</I>&gt;<i> * subtitle alignment
</I>&gt;<i> * subtitle text encoding which chooses the charset.
</I>
That would still be possible today. It doesn't seem that a language 
metadata field would help with the above though.


&gt;<i> &gt; &gt; and speech synthesis.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Are independent SRT processors really going to do audio descriptions 
</I>&gt;<i> &gt; any time soon? I've only ever seen this in highly experimental 
</I>&gt;<i> &gt; settings.
</I>&gt;<i> 
</I>&gt;<i> Once this is usable in the Web context, accessibility people will jump 
</I>&gt;<i> at this opportunity. It has not been possible before. You should see the 
</I>&gt;<i> excitement I always get from blind people when I demonstrate the 
</I>&gt;<i> Elephants Dream video with text audio descriptions. It will totally take 
</I>&gt;<i> off.
</I>
It's not clear to me that language metadata would be of that much help for 
speech synthesis in that kind of scenario. It's like in HTML... people 
don't set it, set it wrong, etc, and at the end of the day, the user's 
likely to only have one or two languages he wants spoken and the UA can 
autodetect between them pretty easily.

For captions themselves, speech-synthesis isn't necessary (just listen to 
the original audio track). For subtitles, mixed language tracks would be 
very rare (since the whole point of subtitles is to translate the text 
into a single language).


&gt;<i> &gt; &gt; [...] the positioning of individual cues is still not controlled by 
</I>&gt;<i> &gt; &gt; CSS but rather by e.g. L:50%.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I considered this issue carefully when speccing WebSRT. My conclusion 
</I>&gt;<i> &gt; (after watching a lot more TV than I'm used to) was that in practice 
</I>&gt;<i> &gt; subtitle positioning is not strictly a presentational issue -- that 
</I>&gt;<i> &gt; is, you can't just swap one set of styles for another and have equally 
</I>&gt;<i> &gt; good results, you have to control the positioning on a per-cue basis 
</I>&gt;<i> &gt; regardless of the styling. This is because you have to avoid burnt-in 
</I>&gt;<i> &gt; text, or overlap burnt-in text, or because you need to align text with 
</I>&gt;<i> &gt; a speaker, or show which audio channel the text came from (e.g. for 
</I>&gt;<i> &gt; people talking off camera in a very directional sense), etc.
</I>&gt;<i> 
</I>&gt;<i> I agree. However, what stops us from specifying the positioning in CSS? 
</I>&gt;<i> Why a new mechanism? The output of rendering the cues ends up as a set 
</I>&gt;<i> of CSS boxes anyway.
</I>
It would be an abuse of CSS to use it for what is semantic data. The whole 
point of CSS is to provide optional switchable style sheets, if we put 
the positioning in CSS we're saying it's presentational.


&gt;<i> &gt; &gt; Alternatively, might it not be better to simply use the voice 
</I>&gt;<i> &gt; &gt; &quot;sound&quot; for this and let the default stylesheet hide those cues? 
</I>&gt;<i> &gt; &gt; When writing subtitles I don't want the maintenance overhead of 2 
</I>&gt;<i> &gt; &gt; different versions that differ only by the inclusion of [doorbell 
</I>&gt;<i> &gt; &gt; rings] and similar. Honestly, it's more likely that I just wouldn't 
</I>&gt;<i> &gt; &gt; bother with accessibility for the HoH at all. If I could add it with 
</I>&gt;<i> &gt; &gt; &lt;sound&gt;doorbell rings, it's far more likely I would do that, as long 
</I>&gt;<i> &gt; &gt; as it isn't rendered by default. This is my preferred solution, then 
</I>&gt;<i> &gt; &gt; keeping only one of kind=subtitles and kind=captions. Enabling the 
</I>&gt;<i> &gt; &gt; HoH-cues could then be a global preference in the browser, or done 
</I>&gt;<i> &gt; &gt; from the context menu of individual videos.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I don't disagree with this, but I fear it might be too radical a step 
</I>&gt;<i> &gt; for the caption-authoring community to take at this point.
</I>&gt;<i> 
</I>&gt;<i> I think we have to get over the notion that the existing subtitling 
</I>&gt;<i> community is our target for this format. In fact, the new subtitling 
</I>&gt;<i> community are all the Web developers out there. They are the ones we 
</I>&gt;<i> should target and for them we should make things easier.
</I>
I think that would be a rather arrogant position for us to take. 
Realistically, the people writing subtitles today are going to be a big 
part of the people writing subtitles tomorrow, whether that be in 
hobbyist communities or in commercial environments.


&gt;<i> &gt; &gt; If we must have both kind=subtitles and kind=captions, then I'd 
</I>&gt;<i> &gt; &gt; suggest making the default subtitles, as that is without a doubt the 
</I>&gt;<i> &gt; &gt; most common kind of timed text. Making captions the default only 
</I>&gt;<i> &gt; &gt; means that most timed text will be mislabeled as being appropriate 
</I>&gt;<i> &gt; &gt; for the HoH when it is not.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Ok, I've changed the default. However, I'm not fighting this battle if 
</I>&gt;<i> &gt; it comes up again, and will just change it back if people don't defend 
</I>&gt;<i> &gt; having this as the default. (And then change it back again if the 
</I>&gt;<i> &gt; browsers pick &quot;subtitles&quot; in their implementations after all, of 
</I>&gt;<i> &gt; course.)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Note that captions aren't just for users that are hard-of-hearing. 
</I>&gt;<i> &gt; Most of the time when I use timed tracks, I want captions, because the 
</I>&gt;<i> &gt; reason I have them enabled is that I have the sound muted.
</I>&gt;<i> 
</I>&gt;<i> Hmm, you both have good points. Maybe we should choose something as the 
</I>&gt;<i> default that is not visible on screen, such as &quot;descriptions&quot;? That 
</I>&gt;<i> would avoid the issue and make it explicit for people who provide 
</I>&gt;<i> captions or subtitles that they have to make a choice.
</I>
Seems like it'd be better to have a default that at least some people are 
going to use. :-)


&gt;<i> &gt; &gt; &gt; - Use existing technologies where appropriate.
</I>&gt;<i> &gt; &gt; &gt; [...]
</I>&gt;<i> &gt; &gt; &gt; - Try as much as possible to have things Just Work.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I think by specifying a standalone cue text parser WebSRT fails on 
</I>&gt;<i> &gt; &gt; these counts compared to reusing the HTML fragment parsing algorithm 
</I>&gt;<i> &gt; &gt; for parsing cue text.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; HTML parsing is a disaster zone that we should avoid at all costs, 
</I>&gt;<i> &gt; IMHO. I certainly don't think it would make any sense to propagate 
</I>&gt;<i> &gt; that format into anywhere where we don't absolutely have to propagate 
</I>&gt;<i> &gt; it.
</I>&gt;<i> 
</I>&gt;<i> A WebSRT authoring application does not have to create all markup that a 
</I>&gt;<i> HTML fragment parser supports. It would only use what it sees necessary 
</I>&gt;<i> for the use cases that it targets.
</I>
It's the parsing ones I'm concerned about. The generating tools will have 
no problem outputting all kinds of complicated stuff without our help.


&gt;<i> Browsers are WebSRT players that will consume the HTML fragments created 
</I>&gt;<i> by such authoring applications. In addition, browsers will also be able 
</I>&gt;<i> to consume richer HTML fragments that were created as time-aligned 
</I>&gt;<i> overlays for video with more fancy styling by Web developers. Something 
</I>&gt;<i> like <A HREF="http://people.mozilla.com/~prouget/demos/vp8/">http://people.mozilla.com/~prouget/demos/vp8/</A> (you need Firefox for 
</I>&gt;<i> it). Where it says &quot;This movie will eat your planet&quot;, you could have 
</I>&gt;<i> fancy timed text.
</I>&gt;<i> 
</I>&gt;<i> Just as much as there is a need for basic captions and subtitles, there 
</I>&gt;<i> is also a need for fancy time-aligned HTML fragments. It would be very 
</I>&gt;<i> strange if, in order to get that working, people would need to use the 
</I>&gt;<i> &quot;metadata&quot; part of the WebSRT spec.
</I>
I don't think it would be strange. I think it would be completely 
reasonable for us to not handle those use cases at all, personally. That 
we provide hooks to enable it is a bonus.


&gt;<i> &gt; &gt; &gt; If we don't use HTML wholesale, then there's really no reason to 
</I>&gt;<i> &gt; &gt; &gt; use HTML at all. (And using HTML wholesale is not really an 
</I>&gt;<i> &gt; &gt; &gt; option, as you say above.)
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I disagree. The most obvious way of reusing existing infrastructure 
</I>&gt;<i> &gt; &gt; in browsers, the most obvious way of getting support for future 
</I>&gt;<i> &gt; &gt; syntax changes that support attributes or new tag names and the most 
</I>&gt;<i> &gt; &gt; obvious way to get error handling that behaves in the way the 
</I>&gt;<i> &gt; &gt; appearance of the syntax suggests is to reuse the HTML fragment 
</I>&gt;<i> &gt; &gt; parsing algorithm for parsing the cue text.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; HTML parsing is one of the most convoluted, quirk-laden, unintuitive 
</I>&gt;<i> &gt; and expensive syntaxes... Its extensibility story is a disaster 
</I>&gt;<i> &gt; (there's so many undocumented and continually evolving constraints 
</I>&gt;<i> &gt; that any addition is massively expensive), its implementation drags 
</I>&gt;<i> &gt; with it all kinds of crazy dependencies on the DOM, event loop 
</I>&gt;<i> &gt; interactions, scripting, and so forth, and it has a highly 
</I>&gt;<i> &gt; inconsistent syntax.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm not at all convinced reusing it would be &quot;obvious&quot;.
</I>&gt;<i> 
</I>&gt;<i> It is obvious to anyone who is not on a standards body. :-)
</I>&gt;<i> 
</I>&gt;<i> But seriously: all the things you mention above are advantages: all this 
</I>&gt;<i> stuff has been solved for HTML and will not have to be solved again if 
</I>&gt;<i> we reuse it.
</I>
The problems I raised haven't been solved at all! HTML is still 
convoluted, quirk-laden, unintuitive, expensive, with a bad extension 
story, with undocumented and continually evolving constraints, with crazy 
dependencies, and its syntax is still inconsistent.


&gt;<i> Anything new will inevitably go through a similar development path.
</I>
I am not at all convinced that such an outcome is inevitable nor that that 
should mean we should just jump straight to the bad end result.


&gt;<i> I don't see this as the opportunity to re-invent HTML when in fact for 
</I>&gt;<i> anyone out there HTML is working just fine.
</I>
It's not working at all for timed tracks, it's working for documents. HTML 
is like a printing press, when what you need here is a telephone. It's 
simply not appropriate.

More important, consider the use cases. The use cases we have for timed 
tracks argue for syntax that makes it easy to set voices and that support 
basic styling and in-cue timings, but do not argue for scripting, embedded 
plugins, videos, exposing a mutable cue DOM, or any such features. Yet if 
we use HTML, we'd have all of the latter, no in-cue timings, etc. 
Basically HTML simply doesn't match the use cases.

Now if there are other use cases then maybe we should do something 
different than what we have; that's why we studied use cases first. There 
are certainly features that we've explicitly not handled, e.g. the 
YouTube-style interactive annotations, and overlaid advertising. It's not 
clear that HTML would actually be the right way to address these either. 

For example, for advertising it's not just an interactive HTML frame that 
appears over the video for a fixed time -- it's generally a frame that 
appears at a fixed time and then stays until manually dismissed, and when 
dismissed typically gets replaced by a tiny button that brings it back. 
Also it tends to be marked in the timeline; HTML parsing doesn't give us 
that. And there's the whole issue that advertising is generally not 
considered optional by publishers, whereas timed tracks are explicitly 
intended to be removable by the user.


&gt;<i> On Sun, 25 Jul 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I think if we have a mixed set of .srt files out there, some of 
</I>&gt;<i> &gt; &gt; which are old-style srt files (with line numbers, without WebSRT 
</I>&gt;<i> &gt; &gt; markup) and some are WebSRT files with all the bells and whistles 
</I>&gt;<i> &gt; &gt; and with additional external CSS files, we create such a mess for 
</I>&gt;<i> &gt; &gt; that existing ecosystem that we won't find much love.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm not sure our goal is to find love here, but in general I would 
</I>&gt;<i> &gt; agree that it would be better to have one format than two. I don't see 
</I>&gt;<i> &gt; why we wouldn't just have one format here though. The idea of WebSRT 
</I>&gt;<i> &gt; is to be sufficiently backwards-compatible that that is possible.
</I>&gt;<i> 
</I>&gt;<i> With &quot;finding love&quot; I referred to your expressed goals:
</I>&gt;<i>  - Keep implementation costs for standalone players low.
</I>&gt;<i>  - Use existing technologies where appropriate.
</I>&gt;<i>  - Try as much as possible to have things Just Work.
</I>&gt;<i> 
</I>&gt;<i> With WebSRT, we will have one label for two different types of files: 
</I>&gt;<i> the old-style SRT files and the new WebSRT files. Just putting a single 
</I>&gt;<i> label on them doesn't mean it is one format, in particular when most old 
</I>&gt;<i> files will not be conformant to the new label and many new files will 
</I>&gt;<i> not play in the software created for the old spec.
</I>
Fair enough. I've changed this.


&gt;<i> &gt; &gt; You mention that karaoke and lyrics are supported by WebSRT, so 
</I>&gt;<i> &gt; &gt; could we add them to the track kinds?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Why would they need new script kinds? Isn't &quot;subtitles&quot; enough?
</I>&gt;<i> 
</I>&gt;<i> Interesting idea.
</I>&gt;<i> 
</I>&gt;<i> This actually gets back to the issue that I have mentioned before: we are
</I>&gt;<i> actually overloading the meaning of the @kind attribute with many different
</I>&gt;<i> things:
</I>&gt;<i> * what the data is semantically: subtitle, caption, textual description,
</I>&gt;<i> chapters or &quot;metadata&quot; (i.e. &quot;anything&quot;)
</I>&gt;<i> * whether the data will be visually displayed
</I>&gt;<i> * how the data will be parsed
</I>
Aren't the second and third bullet points the same as the first? I don't 
understand how they're distinct.

kind=&quot;&quot; is just setting the kind of track: whether it's something that 
gets put on the video (subtitles, captions), or something that gets 
displayed as a jump list (chapters), etc.


&gt;<i> What if, from a semantic viewpoint, people want to have subtitles or 
</I>&gt;<i> captions always show, but not karaoke or lyrics?
</I>
I don't understand the question. Can you elaborate?


&gt;<i> &gt; We could provide an API dedicated to making it easier to render cues 
</I>&gt;<i> &gt; manually if desired (firing an event or callback with the actual cue 
</I>&gt;<i> &gt; for each cue that shows, for example).
</I>&gt;<i> 
</I>&gt;<i> I think that might be a good idea. How would you suggest? Is the 
</I>&gt;<i> oncuechange not sufficient?
</I>
TimedTrack.oncuechange is sufficient, just not necessarily the most 
convenient solution we could use. It would be helpful to see exactly how 
people render cues before adding a better feature.


&gt;<i> &gt; &gt; And what if we wanted to render captions underneath a video rather 
</I>&gt;<i> &gt; &gt; than inside video dimensions? Can that be achieved somehow?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; You'd need to script it, currently. (I didn't see many (any?) cases of 
</I>&gt;<i> &gt; this in my research, so I didn't provide a declarative solution.)
</I>&gt;<i> 
</I>&gt;<i> I've seen it done often on the Web, in particular for descriptions (or 
</I>&gt;<i> timed transcripts) - it won't appear on TV or desktop caption 
</I>&gt;<i> applications though, for obvious reasons.
</I>&gt;<i> 
</I>&gt;<i> For example, the descriptions on TED are rendered into a container that 
</I>&gt;<i> is not overlayed onto the video: e.g. 
</I>&gt;<i> <A HREF="http://www.ted.com/talks/dan_cobley_what_physics_taught_me_about_marketing.html">http://www.ted.com/talks/dan_cobley_what_physics_taught_me_about_marketing.html</A> 
</I>&gt;<i> (click the interactive transcript on the right to display it).
</I>
As far as I can tell that's not subtitles, that's just a transcript with 
hyperlinks. You wouldn't do that with a subtitle format, it's just a 
series of &lt;a&gt; elements with onclick handlers to move the video's playback 
position. No? It's unclear to me how we could make a feature that 
supported this declaratively without making it so narrow in purpose that 
it would fail to hit the 80% bar.


&gt;<i> Or the interactive transcript on youtube is timed text that is not 
</I>&gt;<i> rendered on top of the video but in a box underneath: e.g. 
</I>&gt;<i> <A HREF="http://www.youtube.com/watch?v=nF3yhZrtLRw">http://www.youtube.com/watch?v=nF3yhZrtLRw</A>
</I>
The style seems pretty specific to YouTube, here. I'm not sure how we'd 
make a generic version of this.

In general I would view out-of-frame subtitles the same way as we view 
out-of-frame controls: we provide a default UI, and page authors are 
welcome to script the element to provide a site-specific experience.


&gt;<i> For captions and subtitles 
</I>&gt;<i> it's less common, but rendering it underneath the video rather than on 
</I>&gt;<i> top of it is not uncommon, e.g. 
</I>&gt;<i> <A HREF="http://nihseniorhealth.gov/video/promo_qt300.html">http://nihseniorhealth.gov/video/promo_qt300.html</A> or 
</I>
Conceptually, that's in the video area, it's just that the video isn't 
centered vertically. I suppose we could allow UAs to do that pretty 
easily, if it's commonly desired.

&gt;<i> <A HREF="http://www.fs.fed.us/greatestgood/film/moviefiles/TheGreatestGood_Tr_C_L.mov">http://www.fs.fed.us/greatestgood/film/moviefiles/TheGreatestGood_Tr_C_L.mov</A> 
</I>
Same.

&gt;<i> <A HREF="http://www.veotag.com/player/Default.aspx?mode=sample&amp;sid=1&amp;pid={516D49AA-72F4-4DA6-91BA-6D225C2782D8">http://www.veotag.com/player/Default.aspx?mode=sample&amp;sid=1&amp;pid={516D49AA-72F4-4DA6-91BA-6D225C2782D8</A>}
</I>
I couldn't find subtitles there. There were chapter markers, though, is 
that what you meant? I think it's clear that chapter marker UI is often 
specialised to the point where there'd be no sane way to expose it in 
markup without script, so I'm happy to just leave that up to the authors, 
much like how we are leaving the &quot;play&quot; button up to the author when the 
author wants to do something more fancy than the default.


&gt;<i> &gt; &gt; For linking out of a cue, there is a need to allow having hyperlinks 
</I>&gt;<i> &gt; &gt; in cues. IIUC this is currently only possible by using a HTML-style 
</I>&gt;<i> &gt; &gt; markup in the cue, declaring the cue as kind=metadata and calling 
</I>&gt;<i> &gt; &gt; getCueAsSource() on the cue, then running your own overlays and 
</I>&gt;<i> &gt; &gt; shoving the retrieved text to the innerHTML of that overlay.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Having a hyperlink in a cue seems like really bad UI (having any 
</I>&gt;<i> &gt; temporal interactive UI is typically highly inaccessible, and is 
</I>&gt;<i> &gt; generally only considered a good idea in games). If you want to make 
</I>&gt;<i> &gt; the whole video into a link (as Dave suggested in the e-mail above, if 
</I>&gt;<i> &gt; I understood it correctly) then you don't need anything to do with 
</I>&gt;<i> &gt; timed tracks.
</I>&gt;<i> 
</I>&gt;<i> You can always pause the presentation to follow a given hyperlink.
</I>
That's pretty bad UI though.


&gt;<i> It's definitely better than having to re-type a URL, which is what is 
</I>&gt;<i> currently happening in many of the timed annotations in YouTube that 
</I>&gt;<i> leave YouTube.
</I>
Just put the link below the video.


&gt;<i> I see the need to support hyperlinks in cues as really important for 
</I>&gt;<i> accessibility and usability reasons.
</I>
I see the avoidance of hyperlinks in cues as really important for 
accessibility and usability reasons.


&gt;<i> &gt; &gt; While that works, it seems like a lot of hoops to jump through just 
</I>&gt;<i> &gt; &gt; to be able to use a bit of HTML markup - in particular having to run 
</I>&gt;<i> &gt; &gt; your own overlay. Could we introduce a kind=htmlfragment type where 
</I>&gt;<i> &gt; &gt; it is obvious that the text is HTML and that the fragment parser can 
</I>&gt;<i> &gt; &gt; be run automatically and display it through the given display 
</I>&gt;<i> &gt; &gt; mechanisms?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I would on the contrary think that that would be something we should 
</I>&gt;<i> &gt; _discourage_, not encourage!
</I>&gt;<i> 
</I>&gt;<i> All that is going to achieve is that we will end up with HTML fragments 
</I>&gt;<i> in metadata type cues and have to deal with them through JavaScript. I'd 
</I>&gt;<i> much prefer we have a defined way of dealing with this situation rather 
</I>&gt;<i> than having it be created inconsistently in JS libraries.
</I>
It's unclear to me what use cases would be served by this. All the cases I 
can think of (such as those discussed earlier in this e-mail: advertising, 
annotations, fancy chapter navigation, interactive transcripts...) are all 
things for which there will be script anyway, and for which built-in 
features won't be used. We would just be providing hugely complex features 
for which there is no benefit.


&gt;<i> &gt; &gt; Many existing subtitle formats and similar media-time-aligned text 
</I>&gt;<i> &gt; &gt; formats contain file-wide name-value pairs that explain metadata for 
</I>&gt;<i> &gt; &gt; the complete resource. An example are Lyrics files, e.g.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; On Tue, 20 Apr 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; Lyrics (LRC) files typically look like this:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; [ti:Can't Buy Me Love]
</I>&gt;<i> &gt; &gt; &gt; [ar:Beatles, The]
</I>&gt;<i> &gt; &gt; &gt; [au:Lennon &amp; McCartney]
</I>&gt;<i> &gt; &gt; &gt; [al:Beatles 1 - 27 #1 Singles]
</I>&gt;<i> &gt; &gt; &gt; [by:Wooden Ghost]
</I>&gt;<i> &gt; &gt; &gt; [re:A2 Media Player V2.2 lrc format]
</I>&gt;<i> &gt; &gt; &gt; [ve:V2.20]
</I>&gt;<i> &gt; &gt; &gt; [00:00.45]Can't &lt;00:00.75&gt;buy &lt;00:00.95&gt;me &lt;00:01.40&gt;love,
</I>&gt;<i> &gt; &gt; &gt; &lt;00:02.60&gt;love&lt;00:03.30&gt;, &lt;00:03.95&gt;love, &lt;00:05.30&gt;love&lt;00:05.60&gt;
</I>&gt;<i> &gt; &gt; &gt; [00:05.70]&lt;00:05.90&gt;Can't &lt;00:06.20&gt;buy &lt;00:06.40&gt;me &lt;00:06.70&gt;love,
</I>&gt;<i> &gt; &gt; &gt; &lt;00:08.00&gt;love&lt;00:08.90&gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; You can see that there are title, artist, author, album, related 
</I>&gt;<i> &gt; &gt; content, version and similar metadata information headers on this 
</I>&gt;<i> &gt; &gt; file. Other examples contain copyright information and usage rights 
</I>&gt;<i> &gt; &gt; - important information to understand and deal with when 
</I>&gt;<i> &gt; &gt; distributing media-time-aligned text files on a medium such as the 
</I>&gt;<i> &gt; &gt; Web.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I don't really see why we would want to embed this in a timed track. 
</I>&gt;<i> &gt; Even in HTML embedding this kind of information has never taken off. 
</I>&gt;<i> &gt; We would need to have very compelling use cases, implementation 
</I>&gt;<i> &gt; experience, and implementation committements to move in such a 
</I>&gt;<i> &gt; direction, IMHO.
</I>&gt;<i> 
</I>&gt;<i> Dublin Core has been a huge success.
</I>
I think our definitions of &quot;success&quot; are at odds. :-)


&gt;<i> Every archive in the world uses that kind of metadata. I am confused 
</I>&gt;<i> what you mean by metadata in HTML hasn't taken off. I believe it's only 
</I>&gt;<i> search engines that stopped using metadata and only because people 
</I>&gt;<i> started mis-using the system.
</I>
Metadata in HTML on the Web is rare and when used is uniformly bogus.
Why would this be different for metadata in captions on the Web?


&gt;<i> Such metadata is also relevant to audio and video, just look at the 
</I>&gt;<i> success of ID3 tags or Vorbis Comment. Similarly, we will need this 
</I>&gt;<i> capability in timed text files.
</I>
For audio and video tracks I think there is success (mostly in commercial 
files), but that's out of scope of HTML.


&gt;<i> &gt; &gt; I would think it'd be good to define a standard means of extracting 
</I>&gt;<i> &gt; &gt; plain text out of any type of cue, so it will be possible to hand 
</I>&gt;<i> &gt; &gt; this to e.g. the accessibility API for reading back.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Getting the raw data is already possible, unless I misunderstood what 
</I>&gt;<i> &gt; you meant.
</I>&gt;<i> 
</I>&gt;<i> What I meant is to have a getter in TimedTrackCueList that will not 
</I>&gt;<i> return the cue with its specific markup (WebSRT, JSON or HTML fragment), 
</I>&gt;<i> but stripped off any of the special markers. This can be very 
</I>&gt;<i> interesting when wanting to shoot something through to speech 
</I>&gt;<i> recognition or so.
</I>
That seems like a generic-purpose feature, not a caption-specific one. We 
should address this at the platform level.


&gt;<i> &gt; &gt; I think by understanding this and by making this explicit in the 
</I>&gt;<i> &gt; &gt; spec, we can more clearly decide what track kinds are still missing 
</I>&gt;<i> &gt; &gt; and also what we actually need to implement.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm not sure what to add to make this clearer. Can you elaborate?
</I>&gt;<i> 
</I>&gt;<i> What I meant by this was that in section 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#attr-track-kindwhere">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#attr-track-kindwhere</A> 
</I>&gt;<i> @kind is introduced, there is no mention about the implications of 
</I>&gt;<i> choosing between these @kind attributes. E.g. if I chose a 
</I>&gt;<i> &quot;description&quot;, then it will not be visible unless I implement that in 
</I>&gt;<i> JavaScript - that is a pretty big implication that I only found out when 
</I>&gt;<i> I finally got to reading the rendering section. Also, that section does 
</I>&gt;<i> not provide any hint on what type of markup will be expected in the cue 
</I>&gt;<i> text - I think that is also a pretty big implication that should be 
</I>&gt;<i> mentioned in that section.
</I>
Ok, I've added some explanatory text.


&gt;<i> &gt; [we can extent the syntax later to add metadata, defaults, etc]
</I>&gt;<i> When I read the following: [...] then that doesn't imply for me that we 
</I>&gt;<i> can add anything in front of the WebSRT cues without breaking the spec, 
</I>&gt;<i> or that we can define cues that are not time ranges around the &quot;--&gt;&quot; 
</I>&gt;<i> sign.
</I>
Different &quot;we&quot;s. I meant that a future version of the language could 
support this while being compatible with the first generation of UAs, not 
that authors could do it today.


&gt;<i> &gt; &gt; and we know from image, music and video resources how important it 
</I>&gt;<i> &gt; &gt; is to have the ability to keep such metadata inside the resource.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Do we? I thought from image, music, and video we learnt that it didn't 
</I>&gt;<i> &gt; make much difference! :-)
</I>&gt;<i> 
</I>&gt;<i> I think ID3 is very successful, in particular in iTunes, see 
</I>&gt;<i> <A HREF="http://en.wikipedia.org/wiki/ITunes#File_metadata">http://en.wikipedia.org/wiki/ITunes#File_metadata</A> . The vorbiscomment 
</I>&gt;<i> header on Xiph files enjoys a similar popularity. And the huge success 
</I>&gt;<i> of EXIF for images - written by every single digital photo camera and 
</I>&gt;<i> used by every single photo application. They make a huge difference.
</I>
EXIF is automated and only contains machine-producable data. Metadata in 
iTunes tracks is probably required by contract, there is a high financial 
motivation for it to be of good quality, and the number of people writing 
it is limited. I haven't studied Xiph files so I can't speak about those.

On the Web, though, images in general don't have metadata, and the Web has 
not suffered for it. (EXIF is used on photographs, nor arbitrary Web 
images.) There's not really much music on the Web, so I don't know that we 
can learn much from that, but video on the Web has very little metadata as 
far as I can tell, and seems to have done fine nonetheless.


&gt;<i> &gt; &gt; * there is no style sheet association for a WebSRT resource; this 
</I>&gt;<i> &gt; &gt; can be resolved by having the style sheet linked into the Web page 
</I>&gt;<i> &gt; &gt; where the resource is used with the video, but that's not possible 
</I>&gt;<i> &gt; &gt; when the resource is used by itself. It needs something like a 
</I>&gt;<i> &gt; &gt; &lt;link&gt; to a CSS resource inside the WebSRT file.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Do standalone SRT players want to support CSS? If not, it doesn't much 
</I>&gt;<i> &gt; matter.
</I>&gt;<i> 
</I>&gt;<i> Stand-alone SRT players wouldn't want to see any of the WebSRT 
</I>&gt;<i> extensions. Stand-alone WebSRT players - if we define the styling to be 
</I>&gt;<i> in CSS - would probably want to support whatever is in WebSRT - if that 
</I>&gt;<i> includes CSS, then that's it. But any of this is just guesswork until we 
</I>&gt;<i> have implementations.
</I>
Then we can wait until we have implementations. If it turns out that they 
provide a way to specify a CSS file, then we should support it.


&gt;<i> &gt; &gt; * there is no magic identifier for a WebSRT resource, i.e. what the 
</I>&gt;<i> &gt; &gt; &lt;wmml&gt; element is for WMML. This makes it almost impossible to 
</I>&gt;<i> &gt; &gt; create a program to tell what file type this is, in particular since 
</I>&gt;<i> &gt; &gt; we have made the line numbers optional. We could use &quot;--&gt;&quot; as an 
</I>&gt;<i> &gt; &gt; indicator, but it's not a good signature.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yeah, that's a problem. I considered adding &quot;WEBSRT&quot; at the start of 
</I>&gt;<i> &gt; every file but we couldn't use it reliably since WebSRT parsers 
</I>&gt;<i> &gt; presumably want to support SRT using the same parser, and that has no 
</I>&gt;<i> &gt; signature.
</I>&gt;<i> 
</I>&gt;<i> I continue to doubt that you can support WebSRT without changing your 
</I>&gt;<i> SRT parser. Thus, you might as well make such a change and make it easy 
</I>&gt;<i> for SRT parsers to identify that it's a WebSRT file to parse and not 
</I>&gt;<i> legacy SRT.
</I>
Fair enough.


&gt;<i> &gt; (Note that XML, and anything based on XML, as well as HTML, JS, and 
</I>&gt;<i> &gt; CSS, have no signature either. It's a common problem of text formats.)
</I>&gt;<i> 
</I>&gt;<i> Well, there are typical things to parse at the head of XML files, such as
</I>&gt;<i> processing instructions or
</I>&gt;<i> &lt;!DOCTYPE html&gt;
</I>&gt;<i> &lt;html
</I>&gt;<i> These *are* magic identifiers.
</I>
No, they're not. They're unreliable heuristics. A magic identifier for a 
file type is something that is always present in files of that type and 
can be unambiguously used to determine the file type.


&gt;<i> &gt; &gt; * there is no means to identify which parser is required in the cues 
</I>&gt;<i> &gt; &gt; (is it &quot;plain text&quot;, &quot;minimal markup&quot;, or &quot;anything&quot;?) and therefore 
</I>&gt;<i> &gt; &gt; it is not possible for an application to know how it should parse 
</I>&gt;<i> &gt; &gt; the cues.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Timed track cues are not context-free. In standalone players, the user 
</I>&gt;<i> &gt; says to play a particular cue file, so using the &quot;cue text&quot; mode is a 
</I>&gt;<i> &gt; good assumption (why would you give mplayer a metadata cue file to 
</I>&gt;<i> &gt; display?).
</I>&gt;<i> 
</I>&gt;<i> Because it is a .srt file and thus assumed to be supported by mplayer.
</I>
I don't understand. Users don't just randomly find SRT files and feed them 
to their players. They find a video and then seek out the approriate 
subtitle file and hand that to the player.


&gt;<i> &gt; &gt; I can understand that the definition of WebSRT took inspiration from 
</I>&gt;<i> &gt; &gt; SRT for creating a simple format. But realistically most SRT files 
</I>&gt;<i> &gt; &gt; will not be conformant WebSRT files because they are not written in 
</I>&gt;<i> &gt; &gt; UTF-8.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I don't think they need to be conforming. They're already published. 
</I>&gt;<i> &gt; Conformance is just a quality assurance tool, it's only relevant for 
</I>&gt;<i> &gt; documents being written in the future.
</I>&gt;<i> 
</I>&gt;<i> Conformance is also a problem if players and other tools do not accept 
</I>&gt;<i> files that are not conformant. I would think Web browser will be highly 
</I>&gt;<i> restrictive in what they accept - otherwise the spec isn't quite so 
</I>&gt;<i> useful and we are starting to do quirks again.
</I>
The spec requires specific behaviour in the face of non-conforming 
content, and that behaviour is not to be restrictive.


&gt;<i> &gt; &gt; Right now, there is &quot;plain text&quot;, &quot;minimum markup&quot; and &quot;anything&quot; 
</I>&gt;<i> &gt; &gt; allowed in the cues.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As far as I can tell there's just two modes -- plain text and text 
</I>&gt;<i> &gt; with WebSRT markup.
</I>&gt;<i> 
</I>&gt;<i> @kind=metadata tracks can have &quot;anything&quot; in them, which is what I 
</I>&gt;<i> regarded as the third type of markup.
</I>
That's the same as &quot;plain text&quot;.


&gt;<i> &gt; &gt; Seeing as WebSRT is built with the particular purpose of bringing 
</I>&gt;<i> &gt; &gt; time-synchronized text for HTML5 media elements, it makes no sense 
</I>&gt;<i> &gt; &gt; to exclude all the capabilities of HTML.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I would on the contrary say that it makes no sense to take on all the 
</I>&gt;<i> &gt; HTML baggage when all we want to do is introduce subtitles to video. 
</I>&gt;<i> 
</I>&gt;<i> We are introducing functionality for text and events that are executed 
</I>&gt;<i> in a time-synchronized manner with media elements - this is broader than 
</I>&gt;<i> just subtitles.
</I>
While I'm willing to grant that we're doing a bit more than subtitles, I 
disagree that we're introducing &quot;functionality for text and events that 
are executed in a time-synchronized manner with media elements&quot;. That 
describes something like SMIL, significantly more complexity than the 
narrow set of use cases which this effort is intended to address.

Now it may be that there are use cases whose value we can debate, such as 
advertising, or rich-media-on-rich-media annotations, or declarative 
interactive styled chapter UI, that are not currently considered in-scope, 
but if we want to add new use cases then we should consider them as new 
use cases and figure out from scratch how to address them (which may or 
may not involve reusing the same infrastructure as we are using for 
subtitles). We should not just throw in solutions on the assumption that 
those will address those new use cases.


&gt;<i> &gt; &gt; In the current form, WebSRT only makes limited use of existing CSS. 
</I>&gt;<i> &gt; &gt; I see particularly the following limitations:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; * no use of the positioning functionality is made and instead a new 
</I>&gt;<i> &gt; &gt; means of positioning is introduced; it would be nicer to just have 
</I>&gt;<i> &gt; &gt; this reuse CSS functionality. It would also avoid having to repeat 
</I>&gt;<i> &gt; &gt; the positioning information on every single cue.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; It doesn't make sense to position cues with CSS, because the position 
</I>&gt;<i> &gt; of cues is an intrinsic part of the cue semantic. Where a cues appears 
</I>&gt;<i> &gt; can change the plot of a show, for example (was it the evil twin who 
</I>&gt;<i> &gt; said something or the good twin?).
</I>&gt;<i> 
</I>&gt;<i> When I say &quot;CSS&quot; I mean the CSS means of providing in-line @style
</I>&gt;<i> information. That is just a different means of providing positioning and
</I>&gt;<i> styling information in a cue.
</I>
I don't understand what problem this would solve.

Note that CSS positioning doesn't provide the primitives needed to do cue 
overlap avoidance while still having positioned cues (which the HTML
spec does currently support for timed tracks).


&gt;<i> &gt; &gt; * cue-related metadata (&quot;voice&quot;) could be made more generic; why not 
</I>&gt;<i> &gt; &gt; reuse &quot;class&quot;?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I don't know what this means. What is &quot;class&quot; and how does it differ 
</I>&gt;<i> &gt; from &quot;voice&quot;?
</I>&gt;<i> 
</I>&gt;<i> I am talking about the @class attribute in use by all HTML elements. It 
</I>&gt;<i> could be used with a &lt;span&gt; to provide voice metadata and it would be 
</I>&gt;<i> more flexible than &quot;voice&quot; because it can be associated with text 
</I>&gt;<i> fragments, not with whole lines of text.
</I>
I could see value for a generic class mechanism (so I've added one), but I 
don't see how this relates to voices.


&gt;<i> &gt; &gt; * I noticed that it is not possible to make a language association 
</I>&gt;<i> &gt; &gt; with segments of text and thus it is not possible to have text with 
</I>&gt;<i> &gt; &gt; mixed languages.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Are mixed language subtitles common? I don't know that I've ever seen 
</I>&gt;<i> &gt; that.
</I>&gt;<i> 
</I>&gt;<i> I have seen several caption files that have at least two languages, 
</I>&gt;<i> possibly even in the same cue. You even have some at 
</I>&gt;<i> <A HREF="http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA.">http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA.</A>
</I>
That can be done fine with the spec as written. You don't need to annotate 
the language in captions as far as I can tell (see also the discussion 
earlier in this e-mail).


&gt;<i> &gt; * Is it possible to reuse the HTML font systems?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; What is the HTML font system?
</I>&gt;<i> 
</I>&gt;<i> Basically stuff defined here: 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#fonts-and-colors">http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#fonts-and-colors</A>
</I>
I don't understand what it would mean to re-use that.


&gt;<i> &gt; On Sat, 21 Aug 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; It's not just about implementation cost - it's also the problem of 
</I>&gt;<i> &gt; &gt; maintaining another spec that can grow to have eventually all the 
</I>&gt;<i> &gt; &gt; features that HTML5 has and more. Do you really eventually want to 
</I>&gt;<i> &gt; &gt; re-spec and re-implement a whole innerHTML parser plus the extra &lt;t&gt; 
</I>&gt;<i> &gt; &gt; element when we start putting &lt;svg&gt; and &lt;canvas&gt; and all sorts of 
</I>&gt;<i> &gt; &gt; other more complex HTML features into captions? Just because the &lt;t&gt; 
</I>&gt;<i> &gt; &gt; element is making trouble now? Is this really the time to re-invent 
</I>&gt;<i> &gt; &gt; HTML?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; No, it's not. We should never let subtitles get that crazy.
</I>&gt;<i> 
</I>&gt;<i> Hmm, where have I heard that said before ...
</I>&gt;<i> <A HREF="http://www.ibiblio.org/pioneers/lee.html">http://www.ibiblio.org/pioneers/lee.html</A>
</I>&gt;<i> &quot;Berners-Lee was concerned over some of the new directions the Web was
</I>&gt;<i> taking. There were decided differences between his original vision and the
</I>&gt;<i> visions of Andreesen and the Netscape crowd. The Web was designed to be a
</I>&gt;<i> serious medium.&quot;
</I>&gt;<i> I think it's a myth to believe one has control over the path a technology
</I>&gt;<i> will take and in which way it will be used.
</I>
If we have no control then it doesn't matter what the spec says. If we 
have any control then we should do what we can to not let subtitles get 
crazy. I don't see a contradiction here.


&gt;<i> On Mon, 23 Aug 2010, Philip J&#228;genstedt wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I don't expect that SVG, &lt;canvas&gt;, images, etc will ever natively be 
</I>&gt;<i> &gt; &gt; made part of captions. Rather, I would hope that the metadata state 
</I>&gt;<i> &gt; &gt; together with scripts is used. If we think that e.g. images in 
</I>&gt;<i> &gt; &gt; captions are an important use case, then WebSRT is not a good 
</I>&gt;<i> &gt; &gt; solution.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Indeed.
</I>&gt;<i> 
</I>&gt;<i> Images in captions will be used, I can guarantee that.
</I>
The question isn't whether they'll be used, but whether the use cases for 
them are significant enough that we should support this case natively.


&gt;<i> &gt; &gt; If we allow arbitrary HTML and expect browsers to handle it well, it 
</I>&gt;<i> &gt; &gt; adds some complexity. For example, any videos and images in the cue 
</I>&gt;<i> &gt; &gt; would have to be fully loaded and ready to be decoded by the time 
</I>&gt;<i> &gt; &gt; the cue is to be shown, which I really don't want to implement the 
</I>&gt;<i> &gt; &gt; logic for. Simply having an iframe-like container where the document 
</I>&gt;<i> &gt; &gt; is replaced for each cue wouldn't be enough, rather one would have 
</I>&gt;<i> &gt; &gt; to create one document per cue during parsing and wait for all of 
</I>&gt;<i> &gt; &gt; those to finish loading before beginning playback. I'm not sure, but 
</I>&gt;<i> &gt; &gt; I'm guessing that amounts to significant memory overhead.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Quite.
</I>&gt;<i> 
</I>&gt;<i> People will do it with HTML in the metadata and then decode it through 
</I>&gt;<i> JavaScript and throw it at a the HTML fragment parser, including all the 
</I>&gt;<i> side effects that may have and that they will have to deal with. I'm 
</I>&gt;<i> sure this will eventually catch up with us. Would it not be better to 
</I>&gt;<i> think about it now and address it - in particular if you are saying that 
</I>&gt;<i> WebSRT is not the right solution for this?
</I>
What are the use cases? Are they significant? If so, let's design 
something for them directly.


&gt;<i> &gt; On Tue, 24 Aug 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I believe [SVG etc] will be [added to WebSRT]. But since we are only 
</I>&gt;<i> &gt; &gt; looking at the ways in which captions and subtitles are used 
</I>&gt;<i> &gt; &gt; currently, we haven't accepted this as an important use case, which 
</I>&gt;<i> &gt; &gt; is fair enough. I am considering likely future use though, which is 
</I>&gt;<i> &gt; &gt; always hard to argue.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; In all my research for subtitles, I found very few cases of anything 
</I>&gt;<i> &gt; like this. Even DVDs, whose subtitle tracks are just hardcoded bitmap 
</I>&gt;<i> &gt; images, don't do anything fancy with them... just plain text and 
</I>&gt;<i> &gt; italics, generally. Why haven't people started doing fancy stuff with 
</I>&gt;<i> &gt; subtitles in all the years that we've had TVs? It's not like they 
</I>&gt;<i> &gt; can't do it.
</I>&gt;<i> 
</I>&gt;<i> SVG on the TV? All that was possible was teletext type graphics and 
</I>&gt;<i> indeed, people did a lot of graphics there, e.g. 
</I>&gt;<i> <A HREF="http://www.google.com.au/images?q=teletext">http://www.google.com.au/images?q=teletext</A> .
</I>
Not in subtitles though.


&gt;<i> &gt; My guess is that the real reason is that when you get so fancy that 
</I>&gt;<i> &gt; you're including graphics and the like, you're no longer doing timed 
</I>&gt;<i> &gt; tracks, you're just doing content, and the right thing to do is to 
</I>&gt;<i> &gt; either burn it in, or consider it a separate construct animated on top 
</I>&gt;<i> &gt; of the video, e.g. an &lt;svg:video&gt; and SMIL.
</I>&gt;<i> 
</I>&gt;<i> There was no authoring format available for such things that anything 
</I>&gt;<i> would support to display.
</I>
That's not true. DVDs for example just have bitmap cues, so any graphic 
is possible. Yet much more than 80% of DVD subtitles are just text.


&gt;<i> Even the more complex caption formats were really not supported in any 
</I>&gt;<i> player.
</I>
Shouldn't that be an indicator that there isn't actually a need here?


&gt;<i> Putting it on the Web is a game changer. It will be easy to author 
</I>&gt;<i> (plenty of people know how to author HTML and will be able to throw HTML 
</I>&gt;<i> fragments into WebSRT cues) and it will be easy to display (using some 
</I>&gt;<i> JavaScript and the framework we're putting in place).
</I>
All the more reason not to encourage it! We should make desireable things 
easy, and undesireable things hard. That's a big part of language design.


&gt;<i> &gt; &gt; Then a *playback application* has the chance to identify them as a 
</I>&gt;<i> &gt; &gt; different format and provide a specific parser for it, instead of 
</I>&gt;<i> &gt; &gt; failing like Totem. They can also decide to extend their existing 
</I>&gt;<i> &gt; &gt; SRT parser to support both WebSRT and SRT. And I also have no issue 
</I>&gt;<i> &gt; &gt; with a user deciding to give a WebSRT file a go by renaming it to 
</I>&gt;<i> &gt; &gt; .srt.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I think you think there's more difference between WebSRT and SRT than 
</I>&gt;<i> &gt; there is. In practice, there is less difference between WebSRT and the 
</I>&gt;<i> &gt; equivalent SRT file than there is between two random SRT files today. 
</I>&gt;<i> &gt; The difference between WebSRT and SRT is well within the &quot;error bars&quot; 
</I>&gt;<i> &gt; of what SRT is today.
</I>&gt;<i> 
</I>&gt;<i> A WebSRT file with JSON in the cues is more different to anything that 
</I>&gt;<i> is called .srt today.
</I>
Nobody is going to be passing metadata timed tracks to standalone players, 
so I don't see why that's relevant.


&gt;<i> An authoring application that loads a WebSRT file should support all 
</I>&gt;<i> features of WebSRT, even the metadata type and should know what to do 
</I>&gt;<i> with it.
</I>
Which is what, exactly? I don't understand what it means to use a metadata 
timed track file outside of a Web browser.


&gt;<i> If such a file is clearly marked as .wsrt, the authoring application has 
</I>&gt;<i> a chance to do the right thing with the file and allow you to continue 
</I>&gt;<i> editing your JSON content in a special interface for it.
</I>
A cue editor can just have a user toggle to decide what kind of editor it 
should expose.


On Fri, 10 Sep 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> Not being convinced we need anything more than simple key-value headers 
</I>&gt;<i> in a header, I still looked at the options for comments:
</I>&gt;<i> 
</I>&gt;<i> Making any line with a --&gt; in it be a comment would hide a lot of broken 
</I>&gt;<i> cues from validators, so I think we shouldn't do this.
</I>&gt;<i> 
</I>&gt;<i> ; appears at the beginning of lines in 15/10000 files and most don't 
</I>&gt;<i> look like they're intended as comments.
</I>&gt;<i> 
</I>&gt;<i> # appears at the beginning of lines in 244/10000 files and most don't 
</I>&gt;<i> look like they're intended as comments.
</I>&gt;<i> 
</I>&gt;<i> /* only appears in 3/10000 files, so CSS-style comments might work, but 
</I>&gt;<i> does add some complexity
</I>&gt;<i> 
</I>&gt;<i> // appears at the beginning of lines in 5/10000 files and most look like 
</I>&gt;<i> that *are* intended as comments or are garbage, so it should work.
</I>&gt;<i> 
</I>&gt;<i> (data from OpenSubtitles sample)
</I>
Thanks for the data.

If we're going to change the spec to require a magic header, then the 
legacy content is of limited importance at this point, so I guess it 
doesn't really matter. We can add any kind of backwards-compatible new 
syntax in the future.


&gt;<i> I often see various credits in the cues themselves. Some are there for 
</I>&gt;<i> ego purposes, but I expect at least some of them would end up in a 
</I>&gt;<i> metadata field if it existed. It's hard to get solid numbers, but after 
</I>&gt;<i> some grepping and manual filtering it seems like around 5% of files have 
</I>&gt;<i> some form of credits matching 'subtitle', 'translat' or 'caption' 
</I>&gt;<i> case-insensitively. I guess that many non-English subtitles have the 
</I>&gt;<i> credits in another language, so the true percentage should be higher.
</I>
It's pretty common for subtitles to include visible credits around the 
same time as programme credits. I don't see any reason to believe that 
having metadata for this would be superior. HTML authors for example 
typically put their name in their HTML page rather than using the various 
metadata mechanisms (or use both). Historically in HTML the metadata 
features haven't been especially useful. I don't see why it would be 
different for subtitle data.



On Sat, 11 Sep 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> What I meant was: if I author a text track that is supposed to be 
</I>&gt;<i> visible on screen as the video plays back and if we choose either 
</I>&gt;<i> @kind=subtitle or @kind=caption as the default, then I don't have to 
</I>&gt;<i> really think through about what I authored as it will be displayed on 
</I>&gt;<i> screen. This invites people to not distinguish between whether they 
</I>&gt;<i> authored subtitles or captions, which is a bad thing, because a deaf 
</I>&gt;<i> user may then get tracks with the wrong label and expectations. If, 
</I>&gt;<i> however, we choose as a default something that is not visible on screen, 
</I>&gt;<i> e.g. @kind=description or @kind=metadata, then the author who wants 
</I>&gt;<i> their text track to be visible on screen has to give it a label, i.e. 
</I>&gt;<i> make an explicit choice between @kind=subtitle and @kind=caption. I 
</I>&gt;<i> believe this will lead to more correctly labeled content. I am therefore 
</I>&gt;<i> strongly against default labeling with either subtitle or caption. We 
</I>&gt;<i> could make @kind a required attribute instead as you are saying.
</I>
The history of the Web teaches us that if we require that they pick 
between subtitle and caption, they'll just pick at random.


On Mon, 13 Sep 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> OK, I think we mostly agree. Any default will sometimes be wrong, so to 
</I>&gt;<i> not have to choose between subtitles and captions, I'd still really 
</I>&gt;<i> prefer if specific HoH-tags like &lt;sound&gt; can be shown or hidden 
</I>&gt;<i> depending on user preference. I think that would lead to more content 
</I>&gt;<i> actually being written for HoH users, as it doesn't requiring 
</I>&gt;<i> maintaining 2 different files.
</I>
My main concern with this is that it's not been done before. Given the 
apparent simplicitly of the feature, it seems that there must be some 
reason for this. One reason might be that it's never come up before. 
Another reason might be that captions and subtitles are different in 
subtle ways that make this inappropriate in practice. I think before we 
add this feature, we should try to understand the history here.

Note that even if we were able to point to a single file for both 
subtitles and captions, we'd still have to specify them separately in the 
markup, so that the UI could correctly identify the two options without 
having to download and parse the two tracks first. So I'm not sure it 
would actually help with the problem in question (the default kind).


&gt;<i> Requiring UTF-8 and not requiring UTF-8 both has its downsides. I think 
</I>&gt;<i> that handling charset as an attribute on &lt;track&gt; isn't very difficult, 
</I>&gt;<i> but if there are SRT-incompatible changes for other reasons (e.g. a 
</I>&gt;<i> header) then I think we should go back to always requiring UTF-8.
</I>
Done.


&gt;<i> I don't suppose it's a huge problem in practice that errors can't be 
</I>&gt;<i> detected until EOF, but it's certainly not a desirable feature. To 
</I>&gt;<i> maintain some sanity, we probably ought to either require the correct 
</I>&gt;<i> MIME type or require the correct magic bytes. From the &lt;video&gt; MIME type 
</I>&gt;<i> debacle, I think I slightly prefer magic bytes to be checked by the 
</I>&gt;<i> parser.
</I>
Done.


On Tue, 14 Sep 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> I'd say that the simplest approach is probably requiring the first line to be
</I>&gt;<i> &quot;WebSRT&quot;, and then all lines up to the first blank line are defined as the
</I>&gt;<i> header.
</I>
Done, though currently anything in the header is ignored and invalid.


On Tue, 14 Sep 2010, Anne van Kesteren wrote:
&gt;<i> 
</I>&gt;<i> Apart from text/plain I cannot think of a &quot;web&quot; text format that does 
</I>&gt;<i> not have comments.
</I>
But what's the use case? Is it really useful to have comments in a 
subtitle file?


On Fri, 22 Oct 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> However, UTF-8 does complicate the magic header a bit due to the 
</I>&gt;<i> possibility of a BOM. While it would be nice to forbid the use of a BOM, 
</I>&gt;<i> I expect we'd then see lots of frustration from authors who's editors 
</I>&gt;<i> automatically insert it...
</I>
I think having an optional BOM before the magic string is fine. It just 
means there's two magic strings, basically. (There's actually strictly 
eight; see the spec for details. I list them in the MIME type registration 
for completeness.)


On Fri, 22 Oct 2010, Simon Pieters wrote:
&gt;<i> 
</I>&gt;<i> Do you think browsers will support vanilla SRT as well? If yes, then 
</I>&gt;<i> making WebSRT incompatible seems like doing the quirks mode/standards 
</I>&gt;<i> mode mistake again to me (and eventually we'll have to specify vanilla 
</I>&gt;<i> SRT anyway, but are also stuck with yet another format to support).
</I>
My assumption is that most browsers will not support legacy SRT. If they 
were to do so, we'd have to spec it first, anyway.


&gt;<i> &gt; It can still be inspired by it though so we don't have to change much. 
</I>&gt;<i> &gt; I'd be curious to hear what other things you'd clean up given the 
</I>&gt;<i> &gt; chance.
</I>&gt;<i> 
</I>&gt;<i> WebSRT has a number of quirks to be compatible with SRT, like supporting 
</I>&gt;<i> both comma and dot as decimal separators, the weird parsing of 
</I>&gt;<i> timestamps, etc.
</I>
I've cleaned the timestamp parsing up. I didn't see others.


On Fri, 22 Oct 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> We should just remove charset=&quot;&quot; from the spec.
</I>
Done.


On Fri, 5 Nov 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> seeing the addition of the &lt;bdi&gt; element into HTML, we probably also 
</I>&gt;<i> need to add that to WebSRT cue level markup to allow bidirectional text 
</I>&gt;<i> formatting. 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/text-level-semantics.html#the-bdi-element">http://www.whatwg.org/specs/web-apps/current-work/multipage/text-level-semantics.html#the-bdi-element</A>
</I>
Why can't we just use bidi formatting characters, like in text/plain?


On Fri, 10 Sep 2010, Eric Carlson wrote:
&gt;<i>
</I>&gt;<i> &quot;type&quot;  will definitely be necessary if we use &lt;track&gt; for other media 
</I>&gt;<i> types, eg. for sign language video, descriptive audio, etc.
</I>
Those aren't text tracks, so presumably wouldn't use &lt;track&gt;.


&gt;<i> Images are already commonly used in chapter menus.
</I>
Could you elaborate on this?


On Wed, 20 Oct 2010, Odin Omdal H&#195;&#184;rthe wrote:
&gt;<i> 
</I>&gt;<i> The standards-loving Agency for Public Management and eGovernment here 
</I>&gt;<i> in Norway are getting their eyes up for HTML5 video (like the rest of 
</I>&gt;<i> the world), and are kicking the tires. I've been streaming many 
</I>&gt;<i> conferences with Ogg Theora and using Cortado as fallback for legacy 
</I>&gt;<i> browsers (+Safari).
</I>&gt;<i> 
</I>&gt;<i> Now it has come to a point that we are required to follow the WAI WACG 
</I>&gt;<i> requirements. So we have to caption the live video streams/broadcasts.
</I>&gt;<i> 
</I>&gt;<i> Given the (not surprising) low support of Timed Tracks for live streams 
</I>&gt;<i> in browsers, I'm at this point going to burn the text into the video to 
</I>&gt;<i> be shown. However, that is no good solution long term. When browsers 
</I>&gt;<i> implement the new startOffsetTime I will be able to send the text via a 
</I>&gt;<i> WebSocket to Javascript and have it synced to the video (along with the 
</I>&gt;<i> slide images).
</I>&gt;<i> 
</I>&gt;<i> However, it would be very nice to be able to send this to the 
</I>&gt;<i> caption-track, and not having to reimplement a user interface for 
</I>&gt;<i> choosing to see captions etc (I guess user agents will have that). Also, 
</I>&gt;<i> I guess there will also be other benefits of streaming directly as a 
</I>&gt;<i> timed track, such as the user agent knowing what it is (so that it can 
</I>&gt;<i> do smart things with it).
</I>
The API for timed tracks allows for this.


&gt;<i> Or what other way is there to text such live conferences; or even bring 
</I>&gt;<i> real-time metadata from a live video?
</I>
Video formats typically support in-band subtitles, which I would expect is 
what would be used for subtitles for like streams.


On Tue, 5 Oct 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> At the Open Subtitles Design Summit, there was some discussion about 
</I>&gt;<i> captioning for the HoH. I've already put this input into a related bug 
</I>&gt;<i> [2], but to summarize: The default rendering for the voices syntax 
</I>&gt;<i> should probably be to prefix the text cue with the name of the speaker, 
</I>&gt;<i> not to do anything funny with colors or positioning. What's less clear 
</I>&gt;<i> is if it's annoying to always prefix with the speaker, or if it should 
</I>&gt;<i> be done only to disambiguate.
</I>&gt;<i> [2] <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=10320">http://www.w3.org/Bugs/Public/show_bug.cgi?id=10320</A>
</I>
The bug is about the syntax, nor the rendering.

The syntax suggestion makes sense, and I've updated the spec accordingly.

I'm not sure what to do with the rendering. Could you elaborate on why we 
would show the speaker names? Surely it would be better to let authors 
explicitly put in the speaker names in the text of the cue if that's what 
they want.


&gt;<i> At FOMS we had a session on WebSRT which was extremely helpful. It turns 
</I>&gt;<i> out that SRT has more syntax variations than we had thought, kindly 
</I>&gt;<i> pointed out by VLC developer j-b. Even though there is no SRT spec, 
</I>&gt;<i> there is a test suite of sorts that I had never seen before. I'll call 
</I>&gt;<i> SRT which follows the syntax implied by these tests ale5000-SRT. Apart 
</I>&gt;<i> from the HTML-like markup we knew about, ale5000-SRT also has various 
</I>&gt;<i> markup on the form {...} which was borrowed from SSA, as well as \h and 
</I>&gt;<i> \N for &quot;hard space&quot; and line break respectively. Also in the crazy 
</I>&gt;<i> department is that tags which aren't matched with an opening and closing 
</I>&gt;<i> tag should be rendered as plain text. Stray &lt; should also just be 
</I>&gt;<i> displayed as text. VLC actually implements most of this, as does 
</I>&gt;<i> VSFilter, which we should have tested but didn't. It would probably be 
</I>&gt;<i> possible to write a spec for ale5000-SRT, but extensibility would be 
</I>&gt;<i> limited to matched opening and closing tags, which doesn't work for the 
</I>&gt;<i> suggested voices syntax. With this mess, I'd rather not extend 
</I>&gt;<i> ale5000-SRT. I can only agree with Silvia that we should make WebSRT 
</I>&gt;<i> identifiable, so that different parsers can be used.
</I>
Based on this, and as discussed earlier in this e-mail, I've made a number 
of changes to the language, including:

&gt;<i> * Add magic bytes to identify WebSRT, maybe &quot;WebSRT&quot;. (This will break 
</I>&gt;<i> some existing SRT parsers.)
</I>&gt;<i>
</I>&gt;<i> * Make WebSRT always be UTF-8, since you can't reuse existing SRT files 
</I>&gt;<i> anyway.
</I>

&gt;<i> * Note that certain ale5000-SRT syntax is not part of WebSRT, so that 
</I>&gt;<i> one doesn't have to debug the parsing algorithm to learn that.
</I>
Could you suggest some text for this? It's unclear to me exactly what 
would be helpful here. In fact, noting that the language is no longer 
called &quot;SRT&quot;, is this still necessary?


&gt;<i> Styling hooks were requested. If we only have the predefined tags (i, b, 
</I>&gt;<i> ...) and voices, these will most certainly be abused, e.g. resulting in 
</I>&gt;<i> &lt;i&gt; being used where italics isn't wanted or &lt;v Foo&gt; being used just for 
</I>&gt;<i> styling, breaking the accessibility value it has.
</I>
I've added &lt;span&gt; for styling.


&gt;<i> There was also some discussion about metadata. Language is sometimes 
</I>&gt;<i> necessary for the font engine to pick the right glyph.
</I>
Could you elaborate on this? My assumption was that we'd just use CSS, 
which doesn't rely on language for this.


&gt;<i> License is also an often requested piece of metadata.
</I>
That would get solved if we allowed comments, which is how it's solved in 
JS (CSS and HTML don't usually get licensed for some reason). I've punted 
on this for now, so as to not make too many parsing changes at once.


&gt;<i> Finally, some things I think are broken in the current WebSRT parser:
</I>&gt;<i> 
</I>&gt;<i> * Parsing of timestamps is more liberal than it needs to be. In 
</I>&gt;<i> particular, treating the part after the decimal separator as an integer 
</I>&gt;<i> and dividing by 1000 leads to 00:00:00.1 being interpreted as 0.001 
</I>&gt;<i> seconds, which is weird. This is what e.g. VLC does, but if we need to 
</I>&gt;<i> add a header we could just as well change this to make more sane. 
</I>&gt;<i> Alternatively, if we want to really align with C implementations using 
</I>&gt;<i> scanf, we should also handle negative numbers (00:01:-5,000 means 55 
</I>&gt;<i> seconds), octal and hexadecimal.
</I>
Fixed.


&gt;<i> * The current syntax looks like XML or HTML but has very different 
</I>&gt;<i> parsing. Voices like &lt;narrator&gt; don't create nodes at all and for tags 
</I>&gt;<i> like &lt;i&gt; the paser has a whitelist and also special rules for inserting 
</I>&gt;<i> &lt;rt&gt;. Unless there are strong reasons for this, then for simplicity and 
</I>&gt;<i> forward compatibility, I'd much rather have the parser create an actual 
</I>&gt;<i> DOM (not a tree of &quot;WebSRT Node Object&quot;) that reflects the input. If we 
</I>&gt;<i> also support attributes then people who actually want to use their 
</I>&gt;<i> (silly) &lt;font color=red&gt; tags can do so with CSS. This could also work 
</I>&gt;<i> as styling hooks. Obviously, a WebSRT parser should create elements in 
</I>&gt;<i> another namespace, we don't want e.g. &lt;img&gt; to work inside cues.
</I>
I don't think we want to expose an actual DOM, since then people will just 
do things like put &lt;html:video&gt; elements into the DOM, or try to 
document.write() into it, or the like, which is just as bad as doing HTML 
parsing of cues.


&gt;<i> * The &quot;bad cue&quot; handling is stricter than it should be. After collecting 
</I>&gt;<i> an id, the next line must be a timestamp line. Otherwise, we skip 
</I>&gt;<i> everything until a blank line, so in the following the parser would jump 
</I>&gt;<i> to &quot;bad cue&quot; on line &quot;2&quot; and skip the whole cue.
</I>&gt;<i> 
</I>&gt;<i> 1
</I>&gt;<i> 2
</I>&gt;<i> 00:00:00.000 --&gt; 00:00:01.000
</I>&gt;<i> Bla
</I>&gt;<i> 
</I>&gt;<i> This doesn't match what most existing SRT parsers do, as they simply 
</I>&gt;<i> look for timing lines and ignore everything else. If we really need to 
</I>&gt;<i> collect the id instead of ignoring it like everyone else, this should be 
</I>&gt;<i> more robust, so that a valid timing line always begins a new cue. 
</I>&gt;<i> Personally, I'd prefer if it is simply ignored and that we use some form 
</I>&gt;<i> of in-cue markup for styling hooks.
</I>
The IDs are useful for referencing cues from script, so I haven't removed 
them. I've also left the parsing as is for when neither the first nor 
second line is a timing line, since that gives us a lot of headroom for 
future extensions (we can do anything so long as the second line doesn't 
start with a timestamp and &quot;--&gt;&quot; and another timestamp).


&gt;<i> * At the beginning of &quot;cue text loop&quot; (step 28) a newline should be 
</I>&gt;<i> collected.
</I>
Fixed.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029330.html">[whatwg] WebSRT examples for review
</A></li>
	<LI>Next message: <A HREF="071851.html">[whatwg] Timed tracks: feedback compendium
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#71785">[ date ]</a>
              <a href="thread.html#71785">[ thread ]</a>
              <a href="subject.html#71785">[ subject ]</a>
              <a href="author.html#71785">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
