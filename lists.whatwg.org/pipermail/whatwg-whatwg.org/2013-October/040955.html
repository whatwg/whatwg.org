<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Script preloading
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Script%20preloading&In-Reply-To=%3CCE4FB466.72766%25bruno%40hexanet.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="040953.html">
   <LINK REL="Next"  HREF="040957.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Script preloading</H1>
<!--htdig_noindex-->
    <B>Bruno Racineux</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Script%20preloading&In-Reply-To=%3CCE4FB466.72766%25bruno%40hexanet.net%3E"
       TITLE="[whatwg] Script preloading">bruno at hexanet.net
       </A><BR>
    <I>Wed Oct  2 03:22:40 PDT 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="040953.html">[whatwg] Collecting tips for getting involved in web standards
</A></li>
        <LI>Next message: <A HREF="040957.html">[whatwg] High-density canvases
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40955">[ date ]</a>
              <a href="thread.html#40955">[ thread ]</a>
              <a href="subject.html#40955">[ subject ]</a>
              <a href="author.html#40955">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>

On 8/27/13 2:55 PM, &quot;Ian Hickson&quot; &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:

&gt;<i>
</I>&gt;<i>First, let's get down to use cases. Kyle did a great job of describing
</I>&gt;<i>some key use cases:
</I>&gt;<i>
</I>&gt;<i>On Wed, 10 Jul 2013, Kyle Simpson wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [Use-case Q:] I am dynamically loading one of those social widgets
</I>&gt;&gt;<i>that, 
</I>&gt;&gt;<i> upon load, automatically scans a page and renders social buttons. I
</I>&gt;&gt;<i>need 
</I>&gt;&gt;<i> to be able to preload that script so it's ready to execute, but decide
</I>&gt;&gt;<i> when I want it to run against the page. I don't want to wait for true
</I>&gt;&gt;<i> on-demand loading, like when my user clicks a button, because of the
</I>&gt;&gt;<i> loading delay that will be visible to the user, so I want to pre-load
</I>&gt;&gt;<i> that script and have it waiting, ready at a moment's notice to say
</I>&gt;&gt;<i>&quot;it's 
</I>&gt;&gt;<i> ok to execute, do it now! now! now!&quot;.
</I>&gt;<i>
</I>&gt;&gt;<i> [Use-case S:] One CMS plugin wants to load &quot;A.js&quot; and &quot;B.js&quot;, where B
</I>&gt;&gt;<i> relies on A. Both need to load in parallel (for performance), but A
</I>&gt;&gt;<i>must 
</I>&gt;&gt;<i> execute before B executes. I don't control A and B, so changing them is
</I>&gt;&gt;<i> not an option. This CMS plugin [wants] to wait for some
</I>&gt;&gt;<i> user-interaction, such as a button click, before executing the code. We
</I>&gt;&gt;<i> don't want there to be any big network-loading delay visible to the
</I>&gt;&gt;<i>user 
</I>&gt;&gt;<i> between their click of the button and the running of that plugin's code.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Another CMS plugin on this same page wants to load &quot;A.js&quot;, &quot;C.js&quot;, and
</I>&gt;&gt;<i> &quot;D.js&quot;. This plugin doesn't know or care that the other plugin also
</I>&gt;&gt;<i> requests &quot;A.js&quot;. It doesn't know if there is a script element in the
</I>&gt;&gt;<i> page requesting it or not, and it doesn't want to looking for it. It
</I>&gt;&gt;<i> just wants to ask for A as a pre-requisite to C and D. But C and D have
</I>&gt;&gt;<i> no dependency on each other, only a shared dependency on A. C and D
</I>&gt;&gt;<i> should be free to run ASAP (in whichever order), assuming that A has
</I>&gt;&gt;<i> already run [once] some user-interaction that initiates the load of A,
</I>&gt;&gt;<i> C, and D. This user interaction may be before the other plugin
</I>&gt;&gt;<i>requested 
</I>&gt;&gt;<i> A, or after it requested A.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &quot;A.js&quot; can be requested relatively (via a &lt;base&gt; tag or just relative
</I>&gt;&gt;<i>to 
</I>&gt;&gt;<i> document root) or absolutely, or it might be requested with the
</I>&gt;&gt;<i> leading-// protocol-relative from, taking on whatever http or https
</I>&gt;&gt;<i> protocol the page has, whereas other references to it may specify the
</I>&gt;&gt;<i> prototcol.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> These plugins can't guarantee what ID's or classes they use are
</I>&gt;&gt;<i>reliably 
</I>&gt;&gt;<i> unique without undue processing burden.
</I>&gt;<i>
</I>&gt;<i>[I've trimmed the text Kyle wrote here, but also implicit in his
</I>&gt;<i>description, as I understood it, was that A.js should only run once even
</I>&gt;<i>if both plugins tried to load it.]
</I>&gt;<i>
</I>&gt;&gt;<i> [Use-case T:] I have two different calendar widgets. I want to pop one
</I>&gt;&gt;<i> of them up when a user clicks a button. The user may never click the
</I>&gt;&gt;<i> button, in which case I don't want the calendar widget to have ever
</I>&gt;&gt;<i> executed to render. [...]
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> It'd be nice if both calendar widgets were built sensibly so that
</I>&gt;&gt;<i> loading the code didn't automatically render. One of them IS, the other
</I>&gt;&gt;<i> is unfortunately mis-behaving, and it will render itself as soon as its
</I>&gt;&gt;<i> code is run. [...]
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Furthermore, these two widgets are not &quot;equal&quot;. Perhaps one is better
</I>&gt;&gt;<i> for smaller browser window sizes, and the other is better for larger
</I>&gt;&gt;<i> browser windows. [...]
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Regardless, the point is, there's run-time conditions which are going
</I>&gt;&gt;<i>to 
</I>&gt;&gt;<i> determine if I want to execute calendar widget A or B, or maybe I never
</I>&gt;&gt;<i> execute either. But I want them both preloaded and ready to go, just in
</I>&gt;&gt;<i> case, so that if the user DOES need one, it's free and ready to execute
</I>&gt;&gt;<i> with nearly no delay, instead of having to wait to request as I would
</I>&gt;&gt;<i> with only on-demand techniques.
</I>&gt;<i>
</I>&gt;&gt;<i> [Use-case U:] I have a set of script &quot;A.js&quot;, &quot;B.js&quot;, and &quot;C.js&quot;. B
</I>&gt;&gt;<i> relies on A, and C relies on B. So they need to execute strictly in
</I>&gt;&gt;<i>that 
</I>&gt;&gt;<i> order. [Now], imagine they progressively render different parts of a
</I>&gt;&gt;<i> widget. [...] I only want to execute A, B and C once all 3 are
</I>&gt;&gt;<i>preloaded 
</I>&gt;&gt;<i> and ready to go. It's [...] about minimizing delays between them, for
</I>&gt;&gt;<i> performance PERCEPTION.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [For example, one of them might start playing a video, and another
</I>&gt;&gt;<i>might 
</I>&gt;&gt;<i> introduce the &lt;canvas&gt; slides for that video. You want all of the
</I>&gt;&gt;<i> relevant scripts to be run at once, so there's no point where the page
</I>&gt;&gt;<i> has a &lt;video&gt; element but doesn't have the &lt;canvas&gt;.]
</I>&gt;<i>
</I>&gt;<i>On Thu, 11 Jul 2013, Kyle Simpson wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> [Use-case V:] you have a string of scripts (&quot;A.js&quot;, &quot;B.js&quot;, and &quot;C.js&quot;)
</I>&gt;&gt;<i> loading which constitute a dependency chain. A must run before B, which
</I>&gt;&gt;<i> must run before C. However, if you detect an error in loading, you stop
</I>&gt;&gt;<i> the rest of the executions (and preferably loading too!), since clearly
</I>&gt;&gt;<i> dependencies will fail for further scripts, and the errors will just
</I>&gt;&gt;<i> unnecessarily clutter the developer console log making it harder to
</I>&gt;&gt;<i> debug.
</I>&gt;<i>
</I>&gt;&gt;<i> [Use-case W:] some developers have even requested to be able to stop
</I>&gt;&gt;<i>the 
</I>&gt;&gt;<i> chain and prevent further executions if the script loads, but there's
</I>&gt;&gt;<i> some compile-time syntax error or run-time error that happens during
</I>&gt;&gt;<i>the 
</I>&gt;&gt;<i> execution. For them, it's not enough for B to simply finish loading
</I>&gt;&gt;<i> successfully, but that it must fully execute without error.
</I>&gt;<i>
</I>&gt;<i>On Sun, 14 Jul 2013, Kornel Lesi&#324;ski wrote (trimmed):
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> [Use-case X:] not all dependencies are JS files, e.g. authors use
</I>&gt;&gt;<i> plugins to load template files, JSON, images, etc.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> [Use-case Y:] not all dependencies are usefully satisfied immediately
</I>&gt;&gt;<i> after their JS file is loaded, e.g. some libraries may need
</I>&gt;&gt;<i>asynchronous 
</I>&gt;&gt;<i> initialization.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [Use-case Z:] Another common kind of dependency scripts have is
</I>&gt;&gt;<i>presence 
</I>&gt;&gt;<i> of certain element in the DOM, e.g. `dropdown-menu.js` may require
</I>&gt;&gt;<i>`&lt;nav 
</I>&gt;&gt;<i> id=&quot;menu&quot;&gt;` to be in the document _and_ have its content fully parsed
</I>&gt;&gt;<i> before the script can run.
</I>&gt;<i>
</I>&gt;<i>These use cases are all very helpful. Thanks.
</I>&gt;<i>
</I>&gt;<i>Jake also mentioned these requirements:
</I>&gt;<i>
</I>&gt;|<i> - Provides an adoption path for browsers that don't support the new
</I>&gt;|<i>   feature (happy for the fallback to be blocking document-order
</I>&gt;|<i>   execution)
</I>&gt;|<i> - Is discoverable by pre-parsers (so async=false and old-IE's
</I>&gt;|<i>   readystate methods aren't enough)
</I>&gt;<i>
</I>&gt;<i>And Kyle mentioned this scenario that we need to handle as well (not
</I>&gt;<i>strictly a use case, more a variant on the above use cases):
</I>&gt;<i>
</I>&gt;&gt;<i> I want to preload a script which is hosted somewhere that I don't
</I>&gt;&gt;<i> control caching headers, and to my dismay, I discover that they are
</I>&gt;&gt;<i> serving the script with incorrect/busted/missing caching headers.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Tue, 9 Jul 2013, Kyle Simpson wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I think it's important to note that the primary motivation here is
</I>&gt;&gt;<i> performance.
</I>&gt;<i>
</I>&gt;<i>The primary motivation is running scripts. Performance is just something
</I>&gt;<i>we want all features to have, like security, accessibility, usability,
</I>&gt;<i>support for all locales, etc.
</I>&gt;<i>
</I>&gt;<i>Incidentally, I don't think the use case is or should be &quot;make it
</I>&gt;<i>possible 
</I>&gt;<i>to write a performant script loading library&quot;. I think the use case
</I>&gt;<i>should 
</I>&gt;<i>be more like &quot;make it unnecessary to ever write a script loading library&quot;.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Tue, 9 Jul 2013, Kyle Simpson wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> But even if we standardized a third option, and I had to change LABjs,
</I>&gt;&gt;<i> that would be FAR BETTER in my mind than never addressing this use case
</I>&gt;&gt;<i> at all, especially in light of IE11 sort of retreating on this topic
</I>&gt;&gt;<i> (either intentionally or not).
</I>&gt;<i>
</I>&gt;<i>I think the ideal solution would obsolete LABjs, no?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Thu, 11 Jul 2013, Jake Archibald wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> link[rel=subresource] is the right solution for preloading [...]
</I>&gt;<i>
</I>&gt;<i>I don't know about that. It makes for rather verbose script just to load
</I>&gt;<i>scripts, which seems like a loss. Surely script loading should just
</I>&gt;<i>happen 
</I>&gt;<i>without having to write extra script to do it.
</I>
I agree on the verbosity with the double markup. It feels redundant.
But perhaps so is the repeat of the script name with 'needs=&quot;A.js&quot;' for
every script that would need a dependency.

&gt;<i>
</I>&gt;<i>All of the solutions proposed so far either entirely fail to handle some
</I>&gt;<i>of the use cases, or only support them to the extent that they provide
</I>&gt;<i>some tools with which you can implement scripts that handle the use cases.
</I>&gt;<i>
</I>&gt;<i>IMHO, if you have to write a script to solve use cases like these, you
</I>&gt;<i>haven't really solved the use cases. It seems that the opportunity we
</I>&gt;<i>have 
</I>&gt;<i>here is to provide a feature or set of features that addresses these use
</I>&gt;<i>cases directly, so that anyone can use them without much work.
</I>
Well fair enough from a purely hand written static page sense.

Note that the w3c proposal has now evolved with 2 new attributes:
lazyload+postpone
<A HREF="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overvi">https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/ResourcePriorities/Overvi</A>
ew.html#lazyload-attribute

I think a 'preload' addition could very well answer the 'when-needed' part.
I'll try to put an example below.

Either way, it's worth keeping in mind that those two specs have to
seemingly work together without conflict between the two.

&gt;<i>
</I>&gt;<i>On Thu, 11 Jul 2013, Yoav Weiss wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I've recently contemplated the slightly related issue of adding the
</I>&gt;&gt;<i> &quot;media&quot; attribute to &lt;script&gt;, for declarative loading of scripts that
</I>&gt;&gt;<i> are only relevant to some viewports [1] While it may complicate certain
</I>&gt;&gt;<i> things (e.g. execution when media conditions change, dependencies), I
</I>&gt;&gt;<i> believe it's worth while to give it some thought, as it'd enable
</I>&gt;&gt;<i> preloaders to fetch these scripts as soon as possible, in case they are
</I>&gt;&gt;<i> needed.
</I>&gt;<i>
</I>&gt;<i>How common are media-specific scripts?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Mon, 15 Jul 2013, Bruno Racineux wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Wouldn't browsers be able to store &quot;pre-parsed/compiled' scripts in a
</I>&gt;&gt;<i> separate &quot;byte code&quot; cache, with scripts promoted to the sticky cache
</I>&gt;&gt;<i> based on their access frequency (up to cache expiration)? Say similarly
</I>&gt;&gt;<i> to the way Fusion Drives or Seagate Adaptive Memory SSHDs work.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> i.e. Why do we have to keep re-parsing and re-evaluating the very same
</I>&gt;&gt;<i> scripts, especially CDN libraries and social apis largely shared among
</I>&gt;&gt;<i> websites, over and over?
</I>&gt;<i>
</I>&gt;<i>Fundamentally the problem is that they're often not exactly the very same
</I>&gt;<i>scripts, so the wins aren't as great as you might think.
</I>&gt;<i>
</I>&gt;<i>But there's nothing stopping browsers from doing this today. File bugs
</I>&gt;<i>with browsers. :-)
</I>
Well browsers now do it, but on the different basis. My approach was to
compile entire scripts vs functions bodies as it's apparently currently
done.

&gt;<i>
</I>&gt;&gt;<i> If javascript can't be as truly fast a native apps:
</I>&gt;&gt;<i> <A HREF="http://sealedabstract.com/rants/why-mobile-web-apps-are-slow/">http://sealedabstract.com/rants/why-mobile-web-apps-are-slow/</A> It seems
</I>&gt;&gt;<i> that for frequently visited sites and frequently accessed libraries
</I>&gt;&gt;<i> across websites, the whole parse/evaluation time, could be cut
</I>&gt;&gt;<i> 'partially', yet very significantly, just like opcode does for php.
</I>&gt;<i>
</I>&gt;<i>The article you cite basically answers your question: the problem isn't
</I>&gt;<i>downloading and compiling the scripts, the problem is garbage collection
</I>&gt;<i>and other intrinsic aspects of the JavaScript language and the rest of
</I>&gt;<i>the 
</I>&gt;<i>Web platform.
</I>
Nods. But if recompiling or looking up script+chars pairs are much slower
than deserializing a compiled representation of an entire scripts,
it might be worth considering down the road...

&gt;<i>
</I>&gt;<i>On Tue, 9 Jul 2013, Garrett Smith wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Why limit &quot;depends&quot; to be used by only scripts to refer only to other
</I>&gt;&gt;<i> scripts?
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> If you put &lt;link depends=idref&gt; on style then stylesheet evaluation
</I>&gt;&gt;<i> could be deferred, too.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I explained some cases about why this is desirable here:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i><A HREF="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-February/018435.">http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-February/018435.</A>
</I>&gt;&gt;<i>html
</I>&gt;<i>
</I>&gt;<i>I responded to that e-mail here:
</I>&gt;<i>
</I>&gt;<i><A HREF="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-February/018542.h">http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-February/018542.h</A>
</I>&gt;<i>tml
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Tue, 9 Jul 2013, Bruno Racineux wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why not simply load all such scripts early in the &lt;head&gt; with 'defer',
</I>&gt;&gt;<i> which preserves the dependency order as determined by your app. Using
</I>&gt;&gt;<i> 'defer' in head scripts is actually a very good way to preserve script
</I>&gt;&gt;<i> order with non-blocking scripts. And by loading the scripts very early
</I>&gt;&gt;<i> in the &lt;head&gt;, the possibility of a incurred significant delay of
</I>&gt;&gt;<i> DOMContentLoaded, for an eventual large script not yet downloaded, is
</I>&gt;&gt;<i> minimal to none.
</I>&gt;<i>
</I>&gt;<i>This doesn't seem like it handles all the use cases (e.g. T and U).
</I>
Right.

&gt;<i>
</I>&gt;&gt;<i> I would also strongly favor restoring the previous spec portion of
</I>&gt;&gt;<i> 'defer' which allow to have defer on inline script blocks (i.e. if the
</I>&gt;&gt;<i> src attribute is not present). I don't know why this html4
</I>&gt;&gt;<i>functionality 
</I>&gt;&gt;<i> was removed from html5?
</I>&gt;<i>
</I>&gt;<i>Well, primarily because basically nobody implemented it, but also,
</I>&gt;<i>because 
</I>&gt;<i>it's not clear what the point is. Why would you need it?
</I>
Well for one, many inline functions have no need to run before
'interactive' fires. A delay or 'promise' at this stage is too early and
rarely makes sense. Currently most common domReady hooks rely on
DOMContentLoaded.
As such I see no very good reason to run such plugin code prior to
DOMContentLoaded.

e.g I want to defer jQuery and I want my small inline script events (based
on the context of a page) parsed and run post jQuery, right after
DOMContentLoaded fires.
That priority level is something that cannot be done right now.


&gt;<i>
</I>&gt;&gt;<i> I see use cases which would give much more flexibility with
</I>&gt;&gt;<i>dependencies 
</I>&gt;&gt;<i> (such as putting jquery on 'defer' in the head with inline 'defer'
</I>&gt;&gt;<i> jquery functions) and possibly even improving performance significantly.
</I>&gt;<i>
</I>&gt;<i>Why not just wait for jQuery to say it's loaded, and then run whatever
</I>&gt;<i>scripts depend on jQuery?
</I>
Because for inline script, it implies registering onReady promises early
(knowing fairly well that jQuery is not ready) and having javascript do
more than it should.

Aside from the IE6-9 Defer bug, which made 'ordered defer' somewhat
useless until IE10, 'ordered defer' is a useful flexibility for the future.


&gt;<i>
</I>&gt;&gt;<i> Back to the initial question from my rant. While there is a use case
</I>&gt;&gt;<i>for 
</I>&gt;&gt;<i> not downloading or executing scripts until needed, this can somewhat
</I>&gt;&gt;<i> already be dealt with using ajax or the post-eval method google uses.
</I>&gt;&gt;<i>Or 
</I>&gt;&gt;<i> perhaps this script execution hold could be an ajax only solution, with
</I>&gt;&gt;<i> a no-execute-yet property and a pure javascript behavior, rather than
</I>&gt;&gt;<i> also implicate DOM attributes into this.
</I>&gt;<i>
</I>&gt;<i>Such solutions are somewhat unsatisfactory. A dedicated solution would be
</I>&gt;<i>easier to use and less confusing.
</I>
I agree, I just find the proposed solution slightly convoluted.
And I still think that some of this stuff is best handled via js objects
and functions.

The main part I would want the DOM to do is to hold 'execute' and give me
a very simple way to run the script at will, which link[rel=subresource]
doesn't do or address too well either.

Also something that makes me cringe, is the verbose repeat of long paths
(just like srcset does)

If you need dependencies, then how about something shorter like a
dependency 
Index, with a 'preload' semantic on top of the lazyload+postpone proposal,
like:

&lt;script src=&quot;jquery.js&quot; preload branch=&quot;A1&quot;&gt;
&lt;script src=&quot;plugin1.js&quot; preload branch=&quot;A2&quot;&gt;

&lt;script src=&quot;plugin2.js&quot; preload branch=&quot;A2&quot;&gt;

&lt;script&gt;
	E('plugin2.js');
&lt;/script&gt;

i.e. The browser would takes the letter as indicator of a dependency tree
branch,
and follow along it's priority number to determine the dependencies to
load when-needed.
Or perhaps using the id attribute with the letter+number syntax form.


&gt;<i>
</I>&gt;<i>On Wed, 10 Jul 2013, Bruno Racineux wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think the very idea of having the concept of 'dependency' attributes
</I>&gt;&gt;<i> and relying or asking to the browser to handle it through markup is
</I>&gt;&gt;<i> misguided.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is somehow throwing the entire (or a portion of) dependency
</I>&gt;&gt;<i> information of your platform, asking the browser to deal with it. I can
</I>&gt;&gt;<i> already imagine bloated pages with an entire set of script markup,
</I>&gt;&gt;<i> bigger than that of the page itself. That's not very good for
</I>&gt;&gt;<i> performance.
</I>&gt;<i>
</I>&gt;<i>I don't understand. Can you elaborate on this? Why is it misguided?
</I>
My worry with this, is a performance caveat and potential increasing bloat
in pages,
vs properly isolating what's needed on a per page basis. Platform like
wordpress or drupal, or poorly written plugins in any platform, already
too often add scripts globally to all pages, making pages an increasing
piece of FUBAR script bloat.
With the 'whenneeded' concept, it can become quite tempting to put many
many scripts in the DOM without any guilt, or any sensible notion of
wether it's actually needed or not for a particular page.

&gt;<i>
</I>&gt;&gt;<i> I think Kyle has given more than enough substantiated arguments in:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i><A HREF="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2013-July/039981.html">http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2013-July/039981.html</A>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> not to have me repeat them.
</I>&gt;<i>
</I>&gt;<i>These use cases don't suggest that the browser shouldn't solve them, on
</I>&gt;<i>the contrary.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Mon, 15 Jul 2013, Kornel Lesi&#324;ski wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> ES6 modules[1] have a script loader API[2].
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> That API is pretty powerful to the point it can emulate other script
</I>&gt;&gt;<i> loaders, load files that are not ES6 modules, and even load text files
</I>&gt;&gt;<i> that aren't JS (intended for compilation of coffeescript-like
</I>&gt;&gt;<i>languages, 
</I>&gt;&gt;<i> but could be abused for anything):
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i><A HREF="https://gist.github.com/wycats/51c96e3adcdb3a68cbc3#using-existing-librar">https://gist.github.com/wycats/51c96e3adcdb3a68cbc3#using-existing-librar</A>
</I>&gt;&gt;<i>ies-as-modules
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> There's a very high overlap between module dependencies and &lt;script
</I>&gt;&gt;<i> dependencies&gt; proposal. I think at very least it would be useful to
</I>&gt;&gt;<i> define &lt;script dependencies&gt; in terms of ES6 modules, or even abandon
</I>&gt;&gt;<i> markup solution to avoid duplicating features.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> ES6 modules however do not solve the performance problem. In fact they
</I>&gt;&gt;<i> would benefit from UA having a list of all dependencies up front
</I>&gt;&gt;<i> (otherwise file's dependencies can only be discovered after that file
</I>&gt;&gt;<i>is 
</I>&gt;&gt;<i> loaded, which costs as many RTTs as the height of the dependency tree).
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> So I think that eventually ES6 modules + link[rel=subresource] could be
</I>&gt;&gt;<i> the answer. The &lt;link&gt; would expose URLs to (pre)load for performance,
</I>&gt;&gt;<i> but modules would handle actual loading/execution for flexibility and
</I>&gt;&gt;<i> reliability.
</I>&gt;<i>
</I>&gt;<i>The ES6 module doesn't address some of the use cases above, as far as I
</I>&gt;<i>can tell (e.g. Q, U) and require a lot of work to handle some of the
</I>&gt;<i>others. But it seems important that anything we add to HTML be designed
</I>&gt;<i>to 
</I>&gt;<i>work with ES6 modules on the long run.
</I>&gt;<i>
</I>&gt;<i>(I'm assuming the current state of this is:
</I>&gt;<i>
</I>&gt;<i>   <A HREF="http://wiki.ecmascript.org/doku.php?id=harmony:modules">http://wiki.ecmascript.org/doku.php?id=harmony:modules</A>
</I>&gt;<i>   <A HREF="http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders">http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders</A>
</I>&gt;<i>
</I>&gt;<i>...but that seems to have changed some since wycats' proposal above.)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Mon, 22 Jul 2013, Jonas Sicking wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> [...] adding a &quot;noexecute&quot; attribute on the &lt;script&gt; element which
</I>&gt;&gt;<i> causes the script element not to execute when it normally would.
</I>&gt;&gt;<i>Instead 
</I>&gt;&gt;<i> it fires the &quot;load&quot; event when the script has been loaded and does
</I>&gt;&gt;<i> nothing more.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Once the page wants the script to execute, it would call a new
</I>&gt;&gt;<i> .execute() function on the script which would cause the loaded script
</I>&gt;&gt;<i>to 
</I>&gt;&gt;<i> execute. If the function is called before the load event has fired, an
</I>&gt;&gt;<i> InvalidStateError exception would be thrown.
</I>&gt;<i>
</I>&gt;<i>This doesn't seem like it would address many of the use cases, at least
</I>&gt;<i>not without a bunch more supporting code. It also doesn't seem like it
</I>&gt;<i>would really coordinate well with ES6 modules (unless there was some way
</I>&gt;<i>to say &quot;by the way, this script implement that module&quot; or something, with
</I>&gt;<i>'import' being able to essentially automatically invoke &quot;execute()&quot;).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Mon, 22 Jul 2013, Kyle Simpson wrote:
</I>&gt;&gt;<i> Jonas wrote about JS error conditions:
</I>&gt;&gt;<i> &gt; 
</I>&gt;&gt;<i> &gt; 1. Failed network request
</I>&gt;&gt;<i> &gt; 2. Failed JS compilation
</I>&gt;&gt;<i> &gt; 3. Exception thrown from execution
</I>&gt;&gt;<i> &gt; 
</I>&gt;&gt;<i> &gt; And there are two error reporting mechanisms in play
</I>&gt;&gt;<i> &gt; 
</I>&gt;&gt;<i> &gt; A. Fire an &quot;error&quot; event on the &lt;script&gt; element.
</I>&gt;&gt;<i> &gt; B. Fire the window.onerror callback (like an event, but not exactly
</I>&gt;&gt;<i>the same).
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Agreed. `window.onerror` serves fine case #3. What we don't seem to
</I>&gt;&gt;<i>have 
</I>&gt;&gt;<i> as consistent cross-browser behavior, or even terribly well defined in
</I>&gt;&gt;<i> the spec, is #1 and #2, especially #1. Various older browsers had
</I>&gt;&gt;<i> different interpretations as to which network conditions constituted
</I>&gt;&gt;<i> &quot;load complete&quot; or not.
</I>&gt;<i>
</I>&gt;<i>Can you elaborate on what is underdefined about this in the spec?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Mon, 22 Jul 2013, Jonas Sicking wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> In the noexecute proposal I believe that .execute() would be a
</I>&gt;&gt;<i> synchronous operation. Though we could change it to be an asynchronous
</I>&gt;&gt;<i> operation if that's desired.
</I>&gt;<i>
</I>&gt;<i>It's not clear to me how script execution in the ES6 Module Loader world
</I>&gt;<i>works when it's asynchronous. As in, if you document.appendChild() an
</I>&gt;<i>inline script that has a dependency, does the calling script resume
</I>&gt;<i>executing before the inner script? Or does it block on the network like a
</I>&gt;<i>synchronous XHR?
</I>&gt;<i>
</I>&gt;<i>(I spoke with wycats and he tells me there'll be spec hooks I use in HTML
</I>&gt;<i>to invoke JS' loading logic so that in this case we'd use evalAsync and
</I>&gt;<i>it 
</I>&gt;<i>would throw SyntaxError. Similar hooks will be available to make sure we
</I>&gt;<i>use fetch.spec.whatwg.org for the loading logic.)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Wed, 10 Jul 2013, Jake Archibald wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> If &quot;dependencies&quot; took a CSS selector it could be:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> &lt;script dependencies=&quot;.cms-core&quot; src=&quot;cmd-plugin.js&quot;&gt;&lt;/script&gt;
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Now the number of scripts with class &quot;cms-core&quot; can change between
</I>&gt;&gt;<i> versions of the CMS but the plugin still waits for them all. No ID
</I>&gt;&gt;<i> generation needed.
</I>&gt;<i>
</I>&gt;<i>Using a selector is an interesting idea.
</I>&gt;<i>
</I>&gt;<i>It makes it harder to detect and prevent loops, but not fatally so.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Wed, 10 Jul 2013, Kyle Simpson wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Imagine this scenario: I load jquery.js and 4 other plugins. I could
</I>&gt;&gt;<i> either mark the 4 plugin script tags with &quot;depends on jquery&quot;, or I
</I>&gt;&gt;<i> could mark the one jquery element as &quot;fullfills these 4 plugins&quot;. The
</I>&gt;&gt;<i> latter is simpler because it requires less markup in general.
</I>&gt;<i>
</I>&gt;<i>That's somewhat backwards from normal programming practices, though.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Here's a proposal that attempts to address all the use cases:
</I>&gt;<i>
</I>&gt;<i>High-level overview:
</I>&gt;<i>
</I>&gt;<i>  &lt;script&gt; elements get a new whenneeded=&quot;&quot; attribute, which delays the
</I>&gt;<i>  execution of the script until the &lt;script&gt; element's execute() method
</I>&gt;<i>is 
</I>&gt;<i>  called. (This essentially provides the same as the &quot;preload&quot;
</I>&gt;<i>  suggestions.)
</I>&gt;<i>
</I>&gt;<i>  &lt;script&gt; elements also get a new needs=&quot;&quot; attribute, which takes a list
</I>&gt;<i>  of URLs. A &lt;script&gt; won't run (even if you call execute()) until all
</I>&gt;<i>the 
</I>&gt;<i>  &lt;script src=&quot;&quot;&gt; elements referenced by its needs=&quot;&quot; attribute are
</I>&gt;<i>  themselves ready to run. For example:
</I>&gt;<i>
</I>&gt;<i>     &lt;script src=&quot;b.js&quot; needs=&quot;a.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>     &lt;script src=&quot;a.js&quot; async&gt;&lt;/script&gt;
</I>&gt;<i>
</I>&gt;<i> ...will execute a.js when it's ready, and only then execute b.js.
</I>&gt;<i>&quot;needs&quot; 
</I>&gt;<i> basically implies &quot;async&quot; if its needs aren't met when it first tries to
</I>&gt;<i>run.
</I>&gt;<i>
</I>&gt;<i> &lt;script whenneeded=&quot;jit&quot;&gt; is a special mode where instead of running
</I>&gt;<i>once 
</I>&gt;<i> the script's dependencies are met, it additionally waits until all the
</I>&gt;<i> scripts that depend on _it_ are ready to run. (&quot;Just in time&quot; exection.)
</I>&gt;<i> (The default is whenneeded=asap, &quot;as soon as possible&quot; exection.)
</I>&gt;<i>
</I>&gt;<i> You can manually increase or decrease a dependency count on &lt;script&gt;
</I>&gt;<i> elements by calling incDependencies() and decDependencies().
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Details (tersely):
</I>&gt;<i>
</I>&gt;<i>  scripts have a &quot;whenneeded&quot; mode, initially &quot;none&quot;, can also be &quot;asap&quot;,
</I>&gt;<i>&quot;jit&quot;.
</I>&gt;<i>  scripts have a &quot;ready&quot; flag, initially false
</I>&gt;<i>  scripts have a &quot;needed&quot; flag, initially false.
</I>&gt;<i>  scripts have an &quot;already ran&quot; flag, initially false.
</I>&gt;<i>  scripts have an external dependency count, initially zero.
</I>&gt;<i>  documents have the following registries:
</I>&gt;<i>     url -&gt; script element (script registry)
</I>&gt;<i>     script element -&gt; scripts that this script depends on (dependencies)
</I>&gt;<i>  when a script element is removed from the document, it's removed from
</I>&gt;<i>the 
</I>&gt;<i>  registries (ES6 module registry also).
</I>&gt;<i>
</I>&gt;<i>  &lt;script&gt; gets attributes:
</I>&gt;<i>     whenneeded=&quot;&quot;: enumerated attribute, &quot;asap&quot; (invalid), &quot;jit&quot;, none
</I>&gt;<i>(missing)
</I>&gt;<i>     needs=&quot;&quot;: space-separated list of URLs
</I>&gt;<i>     module=&quot;&quot;: name of module for ES6
</I>&gt;<i>
</I>&gt;<i>  definitions:
</I>&gt;<i>    a script elemen tA &quot;depends&quot; on a script element B with URL C if B is
</I>&gt;<i>      the &lt;script&gt; element registered as the &lt;script&gt; for URL C
</I>&gt;<i>    &quot;a script element's dependencies have been met&quot; when:
</I>&gt;<i>      - each script element that it depends on also matches this, and
</I>&gt;<i>      - there are no entries in the dependency registry for the element
</I>&gt;<i>        that don't correspond to &lt;script&gt;s in the script registry
</I>&gt;<i>      - this script is &quot;ready&quot; and
</I>&gt;<i>      - this script's external dependency count is zero
</I>&gt;<i>    &quot;a script is ready to run&quot; when:
</I>&gt;<i>      - it's dependencies have been met, and
</I>&gt;<i>      - it's &quot;whenneeded&quot; mode is &quot;asap&quot; or missing,
</I>&gt;<i>        or, it's &quot;jit&quot; and all of the scripts that depend on it are
</I>&gt;<i>           either ready to run, or not needed
</I>&gt;<i>
</I>&gt;<i>  &quot;prepare a script&quot; modifications:
</I>&gt;<i>     immediately before the step that today invokes fetch, add these
</I>&gt;<i>steps:
</I>&gt;<i>      0. look up the resolved url in the document's registry. if there's
</I>&gt;<i>an 
</I>&gt;<i>         entry already, abort these steps otherwise, add this script
</I>&gt;<i>element 
</I>&gt;<i>         with this resolved url
</I>&gt;<i>     immediately before the final step, add:
</I>&gt;<i>      0. if there's a module=&quot;&quot; attribute, add this script as a module
</I>&gt;<i>         to the ES6 module registry, and make the logic that imports the
</I>&gt;<i>         module call execute() on the &lt;script&gt; block
</I>&gt;<i>      0. if the element has a &quot;whenneeded&quot; attribute:
</I>&gt;<i>           - set &quot;whenneeded&quot; mode to state of attribute (asap/jit)
</I>&gt;<i>      0. if the element has a &quot;needs&quot; attribute, split it on spaces, and
</I>&gt;<i>         for each value:
</I>&gt;<i>           0. resolve it relative to the element
</I>&gt;<i>           0. add an entry to the dependencies registry, this script
</I>&gt;<i>              is dependant on that one
</I>&gt;<i>               - use the order of the entries in the needs=&quot;&quot; attribute
</I>&gt;<i>
</I>&gt;<i>  &quot;execute a script block&quot; modifications:
</I>&gt;<i>     Change the &quot;If the load was successful&quot; branch to do this instead:
</I>&gt;<i>      0. mark self as &quot;ready&quot;
</I>&gt;<i>      0. check if we need to run
</I>&gt;<i>     ...and move the current steps into a separate &quot;run&quot; algorithm.
</I>&gt;<i>
</I>&gt;<i>  &quot;check if we need to run&quot;:
</I>&gt;<i>    0. if &quot;whenneeded&quot; is not &quot;none&quot; and &quot;needed&quot; is not true, abort
</I>&gt;<i>    0. if the script is not ready to run, abort
</I>&gt;<i>    0. if the script did not already run:
</I>&gt;<i>        0. mark this script as &quot;already ran&quot;
</I>&gt;<i>        0. for each script that this one depends on and whose
</I>&gt;<i>&quot;whenneeded&quot; 
</I>&gt;<i>           mode is &quot;jit&quot;, check if it needs to run
</I>&gt;<i>        0. run
</I>&gt;<i>    0. if we're still ready to run:
</I>&gt;<i>       for each script that depends on this one, check if it needs to run
</I>&gt;<i>
</I>&gt;<i>  &lt;script&gt; gets a method, execute():
</I>&gt;<i>    0. mark as needed
</I>&gt;<i>    0. call execute() on each script we depend on
</I>&gt;<i>    0. if we didn't depend on any, check if we need to run
</I>&gt;<i>
</I>&gt;<i>  &lt;script&gt; gets a pair of methods, incDependencies() and
</I>&gt;<i>decDependencies(),
</I>&gt;<i>  that increase and decrease the dependency count by one, respectively
</I>&gt;<i>  decDependencies() throws if called when the count is zero. If
</I>&gt;<i>  decDependencies() is called and it reduces the number to zero,
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Here's what the use cases would look like (the function E() returns an
</I>&gt;<i>element with the given attributes):
</I>&gt;<i>
</I>&gt;<i>   Q:
</I>&gt;<i>   &lt;script id=&quot;social&quot; src=&quot;social-button.js&quot; whenneeded&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;button onmouseover=&quot;document.scripts.social.execute()&quot;&gt; ... &lt;/button&gt;
</I>&gt;<i>
</I>&gt;<i>   S:
</I>&gt;<i>   // CMS plugin 1
</I>&gt;<i>   var A = E('script', { src: 'A.js', whenneeded: true });
</I>&gt;<i>   var B = E('script', { src: 'B.js', needs: 'A.js', whenneeded: true });
</I>&gt;<i>   document.body.append(A, B);
</I>&gt;<i>   function sawUserInteraction() {
</I>&gt;<i>     B.execute();
</I>&gt;<i>   };
</I>&gt;<i>   // CMS plugin 2
</I>&gt;<i>   var A = E('script', { src: 'A.js', whenneeded: true });
</I>&gt;<i>   var C = E('script', { src: 'C.js', needs: 'A.js', whenneeded: true });
</I>&gt;<i>   var D = E('script', { src: 'D.js', needs: 'A.js', whenneeded: true });
</I>&gt;<i>   document.body.append(A, C, D);
</I>&gt;<i>   function sawUserInteraction() {
</I>&gt;<i>     C.execute();
</I>&gt;<i>     D.execute();
</I>&gt;<i>   };
</I>&gt;<i>
</I>&gt;<i>   T:
</I>&gt;<i>   &lt;script id=calA src=&quot;a.js&quot; whenneeded&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script id=calB src=&quot;b.js&quot; whenneeded&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script&gt;
</I>&gt;<i>    function showCalendar(which) {
</I>&gt;<i>      if (which == 'a')
</I>&gt;<i>        document.scripts.calA.execute();
</I>&gt;<i>      else
</I>&gt;<i>        document.scripts.calB.execute();
</I>&gt;<i>    }
</I>&gt;<i>   &lt;/script&gt;
</I>&gt;<i>
</I>&gt;<i>   U:
</I>&gt;<i>   &lt;script src=&quot;A.js&quot; whenneeded=jit&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script src=&quot;B.js&quot; whenneeded=jit needs=&quot;A.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script id=c src=&quot;C.js&quot; whenneeded=jit needs=&quot;B.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script&gt;
</I>&gt;<i>    // when we need it...
</I>&gt;<i>    document.scripts.c.execute();
</I>&gt;<i>   &lt;/script&gt;
</I>&gt;<i>
</I>&gt;<i>   V:
</I>&gt;<i>   &lt;script src=&quot;A.js&quot; whenneeded&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script src=&quot;B.js&quot; whenneeded needs=&quot;A.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script id=c src=&quot;C.js&quot; whenneeded needs=&quot;B.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script&gt;
</I>&gt;<i>    onerror = function (message, source, lineno, colno, error) {
</I>&gt;<i>      // report error
</I>&gt;<i>    }
</I>&gt;<i>    // when we need it...
</I>&gt;<i>    document.scripts.c.execute();
</I>&gt;<i>   &lt;/script&gt;
</I>&gt;<i>
</I>&gt;<i>   W:
</I>&gt;<i>   &lt;script src=&quot;A.js&quot; whenneeded&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script src=&quot;B.js&quot; whenneeded needs=&quot;A.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script id=c src=&quot;C.js&quot; whenneeded needs=&quot;B.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script&gt;
</I>&gt;<i>    // when we need it...
</I>&gt;<i>    onerror = function (message, source, lineno, colno, error) {
</I>&gt;<i>      document.currentScript.incDependencies();
</I>&gt;<i>      // since the dependency count is never reduced, the script blocks
</I>&gt;<i>      // all the scripts that depend on it forever
</I>&gt;<i>    }
</I>&gt;<i>    document.scripts.c.execute();
</I>&gt;<i>    onerror = null;
</I>&gt;<i>   &lt;/script&gt;
</I>&gt;<i>
</I>&gt;<i>   X:
</I>&gt;<i>   &lt;script src=&quot;deps.js&quot; async&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script src=&quot;build.js&quot; needs=&quot;deps.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>   // in deps.js:
</I>&gt;<i>   var me = document.currentScript;
</I>&gt;<i>   me.incDependencies();
</I>&gt;<i>   var image = new Image();
</I>&gt;<i>   image.src = 'image.png';
</I>&gt;<i>   image.onload = function () {
</I>&gt;<i>     me.decDependencies();
</I>&gt;<i>   };
</I>&gt;<i>
</I>&gt;<i>   Y: 
</I>&gt;<i>   &lt;script src=&quot;slowLoad.js&quot; async&gt;&lt;/script&gt;
</I>&gt;<i>   &lt;script src=&quot;next.js&quot; needs=&quot;slowLoad.js&quot;&gt;&lt;/script&gt;
</I>&gt;<i>   // in slowLoad.js:
</I>&gt;<i>   var me = document.currentScript;
</I>&gt;<i>   me.incDependencies();
</I>&gt;<i>   setTimeout(init, 1000);
</I>&gt;<i>   function init() {
</I>&gt;<i>     // ok, we're ready
</I>&gt;<i>     me.decDependencies();
</I>&gt;<i>   }
</I>&gt;<i>
</I>&gt;<i>   Z:
</I>&gt;<i>   The easiest way to do that one would just be to put the &lt;script&gt; after
</I>&gt;<i>   the &lt;nav id=&quot;menu&quot;&gt; element in the DOM.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Looking at the other requirements:
</I>&gt;<i>
</I>&gt;<i> - Fallback: the fallback is just to execute the scripts in document
</I>&gt;<i>   order. This doesn't work when &quot;async&quot; is used, unfortunately, but it
</I>&gt;<i>   does work when whenneeded=&quot;&quot; is used.
</I>&gt;<i>
</I>&gt;<i> - Pre-parsers should discover these fine if they're in markup.
</I>&gt;<i>OBviously, 
</I>&gt;<i>   for script-generated scripts, that won't work.
</I>&gt;<i>
</I>&gt;<i> - As far as caching goes, the headers shouldn't affect this mechanism,
</I>&gt;<i>so 
</I>&gt;<i>   it'll work fine even with broken headers. (Obviously it'll work better
</I>&gt;<i>   across sessions if the headers aren't broken.)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Any comments on this proposal?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Wed, 10 Jul 2013, Kyle Simpson wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> You know, I keep relying on the fact that the body of work on this
</I>&gt;&gt;<i>topic 
</I>&gt;&gt;<i> for almost 3 years ought NOT have to be re-visited every few months
</I>&gt;&gt;<i>when 
</I>&gt;&gt;<i> these threads wake from dormancy. I keep hoping that someone who really
</I>&gt;&gt;<i> cares about actually addressing all the concerns, and not just some of
</I>&gt;&gt;<i> them, will do the due dilligence to look at all the previous stuff
</I>&gt;&gt;<i> before criticizing me for not providing enough detail.
</I>&gt;<i>
</I>&gt;<i>Unfortunately, since you are so verbose in your e-mails, it is
</I>&gt;<i>impractical 
</I>&gt;<i>to go back and read everything you've written. Just this brief thread had
</I>&gt;<i>something like 1300 lines from you alone (out of 2500 lines and a dozen
</I>&gt;<i>participants). The reality of this is that we can't remember everything
</I>&gt;<i>you've ever written. Sorry.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> I doubt anyone is going to read this crazy long message and actually
</I>&gt;&gt;<i> read all these, but I'll put them here nonetheless.
</I>&gt;<i>
</I>&gt;<i>I read everything.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> That was way more than I wanted to write, and probably way more than
</I>&gt;&gt;<i> anyone wanted to read.
</I>&gt;<i>
</I>&gt;<i>I encourage you to work on editing. It's possible to express the same
</I>&gt;<i>ideas in much shorter text. For example, use case U above is adequately
</I>&gt;<i>expressed in the one paragraph I edited it down to, but you had it spread
</I>&gt;<i>over many paragraphs. The key is to notice when what you are saying
</I>&gt;<i>merely 
</I>&gt;<i>repeats something you've already said, and to just pick the expression of
</I>&gt;<i>the idea that says it best, and remove the other one. Another example
</I>&gt;<i>would be saying &quot;X doesn't want A, it wants not-A&quot;. You don't have to say
</I>&gt;<i>the first part -- if it wants not-A, then it usually obviously doesn't
</I>&gt;<i>want A. So you can just say &quot;X wants not-A&quot;. Similarly, if you ever start
</I>&gt;<i>a sentence with &quot;Again&quot; (or indeed &quot;similarly&quot;!), you have a good
</I>&gt;<i>candidate for something being redundant. :-)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>On Tue, 9 Jul 2013, Kyle Simpson wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> &gt; The proposals I've seen so far for extending the spec's script
</I>&gt;&gt;<i> &gt; preloading mechanisms fall into two categories:
</I>&gt;&gt;<i> &gt; 
</I>&gt;&gt;<i> &gt; - provide some more control over the mechanisms already there, e.g. 
</I>&gt;&gt;<i> &gt;   firing events at various times, adding attributes to make the 
</I>&gt;&gt;<i>script 
</I>&gt;&gt;<i> &gt;   loading algorithm work differently, or adding methods to trigger 
</I>&gt;&gt;<i> &gt;   particular parts of the algorithm under author control.
</I>&gt;&gt;<i> &gt; 
</I>&gt;&gt;<i> &gt; - provide a layer above the current algorithm that provides strong 
</I>&gt;&gt;<i> &gt;   semantics, but that doesn't have much impact on the loading 
</I>&gt;&gt;<i>algorithm 
</I>&gt;&gt;<i> &gt;   itself.
</I>&gt;&gt;<i> &gt; 
</I>&gt;&gt;<i> &gt; I'm very hesitant to do the first of these, because the algorithm is 
</I>&gt;&gt;<i>_so_ 
</I>&gt;&gt;<i> &gt; complicated that adding anything else to it is just going to result 
</I>&gt;&gt;<i>in 
</I>&gt;&gt;<i> &gt; bugs in browsers. There comes a point where an algorithm just becomes 
</I>&gt;&gt;<i>so 
</I>&gt;&gt;<i> &gt; hard to accurately test that it's a lost cause.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Can you please elaborate on how either of the two prominent proposals 
</I>&gt;&gt;<i> that Nicholas Zakas and I detailed years ago here are insufficient in 
</I>&gt;&gt;<i> that they fall into your first category?
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> <A HREF="http://wiki.whatwg.org/wiki/Script_Execution_Control">http://wiki.whatwg.org/wiki/Script_Execution_Control</A>
</I>&gt;<i>
</I>&gt;<i>Well they don't address the use cases directly. They provide APIs that 
</I>&gt;<i>can 
</I>&gt;<i>then be used to write script to address the use cases.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> How does standardizing that suggestion (turning it from a MAY into a 
</I>&gt;&gt;<i> MUST) further complicate the loading algorithm, especially since 
</I>&gt;&gt;<i>there's 
</I>&gt;&gt;<i> over a decade of proof in IE that it works and works fine, and it's 
</I>&gt;&gt;<i> already detailed as a suggestion in the spec?
</I>&gt;<i>
</I>&gt;<i>I disagree with the premise of the question (that IE proves it works 
</I>&gt;<i>fine), since IE didn't implement exactly what the spec wrote plus that, 
</I>&gt;<i>it 
</I>&gt;<i>implemented variants that are hard to distinguish. But in any case, that 
</I>&gt;<i>didn't address the use cases directly either.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> In neither case do I see how this unduly complicates the loading 
</I>&gt;&gt;<i> algorithm? It ONLY pauses it between load and execute, under certain 
</I>&gt;&gt;<i> conditions. It doesn't change any of the order of the algorithm.
</I>&gt;<i>
</I>&gt;<i>One can complicate by adding as well as reordering. The question is 
</I>&gt;<i>whether it's &quot;unduly&quot;. In practice my proposal above is much more 
</I>&gt;<i>complicated than that, but it does so to address the use cases.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> For instance, content-management-systems (through plugins) load 
</I>&gt;&gt;<i> different items into a page independently of other plugins. Those 
</I>&gt;&gt;<i> plugins have no knowledge of the complete content/markup-structure of 
</I>&gt;&gt;<i> the page, and so they would be unable to reliably create &lt;script&gt; 
</I>&gt;&gt;<i> elements with unique ID's, without just guessing by creating really 
</I>&gt;&gt;<i> obscure ID's. Not perfect/perfectly reliable, and certainly ugly and 
</I>&gt;&gt;<i> more work for them to do. Every plugin would have to come up with its 
</I>&gt;&gt;<i> own ID-generation mechanisms. Asking for inconsistencies/problems.
</I>&gt;<i>
</I>&gt;<i>This seems like a generic problem with every mechanism that uses IDs.
</I>&gt;<i>
</I>&gt;<i>-- 
</I>&gt;<i>Ian Hickson               U+1047E                )\._.,--....,'``.    fL
</I>&gt;<i><A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
</I>&gt;<i>Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</I>

</PRE>













































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="040953.html">[whatwg] Collecting tips for getting involved in web standards
</A></li>
	<LI>Next message: <A HREF="040957.html">[whatwg] High-density canvases
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40955">[ date ]</a>
              <a href="thread.html#40955">[ thread ]</a>
              <a href="subject.html#40955">[ subject ]</a>
              <a href="author.html#40955">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
