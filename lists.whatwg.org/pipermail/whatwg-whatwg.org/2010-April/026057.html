<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Adding ECMAScript 5 array extras to HTMLCollection
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Adding%20ECMAScript%205%20array%20extras%20to%20HTMLCollection&In-Reply-To=%3C4BD66E7D.3080003%40enseirb-matmeca.fr%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026045.html">
   <LINK REL="Next"  HREF="026024.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Adding ECMAScript 5 array extras to HTMLCollection</H1>
<!--htdig_noindex-->
    <B>David Bruant</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Adding%20ECMAScript%205%20array%20extras%20to%20HTMLCollection&In-Reply-To=%3C4BD66E7D.3080003%40enseirb-matmeca.fr%3E"
       TITLE="[whatwg] Adding ECMAScript 5 array extras to HTMLCollection">bruant at enseirb-matmeca.fr
       </A><BR>
    <I>Mon Apr 26 21:56:29 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="026045.html">[whatwg] Adding ECMAScript 5 array extras to HTMLCollection
</A></li>
        <LI>Next message: <A HREF="026024.html">[whatwg] Adding ECMAScript 5 array extras to HTMLCollection
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26057">[ date ]</a>
              <a href="thread.html#26057">[ thread ]</a>
              <a href="subject.html#26057">[ subject ]</a>
              <a href="author.html#26057">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Le 26/04/2010 10:33, Garrett Smith a &#233;crit :
&gt;<i> On Mon, Apr 26, 2010 at 9:49 AM, Erik Arvidsson&lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">arv at chromium.org</A>&gt;  wrote:
</I>&gt;<i>    
</I>&gt;&gt;<i> On Sun, Apr 25, 2010 at 01:07, David Bruant&lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">bruant at enseirb-matmeca.fr</A>&gt;  wrote:
</I>&gt;&gt;<i>      
</I>&gt;&gt;&gt;<i> Le 25/04/2010 00:39, J Z a &#233;crit :
</I>&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i> I have thought a lot about weirdnesses that people could think about like
</I>&gt;&gt;&gt;&gt;<i> trying to assign a value to the HTMLCollection (divs[14] = myOtherDiv), but
</I>&gt;&gt;&gt;&gt;<i> once again, it wouldn't be more allowed than it currently is (I have no idea
</I>&gt;&gt;&gt;&gt;<i> of what happens today, but if an error is thrown in a for-loop, it should
</I>&gt;&gt;&gt;&gt;<i> throw an error as well in a call within a forEach).
</I>&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;<i> How would destructive methods like `push` or `sort` behave? Would
</I>&gt;&gt;&gt;<i> `document.body.childNodes.push(document.createTextNode('foo'))` append text
</I>&gt;&gt;&gt;<i> node to a body element? Or would it be a noop?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> That is actually a very good point.
</I>&gt;&gt;&gt;<i> It think that the behavior should be exactly the same as &quot;an equivalent
</I>&gt;&gt;&gt;<i> without array methods&quot;. (this point of my proposal would need to be made
</I>&gt;&gt;&gt;<i> completly explicit for each method)
</I>&gt;&gt;&gt;<i>        
</I>&gt;&gt;<i> One way to solve this could be to split Array into two interfaces. One
</I>&gt;&gt;<i> to be used with immutable array like objects and one to use to mutate
</I>&gt;&gt;<i> objects. Then we could apply the immutable array like interface to
</I>&gt;&gt;<i> NodeList and its related interfaces. The benefit of doing that is that
</I>&gt;&gt;<i> NodeList.prototype.push would be undefined instead of failing when
</I>&gt;&gt;<i> called.
</I>&gt;&gt;<i>      
</I>&gt;<i> Yes, that was also discussed on es-discuss list.
</I>&gt;<i>
</I>&gt;<i> The complaints that have been mentioned on this thread are also detailed:
</I>&gt;<i> <A HREF="https://mail.mozilla.org/pipermail/es-discuss/2009-May/009300.html">https://mail.mozilla.org/pipermail/es-discuss/2009-May/009300.html</A>
</I>&gt;<i> <A HREF="https://mail.mozilla.org/pipermail/es-discuss/2009-May/009323.html">https://mail.mozilla.org/pipermail/es-discuss/2009-May/009323.html</A>
</I>&gt;<i>
</I>&gt;<i> - and the reply by Allen:
</I>&gt;<i> <A HREF="https://mail.mozilla.org/pipermail/es-discuss/2009-May/009323.html">https://mail.mozilla.org/pipermail/es-discuss/2009-May/009323.html</A>
</I>&gt;<i>    
</I>I assume you meant :
<A HREF="https://mail.mozilla.org/pipermail/es-discuss/2009-May/009355.html">https://mail.mozilla.org/pipermail/es-discuss/2009-May/009355.html</A>
&gt;<i> | I'm probably repeating myself here, but an new interface is not
</I>&gt;<i> | necessary to make this requirement explicit.  If you want (and
</I>&gt;<i> | can get agreement) for these objects to fully implement
</I>&gt;<i> | ECMAScript native object semantics then that is all you have to
</I>&gt;<i> | say in the WebIDL JavaScript binding specification.
</I>&gt;<i>
</I>&gt;<i> Nobody argued with that post, which concluded the thread.
</I>&gt;<i>    
</I>I assume Allen Wirfs-Brock meant &quot;implement ECMAScript native object 
semantics&quot; ... as host objects. And I agree with this idea or would 
suggest to say what we have to say either in the WebIDL ECMAScript 
binding or an independent rewriting of the DOM HTML ES binding.

In one of the email you refer to, you said :
 &gt;Host objects currently behave in implementation-dependent manner.
 &gt;Nobody likes it, but that's the way it is. I do not think such
 &gt;&quot;implementation dependent&quot; behavior should be arbitrary.

In my opinion, it's the role of the ECMAScript binding specification to 
determine what is implementation-dependent and what is not. Role that 
previous specifications didn't fill, allowing web browsers to choose, 
thus leading authors to do feature detection or browser sniffing.

I realize now that there is actually a lot that has never been said 
about ECMAScript bindings. WebIDL seems to be a good start. I will have 
a closer look at it.


Back to the main subject, I find interesting the idea of defining 
immutable arrays. To be more precise in the proposal, I would first 
suggest the following :
An *ImmutableCollection* constructor with a prototype containing the 
following methods :
* join
* slice (btw, .slice(0) would return an Array which is a static copy of 
the HTMLCollection)
* splice
* indexOf/lastIndexOf
* every/some
* forEach
* map
* filter
* reduce/reduceRight

Basically, it's all methods where no [[defineOwnProperty]] is used 
directly or indirectly (like through [[put]]).

The definition of each method is strictly the same definition than the 
corresponding method in Array.prototype.

Having this constructor and imposing that HTMLCollections inherit from 
it would make that it is not implementation-dependent anymore.

For the moment, this constructor would be created only for the 
ECMAScript binding purpose.

It would avoid to define methods which, we know, would systematically fail.

&gt;<i> Rather that trying to make DOM collections feel like arrays, how about just
</I>&gt;<i> &gt;  giving them a toArray() method?  This makes it clear that a collection is
</I>&gt;<i> &gt;  not an array, but clearly defines a way to obtain an array.  Clever
</I>&gt;<i> &gt;  implementors might even be able to optimize common uses-cases using some
</I>&gt;<i> &gt;  kind of copy-on-write strategy so that toArray() doesn't involve memory
</I>&gt;<i> &gt;  allocation and copying.
</I>&gt;<i>    
</I>&gt;<i> That might be better than nothing but why should a NodeList not have a
</I>&gt;<i> forEach method? It is pretty clear that people want to be able to
</I>&gt;<i> treat Arguments and NodeList as Arrays.
</I>&gt;<i>    
</I>With my aforementionned proposal. HTMLCollections would have direclty a 
forEach method.

About the idea of clearly defining a way to obtain an Array (for its 
staticness), a method could be added, but no to 
ImmutableCollection.prototype.
Another constructor and prototype would be needed to deal with live 
(dynamic) objects.
Maybe this constructor could be :
*LiveCollection* with method(s) :
* toStaticArray (I think that expliciting &quot;static&quot; is a good thing. It 
can be discussed)

I have tried to separate the notion of &quot;immutable&quot; and &quot;live/dynamic&quot;, 
because these are different concepts. It makes sense to say that live 
implies immutable, but the contrary is not obvious. I have not 
investigated, but I know that NodeLists returned by querySelectorAll are 
not live. I think that they are likely to be immutable (it would make 
sense in my opinion).
I don't know any example for HTMLCollection. I'd be interested to know 
if there is any.


For the moment, NodeList are out of the scope of this proposal since 
NodeList is out of the scope of HTML5 (NodeList is defined in DOM core 
level 3 as well as its ES binding).


&gt;<i> In the longer term, what's the thinking on a more basic change:
</I>&gt;<i>
</I>&gt;<i> - Require specific DOM interfaces like NodeList, HTMLCollection, 
</I>&gt;<i> Element etc. to be available for prototype monkey-patching under their 
</I>&gt;<i> interface names as properties of `window`?
</I>&gt;<i>
</I>&gt;<i> Then we wouldn't have to worry about what Array-like methods need to 
</I>&gt;<i> be provided on HTMLCollection, because application and framework 
</I>&gt;<i> authors could choose whichever they liked to prototype in.
</I>&gt;<i>
</I>&gt;<i> IE8/Moz/Op/Saf/Chr already do this to a significant extent, but 
</I>&gt;<i> there's no standard that says they have to. It would allow DOM 
</I>&gt;<i> extension to be put on a much less shaky footing than the messy hack 
</I>&gt;<i> Prototype 1.x uses.
</I>&gt;<i>
</I>&gt;<i> Is this something that's a reasonable requirement for browsers in future? 
</I>There are a lot of examples where adding or modifying an 
object/prototype you don't own ended to be harmful :
<A HREF="http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/">http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/</A>
<A HREF="http://perfectionkills.com/whats-wrong-with-extending-the-dom/">http://perfectionkills.com/whats-wrong-with-extending-the-dom/</A>

As such, my first reaction is to be cautious about this.
For instance, if authors decide to do the following : 
HTMLCollection.prototype.filter = Array.prototype.filter;
Then the filter method on HTMLCollection is expected to return an Array.
If some day, the W3C or WHATWG decides that HTMLCollection are freely 
instanciable (var hcol = new HTMLCollection()) and contain a filter 
methods that MUST return an HTMLCollection, then calls to .filter will 
break because Array and HTMLCollection are different.

Defining in the ES binding what methods the HTMLCollection implements in 
ES has the advantage of making sure that the same method will always 
have the same behavior.
If some day, the W3C or WHATWG decides that HTMLCollection are freely 
instanciable (var hcol = new HTMLCollection()) and contain a filter 
methods that MUST return an HTMLCollection, then in the ES binding, it 
can be decided that the ES method that implements the HTMLCollection 
interface filter method can be called .filterCollection.
This decision won't break any existing code.

David
</PRE>







<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026045.html">[whatwg] Adding ECMAScript 5 array extras to HTMLCollection
</A></li>
	<LI>Next message: <A HREF="026024.html">[whatwg] Adding ECMAScript 5 array extras to HTMLCollection
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26057">[ date ]</a>
              <a href="thread.html#26057">[ thread ]</a>
              <a href="subject.html#26057">[ subject ]</a>
              <a href="author.html#26057">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
