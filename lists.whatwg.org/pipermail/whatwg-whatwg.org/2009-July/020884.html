<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Codecs%20for%20%3Caudio%3E%20and%20%3Cvideo%3E&In-Reply-To=%3Cop.uws1hhxdsr6mfa%40nog%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020874.html">
   <LINK REL="Next"  HREF="020832.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;</H1>
<!--htdig_noindex-->
    <B>Philip J&#228;genstedt</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Codecs%20for%20%3Caudio%3E%20and%20%3Cvideo%3E&In-Reply-To=%3Cop.uws1hhxdsr6mfa%40nog%3E"
       TITLE="[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;">philipj at opera.com
       </A><BR>
    <I>Thu Jul  9 07:35:31 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020874.html">[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
</A></li>
        <LI>Next message: <A HREF="020832.html">[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20884">[ date ]</a>
              <a href="thread.html#20884">[ thread ]</a>
              <a href="subject.html#20884">[ subject ]</a>
              <a href="author.html#20884">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Wed, 08 Jul 2009 18:24:42 +0200, Charles Pritchard &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">chuck at jumis.com</A>&gt;  
wrote:

&gt;<i> On 7/8/09 2:20 AM, Philip Jagenstedt wrote:
</I>&gt;&gt;<i> On Tue, 07 Jul 2009 22:45:41 +0200, Charles Pritchard &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">chuck at jumis.com</A>&gt;  
</I>&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;<i> At some point, a Blob / Stream API could make things like this easier.
</I>&gt;&gt;&gt;&gt;<i> If the idea is to write a Vorbis decoder in JavaScript that would be  
</I>&gt;&gt;&gt;&gt;<i> quite cool in a way, but for vendors already implementing Vorbis it  
</I>&gt;&gt;&gt;&gt;<i> wouldn't really add anything. A pure JS-implementation of any modern  
</I>&gt;&gt;&gt;&gt;<i> audio codec would probably be a ridiculous amount of code and slow,  
</I>&gt;&gt;&gt;&gt;<i> so I doubt it would be that useful in practice.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Well I'd like to disagree, and reiterate my prior arguments.  Vorbis  
</I>&gt;&gt;&gt;<i> decoders have been written in ActionScript and in Java.
</I>&gt;&gt;&gt;<i> They are not ridiculous, in size, nor in CPU usage. They can play  
</I>&gt;&gt;&gt;<i> audio streams, smoothly, and the file size is completely
</I>&gt;&gt;&gt;<i> tolerable. And the idea is codec neutrality, a Vorbis decoder is just  
</I>&gt;&gt;&gt;<i> one example.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> OK, I won't make any assumptions of the size/speed of such an  
</I>&gt;&gt;<i> implementation until I see one.
</I>&gt;<i> Well,  again, there exist implementations running on Sun/Oracle's Java  
</I>&gt;<i> VM and the Flash VM.
</I>&gt;<i> These two use byte-code packaging, so the file size is under 100k,  
</I>&gt;<i> deflated ECMAScript
</I>&gt;<i> source would also weigh under 100k.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> Transcoding lossy data is a sub-optimal solution. Allowing for  
</I>&gt;&gt;&gt;<i> arbitrary &lt;audio&gt;
</I>&gt;&gt;&gt;<i> codecs is a worthwhile endeavor. ECMAScript can detect if playback is  
</I>&gt;&gt;&gt;<i> too slow.
</I>&gt;<i> I want to point this out again.
</I>&gt;<i>
</I>&gt;<i> While there is some struggle to define a standard codec (so we might be  
</I>&gt;<i> spared the burden
</I>&gt;<i> of so very many encoders), there is a very large supply of  
</I>&gt;<i> already-encoded media in the wild.
</I>&gt;<i>
</I>&gt;<i> I've recently worked on a project that required a difficult to  
</I>&gt;<i> obtain/install codec.
</I>&gt;<i> Open source descriptions were available, and if it was an option, I  
</I>&gt;<i> certainly would have
</I>&gt;<i> paid to have the codec written in ECMAScript, and delivered it with the  
</I>&gt;<i> media files.
</I>&gt;<i>
</I>&gt;<i> In that particular case, paying someone to write a decoder for one  
</I>&gt;<i> particular, minority codec,
</I>&gt;<i> would have been cheaper, and more correct, than paying for the  
</I>&gt;<i> transcoding of 60 gigs of low bit-rate audio.
</I>&gt;<i>
</I>&gt;<i> Most media formats are lossy, making their current format, whatever the  
</I>&gt;<i> encumbrance, the best solution.
</I>
Yes, re-encoding always lowers the quality, so this use case is something  
I would agree with.

&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Additionally, in some cases, the programmer could work-around broken  
</I>&gt;&gt;&gt;<i> codec implementations.
</I>&gt;&gt;&gt;<i> It's forward-looking, it allows real backward compatibility and  
</I>&gt;&gt;&gt;<i> interoperability across browsers.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &lt;canvas&gt; allows for arbitrary, programmable video, &lt;audio&gt; should allow
</I>&gt;&gt;&gt;<i> for programmable audio. Then, we can be codec neutral in our media  
</I>&gt;&gt;&gt;<i> elements.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> While stressing that I don't think this should go into the spec until  
</I>&gt;&gt;<i> there's a proof-of-concept implementation that does useful stuff, is  
</I>&gt;&gt;<i> the idea to set audio.src=new MySynthesizer() and play()?  
</I>&gt;&gt;<i> (MySynthesizer would need to implement some standard interface.) You  
</I>&gt;&gt;<i> also have the question of push vs pull, i.e. does the audio source  
</I>&gt;&gt;<i> request data from the synthesizer when needed or does the synthesizer  
</I>&gt;&gt;<i> need to run a loop pushing audio data?
</I>&gt;&gt;<i>
</I>&gt;<i> Well we really need to define what useful stuff is, you know, to set  
</I>&gt;<i> that bar.
</I>
It really doesn't matter if you and agree on what it useful. If one  
browser implements an audio synthesis interface and it's good enough,  
others will follow and the spec work will begin.

&gt;<i> There are two use cases that I think are important: a codec  
</I>&gt;<i> implementation (let's use Vorbis),
</I>&gt;<i> and an accessibility implementation, working with a &lt;canvas&gt; element.
</I>&gt;<i>
</I>&gt;<i> I don't know what would qualify for accessibility. A topographical map,  
</I>&gt;<i> which makes a lower or higher
</I>&gt;<i> pitched hum, based on elevation (surrounding the pointer), is an example.
</I>&gt;<i>
</I>&gt;<i> On that same line of thinking, a hum of varying intensity signaling  
</I>&gt;<i> proximity to a clickable element,
</I>&gt;<i> (we're still talking about &lt;canvas&gt;) might be useful.  If there is no  
</I>&gt;<i> sound in the right-channel,
</I>&gt;<i> there are no elements to be clicked on, to the right of the pointer. If  
</I>&gt;<i> it is a low-sound, then the
</I>&gt;<i> element is rather far away.
</I>&gt;<i>
</I>&gt;<i> Site developers still need to put in the work. With a buffered audio  
</I>&gt;<i> API, they'll at least
</I>&gt;<i> have the option to do so.
</I>&gt;<i>
</I>&gt;<i> Can we come to an agreement as to what would constitute a reasonable  
</I>&gt;<i> proof of concept?
</I>&gt;<i> This is meant to allow &lt;canvas&gt; to be more accessible to the visually  
</I>&gt;<i> impaired.
</I>&gt;<i>
</I>&gt;<i> Obviously, &lt;audio src&gt; tags could be used in many cases with &lt;canvas&gt;,  
</I>&gt;<i> so our test-case
</I>&gt;<i> should be one where &lt;audio src&gt; would be insufficient.
</I>&gt;<i>
</I>&gt;<i> Both of these use cases can be accomplished with a raw audio buffer.
</I>&gt;<i> They do not need native channel mixing, nor toDataURL support.
</I>&gt;<i>
</I>&gt;<i> In the long term, I think those two options would be nice, but in the  
</I>&gt;<i> short term, would just cause delays in adoption.
</I>&gt;<i> As Robert has said, there are &quot;much more important things to work on&quot;
</I>&gt;<i> ( <A HREF="https://bugzilla.mozilla.org/show_bug.cgi?id=490705">https://bugzilla.mozilla.org/show_bug.cgi?id=490705</A> ).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I think at this point, the model should play buffered bytes as they are  
</I>&gt;<i> made available (if the buffer has anything, start playing it).
</I>&gt;<i>
</I>&gt;<i> I believe the &quot;buffered&quot; attribute can be used by the ECMAScript loop to  
</I>&gt;<i> detect
</I>&gt;<i> how much data is buffered, and whether it should continue decoding or  
</I>&gt;<i> take other actions.
</I>&gt;<i>
</I>&gt;<i> The buffered audio API should be handled by the media API in a way  
</I>&gt;<i> similar to streaming Web radio.
</I>&gt;<i>
</I>&gt;<i> There should be an origin-clean flag, for future use. One might  
</I>&gt;<i> theoretically
</I>&gt;<i> add audio into a currently playing stream. (regardless of toDataURL  
</I>&gt;<i> support).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Does this sound reasonable? What I'm requesting is an append-only raw  
</I>&gt;<i> audio buffer, and an origin-clean flag (similar to &lt;canvas&gt;)
</I>&gt;<i> to be added to the &lt;audio&gt; tag, if not the Media element interface, for  
</I>&gt;<i> future use. The audio buffer plays immediately,
</I>&gt;<i> if any data is available in it.
</I>
It sounds like fun to implement and fun to play with, although none of the  
details really matter at this point (and I shouldn't have asked). When  
(if) a first browser implements something like this, that API will likely  
become the standard (unless it's not useful and all other browsers ignore  
it).

&gt;<i> In v2, we would discuss Vlad's getAudioSampleData proposal, native  
</I>&gt;<i> channel mixing (mix two audio streams, for whatever reason),
</I>&gt;<i> and other effects that allow the more complex &quot;audio editor&quot; use case.  
</I>&gt;<i> For now, let's just consider an &quot;audio player&quot;
</I>&gt;<i> to support arbitrary audio codecs and address accessibility for the  
</I>&gt;<i> visually impaired.
</I>&gt;<i>
</I>&gt;<i> We need Audio.appendBuffer, Audio.createBufferArray
</I>&gt;<i> and an AudioBufferArray interface of some sort, and I think it's good to  
</I>&gt;<i> go.
</I>&gt;<i>
</I>&gt;<i> The naming and arguments still need to be worked out.
</I>&gt;<i>
</I>&gt;<i> I'd enthusiastically support such an interface in Java, Flash and  
</I>&gt;<i> .Net/Active X plugins.
</I>&gt;<i> For the legacy/IE crowd.
</I>&gt;<i>
</I>&gt;<i> -Charles
</I>
-- 
Philip J&#228;genstedt
Core Developer
Opera Software
</PRE>














<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020874.html">[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
</A></li>
	<LI>Next message: <A HREF="020832.html">[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20884">[ date ]</a>
              <a href="thread.html#20884">[ thread ]</a>
              <a href="subject.html#20884">[ subject ]</a>
              <a href="author.html#20884">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
