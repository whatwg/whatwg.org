<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Codecs%20for%20%3Caudio%3E%20and%20%3Cvideo%3E&In-Reply-To=%3Cop.uwqr72aq88ivhk%40sisko.linkoping.osa%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="063132.html">
   <LINK REL="Next"  HREF="063147.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;</H1>
<!--htdig_noindex-->
    <B>Philip Jagenstedt</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Codecs%20for%20%3Caudio%3E%20and%20%3Cvideo%3E&In-Reply-To=%3Cop.uwqr72aq88ivhk%40sisko.linkoping.osa%3E"
       TITLE="[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;">philipj at opera.com
       </A><BR>
    <I>Wed Jul  8 02:20:16 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="063132.html">[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
</A></li>
        <LI>Next message: <A HREF="063147.html">[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#63145">[ date ]</a>
              <a href="thread.html#63145">[ thread ]</a>
              <a href="subject.html#63145">[ subject ]</a>
              <a href="author.html#63145">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Tue, 07 Jul 2009 22:45:41 +0200, Charles Pritchard &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">chuck at jumis.com</A>&gt;  
wrote:

&gt;<i> On 7/7/09 1:10 PM, Philip Jagenstedt wrote:
</I>&gt;&gt;<i> On Tue, 07 Jul 2009 17:52:29 +0200, Charles Pritchard &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">chuck at jumis.com</A>&gt;  
</I>&gt;&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Philip Jagenstedt wrote:
</I>&gt;&gt;&gt;&gt;<i> For all of the simpler use cases you can already generate sounds  
</I>&gt;&gt;&gt;&gt;<i> yourself with a data uri. For example, with is 2 samples of silence:  
</I>&gt;&gt;&gt;&gt;<i> &quot;data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAAAA&quot;.
</I>&gt;&gt;&gt;<i> Yes you can use this method, and with the current audio tag and  
</I>&gt;&gt;&gt;<i> autobuffer, it may work to some degree.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It does not produce smooth transitions.
</I>&gt;<i> At some point, a Blob / Stream API could make things like this easier.
</I>&gt;&gt;<i> If the idea is to write a Vorbis decoder in JavaScript that would be  
</I>&gt;&gt;<i> quite cool in a way, but for vendors already implementing Vorbis it  
</I>&gt;&gt;<i> wouldn't really add anything. A pure JS-implementation of any modern  
</I>&gt;&gt;<i> audio codec would probably be a ridiculous amount of code and slow, so  
</I>&gt;&gt;<i> I doubt it would be that useful in practice.
</I>&gt;&gt;<i>
</I>&gt;<i> Well I'd like to disagree, and reiterate my prior arguments.  Vorbis  
</I>&gt;<i> decoders have been written in ActionScript and in Java.
</I>&gt;<i> They are not ridiculous, in size, nor in CPU usage. They can play audio  
</I>&gt;<i> streams, smoothly, and the file size is completely
</I>&gt;<i> tolerable. And the idea is codec neutrality, a Vorbis decoder is just  
</I>&gt;<i> one example.
</I>
OK, I won't make any assumptions of the size/speed of such an  
implementation until I see one.

&gt;&gt;<i> For some use cases you could use 2 audio elements in tandem, mixing new  
</I>&gt;&gt;<i> sound to a new data URI when the first is nearing the end (although  
</I>&gt;&gt;<i> sync can't be guaranteed with the current API). But yes, there are  
</I>&gt;&gt;<i> things which can only be done by a streaming API integrating into the  
</I>&gt;&gt;<i> underlying media framework.
</I>&gt;<i> Yes, the current API is inadequate. data: encoding is insufficient.
</I>&gt;&gt;<i> Here's the list of propsed features right out of a comment block in the  
</I>&gt;&gt;<i> spec:
</I>&gt;<i> This list of features can be written without a spec, using &lt;canvas&gt;,
</I>&gt;<i> using a raw data buffer, and using ECMAScript.
</I>&gt;<i>
</I>&gt;<i> A few of these features may need hardware level support, or a fast  
</I>&gt;<i> computer.
</I>&gt;<i> The &lt;audio&gt; tag would be invisible, and the &lt;canvas&gt; tag would
</I>&gt;<i> provide the user interface.
</I>&gt;&gt;<i> Your use cases probably fall under audio filters and synthesis. I  
</I>&gt;&gt;<i> expect that attention will turn to gradually more complex use cases  
</I>&gt;&gt;<i> when the basic API we have now is implemented and stable cross-browser  
</I>&gt;&gt;<i> and cross-platform.
</I>&gt;<i> Yes, some of these use cases qualify as filters, some qualify as  
</I>&gt;<i> synthesis.
</I>&gt;<i> I'm proposing that simple filters and synthesis can be accomplished with  
</I>&gt;<i> modern
</I>&gt;<i> ECMAScript virtual machines and a raw data buffer. My use cases are  
</I>&gt;<i> qualified to current capabilities.
</I>&gt;<i>
</I>&gt;<i> Apart from those use cases, I'm proposing that a raw data buffer will  
</I>&gt;<i> allow for
</I>&gt;<i> codec neutrality.
</I>&gt;<i>
</I>&gt;<i> There are dozens of minor audio codecs, some simpler than others, some  
</I>&gt;<i> low bitrate,
</I>&gt;<i> that could be programmed in ECMAScript and would run just fine with  
</I>&gt;<i> modern ECMAScript VMs.
</I>&gt;<i>
</I>&gt;<i> Transcoding lossy data is a sub-optimal solution. Allowing for arbitrary  
</I>&gt;<i> &lt;audio&gt;
</I>&gt;<i> codecs is a worthwhile endeavor. ECMAScript can detect if playback is  
</I>&gt;<i> too slow.
</I>&gt;<i>
</I>&gt;<i> Additionally, in some cases, the programmer could work-around broken  
</I>&gt;<i> codec implementations.
</I>&gt;<i> It's forward-looking, it allows real backward compatibility and  
</I>&gt;<i> interoperability across browsers.
</I>&gt;<i>
</I>&gt;<i> &lt;canvas&gt; allows for arbitrary, programmable video, &lt;audio&gt; should allow
</I>&gt;<i> for programmable audio. Then, we can be codec neutral in our media  
</I>&gt;<i> elements.
</I>
While stressing that I don't think this should go into the spec until  
there's a proof-of-concept implementation that does useful stuff, is the  
idea to set audio.src=new MySynthesizer() and play()? (MySynthesizer would  
need to implement some standard interface.) You also have the question of  
push vs pull, i.e. does the audio source request data from the synthesizer  
when needed or does the synthesizer need to run a loop pushing audio data?

-- 
Philip J&#228;genstedt
Core Developer
Opera Software

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="063132.html">[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
</A></li>
	<LI>Next message: <A HREF="063147.html">[whatwg] Codecs for &lt;audio&gt; and &lt;video&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#63145">[ date ]</a>
              <a href="thread.html#63145">[ thread ]</a>
              <a href="subject.html#63145">[ subject ]</a>
              <a href="author.html#63145">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
