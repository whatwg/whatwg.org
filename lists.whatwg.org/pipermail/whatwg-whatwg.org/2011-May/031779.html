<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] window.cipher HTML crypto API draft spec
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20window.cipher%20HTML%20crypto%20API%20draft%20spec&In-Reply-To=%3CBAA1DB30-5527-42D8-8703-2EA4CF656A99%40simonheckmann.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031778.html">
   <LINK REL="Next"  HREF="031782.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] window.cipher HTML crypto API draft spec</H1>
<!--htdig_noindex-->
    <B>Simon Heckmann</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20window.cipher%20HTML%20crypto%20API%20draft%20spec&In-Reply-To=%3CBAA1DB30-5527-42D8-8703-2EA4CF656A99%40simonheckmann.de%3E"
       TITLE="[whatwg] window.cipher HTML crypto API draft spec">simon at simonheckmann.de
       </A><BR>
    <I>Tue May 24 08:14:33 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="031778.html">[whatwg] window.cipher HTML crypto API draft spec
</A></li>
        <LI>Next message: <A HREF="031782.html">[whatwg] window.cipher HTML crypto API draft spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31779">[ date ]</a>
              <a href="thread.html#31779">[ thread ]</a>
              <a href="subject.html#31779">[ subject ]</a>
              <a href="author.html#31779">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>

Am 24.05.2011 um 16:48 schrieb David Dahl &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ddahl at mozilla.com</A>&gt;:

&gt;<i> ----- Original Message -----
</I>&gt;<i> From: &quot;Henri Sivonen&quot; &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">hsivonen at iki.fi</A>&gt;
</I>&gt;<i> To: &quot;David Dahl&quot; &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ddahl at mozilla.com</A>&gt;
</I>&gt;<i> Cc: <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">whatwg at lists.whatwg.org</A>
</I>&gt;<i> Sent: Tuesday, May 24, 2011 2:25:53 AM
</I>&gt;<i> Subject: Re: [whatwg] window.cipher HTML crypto API draft spec
</I>&gt;<i> 
</I>&gt;&gt;<i> It seems unfortunate that crypto is only available when a JavaScript
</I>&gt;<i>  program explicitly drives encryption. This means that in order to use
</I>&gt;<i>  crypto, the Web app has to be written in such a way that all its
</I>&gt;<i>  resource handling is programmed in JavaScript instead of using
</I>&gt;<i>  traditional browser-handled resource retrievals.
</I>&gt;<i> 
</I>&gt;<i> I imagine using resource retrieval would be the way to handle larger binary data decryption, and would be an amazing counterpart to this API - it also seems like a much bigger project to undertake. The emphasis on DOMCrypt is mainly on giving content developers a way to write privacy-enhanced web apps.
</I>&gt;<i> 
</I>&gt;&gt;<i> Consider for example a DropBox-style service that has a browser-based UI
</I>&gt;<i>  but that has a design where content is encrypted on the client-side so
</I>&gt;<i>  that the service provider is unable to decrypt the data. In this case,
</I>&gt;<i>  it would make sense to be able to implement a file download by having a
</I>&gt;<i>  plain &lt;a href&gt; to an excrypted file and have the browser automatically
</I>&gt;<i>  decrypt it. Likewise, a service that allows the transmission of
</I>&gt;<i>  encrypted images should be implementable by having &lt;img src&gt; point
</I>&gt;<i>  directly to an encrypted file.
</I>&gt;<i> 
</I>&gt;<i> I think someone was asking about that kind of functionality during my presentation at Mozilla. Again, this would be a pretty advanced complement to this API - I would love to see something like that spec'd and implemented as well.
</I>&gt;<i> 
</I>&gt;&gt;<i> I suggest adding a Content-Encoding type that tells the HTTP stack that
</I>&gt;<i>  the payload of a HTTP response is encrypted and needs to be decrypted
</I>&gt;<i>  using a key previously initialized using the JS API.
</I>&gt;<i> 
</I>&gt;<i> cool. I'll look into that.
</I>
Now while your at this, here is another use case I would like to add: Some time ago I developed an offline video viewer using the file system API. To increase security I encrypted the files on the server with username and password. I then used a JavaScript implementation to decrypt the files offline. Sadly this was way to slow. However with a native crypto API, similar to what you are proposing here, the offline decryption could be done quite efficiently. So maybe you want to consider specifying typed arrays and ArrayBuffers as input as well. So there is efficient use for a huge amount of binary data.

Kind regards,
Simon Heckmann

&gt;<i> 
</I>&gt;&gt;<i> On the other hand, it seems that letting Web apps generate per-user key
</I>&gt;<i>  pairs and letting Web apps discover if the user possesses the private
</I>&gt;<i>  key that decrypts a particular message is a privacy problem. Someone who
</I>&gt;<i>  wishes to surveil Web users could use private keys as supercookies,
</I>&gt;<i>  since the generated private key is most probably going to be unique to
</I>&gt;<i>  user.
</I>&gt;<i> 
</I>&gt;<i> Currently, my implementation requires the enduser to open a file from the file system in order to view the contents of the private key. It is only accessible to privileged code - content has no access to it whatsoever.
</I>&gt;<i> 
</I>&gt;&gt;<i> OTOH, wiping keys along with cookies could lead to accidents.
</I>&gt;&gt;<i> Is there a plan on how this will integrate into various private data
</I>&gt;<i>  deletion UIs in such a way that users have the option to delete keys but
</I>&gt;<i>  understand the implications and don't delete them accidentally?
</I>&gt;<i> 
</I>&gt;<i> Not yet. There no doubt will have to be a UI that helps users understand the ramifications of deleting keys, etc.
</I>&gt;<i> 
</I>&gt;&gt;<i> Are all the methods that take a success callback meant to pop up a
</I>&gt;<i>  geolocation-style asynchronous authorization UI until the user
</I>&gt;<i>  perma-authorizes a site to use crypto?
</I>&gt;<i> 
</I>&gt;<i> It is not implemented yet, but yes, that would be the plan.
</I>&gt;<i> - -
</I>&gt;<i> 
</I>&gt;&gt;<i> Is the plan to use Firefox Sync to sync the user's private keys across
</I>&gt;<i>  multiple browser instances so that the user doesn't need to manually
</I>&gt;<i>  transfer keys in the usual case?
</I>&gt;<i> 
</I>&gt;<i> I do think so, however, there are those who would caution against the private key ever going over the wire. I think with Sync, it would be safe.
</I>&gt;<i> 
</I>&gt;<i> - -
</I>&gt;<i> 
</I>&gt;&gt;<i> Currently, it is unfortunate that choosing to use a webmail client
</I>&gt;<i>  effectively prevents a person from using encrypted email. To allow
</I>&gt;<i>  people to use end-to-end encrypted email with webmail apps, it would be
</I>&gt;<i>  useful to support OpenPGP as an encryption format. (Obviously, a
</I>&gt;<i>  malicious webmail app could capture the decrypted messages on the
</I>&gt;<i>  browser and send them back to the server, but when the webmail app
</I>&gt;<i>  itself doesn't contain code like that, putting the decryption in the
</I>&gt;<i>  browser rather than putting it on the server would still probably be
</I>&gt;<i>  more subpoena-resistant and resistant against casual snooping by bored
</I>&gt;<i>  administrators.)
</I>&gt;<i> 
</I>&gt;<i> I think with an API like this we might see a whole new breed of communications applications that can supplant email and webmail entirely. &quot;Host Proof&quot; apps like Sync are what we need to move to, encrypted by default is possible with our fast CPUs. As I have strived for a very &quot;webby&quot; API, I tried not to design around existing formats, just going for a simple JSON based message, keypair and addressbook-entry. There is no reason a followup spec could not support existing messaging formats.
</I>&gt;<i> 
</I>&gt;<i> - -
</I>&gt;<i> 
</I>&gt;&gt;<i> It seems unfortunate that the proposed API entry point is yet another
</I>&gt;<i>  special name in the global scope. It seems to me that it would be better
</I>&gt;<i>  to put the new stuff on the existing window.crypto object or, if mixing
</I>&gt;<i>  with the old object is considered confusing, it would make sense to put
</I>&gt;<i>  the new stuff on the navigator object as navigator.crypto or
</I>&gt;<i>  navigator.cipher in order to avoid polluting the global scope.
</I>&gt;<i> 
</I>&gt;<i> I am not tied to 'window.cipher', and there has been a bit of discussion on consolidating this API into window.crypto - I put the property on the window via nsIDOMGlobalPropertyInitializer, which makes it easy:)
</I>&gt;<i> 
</I>&gt;<i> - -
</I>&gt;<i> 
</I>&gt;&gt;<i> The public key discovery section shows a &lt;/meta&gt; end tag. I hope this is
</I>&gt;<i> just a plain error and having content in a meta element isn't part of
</I>&gt;<i> any design.
</I>&gt;<i> 
</I>&gt;<i> The tag is unimportant as well - can you explain why you hope this wil not use a meta tag? I could just as easily use &lt;addressbookentry&gt;
</I>&gt;<i> 
</I>&gt;<i> - -
</I>&gt;<i> 
</I>&gt;&gt;<i> The public key discovery section is generally confusing. Is &lt;meta
</I>&gt;<i>  name=&quot;addressbook-entry&quot;&gt; meant to represent an email addressbook entry
</I>&gt;<i>  that may happen to have a public key associated with it? Or is &quot;cipher
</I>&gt;<i>  addressbook&quot; crypto lingo that I'm unfamiliar with and &lt;meta
</I>&gt;<i>  name=&quot;addressbook-entry&quot;&gt; always represents a public key plus metadata?
</I>&gt;<i>  Without understanding the general design, it's hard to comment on the
</I>&gt;<i>  choice of minting special name=&quot;addressbook-entry&quot;-specific attributes.
</I>&gt;<i> 
</I>&gt;<i> The ironic thing here is that I am calling a public key with additional meta data an 'addressbook-entry' to avoid using crypto lingo in the first place. The simplest way I can imagine publishing my public key is in a web page tag, where it is parsed by the browser, and the user is prompted to save their contact's &quot;addressbook entry&quot; in order to send private messages to them. I want to avoid standard crypto nomenclature when endusers are involved. I think the complexity of just the crypto lingo is what doomed PGP from mass adoption.
</I>&gt;<i> 
</I>&gt;<i> So you publish your addressbook entry in a tag on your page in order to pass your public key over to a contact. Your contact also does this and here we have the simplest possible public key exchange method. 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Best Regards,
</I>&gt;<i> 
</I>&gt;<i> David
</I></PRE>


















<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031778.html">[whatwg] window.cipher HTML crypto API draft spec
</A></li>
	<LI>Next message: <A HREF="031782.html">[whatwg] window.cipher HTML crypto API draft spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31779">[ date ]</a>
              <a href="thread.html#31779">[ thread ]</a>
              <a href="subject.html#31779">[ subject ]</a>
              <a href="author.html#31779">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
