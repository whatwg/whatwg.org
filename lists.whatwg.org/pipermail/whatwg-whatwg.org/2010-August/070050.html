<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Fwd: Discussing WebSRT and alternatives/improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Fwd%3A%20Discussing%20WebSRT%20and%20alternatives/improvements&In-Reply-To=%3CAANLkTi%3DkBhd9vr%2BumBWo0KvAZE31Pup8%2BU_OeG9pjc8t%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="070029.html">
   <LINK REL="Next"  HREF="070077.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Fwd: Discussing WebSRT and alternatives/improvements</H1>
<!--htdig_noindex-->
    <B>Silvia Pfeiffer</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Fwd%3A%20Discussing%20WebSRT%20and%20alternatives/improvements&In-Reply-To=%3CAANLkTi%3DkBhd9vr%2BumBWo0KvAZE31Pup8%2BU_OeG9pjc8t%40mail.gmail.com%3E"
       TITLE="[whatwg] Fwd: Discussing WebSRT and alternatives/improvements">silviapfeiffer1 at gmail.com
       </A><BR>
    <I>Mon Aug  9 16:34:02 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="070029.html">[whatwg] Fwd:  Discussing WebSRT and alternatives/improvements
</A></li>
        <LI>Next message: <A HREF="070077.html">[whatwg] Fwd: Discussing WebSRT and alternatives/improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70050">[ date ]</a>
              <a href="thread.html#70050">[ thread ]</a>
              <a href="subject.html#70050">[ subject ]</a>
              <a href="author.html#70050">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Tue, Aug 10, 2010 at 12:04 AM, Philip J&#228;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt;wrote:

&gt;<i> On Sat, 07 Aug 2010 09:57:39 +0200, Silvia Pfeiffer &lt;
</I>&gt;<i> <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">silviapfeiffer1 at gmail.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;<i>  Hi Philip,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Sat, Aug 7, 2010 at 1:50 AM, Philip J&#228;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt;
</I>&gt;&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  * there is a possibility to provide script that just affects the
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> time-synchronized text resource
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I agree that some metadata would be useful, more on that below. I'm not
</I>&gt;&gt;&gt;<i> sure why we would want to run scripts inside the text document, though,
</I>&gt;&gt;&gt;<i> when
</I>&gt;&gt;&gt;<i> that can be accomplished by using the TimedTrack API from the containing
</I>&gt;&gt;&gt;<i> page.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Scripts inside a timed text document would only be useful for applications
</I>&gt;&gt;<i> that use the track not in conjunction with a Web page.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Do you mean that media players could include a JavaScript engine just for
</I>&gt;<i> supporting scripts in WebSRT? Not to say that it can't happen, but it seems
</I>&gt;<i> a bit unlikely.
</I>


Yes, it's indeed an &quot;out there&quot; feature and I am not worried about having it
now. I just mentioned it as a simple possibility for extension.



&gt;<i>
</I>&gt;<i>  2. There is a natural mapping of WebSRT into in-band text tracks.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Each cue naturally maps into a encoding page (just like a WMML cue does,
</I>&gt;&gt;&gt;&gt;<i> too). But in WebSRT, because the setup information is not brought in a
</I>&gt;&gt;&gt;&gt;<i> hierarchical element surrounding all cues, it is easier to just chuck
</I>&gt;&gt;&gt;&gt;<i> anything that comes before the first cue into an encoding header page.
</I>&gt;&gt;&gt;&gt;<i> For
</I>&gt;&gt;&gt;&gt;<i> WMML, this problem can be solved, but it is less natural.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I really like the idea of letting everything before the first timestamp
</I>&gt;&gt;&gt;<i> in
</I>&gt;&gt;&gt;<i> WebSRT be interpreted as the header. I'd want to use it like this:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> # author: Fan Subber
</I>&gt;&gt;&gt;<i> # voices: &lt;1&gt; Boy
</I>&gt;&gt;&gt;<i> #         &lt;2&gt; Girl
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 01:23:45.678 --&gt; 01:23:46.789
</I>&gt;&gt;&gt;<i> &lt;1&gt; Hello
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 01:23:48.910 --&gt; 01:23:49.101
</I>&gt;&gt;&gt;<i> &lt;2&gt; Hello
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It's not critical that the format of the header be machine-readable, but
</I>&gt;&gt;&gt;<i> we
</I>&gt;&gt;&gt;<i> could of course make up a key-value syntax, use JSON, or something else.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I disagree. I think it's absolutely necessary that the format of the
</I>&gt;&gt;<i> header
</I>&gt;&gt;<i> be machine-readable. Just like EXIF in images is machine readable or ID3
</I>&gt;&gt;<i> in
</I>&gt;&gt;<i> MP3 is machine-readable. It would be counter-productive not to have it
</I>&gt;&gt;<i> machine-readable, in particular useless to archiving and media management
</I>&gt;&gt;<i> solutions.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> OK, so maybe key-values?
</I>&gt;<i>
</I>&gt;<i> Author: Fan Subber
</I>&gt;<i> Voice: &lt;1&gt; Boy
</I>&gt;<i> Voice: &lt;2&gt; Girl
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 01:23:45.678 --&gt; 01:23:46.789
</I>&gt;<i> &lt;1&gt; Hello
</I>&gt;<i>
</I>&gt;<i> This looks a bit like HTTP headers. (I'm not sure I'd actually want to
</I>&gt;<i> allow multiple occurrences of the same key, in practice that seems to result
</I>&gt;<i> in inconsistencies in how people mark up multiple authors.)
</I>


Yes, anything that can replicate the name-value possibilities of the &lt;meta&gt;
element should be fine.
Multiple occurrences make sense for some fields and not for others.
I wonder if we would need to make a defined list of what should go in here
or just define a general mechanism. HTML has a general mechanism (with
&lt;meta&gt;) while most subtitle formats have a defined set of fileds, e.g.
<A HREF="http://en.wikipedia.org/wiki/LRC_%28file_format%29">http://en.wikipedia.org/wiki/LRC_%28file_format%29</A> (ID3 tags) or
<A HREF="http://www.matroska.org/technical/specs/subtitles/ssa.html">http://www.matroska.org/technical/specs/subtitles/ssa.html</A> (SSA headers).



&gt;<i>
</I>&gt;<i>  I'm not sure of the best solution. I'd quite like the ability to use
</I>&gt;&gt;&gt;<i> arbitrary voices, e.g. to use the names/initials of the speaker rather
</I>&gt;&gt;&gt;<i> than
</I>&gt;&gt;&gt;<i> a number, or to use e.g. &lt;shouting&gt; in combination with CSS :before {
</I>&gt;&gt;&gt;<i> content 'Shouting: ' } or similar to adapt the display for different
</I>&gt;&gt;&gt;<i> audiences (accessibility, basically).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I agree. I think we can go back to using&lt;span&gt; and @class and @id and that
</I>&gt;&gt;<i> would solve it all.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I guess this is in support of Henri's proposal of parsing the cue using the
</I>&gt;<i> HTML fragment parser (same as innerHTML)? That would be easy to implement,
</I>&gt;<i> but how do we then mark up speakers? Using &lt;span class=&quot;narrator&quot;&gt;&lt;/span&gt;
</I>&gt;<i> around each cue is very verbose. HTML isn't very good for marking up dialog,
</I>&gt;<i> which is quite a limitation when dealing with subtitles...
</I>


I actually think that the &lt;span @class&gt; mechanism is much more flexible than
what we have in WebSRT right now. If we want multiple speakers to be able to
speak in the same subtitle, then that's not possible in WebSRT. It's a
little more verbose in HTML, but not massively.

We might be able to add a special markup similar to the &lt;[timestamp]&gt; markup
that Hixie introduced for Karaoke. This is beyond the innerHTML parser and I
am not sure if it breaks it. But if it doesn't, then maybe we can also
introduce a &lt;[voice]&gt; marker to be used similarly?



&gt;<i>
</I>&gt;<i>   * there is no means to identify which parser is required in the cues (is
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> it
</I>&gt;&gt;&gt;&gt;<i> &quot;plain text&quot;, &quot;minimal markup&quot;, or &quot;anything&quot;?) and therefore it is not
</I>&gt;&gt;&gt;&gt;<i> possible for an application to know how it should parse the cues.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> All the types that are actually for visual rendering are parsed in the
</I>&gt;&gt;&gt;<i> same
</I>&gt;&gt;&gt;<i> way, aren't they? Of course there's no way for non-browsers to know that
</I>&gt;&gt;&gt;<i> metadata tracks aren't interesting to look at as subtitles, but I think
</I>&gt;&gt;&gt;<i> showing the user the garbage is a quicker to communicate that the file
</I>&gt;&gt;&gt;<i> isn't
</I>&gt;&gt;&gt;<i> for direct viewing than hiding the text or similar.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The spec says that files of kind &quot;descriptions&quot; and &quot;metadata&quot; are not
</I>&gt;&gt;<i> displayed. It seems though that the parsing section will try two
</I>&gt;&gt;<i> interfaces:
</I>&gt;&gt;<i> HTML and plain. I think there is a disconnect there. If we already know
</I>&gt;&gt;<i> that
</I>&gt;&gt;<i> it's not parsable in HTML, why even try?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I was confused. The parsing algorithm does the same thing regardless of
</I>&gt;<i> what kind of text track it is dealing with. I guess what you're saying is
</I>&gt;<i> that non-browser applications also need to know that something is e.g.
</I>&gt;<i> chapter markers, so that it can display it appropriately?
</I>&gt;<i>
</I>&gt;<i> I don't have a strong opinion, but repeating the same information both in
</I>&gt;<i> the containing document and in the subtitle file means that one of them will
</I>&gt;<i> be ignored by browsers. People will copy-paste the ignored one and it will
</I>&gt;<i> end up being wrong a lot of the time.
</I>

I don't see a problem with repeating this information.There will be files
and other file formats that do not have the &quot;kind&quot; inside the file - maybe
because the files are always only used for captions/subtitles or only for
lyrics/karaoke and thus don't need an extra specification. But for WebSRT
files, which provide a platform for time-synchronized text, this is
important information to have inside the file - or assume a default of
&quot;captions&quot; or so. Thus, for files that do not have a &quot;kind&quot;, the
specification in HTML is necessary. For those that do, it provides the
author with an opportunity to take that hint or even to override it. An
authoring application could even alert a Web developer if they are
referencing a &quot;chapters&quot; file with a &quot;subtitles&quot; @kind attribute. But
obviously what is stated in the HTML page will be what matters.



&gt;<i>
</I>&gt;<i>   * there is no version number on the format, thus it will be difficult to
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> introduce future changes.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I think we shouldn't have a version number, for the same reason that CSS
</I>&gt;&gt;&gt;<i> and HTML don't really have versions. If we evolve the WebSRT spec, it
</I>&gt;&gt;&gt;<i> should
</I>&gt;&gt;&gt;<i> be in a backwards-compatible way.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> CSS and HTML are structured formats where you ignore things that you
</I>&gt;&gt;<i> cannot
</I>&gt;&gt;<i> interpret. But the parsing is fixed and extensions play within this
</I>&gt;&gt;<i> parsing
</I>&gt;&gt;<i> framework. I have my doubts that is possible with WebSRT. Already one
</I>&gt;&gt;<i> extension that we are discussion here will break parsing: the introduction
</I>&gt;&gt;<i> of structured headers. Because there is no structured way of extending
</I>&gt;&gt;<i> WebSRT, I believe the best way to communicate whether it is backwards
</I>&gt;&gt;<i> compatible is through a version number. We can change the minor versions
</I>&gt;&gt;<i> if
</I>&gt;&gt;<i> the compatibility is not broken - it communicates though what features are
</I>&gt;&gt;<i> being used - and we can change the major version of compatibility is
</I>&gt;&gt;<i> broken.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Similarly, I think that the WebSRT parser should be designed to ignore
</I>&gt;<i> things that it doesn't recognize, in particular unknown voices (if we keep
</I>&gt;<i> those). Requiring parsers to fail when the version number is increased
</I>

oh, you misunderstood me: I am not saying that parser have to fail - it's
good if they don't. But I am saying that if we make a change to the
specification that is not backwards compatible with the previous one and
will thus invariably break parsers, we have to notify parsers somehow such
that if they get parse errors they can e.g. notify the user that this is a
new version of the WebSRT format which their software doesn't support yet.
Think for example about the case where we had a requirement that a double
newline starts a new cue, but now we want to introduce a means where the
double newline is escaped and can be made part of a cue.

Other formats keep track of their version, such as MS Word files. It is to
be hoped that most new features can be introduced without breaking backwards
compatibility and we can write the parsing requirements such that certain
things will be ignored, but in and of itself, WebSRT doesn't provide for
this extensibility. Right now, there is for example extensibility with the
&quot;WebSRT settings parsing&quot; (that's the stuff behind the timestamps) where
further &quot;setting:value&quot; settings can be introduced. But for example the
introduction of new &quot;cue identifiers&quot; (that's the &lt;&gt; marker at the start of
a cue) would be difficult without a version string, since anything that
doesn't match the given list will just be parsed as cue-internal tag and
thus end up as part of the cue text where plain text parsing is used.



&gt;<i> makes it harder to introduce changes to the format, because you'll have to
</I>&gt;<i> either break all existing implementations or provide one subtitle file for
</I>&gt;<i> each version. (Having a version number but letting parsers ignore it is just
</I>&gt;<i> weird, quite like in HTML.)
</I>&gt;<i>
</I>&gt;<i> I filed a bug suggesting that voice is allowed to be an arbitrary string: &lt;
</I>&gt;<i> <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=10320">http://www.w3.org/Bugs/Public/show_bug.cgi?id=10320</A>&gt; (From the point of
</I>&gt;<i> view of the parser, it still wouldn't be valid syntax.)
</I>


As it stands, the voice marker is more of a &quot;WebSRT setting&quot; for the
complete cue and should probably be moved up with the other &quot;WebSRT
settings&quot;, since it's not markup inside the cue like the others and should
not end up as a token during parsing.




&gt;<i>
</I>&gt;<i>   2. Break the SRT link.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  * the mime type of WebSRT resources should be a different mime type to
</I>&gt;&gt;&gt;<i> SRT
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> files, since they are so fundamentally different; e.g. text/websrt
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> * the file extension of WebSRT resources should be different from SRT
</I>&gt;&gt;&gt;&gt;<i> files,
</I>&gt;&gt;&gt;&gt;<i> e.g. wsrt
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I'm not sure if either of these would make a difference.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Really? How do you propose that a media player identifies that it cannot
</I>&gt;&gt;<i> parse a WebSRT file that has random metadata in it when it is called .srt
</I>&gt;&gt;<i> and provided under the same mime type as SRT files? Or a transcoding
</I>&gt;&gt;<i> pipeline that relies on srt files just being plain old simple SRT. It
</I>&gt;&gt;<i> breaks
</I>&gt;&gt;<i> expectations with users, with developers and with software.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I think it's unlikely that people will offer download links to SRT files
</I>&gt;<i> that aren't useful outside of the page, so random metadata isn't likely to
</I>&gt;<i> reach end users or applications by accident. Also, most media frameworks
</I>&gt;<i> rely mainly on sniffing, so even a file that uses lots of WebSRT-only
</I>&gt;<i> features is quite likely going to be detected as SRT anyway. At least in
</I>&gt;<i> GStreamer, the file extension is given quite little weight in guessing the
</I>&gt;<i> type and MIME isn't used at all (because the sniffing code doesn't know
</I>&gt;<i> anything about HTTP). Finally, seeing random metadata displayed on screen is
</I>&gt;<i> about as good an indication that the file is &quot;broken&quot; as the application
</I>&gt;<i> failing to recognize the file completely.
</I>&gt;<i>
</I>
But very poor user experience and a &quot;WTF: I thought this application
supported SRT and now it doesn't&quot;. Transcoding pipelines will break in
existing productions that expect the simplest SRT without much tolerance for
extra characters and they will have the extra markup of voice and ruby etc
in plain sight, since they are not built as WebSRT parsers. It will lead to
many many headaches. We're even against serving a WebM resource as a .mkv
video with video/x-matroska MIME type when WebM is really completely
compatible with Matroska. So, why do it with WebSRT and SRT?



&gt;<i>
</I>&gt;<i> On the other hand, keeping the same extension and (unregistered) MIME type
</I>&gt;<i> as SRT has plenty of benefits, such as immediately being able to use
</I>&gt;<i> existing SRT files in browsers without changing their file extension or MIME
</I>&gt;<i> type.
</I>

There is no harm for browsers to accept both MIME types if they are sure
they can parse old srt as well as new websrt. But these two formats are
different enough that they should be given a different extension and mime
type. I do not see a single advantage in stealing the MIME type of an
existing format for a new specification.



&gt;<i>
</I>&gt;<i>   * there is no definition of the &quot;canvas&quot; dimensions that the cues are
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> prepared for (width/height) and expected to work with other than saying
</I>&gt;&gt;&gt;&gt;<i> it
</I>&gt;&gt;&gt;&gt;<i> is the video dimensions - but these can change and the proportions
</I>&gt;&gt;&gt;&gt;<i> should
</I>&gt;&gt;&gt;&gt;<i> be
</I>&gt;&gt;&gt;&gt;<i> changed with that
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I'm not sure what you're saying here. Should the subtitle file be
</I>&gt;&gt;&gt;<i> hard-coded to a particular size? In the quite peculiar case where the
</I>&gt;&gt;&gt;<i> same
</I>&gt;&gt;&gt;<i> subtitles really don't work at two different resolutions, couldn't we
</I>&gt;&gt;&gt;<i> just
</I>&gt;&gt;&gt;<i> have two files? In what cases would this be needed?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Most subtitles will be created with a specific width and height in mind.
</I>&gt;&gt;<i> For
</I>&gt;&gt;<i> example, the width in characters relies on the video canvas having at
</I>&gt;&gt;<i> least
</I>&gt;&gt;<i> that size and the number of lines used usually refers to a lower third of
</I>&gt;&gt;<i> a
</I>&gt;&gt;<i> video - where that is too small, it might cover the whole video. So, my
</I>&gt;&gt;<i> proposal is not the hard-code the subtitles to a particular size, but to
</I>&gt;&gt;<i> put
</I>&gt;&gt;<i> the minimum width and height that are being used for the creation of the
</I>&gt;&gt;<i> subtitles into the file. Then, the file can be scaled below or above this
</I>&gt;&gt;<i> size to adjust to the actual available space.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In practice, does this mean scaling font-size by
</I>&gt;<i> width_actual/width_intended or similar? Personally, I prefer subtitles to be
</I>&gt;<i> something like 20 screen pixels regardless of video size, as that is
</I>&gt;<i> readable. Making them bigger hides more of the video, while making them
</I>&gt;<i> smaller makes them hard to read. But I guess we could let the CSS media
</I>&gt;<i> query min-width and similar be evaluated against the size of the containing
</I>&gt;<i> video element, to make it possible anyway.
</I>


Have you ever tried to keep the small font size of subtitles on a 320x240
video when going full-screen? They are almost unusable at that size. YouTube
doesn't do a good job at that, incidentally, so you can go check it out
there - go full-screen and see how tiny the captions become then step back
from your screen to where you'd want to watch the video from and notice how
the captions are basically unreadable.

When you scale the font-size with the video, you do not hide more of the
video - you hide the exact same part of the video. Video and font get larger
in the same way. And that's exactly the need that we have.


Cheers,
Silvia.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20100810/64f3915a/attachment-0002.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20100810/64f3915a/attachment-0002.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="070029.html">[whatwg] Fwd:  Discussing WebSRT and alternatives/improvements
</A></li>
	<LI>Next message: <A HREF="070077.html">[whatwg] Fwd: Discussing WebSRT and alternatives/improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70050">[ date ]</a>
              <a href="thread.html#70050">[ thread ]</a>
              <a href="subject.html#70050">[ subject ]</a>
              <a href="author.html#70050">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
