<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Fwd: Discussing WebSRT and alternatives/improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Fwd%3A%20Discussing%20WebSRT%20and%20alternatives/improvements&In-Reply-To=%3Cop.vg7uw9ogsr6mfa%40philip-pc.gothenburg.osa%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="070050.html">
   <LINK REL="Next"  HREF="070111.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Fwd: Discussing WebSRT and alternatives/improvements</H1>
<!--htdig_noindex-->
    <B>Philip J&#228;genstedt</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Fwd%3A%20Discussing%20WebSRT%20and%20alternatives/improvements&In-Reply-To=%3Cop.vg7uw9ogsr6mfa%40philip-pc.gothenburg.osa%3E"
       TITLE="[whatwg] Fwd: Discussing WebSRT and alternatives/improvements">philipj at opera.com
       </A><BR>
    <I>Tue Aug 10 02:49:47 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="070050.html">[whatwg] Fwd: Discussing WebSRT and alternatives/improvements
</A></li>
        <LI>Next message: <A HREF="070111.html">[whatwg] Fwd: Discussing WebSRT and alternatives/improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70077">[ date ]</a>
              <a href="thread.html#70077">[ thread ]</a>
              <a href="subject.html#70077">[ subject ]</a>
              <a href="author.html#70077">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Tue, 10 Aug 2010 01:34:02 +0200, Silvia Pfeiffer  
&lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">silviapfeiffer1 at gmail.com</A>&gt; wrote:

&gt;<i> On Tue, Aug 10, 2010 at 12:04 AM, Philip J&#228;genstedt  
</I>&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt;wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> On Sat, 07 Aug 2010 09:57:39 +0200, Silvia Pfeiffer &lt;
</I>&gt;&gt;<i> <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">silviapfeiffer1 at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  Hi Philip,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On Sat, Aug 7, 2010 at 1:50 AM, Philip J&#228;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt;
</I>&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  I'm not sure of the best solution. I'd quite like the ability to use
</I>&gt;&gt;&gt;&gt;<i> arbitrary voices, e.g. to use the names/initials of the speaker rather
</I>&gt;&gt;&gt;&gt;<i> than
</I>&gt;&gt;&gt;&gt;<i> a number, or to use e.g. &lt;shouting&gt; in combination with CSS :before {
</I>&gt;&gt;&gt;&gt;<i> content 'Shouting: ' } or similar to adapt the display for different
</I>&gt;&gt;&gt;&gt;<i> audiences (accessibility, basically).
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I agree. I think we can go back to using&lt;span&gt; and @class and @id and  
</I>&gt;&gt;&gt;<i> that
</I>&gt;&gt;&gt;<i> would solve it all.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I guess this is in support of Henri's proposal of parsing the cue using  
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> HTML fragment parser (same as innerHTML)? That would be easy to  
</I>&gt;&gt;<i> implement,
</I>&gt;&gt;<i> but how do we then mark up speakers? Using &lt;span  
</I>&gt;&gt;<i> class=&quot;narrator&quot;&gt;&lt;/span&gt;
</I>&gt;&gt;<i> around each cue is very verbose. HTML isn't very good for marking up  
</I>&gt;&gt;<i> dialog,
</I>&gt;&gt;<i> which is quite a limitation when dealing with subtitles...
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I actually think that the &lt;span @class&gt; mechanism is much more flexible  
</I>&gt;<i> than
</I>&gt;<i> what we have in WebSRT right now. If we want multiple speakers to be  
</I>&gt;<i> able to
</I>&gt;<i> speak in the same subtitle, then that's not possible in WebSRT. It's a
</I>&gt;<i> little more verbose in HTML, but not massively.
</I>&gt;<i>
</I>&gt;<i> We might be able to add a special markup similar to the &lt;[timestamp]&gt;  
</I>&gt;<i> markup
</I>&gt;<i> that Hixie introduced for Karaoke. This is beyond the innerHTML parser  
</I>&gt;<i> and I
</I>&gt;<i> am not sure if it breaks it. But if it doesn't, then maybe we can also
</I>&gt;<i> introduce a &lt;[voice]&gt; marker to be used similarly?
</I>
An HTML parser parsing &lt;1&gt; or &lt;00:01:30&gt; will produce text nodes &quot;&lt;1&gt;&quot; and  
&quot;&lt;00:01:30&gt;&quot;. Without having read the HTML parsing algorithm I guess that  
elements need to begin with a letter or similar. So, it's not possible to  
(ab)use the HTML parser to handle inner timestamps of numerical voices,  
we'd have to replace those with something else, probably more verbose.

&gt;&gt;<i>   * there is no version number on the format, thus it will be difficult  
</I>&gt;&gt;<i> to
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> introduce future changes.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I think we shouldn't have a version number, for the same reason that  
</I>&gt;&gt;&gt;&gt;<i> CSS
</I>&gt;&gt;&gt;&gt;<i> and HTML don't really have versions. If we evolve the WebSRT spec, it
</I>&gt;&gt;&gt;&gt;<i> should
</I>&gt;&gt;&gt;&gt;<i> be in a backwards-compatible way.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> CSS and HTML are structured formats where you ignore things that you
</I>&gt;&gt;&gt;<i> cannot
</I>&gt;&gt;&gt;<i> interpret. But the parsing is fixed and extensions play within this
</I>&gt;&gt;&gt;<i> parsing
</I>&gt;&gt;&gt;<i> framework. I have my doubts that is possible with WebSRT. Already one
</I>&gt;&gt;&gt;<i> extension that we are discussion here will break parsing: the  
</I>&gt;&gt;&gt;<i> introduction
</I>&gt;&gt;&gt;<i> of structured headers. Because there is no structured way of extending
</I>&gt;&gt;&gt;<i> WebSRT, I believe the best way to communicate whether it is backwards
</I>&gt;&gt;&gt;<i> compatible is through a version number. We can change the minor  
</I>&gt;&gt;&gt;<i> versions
</I>&gt;&gt;&gt;<i> if
</I>&gt;&gt;&gt;<i> the compatibility is not broken - it communicates though what features  
</I>&gt;&gt;&gt;<i> are
</I>&gt;&gt;&gt;<i> being used - and we can change the major version of compatibility is
</I>&gt;&gt;&gt;<i> broken.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Similarly, I think that the WebSRT parser should be designed to ignore
</I>&gt;&gt;<i> things that it doesn't recognize, in particular unknown voices (if we  
</I>&gt;&gt;<i> keep
</I>&gt;&gt;<i> those). Requiring parsers to fail when the version number is increased
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> oh, you misunderstood me: I am not saying that parser have to fail - it's
</I>&gt;<i> good if they don't. But I am saying that if we make a change to the
</I>&gt;<i> specification that is not backwards compatible with the previous one and
</I>&gt;<i> will thus invariably break parsers, we have to notify parsers somehow  
</I>&gt;<i> such
</I>&gt;<i> that if they get parse errors they can e.g. notify the user that this is  
</I>&gt;<i> a
</I>&gt;<i> new version of the WebSRT format which their software doesn't support  
</I>&gt;<i> yet.
</I>
A browser won't bother their users by saying &quot;hey, there was something in  
this page I didn't understand&quot;, as users won't know what to do to fix it.

&gt;<i> Think for example about the case where we had a requirement that a double
</I>&gt;<i> newline starts a new cue, but now we want to introduce a means where the
</I>&gt;<i> double newline is escaped and can be made part of a cue.
</I>&gt;<i>
</I>&gt;<i> Other formats keep track of their version, such as MS Word files. It is  
</I>&gt;<i> to
</I>&gt;<i> be hoped that most new features can be introduced without breaking  
</I>&gt;<i> backwards
</I>&gt;<i> compatibility and we can write the parsing requirements such that certain
</I>&gt;<i> things will be ignored, but in and of itself, WebSRT doesn't provide for
</I>&gt;<i> this extensibility. Right now, there is for example extensibility with  
</I>&gt;<i> the
</I>&gt;<i> &quot;WebSRT settings parsing&quot; (that's the stuff behind the timestamps) where
</I>&gt;<i> further &quot;setting:value&quot; settings can be introduced. But for example the
</I>&gt;<i> introduction of new &quot;cue identifiers&quot; (that's the &lt;&gt; marker at the start  
</I>&gt;<i> of
</I>&gt;<i> a cue) would be difficult without a version string, since anything that
</I>&gt;<i> doesn't match the given list will just be parsed as cue-internal tag and
</I>&gt;<i> thus end up as part of the cue text where plain text parsing is used.
</I>
The bug I filed suggested allowing arbitrary voices, to simplify the  
parser and to make future extensions possible. For a web format I think  
this is a better approach format than versioning. I haven't done a full  
review of the parser, but there are probably more places where it could be  
more forgiving so as to allow future tweaking.

&gt;&gt;<i> makes it harder to introduce changes to the format, because you'll have  
</I>&gt;&gt;<i> to
</I>&gt;&gt;<i> either break all existing implementations or provide one subtitle file  
</I>&gt;&gt;<i> for
</I>&gt;&gt;<i> each version. (Having a version number but letting parsers ignore it is  
</I>&gt;&gt;<i> just
</I>&gt;&gt;<i> weird, quite like in HTML.)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I filed a bug suggesting that voice is allowed to be an arbitrary  
</I>&gt;&gt;<i> string: &lt;
</I>&gt;&gt;<i> <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=10320">http://www.w3.org/Bugs/Public/show_bug.cgi?id=10320</A>&gt; (From the point of
</I>&gt;&gt;<i> view of the parser, it still wouldn't be valid syntax.)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> As it stands, the voice marker is more of a &quot;WebSRT setting&quot; for the
</I>&gt;<i> complete cue and should probably be moved up with the other &quot;WebSRT
</I>&gt;<i> settings&quot;, since it's not markup inside the cue like the others and  
</I>&gt;<i> should
</I>&gt;<i> not end up as a token during parsing.
</I>
Yeah, that would also be an option.

&gt;&gt;<i>   2. Break the SRT link.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  * the mime type of WebSRT resources should be a different mime type  
</I>&gt;&gt;&gt;&gt;<i> to
</I>&gt;&gt;&gt;&gt;<i> SRT
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> files, since they are so fundamentally different; e.g. text/websrt
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> * the file extension of WebSRT resources should be different from SRT
</I>&gt;&gt;&gt;&gt;&gt;<i> files,
</I>&gt;&gt;&gt;&gt;&gt;<i> e.g. wsrt
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I'm not sure if either of these would make a difference.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Really? How do you propose that a media player identifies that it  
</I>&gt;&gt;&gt;<i> cannot
</I>&gt;&gt;&gt;<i> parse a WebSRT file that has random metadata in it when it is called  
</I>&gt;&gt;&gt;<i> .srt
</I>&gt;&gt;&gt;<i> and provided under the same mime type as SRT files? Or a transcoding
</I>&gt;&gt;&gt;<i> pipeline that relies on srt files just being plain old simple SRT. It
</I>&gt;&gt;&gt;<i> breaks
</I>&gt;&gt;&gt;<i> expectations with users, with developers and with software.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think it's unlikely that people will offer download links to SRT files
</I>&gt;&gt;<i> that aren't useful outside of the page, so random metadata isn't likely  
</I>&gt;&gt;<i> to
</I>&gt;&gt;<i> reach end users or applications by accident. Also, most media frameworks
</I>&gt;&gt;<i> rely mainly on sniffing, so even a file that uses lots of WebSRT-only
</I>&gt;&gt;<i> features is quite likely going to be detected as SRT anyway. At least in
</I>&gt;&gt;<i> GStreamer, the file extension is given quite little weight in guessing  
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> type and MIME isn't used at all (because the sniffing code doesn't know
</I>&gt;&gt;<i> anything about HTTP). Finally, seeing random metadata displayed on  
</I>&gt;&gt;<i> screen is
</I>&gt;&gt;<i> about as good an indication that the file is &quot;broken&quot; as the application
</I>&gt;&gt;<i> failing to recognize the file completely.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> But very poor user experience and a &quot;WTF: I thought this application
</I>&gt;<i> supported SRT and now it doesn't&quot;. Transcoding pipelines will break in
</I>&gt;<i> existing productions that expect the simplest SRT without much tolerance  
</I>&gt;<i> for
</I>&gt;<i> extra characters and they will have the extra markup of voice and ruby  
</I>&gt;<i> etc
</I>&gt;<i> in plain sight, since they are not built as WebSRT parsers. It will lead  
</I>&gt;<i> to many many headaches.
</I>
Yes, it cannot be denied that there will be some confusion.

&gt;<i> We're even against serving a WebM resource as a .mkv
</I>&gt;<i> video with video/x-matroska MIME type when WebM is really completely
</I>&gt;<i> compatible with Matroska. So, why do it with WebSRT and SRT?
</I>
For the record, we at Opera argued against changing the EBML doctype to  
&quot;webm&quot; and artificially breaking compatibility with Matroska. However,  
that wasn't our decision to make and now it's better to only support one  
doctype/extension/mime type.

&gt;&gt;<i> On the other hand, keeping the same extension and (unregistered) MIME  
</I>&gt;&gt;<i> type
</I>&gt;&gt;<i> as SRT has plenty of benefits, such as immediately being able to use
</I>&gt;&gt;<i> existing SRT files in browsers without changing their file extension or  
</I>&gt;&gt;<i> MIME
</I>&gt;&gt;<i> type.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> There is no harm for browsers to accept both MIME types if they are sure
</I>&gt;<i> they can parse old srt as well as new websrt. But these two formats are
</I>&gt;<i> different enough that they should be given a different extension and mime
</I>&gt;<i> type. I do not see a single advantage in stealing the MIME type of an
</I>&gt;<i> existing format for a new specification.
</I>
But there's no spec for the old SRT, the only thing one could do is parser  
it with a WebSRT parser. That would make text/srt and text/websrt  
synonymous, which is kind of pointless. The advantages of taking text/srt  
is that all existing software to create SRT can be used to create WebSRT  
and servers that already send text/srt don't need to be updated. In either  
case I think we should support only one mime type.

&gt;&gt;<i>   * there is no definition of the &quot;canvas&quot; dimensions that the cues are
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> prepared for (width/height) and expected to work with other than  
</I>&gt;&gt;&gt;&gt;&gt;<i> saying
</I>&gt;&gt;&gt;&gt;&gt;<i> it
</I>&gt;&gt;&gt;&gt;&gt;<i> is the video dimensions - but these can change and the proportions
</I>&gt;&gt;&gt;&gt;&gt;<i> should
</I>&gt;&gt;&gt;&gt;&gt;<i> be
</I>&gt;&gt;&gt;&gt;&gt;<i> changed with that
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I'm not sure what you're saying here. Should the subtitle file be
</I>&gt;&gt;&gt;&gt;<i> hard-coded to a particular size? In the quite peculiar case where the
</I>&gt;&gt;&gt;&gt;<i> same
</I>&gt;&gt;&gt;&gt;<i> subtitles really don't work at two different resolutions, couldn't we
</I>&gt;&gt;&gt;&gt;<i> just
</I>&gt;&gt;&gt;&gt;<i> have two files? In what cases would this be needed?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Most subtitles will be created with a specific width and height in  
</I>&gt;&gt;&gt;<i> mind.
</I>&gt;&gt;&gt;<i> For
</I>&gt;&gt;&gt;<i> example, the width in characters relies on the video canvas having at
</I>&gt;&gt;&gt;<i> least
</I>&gt;&gt;&gt;<i> that size and the number of lines used usually refers to a lower third  
</I>&gt;&gt;&gt;<i> of
</I>&gt;&gt;&gt;<i> a
</I>&gt;&gt;&gt;<i> video - where that is too small, it might cover the whole video. So, my
</I>&gt;&gt;&gt;<i> proposal is not the hard-code the subtitles to a particular size, but  
</I>&gt;&gt;&gt;<i> to
</I>&gt;&gt;&gt;<i> put
</I>&gt;&gt;&gt;<i> the minimum width and height that are being used for the creation of  
</I>&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;<i> subtitles into the file. Then, the file can be scaled below or above  
</I>&gt;&gt;&gt;<i> this
</I>&gt;&gt;&gt;<i> size to adjust to the actual available space.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In practice, does this mean scaling font-size by
</I>&gt;&gt;<i> width_actual/width_intended or similar? Personally, I prefer subtitles  
</I>&gt;&gt;<i> to be
</I>&gt;&gt;<i> something like 20 screen pixels regardless of video size, as that is
</I>&gt;&gt;<i> readable. Making them bigger hides more of the video, while making them
</I>&gt;&gt;<i> smaller makes them hard to read. But I guess we could let the CSS media
</I>&gt;&gt;<i> query min-width and similar be evaluated against the size of the  
</I>&gt;&gt;<i> containing
</I>&gt;&gt;<i> video element, to make it possible anyway.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Have you ever tried to keep the small font size of subtitles on a 320x240
</I>&gt;<i> video when going full-screen? They are almost unusable at that size.  
</I>&gt;<i> YouTube
</I>&gt;<i> doesn't do a good job at that, incidentally, so you can go check it out
</I>&gt;<i> there - go full-screen and see how tiny the captions become then step  
</I>&gt;<i> back
</I>&gt;<i> from your screen to where you'd want to watch the video from and notice  
</I>&gt;<i> how
</I>&gt;<i> the captions are basically unreadable.
</I>&gt;<i>
</I>&gt;<i> When you scale the font-size with the video, you do not hide more of the
</I>&gt;<i> video - you hide the exact same part of the video. Video and font get  
</I>&gt;<i> larger
</I>&gt;<i> in the same way. And that's exactly the need that we have.
</I>
Existing media players have basically two different ways of handling this.  
The kind you're describing is like MPlayer, where subtitles appear to  
actually be rendered on to the video frames and then scaled together with  
the video. The kind I've used more is like Totem, where subtitles are  
rendered in a separate layer at a fixed size in pixels, regardless of  
whether or not you're watching in fullscreen. This means that word  
wrapping will be different depending on screen size. I find both MPlayer's  
and Totem's behavior annoying in some situations, but personally prefer  
Totem most of the time.

Certainly you want a different size depending on whether you're going to  
watch from your desk or from the sofa, so I guess we'd want to make it  
easy to adjust the size.

-- 
Philip J&#228;genstedt
Core Developer
Opera Software

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="070050.html">[whatwg] Fwd: Discussing WebSRT and alternatives/improvements
</A></li>
	<LI>Next message: <A HREF="070111.html">[whatwg] Fwd: Discussing WebSRT and alternatives/improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70077">[ date ]</a>
              <a href="thread.html#70077">[ thread ]</a>
              <a href="subject.html#70077">[ subject ]</a>
              <a href="author.html#70077">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
