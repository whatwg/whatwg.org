<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Fwd:  Discussing WebSRT and alternatives/improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Fwd%3A%20%20Discussing%20WebSRT%20and%20alternatives/improvements&In-Reply-To=%3Cop.vg6b2bhpsr6mfa%40philip-pc.gothenburg.osa%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="069994.html">
   <LINK REL="Next"  HREF="070050.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Fwd:  Discussing WebSRT and alternatives/improvements</H1>
<!--htdig_noindex-->
    <B>Philip J&#228;genstedt</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Fwd%3A%20%20Discussing%20WebSRT%20and%20alternatives/improvements&In-Reply-To=%3Cop.vg6b2bhpsr6mfa%40philip-pc.gothenburg.osa%3E"
       TITLE="[whatwg] Fwd:  Discussing WebSRT and alternatives/improvements">philipj at opera.com
       </A><BR>
    <I>Mon Aug  9 07:04:49 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="069994.html">[whatwg] Fwd:  Discussing WebSRT and alternatives/improvements
</A></li>
        <LI>Next message: <A HREF="070050.html">[whatwg] Fwd: Discussing WebSRT and alternatives/improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70029">[ date ]</a>
              <a href="thread.html#70029">[ thread ]</a>
              <a href="subject.html#70029">[ subject ]</a>
              <a href="author.html#70029">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Sat, 07 Aug 2010 09:57:39 +0200, Silvia Pfeiffer  
&lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">silviapfeiffer1 at gmail.com</A>&gt; wrote:

&gt;<i> Hi Philip,
</I>&gt;<i>
</I>&gt;<i> On Sat, Aug 7, 2010 at 1:50 AM, Philip J&#228;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt;  
</I>&gt;<i> wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> * there is a possibility to provide script that just affects the
</I>&gt;&gt;&gt;<i> time-synchronized text resource
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I agree that some metadata would be useful, more on that below. I'm not
</I>&gt;&gt;<i> sure why we would want to run scripts inside the text document, though,  
</I>&gt;&gt;<i> when
</I>&gt;&gt;<i> that can be accomplished by using the TimedTrack API from the containing
</I>&gt;&gt;<i> page.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Scripts inside a timed text document would only be useful for  
</I>&gt;<i> applications
</I>&gt;<i> that use the track not in conjunction with a Web page.
</I>
Do you mean that media players could include a JavaScript engine just for  
supporting scripts in WebSRT? Not to say that it can't happen, but it  
seems a bit unlikely.

&gt;&gt;<i> 2. There is a natural mapping of WebSRT into in-band text tracks.
</I>&gt;&gt;&gt;<i> Each cue naturally maps into a encoding page (just like a WMML cue  
</I>&gt;&gt;&gt;<i> does,
</I>&gt;&gt;&gt;<i> too). But in WebSRT, because the setup information is not brought in a
</I>&gt;&gt;&gt;<i> hierarchical element surrounding all cues, it is easier to just chuck
</I>&gt;&gt;&gt;<i> anything that comes before the first cue into an encoding header page.  
</I>&gt;&gt;&gt;<i> For
</I>&gt;&gt;&gt;<i> WMML, this problem can be solved, but it is less natural.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I really like the idea of letting everything before the first timestamp  
</I>&gt;&gt;<i> in
</I>&gt;&gt;<i> WebSRT be interpreted as the header. I'd want to use it like this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> # author: Fan Subber
</I>&gt;&gt;<i> # voices: &lt;1&gt; Boy
</I>&gt;&gt;<i> #         &lt;2&gt; Girl
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 01:23:45.678 --&gt; 01:23:46.789
</I>&gt;&gt;<i> &lt;1&gt; Hello
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 01:23:48.910 --&gt; 01:23:49.101
</I>&gt;&gt;<i> &lt;2&gt; Hello
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It's not critical that the format of the header be machine-readable,  
</I>&gt;&gt;<i> but we
</I>&gt;&gt;<i> could of course make up a key-value syntax, use JSON, or something else.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I disagree. I think it's absolutely necessary that the format of the  
</I>&gt;<i> header
</I>&gt;<i> be machine-readable. Just like EXIF in images is machine readable or ID3  
</I>&gt;<i> in
</I>&gt;<i> MP3 is machine-readable. It would be counter-productive not to have it
</I>&gt;<i> machine-readable, in particular useless to archiving and media management
</I>&gt;<i> solutions.
</I>
OK, so maybe key-values?

Author: Fan Subber
Voice: &lt;1&gt; Boy
Voice: &lt;2&gt; Girl

01:23:45.678 --&gt; 01:23:46.789
&lt;1&gt; Hello

This looks a bit like HTTP headers. (I'm not sure I'd actually want to  
allow multiple occurrences of the same key, in practice that seems to  
result in inconsistencies in how people mark up multiple authors.)

&gt;&gt;<i> I'm not sure of the best solution. I'd quite like the ability to use
</I>&gt;&gt;<i> arbitrary voices, e.g. to use the names/initials of the speaker rather  
</I>&gt;&gt;<i> than
</I>&gt;&gt;<i> a number, or to use e.g. &lt;shouting&gt; in combination with CSS :before {
</I>&gt;&gt;<i> content 'Shouting: ' } or similar to adapt the display for different
</I>&gt;&gt;<i> audiences (accessibility, basically).
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I agree. I think we can go back to using&lt;span&gt; and @class and @id and  
</I>&gt;<i> that
</I>&gt;<i> would solve it all.
</I>
I guess this is in support of Henri's proposal of parsing the cue using  
the HTML fragment parser (same as innerHTML)? That would be easy to  
implement, but how do we then mark up speakers? Using &lt;span  
class=&quot;narrator&quot;&gt;&lt;/span&gt; around each cue is very verbose. HTML isn't very  
good for marking up dialog, which is quite a limitation when dealing with  
subtitles...

&gt;&gt;&gt;<i> * there is no language specification for a WebSRT resource; while this
</I>&gt;&gt;&gt;<i> will
</I>&gt;&gt;&gt;<i> not be a problem when used in conjunction with a &lt;track&gt; element, it  
</I>&gt;&gt;&gt;<i> still
</I>&gt;&gt;&gt;<i> is a problem when the resource is used just by itself, in particular  
</I>&gt;&gt;&gt;<i> as a
</I>&gt;&gt;&gt;<i> hint for font selection and speech synthesis.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The language inside the WebSRT file wouldn't end up being used for  
</I>&gt;&gt;<i> anything
</I>&gt;&gt;<i> by a browser, as it needs to know the language before downloading it to  
</I>&gt;&gt;<i> know
</I>&gt;&gt;<i> whether or not to download it at all. Still, I'd like a header section  
</I>&gt;&gt;<i> in
</I>&gt;&gt;<i> WebSRT. I think the parser is already defined so that it would ignore
</I>&gt;&gt;<i> garbage before the first cue, so this is more a matter of making it  
</I>&gt;&gt;<i> legal
</I>&gt;&gt;<i> syntax.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Not quite. Some metadata in the header can make sense to also expose to  
</I>&gt;<i> the
</I>&gt;<i> Web page.
</I>&gt;<i>
</I>&gt;<i> I agree that we need a structured header section in WebSRT.
</I>
Fair enough, we should revisit this when deciding on how to expose  
metadata in media resources in general.

&gt;&gt;<i>  * there is no means to identify which parser is required in the cues  
</I>&gt;&gt;<i> (is
</I>&gt;&gt;&gt;<i> it
</I>&gt;&gt;&gt;<i> &quot;plain text&quot;, &quot;minimal markup&quot;, or &quot;anything&quot;?) and therefore it is not
</I>&gt;&gt;&gt;<i> possible for an application to know how it should parse the cues.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> All the types that are actually for visual rendering are parsed in the  
</I>&gt;&gt;<i> same
</I>&gt;&gt;<i> way, aren't they? Of course there's no way for non-browsers to know that
</I>&gt;&gt;<i> metadata tracks aren't interesting to look at as subtitles, but I think
</I>&gt;&gt;<i> showing the user the garbage is a quicker to communicate that the file  
</I>&gt;&gt;<i> isn't
</I>&gt;&gt;<i> for direct viewing than hiding the text or similar.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The spec says that files of kind &quot;descriptions&quot; and &quot;metadata&quot; are not
</I>&gt;<i> displayed. It seems though that the parsing section will try two  
</I>&gt;<i> interfaces:
</I>&gt;<i> HTML and plain. I think there is a disconnect there. If we already know  
</I>&gt;<i> that
</I>&gt;<i> it's not parsable in HTML, why even try?
</I>
I was confused. The parsing algorithm does the same thing regardless of  
what kind of text track it is dealing with. I guess what you're saying is  
that non-browser applications also need to know that something is e.g.  
chapter markers, so that it can display it appropriately?

I don't have a strong opinion, but repeating the same information both in  
the containing document and in the subtitle file means that one of them  
will be ignored by browsers. People will copy-paste the ignored one and it  
will end up being wrong a lot of the time.

&gt;&gt;<i>  * there is no version number on the format, thus it will be difficult  
</I>&gt;&gt;<i> to
</I>&gt;&gt;&gt;<i> introduce future changes.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think we shouldn't have a version number, for the same reason that CSS
</I>&gt;&gt;<i> and HTML don't really have versions. If we evolve the WebSRT spec, it  
</I>&gt;&gt;<i> should
</I>&gt;&gt;<i> be in a backwards-compatible way.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> CSS and HTML are structured formats where you ignore things that you  
</I>&gt;<i> cannot
</I>&gt;<i> interpret. But the parsing is fixed and extensions play within this  
</I>&gt;<i> parsing
</I>&gt;<i> framework. I have my doubts that is possible with WebSRT. Already one
</I>&gt;<i> extension that we are discussion here will break parsing: the  
</I>&gt;<i> introduction
</I>&gt;<i> of structured headers. Because there is no structured way of extending
</I>&gt;<i> WebSRT, I believe the best way to communicate whether it is backwards
</I>&gt;<i> compatible is through a version number. We can change the minor versions  
</I>&gt;<i> if
</I>&gt;<i> the compatibility is not broken - it communicates though what features  
</I>&gt;<i> are
</I>&gt;<i> being used - and we can change the major version of compatibility is  
</I>&gt;<i> broken.
</I>
Similarly, I think that the WebSRT parser should be designed to ignore  
things that it doesn't recognize, in particular unknown voices (if we keep  
those). Requiring parsers to fail when the version number is increased  
makes it harder to introduce changes to the format, because you'll have to  
either break all existing implementations or provide one subtitle file for  
each version. (Having a version number but letting parsers ignore it is  
just weird, quite like in HTML.)

I filed a bug suggesting that voice is allowed to be an arbitrary string:  
&lt;<A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=10320">http://www.w3.org/Bugs/Public/show_bug.cgi?id=10320</A>&gt; (From the point of  
view of the parser, it still wouldn't be valid syntax.)

&gt;&gt;<i>  2. Break the SRT link.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  * the mime type of WebSRT resources should be a different mime type to  
</I>&gt;&gt;<i> SRT
</I>&gt;&gt;&gt;<i> files, since they are so fundamentally different; e.g. text/websrt
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * the file extension of WebSRT resources should be different from SRT
</I>&gt;&gt;&gt;<i> files,
</I>&gt;&gt;&gt;<i> e.g. wsrt
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not sure if either of these would make a difference.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Really? How do you propose that a media player identifies that it cannot
</I>&gt;<i> parse a WebSRT file that has random metadata in it when it is called .srt
</I>&gt;<i> and provided under the same mime type as SRT files? Or a transcoding
</I>&gt;<i> pipeline that relies on srt files just being plain old simple SRT. It  
</I>&gt;<i> breaks
</I>&gt;<i> expectations with users, with developers and with software.
</I>
I think it's unlikely that people will offer download links to SRT files  
that aren't useful outside of the page, so random metadata isn't likely to  
reach end users or applications by accident. Also, most media frameworks  
rely mainly on sniffing, so even a file that uses lots of WebSRT-only  
features is quite likely going to be detected as SRT anyway. At least in  
GStreamer, the file extension is given quite little weight in guessing the  
type and MIME isn't used at all (because the sniffing code doesn't know  
anything about HTTP). Finally, seeing random metadata displayed on screen  
is about as good an indication that the file is &quot;broken&quot; as the  
application failing to recognize the file completely.

On the other hand, keeping the same extension and (unregistered) MIME type  
as SRT has plenty of benefits, such as immediately being able to use  
existing SRT files in browsers without changing their file extension or  
MIME type.

&gt;&gt;<i>  4. Make full use of CSS
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In the current form, WebSRT only makes limited use of existing CSS. I  
</I>&gt;&gt;&gt;<i> see
</I>&gt;&gt;&gt;<i> particularly the following limitations:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * no use of the positioning functionality is made and instead a new  
</I>&gt;&gt;&gt;<i> means
</I>&gt;&gt;&gt;<i> of
</I>&gt;&gt;&gt;<i> positioning is introduced; it would be nicer to just have this reuse  
</I>&gt;&gt;&gt;<i> CSS
</I>&gt;&gt;&gt;<i> functionality. It would also avoid having to repeat the positioning
</I>&gt;&gt;&gt;<i> information on every single cue.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I agree, the positioning syntax isn't something I'm happy about with
</I>&gt;&gt;<i> WebSRT. I think treating everything that follows the timestamp to be CSS
</I>&gt;&gt;<i> that applies to the whole cue would be better.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Or taking the positioning stuff out of WebSRT and moving it to an  
</I>&gt;<i> external
</I>&gt;<i> CSS file as is done with formatting would make it much simpler.
</I>
Ah, that would be great. It's quite likely that there will only be 1 or 2  
different positions in the whole file, which you don't want to repeat on  
each and every cue.

&gt;&gt;<i>  * there is no definition of the &quot;canvas&quot; dimensions that the cues are
</I>&gt;&gt;&gt;<i> prepared for (width/height) and expected to work with other than  
</I>&gt;&gt;&gt;<i> saying it
</I>&gt;&gt;&gt;<i> is the video dimensions - but these can change and the proportions  
</I>&gt;&gt;&gt;<i> should
</I>&gt;&gt;&gt;<i> be
</I>&gt;&gt;&gt;<i> changed with that
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not sure what you're saying here. Should the subtitle file be
</I>&gt;&gt;<i> hard-coded to a particular size? In the quite peculiar case where the  
</I>&gt;&gt;<i> same
</I>&gt;&gt;<i> subtitles really don't work at two different resolutions, couldn't we  
</I>&gt;&gt;<i> just
</I>&gt;&gt;<i> have two files? In what cases would this be needed?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Most subtitles will be created with a specific width and height in mind.  
</I>&gt;<i> For
</I>&gt;<i> example, the width in characters relies on the video canvas having at  
</I>&gt;<i> least
</I>&gt;<i> that size and the number of lines used usually refers to a lower third  
</I>&gt;<i> of a
</I>&gt;<i> video - where that is too small, it might cover the whole video. So, my
</I>&gt;<i> proposal is not the hard-code the subtitles to a particular size, but to  
</I>&gt;<i> put
</I>&gt;<i> the minimum width and height that are being used for the creation of the
</I>&gt;<i> subtitles into the file. Then, the file can be scaled below or above this
</I>&gt;<i> size to adjust to the actual available space.
</I>
In practice, does this mean scaling font-size by  
width_actual/width_intended or similar? Personally, I prefer subtitles to  
be something like 20 screen pixels regardless of video size, as that is  
readable. Making them bigger hides more of the video, while making them  
smaller makes them hard to read. But I guess we could let the CSS media  
query min-width and similar be evaluated against the size of the  
containing video element, to make it possible anyway.

-- 
Philip J&#228;genstedt
Core Developer
Opera Software

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="069994.html">[whatwg] Fwd:  Discussing WebSRT and alternatives/improvements
</A></li>
	<LI>Next message: <A HREF="070050.html">[whatwg] Fwd: Discussing WebSRT and alternatives/improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70029">[ date ]</a>
              <a href="thread.html#70029">[ thread ]</a>
              <a href="subject.html#70029">[ subject ]</a>
              <a href="author.html#70029">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
