<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] AppCache-related e-mails
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20AppCache-related%20e-mails&In-Reply-To=%3CPine.LNX.4.64.1106062352550.19153%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031883.html">
   <LINK REL="Next"  HREF="074395.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] AppCache-related e-mails</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20AppCache-related%20e-mails&In-Reply-To=%3CPine.LNX.4.64.1106062352550.19153%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] AppCache-related e-mails">ian at hixie.ch
       </A><BR>
    <I>Wed Jun  8 12:21:36 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="031883.html">[whatwg] Pain with the Headers in webkit/appcache.
</A></li>
        <LI>Next message: <A HREF="074395.html">[whatwg] AppCache-related e-mails
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#74237">[ date ]</a>
              <a href="thread.html#74237">[ thread ]</a>
              <a href="subject.html#74237">[ subject ]</a>
              <a href="author.html#74237">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Mon, 31 Jan 2011, Michael Nordman wrote:
&gt;<i> On Mon, Jan 31, 2011 at 4:20 PM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; On Thu, 13 Jan 2011, Michael Nordman wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; AppCache feature request: An https manifest should be able to list 
</I>&gt;<i> &gt;&gt; resources from other https origins.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I've got some app developers asking for this feature. Currently, it's 
</I>&gt;<i> &gt;&gt; explicitly disallowed by the the spec for valid security reasons, but 
</I>&gt;<i> &gt;&gt; there are also valid reasons to have this capability, like a webapp 
</I>&gt;<i> &gt;&gt; that uses resources hosted on gstatic.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Seems like a robots.txt like scheme where a site like gstatic can 
</I>&gt;<i> &gt;&gt; declare that its &quot;OK to appcache me from elsewhere&quot; is needed.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I've opened a chromium bug for this here... 
</I>&gt;<i> &gt;&gt; <A HREF="http://code.google.com/p/chromium/issues/detail?id=69594">http://code.google.com/p/chromium/issues/detail?id=69594</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Why do the valid security reasons not apply in this case?
</I>&gt;<i> 
</I>&gt;<i> The vendors of originA and originB have expressed that its OK for one to 
</I>&gt;<i> appcache resources of the other. In practical terms this is to support a 
</I>&gt;<i> single application being hosted on multiple 'origins'. Google 
</I>&gt;<i> gstatic.com for one example... 
</I>&gt;<i> <A HREF="http://superuser.com/questions/64716/what-is-gstatic-com">http://superuser.com/questions/64716/what-is-gstatic-com</A>
</I>&gt;<i> 
</I>&gt;<i> If I understand the reason for the restrictions on HTTPS as the 
</I>&gt;<i> following...
</I>&gt;<i> 
</I>&gt;<i> &quot;The requirement is intended to prevent hostile.example.com from forcing 
</I>&gt;<i> content from checkout.google.com to be stored onto the user's machine, 
</I>&gt;<i> so that a later offline attack involving grabbing the user's laptop 
</I>&gt;<i> cannot retrieve the information.&quot;
</I>&gt;<i> 
</I>&gt;<i> That doesn't apply in this case because gstatic.com is not hostile to 
</I>&gt;<i> gmail.com.
</I>
&gt;<i> [...suggestion to use CORS...]
</I>
On Mon, 31 Jan 2011, Jonas Sicking wrote:
&gt;<i> On Mon, Jan 31, 2011 at 2:57 PM, Michael Nordman &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">michaeln at google.com</A>&gt; 
</I>&gt;<i> wrote:
</I>&gt;<i> &gt; I don't &#160;fully understand your emphasis on the implied semantics of a 
</I>&gt;<i> &gt; CORS request. You say it *only* means a site can read the response. I 
</I>&gt;<i> &gt; don't see that in the draft spec. Cross-origin XHR may have been the 
</I>&gt;<i> &gt; big motivation behind CORS, but the mechanisms described in the spec 
</I>&gt;<i> &gt; appear agnostic with regard to use cases and the abstract section 
</I>&gt;<i> &gt; seems to invite additional use cases.
</I>&gt;<i> 
</I>&gt;<i> The spec does say what the meaning of the Access-Contol-Allow-Origin 
</I>&gt;<i> header means. You're trying to modify that meaning.
</I>&gt;<i> 
</I>&gt;<i> Consider things from a web authors point of view. The author develops a 
</I>&gt;<i> website, bunnies.com, which contains a HTML page which performs 
</I>&gt;<i> same-site, and thus trusted, XHR requests. The HTML page additionally 
</I>&gt;<i> exposes an API based on postMessage to allow parent frames to 
</I>&gt;<i> communicate with it.
</I>
As specced, this isn't possible. Nothing from an appcache is ever run with 
the origin privileges of an origin other than the cache manifest's origin.


&gt;<i> Since the site exposes various useful HTTP APIs it further has adds 
</I>&gt;<i> Access-Control-Allow-Origin: &lt;origin&gt; Access-Control-Allow-Credentials: 
</I>&gt;<i> true
</I>&gt;<i> 
</I>&gt;<i> to a set of the URLs on the site. Including the url of the static HTML 
</I>&gt;<i> page. This is per CORS safe since the HTML page is static there is no 
</I>&gt;<i> information leakage that doesn't happen through a normal 
</I>&gt;<i> server-to-server request anyway.
</I>&gt;<i> 
</I>&gt;<i> However, with the modification you are proposing, an attacker site could 
</I>&gt;<i> forever pin this page the users app-cache. This means that if there is a 
</I>&gt;<i> security bug in the page, the attacker site could exploit that security 
</I>&gt;<i> problem forever since any javascript in the page will continue to run in 
</I>&gt;<i> the security context of bunnies.com. So all of a sudden the CORS headers 
</I>&gt;<i> that the site added has now had a severe security impact.
</I>&gt;<i> 
</I>&gt;<i> That's why I'm hampering on the semantics.
</I>&gt;<i> 
</I>&gt;<i> Another issue is that if a site *is* willing to allow resources to be 
</I>&gt;<i> pinned in the app-cache of another site, it might still not be willing 
</I>&gt;<i> to share the contents of those resources with everyone. If we reuse the 
</I>&gt;<i> existing CORS headers to express &quot;is allowed to be app-cache pinned&quot;, 
</I>&gt;<i> then we can't satisfy that use case.
</I>&gt;<i> 
</I>&gt;<i> For example a website could create a HTML page which embeds a 
</I>&gt;<i> user-specific key and exposes a postMessage based API for third party 
</I>&gt;<i> sites to encrypt/decrypt content using that users key. To allow this to 
</I>&gt;<i> happen for off-line apps it wants to allow the HTML page to be pinned in 
</I>&gt;<i> a third party app-cache. But it doesn't want to expose the actual key to 
</I>&gt;<i> the third party sites. If CORS was used to allow cache-pinning, this 
</I>&gt;<i> wouldn't be possible.
</I>
Well this problem doesn't exist for HTML pages, since they wouldn't ever 
run from the appcache, so the above wouldn't work anyway. But your concern 
is valid for, e.g., an image: if we use CORS to allow pinning HTTPS 
resources, there'd be no way to allow an HTTPS resource to be pinned 
without granting read access to that resource as well.


On Tue, 8 Feb 2011, Michael Nordman wrote:
&gt;<i> 
</I>&gt;<i> Just had an offline discussion about this and I think the answer can be 
</I>&gt;<i> much simpler than what's been proposed so far.  All we have to do for 
</I>&gt;<i> cross-origin HTTPS resources is respect the cache-control no-store 
</I>&gt;<i> header.
</I>&gt;<i> 
</I>&gt;<i> Let me explain the rationale... first let's back up to the motivation 
</I>&gt;<i> for the restrictions on HTTPS. They're there to defeat attacks that 
</I>&gt;<i> involve physical access the the client system, so the attacker cannot 
</I>&gt;<i> look at the cross-origin HTTS data stored in the appcache on disk. But 
</I>&gt;<i> the regular disk cache stores HTTPS data provided the cache-control 
</I>&gt;<i> header doesn't say no-store, so excluding this data from appcaching does 
</I>&gt;<i> nothing to defeat that attack.
</I>&gt;<i> 
</I>&gt;<i> Maybe the spec changes to make are...
</I>&gt;<i>
</I>&gt;<i> 1) Examine the cache-control header for all cross-origin resources (not 
</I>&gt;<i> just HTTPS), and only allow them if they don't contain the &quot;no-store&quot; 
</I>&gt;<i> directive.
</I>&gt;<i>
</I>&gt;<i> 2) Remove the special-case restriction that is currently in place only 
</I>&gt;<i> for HTTPS cross-origin resources.
</I>
On Wed, 30 Mar 2011, Michael Nordman wrote:
&gt;<i>
</I>&gt;<i> Fyi: This change has been made in chrome.
</I>&gt;<i> * respect &quot;no-store&quot; headers for cross-origin resources (only for HTTPS)
</I>&gt;<i> * allow HTTPS cross-origin resources to be listed in manifest hosted on
</I>&gt;<i> HTTPS
</I>
This seems reasonable. Done.


On Tue, 1 Feb 2011, Patrick Mueller wrote:
&gt;<i> 
</I>&gt;<i> I just tested Chrome beta this morning and saw nothing interesting in 
</I>&gt;<i> appcache error events, however progress events have now grown &quot;loaded&quot; 
</I>&gt;<i> and &quot;total&quot; properties (think those were the names, and I think they're 
</I>&gt;<i> new-ish).  That's nice, as I can provide a progress meter during cache 
</I>&gt;<i> load/reload.  I wouldn't mind having the URL of the resource being 
</I>&gt;<i> loaded (that was just loaded?) as well as those numbers.  And for errors 
</I>&gt;<i> it would be nice to know, in the case of an error caused by a cache 
</I>&gt;<i> manifest entry 404'ing (or otherwise unavailable), what URL it was. HTTP 
</I>&gt;<i> error code, if appropriate, etc.
</I>
In theory, we don't want to expose this information because it can be used 
to introspect intranets.

In general, the browser should definitely be able to help the user out in 
such a situation. Maybe pop up a notification &quot;there was a problem 
downloading the app, click here for more information&quot; or some such.

I suppose the intranet problem isn't that bad since you can do it with 
&lt;img onerror&gt; already... Maybe we can expose something on the 'error' 
event for appcache after all?

What kind of information would be most useful? Should it be in the same 
format from every browser or should it be detailed and freeform?


On Wed, 2 Feb 2011, Michael Nordman wrote:
&gt;<i> &gt; On Mon, 20 Dec 2010, Michael Nordman wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; What if we had something along the lines of &lt;html 
</I>&gt;<i> &gt;&gt; useManifest=''manifestFile&quot;&gt;, which would do the association of the 
</I>&gt;<i> &gt;&gt; doc with the appcache (so subresources loads hit the cache) but not 
</I>&gt;<i> &gt;&gt; add the document to the cache?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Why can't the pages just switch to a more AJAX-like model rather than 
</I>&gt;<i> &gt; having the main page still load over the network? The main page 
</I>&gt;<i> &gt; loading over the network is a big part of the page being slow.
</I>&gt;<i> 
</I>&gt;<i> The premise of the feature request is that the &quot;main&quot; pages aren't 
</I>&gt;<i> cached at all.
</I>&gt;<i> 
</I>&gt;<i> | I tried to use the HTML5 Application Cache to improve the performances
</I>&gt;<i> | of on-line sites (all the tutorials on the web write only about usage
</I>&gt;<i> | with off-line apps)
</I>&gt;<i> 
</I>&gt;<i> As for &quot;why can't the pages just switch&quot;, I can't speak for andrea, but 
</I>&gt;<i> i can guess that a redesign of that nature was out of scope and/or would 
</I>&gt;<i> conflict with other requirements around how the url address space of the 
</I>&gt;<i> app is defined.
</I>
The whole point of appcache is to cache the main page, so that loading the 
page happens without hitting the network, thus enabling offline apps (and 
faster page loads).

If you're not loading the main page from the cache, what does this gain 
you that regular HTTP caching doesn't?

I don't understand the use case here.


On Fri, 11 Feb 2011, Jeremy Orlow wrote:
&gt;<i> On Fri, Feb 11, 2011 at 1:14 PM, Michael Nordman &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">michaeln at google.com</A>&gt; 
</I>&gt;<i> wrote (on a chromium list, presumably):
</I>&gt;<i> &gt; UVL &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">andrea.doimo at gmail.com</A>&gt; wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I tried to use the HTML5 Application Cache to improve the 
</I>&gt;<i> &gt; &gt; performances of on-line sites (all the tutorials on the web write 
</I>&gt;<i> &gt; &gt; only about usage with off-line apps)
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I created the manifest listing all the js, css and images, and the 
</I>&gt;<i> &gt; &gt; performances were really exciting, until I found that even the page 
</I>&gt;<i> &gt; &gt; HTML was cached, despite it was not listed in the manifest. The 
</I>&gt;<i> &gt; &gt; pages of the site are in PHP, so I don't want them to be cached.
</I>
You can already get your JS, CSS, and images cached. That's been possible 
for some 15+ years, using HTTP caching. No need for a manifest.


&gt;<i> &gt; &gt; From <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html">http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html</A> :
</I>&gt;<i> &gt; &gt; &quot;Authors are encouraged to include the main page in the manifest 
</I>&gt;<i> &gt; &gt; also, but in practice the page that referenced the manifest is 
</I>&gt;<i> &gt; &gt; automatically cached even if it isn't explicitly mentioned.&quot;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Is there a way to have this automating caching disabled?
</I>
The feature would break if it was disabled. Consider this scenario:

   User visits page in January 2012. The manifest is downloaded, all the 
   images, CSS, and JS are cached.

   User visits page in September 2013. The page has completely changed, 
   relies on entirely different JS, CSS, and images, but the browser uses 
   those from the cache. The page ends up being a complete jumble of old 
   images, new images, broken images, scripts doing unexpected things, old 
   CSS, new CSS...


&gt;<i> &gt; &gt; Note: I know that caching can be controlled via HTTP headers, but I 
</I>&gt;<i> &gt; &gt; just wanted to try this way as it looks quite reliable, clean and 
</I>&gt;<i> &gt; &gt; powerful.
</I>
HTTP caching is also &quot;reliable, clean, and powerful&quot;. It also has the 
added advantage of already working. Plus it works with shared network 
caches, so people can get the benefit even if they haven't been to your 
site before, in many cases.


&gt;<i> &gt; On Mon, Dec 20, 2010 at 12:56 PM, Michael Nordman &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">michaeln at chromium.org</A>&gt; wrote:
</I>&gt;<i> &gt; &gt; This type of request (see forwarded message [above]) to utilize the 
</I>&gt;<i> &gt; &gt; application cache for subresource loads into documents that are not 
</I>&gt;<i> &gt; &gt; stored in the cache has come up several times now. The current 
</I>&gt;<i> &gt; &gt; feature set is very focused on the &quot;offline&quot; use case.
</I>
Well yeah. It's called &quot;offline application cache&quot;. :-)


&gt;<i> &gt; &gt; Is it worth making additions such that a document that loads from a 
</I>&gt;<i> &gt; &gt; server can utilize the resources in an appcache? Today we have &lt;html 
</I>&gt;<i> &gt; &gt; manifest=&quot;manifestFile&quot;&gt;, which adds the document containing this 
</I>&gt;<i> &gt; &gt; tag to the appcache and associates that doc with that appcache such 
</I>&gt;<i> &gt; &gt; that subresource loads hit the appcache. Not a complete proposal, 
</I>&gt;<i> &gt; &gt; but... What if we had something along the lines of &lt;html 
</I>&gt;<i> &gt; &gt; useManifest=''manifestFile&quot;&gt;, which would do the association of the 
</I>&gt;<i> &gt; &gt; doc with the appcache (so subresources loads hit the cache) but not 
</I>&gt;<i> &gt; &gt; add the document to the cache?
</I>
How would this be better than just using the regular HTTP cache? 
Everything in the appcaches is also going to be in the regular HTTP cache, 
unless it is explicitly marked as not being cachable. If it's marked as 
not cachable, the solution is to mark it as cachable, not to work around 
HTTP by finding another caching mechanism.


&gt;<i> &gt; Waking this feature request up again as it's been requested multiple 
</I>&gt;<i> &gt; times, I think the ability to utilize an appcache w/o having to have 
</I>&gt;<i> &gt; the page added to it is the #1 appcache feature request that I've 
</I>&gt;<i> &gt; heard.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; [...]
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; * More recently this has been requested in the context of an 
</I>&gt;<i> &gt; application that uses pushState to alter the url of the main page.
</I>
If the page is using pushState() with different paths (not just changing 
the fragment identifier), but the pages are still cachable, then it'll 
work just fine if you just put the file in the FALLBACK section. (Well, 
it's slightly slower than normal, since it tries to hit the network 
first. But it'll still work.)

If the pages aren't cachable, then the use of pushState() isn't really 
relevant. It's just the same as having many uncachable main pages, at 
which point, what's the point of using appcache? Just use a regular cache. 
It's not going to work offline anyway.


On Mon, 14 Feb 2011, Felix Halim wrote:
&gt;<i>
</I>&gt;<i> I have a use case where it is preferable that the main page is not 
</I>&gt;<i> cached:
</I>&gt;<i> 
</I>&gt;<i> Suppose you have a main page that changes based on it's ID:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://example.com/page.php?id=10">http://example.com/page.php?id=10</A>
</I>&gt;<i> 
</I>&gt;<i> The appCache will store each main page with different id in separate 
</I>&gt;<i> cache, which is undesirable! And we DON'T want to cache the main pages, 
</I>&gt;<i> since the content differs significantly (think of it as a forum 
</I>&gt;<i> website).
</I>
The idea of the appcache feature is to enable offline usage. If you don't 
want it cached, how is it going to work offline?


&gt;<i> The main goal here is NOT to make the page offline, but to cache the 
</I>&gt;<i> resources that the page uses (i.e, .js, .css, images, etc...) that are 
</I>&gt;<i> very likely to be IMMUTABLE (particularly the jQuery.js and jQueryUI 
</I>&gt;<i> css+images that almost every sites uses!).
</I>
Appcache only adds one feature: The ability to work offline.

Everything else that appcache does is already possible with regular HTTP 
caching.

So if you don't want to work offline, just use regular HTTP caching.


On Fri, 18 Feb 2011, Biju wrote:
&gt;<i>
</I>&gt;<i> IE 9 is introducing meta-tags for custom jumplist actions (+ Pinned 
</I>&gt;<i> Sites). Mozilla is also planning to do same 
</I>&gt;<i> <A HREF="https://bugzilla.mozilla.org/show_bug.cgi?id=605222">https://bugzilla.mozilla.org/show_bug.cgi?id=605222</A> Some website 
</I>&gt;<i> (<A HREF="http://www.pcworld.com/">http://www.pcworld.com/</A> ) already started using it !!!
</I>&gt;<i> 
</I>&gt;<i> At present IE9 make jumplist using msapplication-* If we dont make any 
</I>&gt;<i> standard now it will ugly to see pages with lot of meta tags named 
</I>&gt;<i> appleapplication-*, ubuntuapplication-*, redhatapplication-*, 
</I>&gt;<i> fedoraapplication-* and also tags for Web App support in Fennec 
</I>&gt;<i> <A HREF="https://bugzilla.mozilla.org/show_bug.cgi?id=583750">https://bugzilla.mozilla.org/show_bug.cgi?id=583750</A>
</I>
Whether we make a standard or not, why would anyone use anything other 
than &quot;msapplication-*&quot; for this feature?


&gt;<i> Also I did not like current implementation with a meta tag for each 
</I>&gt;<i> item. <A HREF="http://msdn.microsoft.com/en-us/library/gg131029">http://msdn.microsoft.com/en-us/library/gg131029</A> I wish whole list 
</I>&gt;<i> was kept in an external file (like the proposed &lt;link 
</I>&gt;<i> rel=&quot;application-description&quot; href=&quot;myapp.json&quot;&gt;) to avoid this same 
</I>&gt;<i> meta tag clutter on every page.
</I>&gt;<i> 
</I>&gt;<i> Did anybody discussed with IE team about already proposed &lt;link 
</I>&gt;<i> rel=&quot;application-description&quot; href=&quot;myapp.json&quot;&gt; ? Looks like IE team 
</I>&gt;<i> only just used Ian's comment for
</I>&gt;<i>
</I>&gt;<i> &gt;&gt; - a name
</I>&gt;<i> &gt;  &lt;meta name=application-name content=&quot;Flickr&quot;&gt;
</I>
I haven't seen anything from Microsoft regarding this, for what it's 
worth.

Anyway. I don't really understand the use case here. What problem are we 
trying to solve here? Do sites actually use this feature? Do users use the 
feature in the sites that offer it?


On Fri, 18 Feb 2011, Charles McCathieNevile wrote:
&gt;<i> 
</I>&gt;<i> Perhaps it makes sense to think about using a single metadata file (as 
</I>&gt;<i> widgets do), and allow Web apps based on a server to associate a 
</I>&gt;<i> config.xml (or JSON equivalent? Why not reinvent the syntax a few 
</I>&gt;<i> times...). You may also want a file manifest like appCache, but if you 
</I>&gt;<i> want the thing to run offline you could just require that it use 
</I>&gt;<i> appCache etc anyway.
</I>&gt;<i> 
</I>&gt;<i> Widgets don't do that because they have a packaging concept where 
</I>&gt;<i> everything is already in the package, which is to allow for simple 
</I>&gt;<i> offline installation and signature, whereas the webapp model requires 
</I>&gt;<i> continually trusting the server. On the other hand, it seems that there 
</I>&gt;<i> are plenty of people happy to trust facebook, google, farmville and so 
</I>&gt;<i> on anyway, so we wouldn't be opening them to new security problems.
</I>
Without knowing exactly what problem we're trying to solve here, it's hard 
to evaluate these proposals.


On Wed, 2 Mar 2011, Edward Gerhold wrote:
&gt;<i> 
</I>&gt;<i> I&#180;ve found out, that i can not Cache my Joomla! Content Management 
</I>&gt;<i> System. Of course i&#180;ve read and heard about, that the application cache 
</I>&gt;<i> is for static pages. But with a little change to the spec and the 
</I>&gt;<i> implementations, it would be possible to cache more than static pages.
</I>&gt;<i> 
</I>&gt;<i> I would like to cache my Joomla! system. To put the scripts, css and 
</I>&gt;<i> images into the cache. I would like to add the appcache manifest to the 
</I>&gt;<i> index.php file of the Joomla Template. What happens is, that the 
</I>&gt;<i> index.php is cached once and not updated again. I can not view new 
</I>&gt;<i> articles. The problem is, that i can neither update the Master File, nor 
</I>&gt;<i> whitelist it.
</I>
What problem are you trying to solve here?


&gt;<i> And this is, what my request or suggestion is about. I would like to 
</I>&gt;<i> whitelist the Master file, where the appcache manifest is installed in. 
</I>
If the main index page isn't cached, then really there's no benefit to 
appcache that you can't already get just by using regular HTTP caching, 
as far as I can tell.


&gt;<i> Or i would like to update this file, or any file else, i would like to 
</I>&gt;<i> update, on demand.
</I>
Not sure what this means.


&gt;<i> For the script i would like to add *applicationCache.updateMaster()*, 
</I>&gt;<i> which forces the browser to fetch the file again.
</I>
You can do this with applicationCache.update() -- it updates everything, 
including the current file.

You always want to update everything at once, since otherwise you'll have 
mismatched versions.


&gt;<i> I think, this is impossible today, to update exactly this file. For the 
</I>&gt;<i> function, i could add a button to my page, to let the user choose to 
</I>&gt;<i> update the file. The second function would be 
</I>&gt;<i> *applicationCache.updateFile(url)*, which could be triggered by a button 
</I>&gt;<i> and script, too. I could let the user update certain articles.
</I>
If you just want to update data, then I would recommend having the data 
stored in a database locally (IndexDB, localStorage, FileSystem, or some 
such) and then update that over the network, rather than in appcache.


&gt;<i> With that i would like to suggest* applicationCache.addToCache(url)* to 
</I>&gt;<i> add files manually or programmatic, which can not be determined by the 
</I>&gt;<i> manifest. Urls like new articles (*), i would like to read offline. I 
</I>&gt;<i> would like to add them to the cache, if the link appears, maybe on the 
</I>&gt;<i> frontpage. I would have to add the manifest to the CMS anyways, so i 
</I>&gt;<i> could add a few more functions to the page, of course. * 
</I>&gt;<i> applicationCache.removeFromCache(url)* should be obvious and helpful 
</I>&gt;<i> with the other functions. Good would be, to be able to iterate through 
</I>&gt;<i> the list of cached objects and even the manifest, with the update, add, 
</I>&gt;<i> remove functions, it would be very useful to work with the filenames and 
</I>&gt;<i> parameters.
</I>&gt;<i> 
</I>&gt;<i> [(*) I could let the user decide wether he wants to download my mp3 
</I>&gt;<i> files to the appcache or not, and fulfill the wish with the javascript 
</I>&gt;<i> functions. Maybe he&#180;s got no bytes left or wants only the lyrics.]
</I>
We'll probably add this feature eventually. It was in an early draft IIRC 
but we got rid of it, IIRC to simplify the API for the first version.


&gt;<i> The application cache is very powerful. But it is very disappointing, 
</I>&gt;<i> that it is only useful for static pages. With a little improvement to 
</I>&gt;<i> the Offline Web applications chapter, and of course to the browsers, it 
</I>&gt;<i> would be possible to cache any Content Manager or dynamic page. And that 
</I>&gt;<i> would let the appcache become one of the most powerful things in the 
</I>&gt;<i> world.
</I>
HTTP caches already do most of this.


&gt;<i> I could read my Joomla! offline, could update the cached files, if i 
</I>&gt;<i> want to, on a click or if the cache expires. I could let the half of the 
</I>&gt;<i> CMS load from the cache. But for that, the index.php, where the manifest 
</I>&gt;<i> is, has to be updateable. Correct me, if i am wrong. But this is not 
</I>&gt;<i> possible today, the master file can not be influenced. And there is no 
</I>&gt;<i> expiration or a possibility to update or manipulate the cache and even 
</I>&gt;<i> no way to find out which files are cached, what would let me/us have 
</I>&gt;<i> control over the Offline Web application.
</I>
I'm not sure I really follow here.

I don't really understand how offline access would work if we're not 
caching the main file...


&gt;<i> Oh, i forgot one thing: Wildcards in the manifest. And I think, 
</I>&gt;<i> directories belong into the CACHE section, i got an error on any 
</I>&gt;<i> directory there, i had to state the whole filename. You should 
</I>&gt;<i> abbreviate that. But that is not so important against that what i wrote 
</I>&gt;<i> down in this message above. Anyways, this completes my wishlist.
</I>
I don't see how wildcards would work. How would the browser know what to 
fetch?


On Thu, 3 Mar 2011, Michael Nordman wrote:
&gt;<i>
</I>&gt;<i> 2) The ability to add(), remove(), and enumerate() individual urls in 
</I>&gt;<i> the appcache. Long ago, there were interfaces on the appcache drawing 
</I>&gt;<i> board to allow that. They got removed for a variety of reasons including 
</I>&gt;<i> &quot;to start simpler&quot;. A couple of years later, it may make sense to 
</I>&gt;<i> revisit these kind of features, although there is another repository 
</I>&gt;<i> also capable of storing ad-hoc collection of resources now (FileSystem), 
</I>&gt;<i> so i'm not sure this feature really needs to be in the appcache.
</I>
Yeah, it may be better just to use the FileSystem for that... It's hard to 
know without really seeing how people envisage using this.

For offline use, FileSystem isn't going to work; for that we'd have to 
support adding files to the appcache. (Note that you can do that today by 
just opening the files you want to add in an iframe. It's a hack, but it 
should generally work.)


&gt;<i> @Hixie... any idea when the appcache feature set will be up for a growth 
</I>&gt;<i> spurt? I think there's an appetite for another round of features in the 
</I>&gt;<i> offline app developers that i communicate with. There's been some recent 
</I>&gt;<i> interest here in pursuing a means of programatically producing a 
</I>&gt;<i> response instead of just returning static content.
</I>
Who implements it currently? Is there a test suite? Those are the main 
things that would gate a dramatic addition of new features.


On Fri, 18 Mar 2011, Nikolas Coukouma wrote:
&gt;<i>
</I>&gt;<i> Section 6.6.2 &quot;Application caches&quot; says
</I>&gt;<i>   Zero or more URLs that form the online whitelist namespaces.
</I>&gt;<i> 
</I>&gt;<i>   These are used as prefix match patterns, and declare URLs that the
</I>&gt;<i>   user agent will never load from the cache but will instead always
</I>&gt;<i>   attempt to obtain from the network.
</I>&gt;<i> 
</I>&gt;<i> The above doesn't seem accurate since section 6.6.6 &quot;Changes to the 
</I>&gt;<i> networking model&quot; was altered (in 2008) so that, in the case of an entry 
</I>&gt;<i> matching the online whitelist, the entry is loaded from the cache.
</I>
The entires in the online whitelist aren't in the appcache at all, so they 
can't be fetched from it.

Or do you mean that &quot;from the network&quot; should mention that it doesn't mean 
to imply that local HTTP caches are ignored?


On Sun, 10 Apr 2011, Edward Gerhold wrote:
&gt;<i> 
</I>&gt;<i> A programmer has to add some code to the CMS template or somewhere else, 
</I>&gt;<i> that you can invoke the add function. The page would be added to the 
</I>&gt;<i> cache. If i cache the start page and open an article and cache it too, 
</I>&gt;<i> go offline, and read the cached frontpage again, and click on the link 
</I>&gt;<i> of the other page i cached, the url should be read from the cache.
</I>&gt;<i> 
</I>&gt;<i> To give me the possibilty to grow or to shrink the cache, i should be 
</I>&gt;<i> able to remove pages, too. Modifying the page has an obvious sense.
</I>
Before evaluating the above or many other suggestions you have made, I 
must first understand what problem it is you are trying to solve. Could 
you elaborate on what experiene it is you are trying to provide the user 
which you cannot currently provide?


On Fri, 1 Apr 2011, Edward Gerhold wrote:
&gt;<i> 
</I>&gt;<i> The appCache is not ready for storing dynamic data. This could be done 
</I>&gt;<i> by the user by simply pressing a &quot;cache this&quot; button or a link or some 
</I>&gt;<i> other function in a script.
</I>
What do you mean by &quot;dynamic data&quot;?


On Wed, 13 Apr 2011, Edward Gerhold wrote:
&gt;<i> 
</I>&gt;<i> The problem is:
</I>&gt;<i> 
</I>&gt;<i> Cached once, the files are NEVER being updated again, except the manifest
</I>&gt;<i> changes a byte.
</I>
Right. The manifest is used as a proxy for the state of the server.


&gt;<i> Second thing, the rename of the URLs, or better a local and a network 
</I>&gt;<i> identifier is neccessary. It would be good, if the user agent could care 
</I>&gt;<i> for local identifiers, too. The programmer would sometimes have to give 
</I>&gt;<i> the page a new name to prevent overwriting another file (with access to 
</I>&gt;<i> the cache, maybe even dupe names but other array positions work?).
</I>
Not sure what this means.


On Sat, 16 Apr 2011, Edward Gerhold wrote:
&gt;<i> 
</I>&gt;<i> I came to the conclusion, the cache is linked too tightly to the 
</I>&gt;<i> manifest. The cache is good how it is as long as it isn&#180;t developed for 
</I>&gt;<i> dynamic websites and caches. The manifest should only be the basis of 
</I>&gt;<i> the cached site, and the programmatic addition and removal of the pages 
</I>&gt;<i> should expand or shrink the array of files. This is how the story goes 
</I>&gt;<i> so far. I am working on my draft or am not working on and try to imagine 
</I>&gt;<i> and formulate the steps of each element i suggest.
</I>
To evaluate this conclusion it weould be helpful to more clearly 
understand the use case.


&gt;<i> *Another thing which i would like to introduce together with the better 
</I>&gt;<i> api is the &quot;Expiration of the Cache&quot;.* Like i already knew, there have 
</I>&gt;<i> some passages of the original to be changed. I don&#180;t think, that i want 
</I>&gt;<i> to setup a v2.0 or a module for the cache, no, i want to change the 
</I>&gt;<i> original to use all functions. I think an expiration of cached files 
</I>&gt;<i> should be introduced together with the dynamic application cache.
</I>&gt;<i> 
</I>&gt;<i> The local identifier, i suggested, i think, i&#180;ll add it, but leave the 
</I>&gt;<i> handling of it blank. Means, the programmer has the possibility to give 
</I>&gt;<i> local identifiers, but has to handle it alone. If i come to that chapter 
</I>&gt;<i> and find out, how the user agent should treat it, i&#180;ll write it down. 
</I>&gt;<i> But so far, i&#180;d like to leave the string empty, for the obvious cases, 
</I>&gt;<i> that a website uses index.php for all files. The application programmer 
</I>&gt;<i> adding the cache functions should be able to make use of the local ids 
</I>&gt;<i> to retrieve the files. And here is the case, where the user agent should 
</I>&gt;<i> call the right page in the cache, if the local identifier is referred. 
</I>&gt;<i> Ok.
</I>&gt;<i> 
</I>&gt;<i> Well, this was about, you could overread it, the introduction of the 
</I>&gt;<i> expiration date of cached files should be made together with the 
</I>&gt;<i> programmatic access to the cache. It will be useful to let certain files 
</I>&gt;<i> expired then. And, i can&#180;t cite the original, i would like to end with 
</I>&gt;<i> my first words, i think, the cache is bound to tightly to the manifest 
</I>&gt;<i> at the moment.
</I>
Not sure what you are proposing here, so it's hard to evaluate it.


On Sun, 17 Apr 2011, Jukka K. Korpela wrote:
&gt;<i> 
</I>&gt;<i> I'd like to see a simple summary of the benefits of an application 
</I>&gt;<i> cache, as compared with normal caching - not with some hypothetical 
</I>&gt;<i> situation without any caching.
</I>
The benefit of the application cache is simple: it allows a user to visit 
a Web page while offline, if they have visited it while online and if that 
page declares a manifest.

Regular caching (i.e. without a manifest) doesn't work with this because 
it doesn't provide a way to declare the set of resources that are needed 
for a page to be usable offline.


&gt;<i> As a drawback, when _any_ change is made to any of the files, the 
</I>&gt;<i> manifest needs to be modified and all user agents will have to download 
</I>&gt;<i> the entire application (all files) when online next time.
</I>
They only need to check all the files -- only the changed ones get 
downloaded.


On Tue, 19 Apr 2011, Ilkka Huotari wrote:
&gt;<i> [Anne wrote:]
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If you use a fallback namespace it will always try to do a network 
</I>&gt;<i> &gt; fetch before using the fallback entry so why is there a need for a 
</I>&gt;<i> &gt; NETWORK entry in the cache manifest?
</I>&gt;<i>
</I>&gt;<i> Now, I haven't probably thought this enough, but could the FALLBACK and 
</I>&gt;<i> NETWORK be combined into one NETWORK? Both are doing pretty much the 
</I>&gt;<i> same thing after all?
</I>&gt;<i> 
</I>&gt;<i> Here's how it would work:
</I>&gt;<i> 
</I>&gt;<i> NETWORK:
</I>&gt;<i> &lt;item&gt; [optional-fallback-item]
</I>&gt;<i> 
</I>&gt;<i> More specific entries would take precedence, i.e. /file.html would be
</I>&gt;<i> more important than /file or / or * ... Example:
</I>&gt;<i> 
</I>&gt;<i> NETWORK:
</I>&gt;<i> *
</I>&gt;<i> / /offline
</I>&gt;<i> /file.html /offline-for-file.html
</I>&gt;<i> 
</I>&gt;<i> This way
</I>&gt;<i> - &quot;*&quot; would map like it does in the current spec
</I>&gt;<i> - &quot;/ /offline&quot; would map like it does in the FALLBACK section/current
</I>&gt;<i> spec and would take precedence over &quot;*&quot; because it's more specific
</I>&gt;<i> over *&quot;*
</I>&gt;<i> - &quot;/file.html /offline-for-file.html&quot; would take precedence over all of these.
</I>&gt;<i> 
</I>&gt;<i> Benefits: Making things simpler, easier for the programmer to 
</I>&gt;<i> understand. Faster to learn, less bugs, better code?
</I>
I'm not convinced that's much simpler. It's the same, except that you've 
replaced two sections with different simple syntax with one section with 
more complicated syntax.


On Wed, 20 Apr 2011, Ilkka Huotari wrote:
&gt;<i>
</I>&gt;<i> I'm trying to figure out if there is any other difference between 
</I>&gt;<i> NETWORK and FALLBACK sections than FALLBACK section having the fallback 
</I>&gt;<i> resource. (I hope I'm not bothering people with my questions, but I also 
</I>&gt;<i> hope that these questions could help somebody else.)
</I>&gt;<i> 
</I>&gt;<i> So... is there any other difference between them? I did some testing in 
</I>&gt;<i> Chrome and Firefox and while the behavior was not actually identical 
</I>&gt;<i> between those browsers, it seemed that there isn't any other crucial 
</I>&gt;<i> difference between the sections.
</I>
It's a pretty big difference and it has several side-effects, but yes, 
that's the only difference.


On Mon, 23 May 2011, Nicholas Zakas wrote:
&gt;<i>
</I>&gt;<i> The spec currently states this about the obsolete and error events on 
</I>&gt;<i> window.applicationCache (5.6.1.1):
</I>&gt;<i> 
</I>&gt;<i>  * Obsolete - The manifest was found to have become a 404 or 410 page, 
</I>&gt;<i> so the application cache is being deleted.
</I>&gt;<i>
</I>&gt;<i>  * Error - The manifest was a 404 or 410 page, so the attempt to cache 
</I>&gt;<i> the application has been aborted.
</I>&gt;<i> 
</I>&gt;<i> Later on (5.6.4), the spec states about 404 or 410 manifest files:
</I>&gt;<i> 
</I>&gt;<i>  * For each cache host associated with an application cache in cache 
</I>&gt;<i> group, create a task to fire a simple event named obsolete that is 
</I>&gt;<i> cancelable at the ApplicationCache singleton of the cache host, and 
</I>&gt;<i> append it to task list. The default action of these events must be, if 
</I>&gt;<i> the user agent shows caching progress, the display of some sort of user 
</I>&gt;<i> interface indicating to the user that the application is no longer 
</I>&gt;<i> available for offline use.
</I>&gt;<i>
</I>&gt;<i>  * For each entry in cache group's list of pending master entries, 
</I>&gt;<i> create a task to fire a simple event that is cancelable named error (not 
</I>&gt;<i> obsolete!) at the ApplicationCache singleton of the cache host the 
</I>&gt;<i> Document for this entry, if there still is one, and append it to task 
</I>&gt;<i> list. The default action of this event must be, if the user agent shows 
</I>&gt;<i> caching progress, the display of some sort of user interface indicating 
</I>&gt;<i> to the user that the user agent failed to save the application for 
</I>&gt;<i> offline use.
</I>&gt;<i> 
</I>&gt;<i> This seems to indicate that the obsolete event is always fired and the 
</I>&gt;<i> error event may optionally fire afterward.
</I>
No, the list of objects that the two events are fired at are mutually 
exclusive. (One is those that already have the cache associated, and the 
other is those that do not yet have the cache associated.)


On Sat, 28 May 2011, Felix Halim wrote:
&gt;<i>
</I>&gt;<i> AFAIK, currently there is no storage limit for the App Cache.
</I>
There is a limit on App Cache:

   <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/offline.html#disk-space">http://www.whatwg.org/specs/web-apps/current-work/complete/offline.html#disk-space</A>

Exactly how it works is up to the UA. Personally I think the same quota 
should be used for all client-side storage mechanisms per origin group, 
where origins are grouped so that all related subdomains, ports, etc, 
count as the same origin.


On Sun, 29 May 2011, Bjartur Thorlacius wrote:
&gt;<i>
</I>&gt;<i> User agents may store expired pages for offline use. Internet Explorer 
</I>&gt;<i> and Firefox have 'Work offline' modes automatically enabled on complete 
</I>&gt;<i> disconnection from the network. Currently, only cached pages and sites 
</I>&gt;<i> explicitly selected by the user are available offline, but given enough 
</I>&gt;<i> disk space, user agents might keep all files of MIME type &quot;text&quot; (e.g. 
</I>&gt;<i> text/html and text/plain) - or even all files. The variation on 
</I>&gt;<i> constraints between systems is such that even looking only at my desk 
</I>&gt;<i> there's a system with over 1.7GiB of free read-write memory (0.5MiB 
</I>&gt;<i> magnetic, 1.3GiB volatile RAM) and another one with under 300MiB 
</I>&gt;<i> (volatile RAM). I don't want authors to be able to use up my memory by 
</I>&gt;<i> storing most or all content for offline use, nor to unnecessarily loose 
</I>&gt;<i> access to content when storage space is plentiful.
</I>
This is the kind of thing user agents should offer their users.

Note that the constraints are mainly aimed at preventing abuse. It's easy 
to imagine a hostile site sending the user (without the user's knowledge) 
on a journey across dozens of origins each storing terabytes of data in 
local storage, databases, cookies, appcache, etc.


On Mon, 30 May 2011, Felix Halim wrote:
&gt;<i> 
</I>&gt;<i> Suppose I have a web page and want to store it in an App Cache. This web 
</I>&gt;<i> page requires a few resources (.ccs, .js, images, etc..). But all of 
</I>&gt;<i> them are &quot;static&quot; resources. I want to store &quot;dynamic&quot; resources as well 
</I>&gt;<i> for that particular page only (not shared). Think of the dynamic 
</I>&gt;<i> resources as &quot;data&quot; that changes from time to time for that particular 
</I>&gt;<i> page only. localStorage can be used to store the &quot;dynamic&quot; resources, 
</I>&gt;<i> but localStorage has very limited quota and it is shared to the entire 
</I>&gt;<i> domain. Different unrelated pages in the same domain will use the shared 
</I>&gt;<i> quota!
</I>&gt;<i> 
</I>&gt;<i> Currently I can &quot;hack&quot; the App Cache to simulate the pageStorage like 
</I>&gt;<i> this:
</I>&gt;<i> 
</I>&gt;<i> We can turn one of the .js files &quot;dynamic&quot; by updating the .js file, 
</I>&gt;<i> then edit the MANIFEST file a bit, so that the browser re-download *ALL* 
</I>&gt;<i> the resources again.  This way, the .js file quota gets in the App Cache 
</I>&gt;<i> quota which is currently *UNLIMITED*.
</I>
It's no less limited than any other storage mechanism, per spec.


On Tue, 31 May 2011, Felix Halim wrote:
&gt;<i> 
</I>&gt;<i> The current App Cache design updates the cache to the latest version in 
</I>&gt;<i> the background when the user visit the page for the second time and then 
</I>&gt;<i> it needs to refresh the page to actually update the display. This is 
</I>&gt;<i> annoying since the user will first see stale data, then a few second 
</I>&gt;<i> later, it's updated with a giant refresh (including all the static 
</I>&gt;<i> resources).
</I>
You shouldn't store data in the appcache, only logic, otherwise yes, the 
user will always be one version behind.

Note that there is no giant refresh unless the page makes it so.


&gt;<i> This is because the App Cache is too COARSE grained. It doesn't know 
</I>&gt;<i> what actually changes (which data are static, which data are dynamic). 
</I>
Right. It uses regular HTTP semantics to update the cache.


&gt;<i> That is another reason why we need pageStorage: to separate the dynamic 
</I>&gt;<i> and the static resources.
</I>
Don't we already have enough ways to store data?


On Wed, 1 Jun 2011, Bjartur Thorlacius wrote:
&gt;<i>
</I>&gt;<i> Caches should still be allowed to refetch resources just before they're 
</I>&gt;<i> expected to be used. I might want my home computer to fetch the latest 
</I>&gt;<i> news in the morning and evening, so I can start reading when I wake up 
</I>&gt;<i> and when I get home from school.
</I>
The spec allows the UA to run the update algorithm at any time.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031883.html">[whatwg] Pain with the Headers in webkit/appcache.
</A></li>
	<LI>Next message: <A HREF="074395.html">[whatwg] AppCache-related e-mails
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#74237">[ date ]</a>
              <a href="thread.html#74237">[ thread ]</a>
              <a href="subject.html#74237">[ subject ]</a>
              <a href="author.html#74237">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
