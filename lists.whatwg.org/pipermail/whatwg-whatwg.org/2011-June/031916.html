<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Video feedback
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Video%20feedback&In-Reply-To=%3CPine.LNX.4.64.1106010005541.19153%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031897.html">
   <LINK REL="Next"  HREF="074171.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Video feedback</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Video%20feedback&In-Reply-To=%3CPine.LNX.4.64.1106010005541.19153%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] Video feedback">ian at hixie.ch
       </A><BR>
    <I>Thu Jun  2 16:28:45 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="031897.html">[whatwg] Blacklist for regsiterProtocolHandler()
</A></li>
        <LI>Next message: <A HREF="074171.html">[whatwg] Video feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31916">[ date ]</a>
              <a href="thread.html#31916">[ thread ]</a>
              <a href="subject.html#31916">[ subject ]</a>
              <a href="author.html#31916">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
(Note that I have tried to only reply to each suggestion once, so 
subsequent requests for the same feature are not included below.)

(I apologise for the somewhat disorganised state of this e-mail. I 
normally try to group topics together, but the threads I'm responding to 
here jumped back and forth across different issues quite haphazardly and 
trying to put related things together broke some of the flow and context 
of the discussions, so I opted in several places to leave the context as 
it was originally presented, and just jump back and forth amongst the 
topics raised. Hopefully it's not too confusing.)

On Thu, 9 Dec 2010, Silvia Pfeiffer wrote:
&gt;<i> &gt;&gt; &gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; &gt; Sure, but this is only a snippet of an actual application. If, 
</I>&gt;<i> &gt;&gt; &gt; &gt; e.g., you want to step through a list of videos (maybe an 
</I>&gt;<i> &gt;&gt; &gt; &gt; automated playlist) using script and you need to provide at least 
</I>&gt;<i> &gt;&gt; &gt; &gt; two different formats with &lt;source&gt;, you'd want to run this 
</I>&gt;<i> &gt;&gt; &gt; &gt; algorithm frequently.
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; Just have a bunch of &lt;video&gt;s in the markup, and when one ends, 
</I>&gt;<i> &gt;&gt; &gt; hide it and show the next one. Don't start dynamically manipulating 
</I>&gt;<i> &gt;&gt; &gt; &lt;source&gt; elements, that's just asking for pain.
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; If you really must do it all using script, just use canPlayType and 
</I>&gt;<i> &gt;&gt; &gt; the &lt;video src=&quot;&quot;&gt; attribute, don't mess around with &lt;source&gt;.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Thanks for adding that advice. I think it's important to point that 
</I>&gt;<i> &gt;&gt; out.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I can add it to the spec too if you think that would help. Where would 
</I>&gt;<i> &gt; a good place for it be?
</I>&gt;<i> 
</I>&gt;<i> There is a note in the &lt;source&gt; element section that reads as follows: 
</I>&gt;<i> &quot;Dynamically modifying a source element and its attribute when the 
</I>&gt;<i> element is already inserted in a video or audio element will have no 
</I>&gt;<i> effect. To change what is playing, either just use the src attribute on 
</I>&gt;<i> the media element directly, or call the load() method on the media 
</I>&gt;<i> element after manipulating the source elements.&quot;
</I>&gt;<i> 
</I>&gt;<i> Maybe you can add some advice there to use canPlayType to identify what 
</I>&gt;<i> type of resource to add in the @src attribute on the media element. 
</I>&gt;<i> Also, you should remove the last half of the second sentence in this 
</I>&gt;<i> note if that is not something we'd like to encourage.
</I>
Done.


On Wed, 8 Dec 2010, Kevin Marks wrote:
&gt;<i> 
</I>&gt;<i> One case where posters come back after playback is complete is when 
</I>&gt;<i> there are multiple videos on the page, and only one has playback focus 
</I>&gt;<i> at a time, such as a page of preview movies for longer ones to purchase.
</I>&gt;<i> 
</I>&gt;<i> In that case, showing the poster again on blur makes sense conceptually.
</I>&gt;<i> 
</I>&gt;<i> It seems that getting back into the pre-playback state, showing the 
</I>&gt;<i> poster again would make sense in this context.
</I>&gt;<i> 
</I>&gt;<i> That would imply adding an unload() method that reverted to that state, 
</I>&gt;<i> and could be used to make any cached media data purgeable in favour of 
</I>&gt;<i> another video that is subsequently loaded.
</I>
You don't need unload(), you can just use load(). It essentially resets 
the media element.

It's not hugely efficient, but if we find people are trying to do this a 
lot, then we can add a more efficent variant that just resets the poster 
frame state, I guess. (I'd probably call it stop(), though, not unload().)


On Thu, 9 Dec 2010, David Singer wrote:
&gt;<i>
</I>&gt;<i> I think if you want that effect, you flip what's visible in an area of 
</I>&gt;<i> the page between a playing video, and an image.  Relying on the poster 
</I>&gt;<i> is not effective, IMHO.
</I>
I don't know, I think it would make semantic sense to have all the videos 
be &lt;video&gt; elements if they're actually going to be played right there.


On Thu, 9 Dec 2010, Kevin Marks wrote:
&gt;<i>
</I>&gt;<i> I know it's not effective at the moment; it is a common use case. 
</I>&gt;<i> QuickTime had the 'badge' ux for years that hardly anyone took advantage 
</I>&gt;<i> of:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.mactech.com/articles/mactech/Vol.16/16.02/Feb00QTToolkit/index.html">http://www.mactech.com/articles/mactech/Vol.16/16.02/Feb00QTToolkit/index.html</A>
</I>&gt;<i> 
</I>&gt;<i> What we're seeing on the web is a converged implementation of the 
</I>&gt;<i> YouTube-like overlaid grey play button, but this is effectively 
</I>&gt;<i> reimplemented independently by each video site that enables embedding.
</I>&gt;<i> 
</I>&gt;<i> As we see HTML used declaratively for long-form works like ebooks on 
</I>&gt;<i> lower performance devices, having embedded video that doesn't 
</I>&gt;<i> cumulatively absorb all the memory available is going to be like the old 
</I>&gt;<i> CD-ROM use cases the QT Badge was meant for.
</I>
This seems like a presentational issue, for which CSS would be better 
positioned to provide a solution.


On Thu, 9 Dec 2010, Boris Zbarsky wrote:
&gt;<i> On 12/8/10 8:19 PM, Ian Hickson wrote:
</I>&gt;<i> &gt; Boris wrote:
</I>&gt;<i> &gt; &gt; You can't sniff in a toplevel browser window.  Not the same way that 
</I>&gt;<i> &gt; &gt; people are sniffing in &lt;video&gt;. It would break the web.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; How so?
</I>&gt;<i> 
</I>&gt;<i> People actually rely on the not-sniffing behavior of UAs in actual 
</I>&gt;<i> browser windows in some cases.  For example, application/octet-stream at 
</I>&gt;<i> toplevel is somewhat commonly used to force downloads without a 
</I>&gt;<i> corresponding Content-Disposition header (poor practice, but support for 
</I>&gt;<i> Content-Disposition hasn't been historically great either).
</I>&gt;<i> 
</I>&gt;<i> &gt; (Note that the spec as it stands takes a compromise position: the 
</I>&gt;<i> &gt; content is only accepted if the Content-Type and type=&quot;&quot; values are 
</I>&gt;<i> &gt; supported types (if present) and the content sniffs as a supported 
</I>&gt;<i> &gt; type, but nothing in the spec checks that all three values are the 
</I>&gt;<i> &gt; same.)
</I>&gt;<i> 
</I>&gt;<i> Ah, I see.  So similar to the way &lt;img&gt; is handled...
</I>&gt;<i> 
</I>&gt;<i> I can't quite decide whether this is the best of both worlds, or the 
</I>&gt;<i> worst. ;)
</I>
Yeah, I hear ya.


&gt;<i> It certainly makes it simpler to implement video by delegating to 
</I>&gt;<i> QuickTime or the like, though I suspect such an implementation would 
</I>&gt;<i> also end up sniffing types the UA doesn't necessarily claim to 
</I>&gt;<i> support.... so maybe it's not simpler after all.
</I>
Indeed.

At this point I'm basically just waiting to see what implementations end 
up doing. When I tried moving us more towards sniffing, there was 
pushback; when I tried moving us more towards honouring types, there was 
equal and opposite pushback. So at this point, I'm letting the market 
decide it. :-)


On Thu, 9 Dec 2010, Simon Pieters wrote:
&gt;<i> On Thu, 09 Dec 2010 02:58:12 +0100, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; On Wed, 1 Sep 2010, Simon Pieters wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I think it might be good to run the media element load algorithm 
</I>&gt;<i> &gt; &gt; when setting or changing src on &lt;source&gt; (that has a media element 
</I>&gt;<i> &gt; &gt; as its parent), but not type and media (what's the use case for type 
</I>&gt;<i> &gt; &gt; and media?). However it would fire an 'emptied' event for each 
</I>&gt;<i> &gt; &gt; &lt;source&gt; that changed, which is kind of undesirable. Maybe the media 
</I>&gt;<i> &gt; &gt; element load algorithm should only be invoked if src is set or 
</I>&gt;<i> &gt; &gt; changed on a &lt;source&gt; that has no previous sibling &lt;source&gt; 
</I>&gt;<i> &gt; &gt; elements?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; What's the use case? Just set .src before you insert the element.
</I>&gt;<i> 
</I>&gt;<i> The use case under discussion is changing to another video. So the 
</I>&gt;<i> element is already inserted and already has src.
</I>&gt;<i> 
</I>&gt;<i> Something like:
</I>&gt;<i> 
</I>&gt;<i> &lt;video controls autoplay&gt;
</I>&gt;<i> &lt;source src=video1.webm type=video/webm&gt;
</I>&gt;<i> &lt;source src=video1.mp4 type=video/mp4&gt;
</I>&gt;<i> &lt;/video&gt;
</I>&gt;<i> &lt;script&gt;
</I>&gt;<i> function loadVideo(src) {
</I>&gt;<i>  var video = document.getElementsByTagName('video')[0];
</I>&gt;<i>  sources = video.getElementsByTagName('source');
</I>&gt;<i>  sources[0].src = src + '.webm';
</I>&gt;<i>  sources[1].src = src + '.mp4';
</I>&gt;<i> }
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i> &lt;input type=&quot;button&quot; value=&quot;See video 1&quot; onclick=&quot;loadVideo('video1')&quot;&gt;
</I>&gt;<i> &lt;input type=&quot;button&quot; value=&quot;See video 2&quot; onclick=&quot;loadVideo('video2')&quot;&gt;
</I>&gt;<i> &lt;input type=&quot;button&quot; value=&quot;See video 3&quot; onclick=&quot;loadVideo('video3')&quot;&gt;
</I>
Well if you _really_ want to do that, just call video.load() at the end of 
loadVideo(). But really, you're better off poking around with 
canPlayType() and setting video.src directly instead of using &lt;source&gt; 
for these dynamic cases.


On Thu, 9 Dec 2010, Kevin Carle wrote something more or less like:
&gt;<i> 
</I>&gt;<i> function loadVideo(src) {
</I>&gt;<i>  var video = document.getElementsByTagName('video')[0];
</I>&gt;<i>  if (video.canPlayType(&quot;video/webm&quot;) != &quot;&quot;)
</I>&gt;<i>    video.src = src + '.webm';
</I>&gt;<i>  else
</I>&gt;<i>    video.src = src + '.mp4';
</I>&gt;<i> }
</I>
Yeah.

And hopefully this will become moot when there's a common video format, 
anyway.


On Fri, 10 Dec 2010, Simon Pieters wrote:
&gt;<i> 
</I>&gt;<i> You'd need to remove the &lt;source&gt; elements to keep the document valid.
</I>
You don't need them in the first place if you're doing things by script, 
as far as I can tell.


&gt;<i> The author might want to have more than two &lt;source&gt;s, maybe with 
</I>&gt;<i> media=&quot;&quot;, onerror=&quot;&quot; etc. Then it becomes simpler to rely on the 
</I>&gt;<i> resource selection algorithm.
</I>
It's hard to comment without seeing a concrete use case.


On Tue, 14 Dec 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i> On Wed, 24 Nov 2010 17:11:02 +0100, Eric Winkelman &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">E.Winkelman at cablelabs.com</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm investigating how TimedTracks can be used for in-band-data-tracks 
</I>&gt;<i> &gt; within MPEG transport streams (used for cable television).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; In this format, the number and types of in-band-data-tracks can change 
</I>&gt;<i> &gt; over time.  So, for example, when the programming switches from a 
</I>&gt;<i> &gt; football game to a movie, an alternate language track may appear that 
</I>&gt;<i> &gt; wasn't there before. Later, when the programming changes again, that 
</I>&gt;<i> &gt; language track may be removed.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; It's not clear to me how these changes are exposed by the proposed 
</I>&gt;<i> &gt; Media Element events.
</I>&gt;<i> 
</I>&gt;<i> The thinking is that you switch between different streams by setting the 
</I>&gt;<i> src=&quot;&quot; attribute to point to another stream, in which case you'll get an 
</I>&gt;<i> emptied event along with another bunch of events. If you have a single 
</I>&gt;<i> source where audio/video/text streams appear and disappear, there's not 
</I>&gt;<i> really any way to handle it.
</I>
As specified, there's no way for a media element's in-band text tracks to 
change after the 'loadedmetadata' event has fired.


&gt;<i> &gt; The &quot;loadedmetadata&quot; event is used to indicate that the TimedTracks 
</I>&gt;<i> &gt; are ready, but it appears that it is only fired before playback 
</I>&gt;<i> &gt; begins.  Is this event fired again whenever a new track is discovered?  
</I>&gt;<i> &gt; Is there another event that is intended for this situation?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Similarly, is there an event that indicates when a track has been 
</I>&gt;<i> &gt; removed? Or is this also handled by the &quot;loadedmetadata&quot; event 
</I>&gt;<i> &gt; somehow?
</I>&gt;<i> 
</I>&gt;<i> No, the loadedmetadata event is only fired once per resource, it's not 
</I>&gt;<i> the event you're looking for.
</I>&gt;<i> 
</I>&gt;<i> As for actual solutions, I think that having loadedmetadata fire again 
</I>&gt;<i> if the number or type of streams change would make some sense.
</I>
It would be helpful to know more about these cases where there are dynamic 
changes to the audio, video, or text tracks. Does this really happen on 
the Web? Do we need to handle it?


On Thu, 16 Dec 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> I do not know how technically the change of stream composition works in 
</I>&gt;<i> MPEG, but in Ogg we have to end a current stream and start a new one to 
</I>&gt;<i> switch compositions. This has been called &quot;sequential multiplexing&quot; or 
</I>&gt;<i> &quot;chaining&quot;. In this case, stream setup information is repeated, which 
</I>&gt;<i> would probably lead to creating a new steam handler and possibly a new 
</I>&gt;<i> firing of &quot;loadedmetadata&quot;. I am not sure how chaining is implemented in 
</I>&gt;<i> browsers.
</I>
Per spec, chaining isn't currently supported. The closest thing I can find 
in the spec to this situation is handling a non-fatal error, which causes 
the unexpected content to be ignored.


On Fri, 17 Dec 2010, Eric Winkelman wrote:
&gt;<i> 
</I>&gt;<i> The short answer for changing stream composition is that there is a 
</I>&gt;<i> Program Map Table (PMT) that is repeated every 100 milliseconds and 
</I>&gt;<i> describes the content of the stream.  Depending on the programming, the 
</I>&gt;<i> stream's composition could change entering/exiting every advertisement.
</I>
If this is something that browser vendors want to support, I can specify 
how to handle it. Anyone?


On Sat, 18 Dec 2010, Robert O'Callahan wrote:
&gt;<i>
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-media-duration">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-media-duration</A> says:
</I>&gt;<i> [...]
</I>&gt;<i> 
</I>&gt;<i> What if the duration is not currently known?
</I>
The user agent must determine the duration of the media resource before 
playing any part of the media data and before setting readyState to a 
value equal to or greater than HAVE_METADATA, even if doing so requires 
fetching multiple parts of the resource.


&gt;<i> I think in general it will be very difficult for a user-agent to know 
</I>&gt;<i> that a stream is unbounded. In Ogg or WebM a stream might not contain an 
</I>&gt;<i> explicit duration but still eventually end. Maybe it would make more 
</I>&gt;<i> sense for the last sentence to read &quot;If the media resource is not known 
</I>&gt;<i> to be bounded, ...&quot;
</I>
Done.


On Sat, 18 Dec 2010, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> Agreed, this is how I've interpreted the spec already. If a server 
</I>&gt;<i> replies with 200 OK instead of 206 Partial Content and the duration 
</I>&gt;<i> isn't in the header of the resource, then the duration is reported to be 
</I>&gt;<i> Infinity. If the resource eventually ends another durationchange event 
</I>&gt;<i> is fired and the duration is reported to be the (now known) length of 
</I>&gt;<i> the resource.
</I>
That's fine.


On Mon, 20 Dec 2010, Robert O'Callahan wrote:
&gt;<i> 
</I>&gt;<i> That sounds good to me. We'll probably do that. The spec will need to be 
</I>&gt;<i> changed though.
</I>
I changed it as you suggest above.


On Fri, 31 Dec 2010, Bruce Lawson wrote:
&gt;<i> &gt; On Fri, 5 Nov 2010, Bruce Lawson wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#sourcing-in-band-timed-tracks">http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#sourcing-in-band-timed-tracks</A> 
</I>&gt;<i> &gt; &gt; says to create TimedTrack objects etc for in-band tracks which are 
</I>&gt;<i> &gt; &gt; then exposed in the API - so captions/subtitles etc that are 
</I>&gt;<i> &gt; &gt; contained in the media container file are exposed, as well as those 
</I>&gt;<i> &gt; &gt; tracks pointed to by the &lt;track&gt; element.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; But 
</I>&gt;<i> &gt; &gt; <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#timed-track-api">http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#timed-track-api</A> 
</I>&gt;<i> &gt; &gt; implies that the array is only of tracks in the track element:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &quot;media . tracks . length
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Returns the number of timed tracks associated with the media element 
</I>&gt;<i> &gt; &gt; (e.g. from track elements). This is the number of timed tracks in 
</I>&gt;<i> &gt; &gt; the media element's list of timed tracks.&quot;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I don't understand why you interpret this as implying anything about 
</I>&gt;<i> &gt; the track element. Are you interpreting &quot;e.g.&quot; as &quot;i.e.&quot;?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; Suggestion: amend to say &quot;Returns the number of timed tracks 
</I>&gt;<i> &gt; &gt; associated with the media element (e.g.  from track elements and any 
</I>&gt;<i> &gt; &gt; in-band track files inside the media container file)&quot; or some such.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I'd rather avoid talking about the in-band ones here, in part because 
</I>&gt;<i> &gt; I think it's likely to confuse authors at least as much as help them, 
</I>&gt;<i> &gt; and in part because the terminology around in-band timed tracks is a 
</I>&gt;<i> &gt; little unclear to me and so I'd rather not talk about them in 
</I>&gt;<i> &gt; informative text. :-)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; If you disagree, though, let me know. I can find a way to make it 
</I>&gt;<i> &gt; work.
</I>&gt;<i> 
</I>&gt;<i> I disagree, but not aggressively vehemently. My confusion was conflating 
</I>&gt;<i> &quot;track elements&quot; with the three instances of the phrase &quot;timed tracks&quot; 
</I>&gt;<i> in close proximity.
</I>&gt;<i> 
</I>&gt;<i> I suggest that &quot;Returns the number of timed tracks associated with the 
</I>&gt;<i> media element (i.e. from track elements and any packaged along with the 
</I>&gt;<i> media in its container file)&quot; would be clearer and avoid use of the 
</I>&gt;<i> confusing phrase &quot;in-band tracks&quot;.
</I>
That's still confusing, IMHO. &quot;Packaged&quot; doesn't imply in-band; most 
subtitle files are going to be &quot;packaged&quot; with the video even if they're 
out of band.

Also, your 'i.e.' here is wrong. There's at least one other source of 
tracks: the ones added by the script.

The non-normative text is intentionally not overly precise, because if it 
was precise it would just be the same as the normative text and wouldn't 
be any simpler, defeating its entire purpose.


On Mon, 3 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; + I've added a magic string that is required on the format to make it
</I>&gt;<i> &gt;   recognisable in environments with no or unreliable type labeling.
</I>&gt;<i> 
</I>&gt;<i> Is there a reason it's &quot;WEBVTT FILE&quot; instead of just &quot;WEBVTT&quot;? &quot;FILE&quot; 
</I>&gt;<i> seems redundant and like unnecessary typing to me.
</I>
It seemed more likely that non-WebVTT files would start with a line that 
said just &quot;WEBVTT&quot; than a line that said just &quot;WEBVTT FILE&quot;. But I guess 
&quot;WEBVTT FILE FORMAT&quot; is just as likely and it'll be caught.

I've changed it to just &quot;WEBVTT&quot;; there may be existing implementations 
that only accept &quot;WEBVTT FILE&quot; so for now I recommend that authors still 
use the longer header.


&gt;<i> &gt; On Wed, 8 Sep 2010, Philip J&#195;&#164;genstedt wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; In the discussion on public-html-a11y &lt;trackgroup&gt; was suggested to 
</I>&gt;<i> &gt; &gt; group together mutually exclusive tracks, so that enabling one 
</I>&gt;<i> &gt; &gt; automatically disables the others in the same trackgroup.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I guess it's up to the UA how to enable and disable &lt;track&gt;s now, 
</I>&gt;<i> &gt; &gt; but the only option is making them all mutually exclusive (as 
</I>&gt;<i> &gt; &gt; existing players do) or a weird kind of context menu where it's 
</I>&gt;<i> &gt; &gt; possible to enable and disable tracks completely independently. 
</I>&gt;<i> &gt; &gt; Neither options is great, but as a user I would almost certainly 
</I>&gt;<i> &gt; &gt; prefer all tracks being mutually exclusive and requiring scripts to 
</I>&gt;<i> &gt; &gt; enable several at once.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; It's not clear to me what the use case is for having multiple groups 
</I>&gt;<i> &gt; of mutually exclusive tracks.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The intent of the spec as written was that a browser would by default 
</I>&gt;<i> &gt; just have a list of all the subtitle and caption tracks (the latter 
</I>&gt;<i> &gt; with suitable icons next to them, e.g. the [CC] icon in US locales), 
</I>&gt;<i> &gt; and the user would pick one (or none) from the list. One could easily 
</I>&gt;<i> &gt; imagine a UA allowing the user to enable multiple tracks by having the 
</I>&gt;<i> &gt; user ctrl-click a menu item, though, or some similar solution, much 
</I>&gt;<i> &gt; like with the commonly seen select box UI.
</I>&gt;<i> 
</I>&gt;<i> In the vast majority of cases, all tracks are intended to be mutually 
</I>&gt;<i> exclusive, such as English+English HoH or subtitles in different 
</I>&gt;<i> languages. No media player UI (hardware or software) that I have ever 
</I>&gt;<i> used allows enabling multiple tracks at once. Without any kind of hint 
</I>&gt;<i> about which tracks make sense to enable together, I can't see desktop 
</I>&gt;<i> Opera allowing multiple tracks (of the same kind) to be enabled via the 
</I>&gt;<i> main UI.
</I>
Personally I think it's quite reasonable to want to see two languages at 
once, or even two forms of the same language at once, especially for, 
e.g., reviewing subtitles. But I don't think it would be a bad thing if 
some browsers didn't expose that in the UI; that's something that could 
be left to bookmarklets, for example.


&gt;<i> Using this syntax, I would expect some confusion when you omit the closing
</I>&gt;<i> &lt;/v&gt;, when it's *not* a cue spoken by two voices at the same time, such as:
</I>&gt;<i> 
</I>&gt;<i> &lt;v Jim&gt;- Boo!
</I>&gt;<i> &lt;v Bob&gt;- Gah!
</I>&gt;<i> 
</I>&gt;<i> Gah! is spoken by both Jim and Bob, but that was likely not intended. If 
</I>&gt;<i> this causes confusion, we should make validators warn about multiple 
</I>&gt;<i> voices with with no closing &lt;/v&gt;.
</I>
No need to just warn, the spec says the above is outright invalid, so 
they would raise an error.


&gt;<i> &gt; &gt; For captions and subtitles it's less common, but rendering it 
</I>&gt;<i> &gt; &gt; underneath the video rather than on top of it is not uncommon, e.g. 
</I>&gt;<i> &gt; &gt; <A HREF="http://nihseniorhealth.gov/video/promo_qt300.html">http://nihseniorhealth.gov/video/promo_qt300.html</A> or
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Conceptually, that's in the video area, it's just that the video isn't 
</I>&gt;<i> &gt; centered vertically. I suppose we could allow UAs to do that pretty 
</I>&gt;<i> &gt; easily, if it's commonly desired.
</I>&gt;<i> 
</I>&gt;<i> It's already possible to align the video to the top of its content box 
</I>&gt;<i> using &lt;<A HREF="http://dev.w3.org/csswg/css3-images/#object-position">http://dev.w3.org/csswg/css3-images/#object-position</A>&gt;:
</I>&gt;<i> 
</I>&gt;<i> video { object-position: center top }
</I>&gt;<i> 
</I>&gt;<i> (This is already supported in Opera, but prefixed: -o-object-position)
</I>
Sounds good.


&gt;<i> Note that in Sweden captioning for the HoH is delivered via the teletext 
</I>&gt;<i> system, which would allow ASCII-art to be displayed. Still, I've never 
</I>&gt;<i> seen it. The only case of graphics being used in &quot;subtitles&quot; I can 
</I>&gt;<i> remember ever seeing is the DVD of 
</I>&gt;<i> &lt;<A HREF="http://en.wikipedia.org/wiki/Cat_Soup">http://en.wikipedia.org/wiki/Cat_Soup</A>&gt;, where the subtitle system is 
</I>&gt;<i> (ab)used to overlay some graphics.
</I>
Yeah, I'm not at all concerned about not supporting graphics in subtitles. 
It's nowhere near the 80% bar.


&gt;<i> If we ever want comments, we need to add support in the parser before 
</I>&gt;<i> any content accidentally uses the syntax, in other words pretty soon 
</I>&gt;<i> now.
</I>
No, we can use any syntax that the parser currently ignores. It won't 
break backwards compat with content that already uses it by then, since 
the whole point of comments is to be ignored. The only difference is 
whether validators complain or not.


&gt;<i> &gt; On Tue, 14 Sep 2010, Anne van Kesteren wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Apart from text/plain I cannot think of a &quot;web&quot; text format that 
</I>&gt;<i> &gt; &gt; does not have comments.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; But what's the use case? Is it really useful to have comments in a 
</I>&gt;<i> &gt; subtitle file?
</I>&gt;<i> 
</I>&gt;<i> Being able to put licensing/contact information at the top of the file 
</I>&gt;<i> would be useful, just as it is in JavaScript/CSS.
</I>
Well the parser explicitly skips over anything in the header block 
(everything up to the first blank line IIRC), so if we find that people 
want this then we can allow it without having to change any UAs except the 
validators.


&gt;<i> &gt; On Fri, 22 Oct 2010, Simon Pieters wrote:
</I>&gt;<i> &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt; It can still be inspired by it though so we don't have to change 
</I>&gt;<i> &gt; &gt; &gt; much. I'd be curious to hear what other things you'd clean up 
</I>&gt;<i> &gt; &gt; &gt; given the chance.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; WebSRT has a number of quirks to be compatible with SRT, like 
</I>&gt;<i> &gt; &gt; supporting both comma and dot as decimal separators, the weird 
</I>&gt;<i> &gt; &gt; parsing of timestamps, etc.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I've cleaned the timestamp parsing up. I didn't see others.
</I>&gt;<i> 
</I>&gt;<i> I consider the cue id line (the line preceding the timing line) to be 
</I>&gt;<i> cruft carried over from SRT. When we now both have classes and the 
</I>&gt;<i> possibility of getting a cue by index, so why do we need it?
</I>
It's optional, but it is useful, especially for metadata tracks, as a way 
to grab specific cues. For example, consider a metadata or chapter track 
that contains cues with specific IDs that the site would use to jump to 
particular parts of the video in response to key presses, such as &quot;start 
of content after intro&quot;, or maybe for a podcast with different segments, 
where the user can jump to &quot;news&quot; and &quot;reviews&quot; and &quot;final thought&quot; -- you 
need an ID to be able to find the right cue quickly.


&gt;<i> &gt; &gt; There was also some discussion about metadata. Language is sometimes 
</I>&gt;<i> &gt; &gt; necessary for the font engine to pick the right glyph.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Could you elaborate on this? My assumption was that we'd just use CSS, 
</I>&gt;<i> &gt; which doesn't rely on language for this.
</I>&gt;<i> 
</I>&gt;<i> It's not in any spec that I'm aware of, but some browsers (including 
</I>&gt;<i> Opera) pick different glyphs depending on the language of the text, 
</I>&gt;<i> which really helps when rendering CJK when you have several CJK fonts on 
</I>&gt;<i> the system. Browsers will already know the language from &lt;track 
</I>&gt;<i> srclang&gt;, so this would be for external players.
</I>
How is this problem solved in SRT players today?


On Mon, 14 Feb 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i>
</I>&gt;<i> Given that most existing subtitle formats don't have any language 
</I>&gt;<i> metadata, I'm a bit skeptical. However, if implementors of non-browser 
</I>&gt;<i> players want to implement WebVTT and ask for this I won't stand in the 
</I>&gt;<i> way (not that I could if I wanted to). For simplicity, I'd prefer the 
</I>&gt;<i> language metadata from the file to not have any effect on browsers 
</I>&gt;<i> though, even if no language is given on &lt;track&gt;.
</I>
Indeed.


On Tue, 4 Jan 2011, Alex Bishop wrote:
&gt;<i> 
</I>&gt;<i> Firefox too. If you visit 
</I>&gt;<i> <A HREF="http://people.mozilla.org/~jdaggett/webfonts/serbianglyphs.html">http://people.mozilla.org/~jdaggett/webfonts/serbianglyphs.html</A> in 
</I>&gt;<i> Firefox 4, the text explicitly marked-up as being Serbian Cyrillic 
</I>&gt;<i> (using the lang=&quot;sr-Cyrl&quot; attribute) uses some different glyphs to the 
</I>&gt;<i> text with no language metadata.
</I>
This seems to be in violation of CSS; we should probably fix it there 
before fixing it in WebVTT since WebVTT relis on CSS.


On Mon, 3 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i>
</I>&gt;<i> &gt; &gt; * The &quot;bad cue&quot; handling is stricter than it should be. After 
</I>&gt;<i> &gt; &gt; collecting an id, the next line must be a timestamp line. Otherwise, 
</I>&gt;<i> &gt; &gt; we skip everything until a blank line, so in the following the 
</I>&gt;<i> &gt; &gt; parser would jump to &quot;bad cue&quot; on line &quot;2&quot; and skip the whole cue.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 1
</I>&gt;<i> &gt; &gt; 2
</I>&gt;<i> &gt; &gt; 00:00:00.000 --&gt; 00:00:01.000
</I>&gt;<i> &gt; &gt; Bla
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; This doesn't match what most existing SRT parsers do, as they simply 
</I>&gt;<i> &gt; &gt; look for timing lines and ignore everything else. If we really need 
</I>&gt;<i> &gt; &gt; to collect the id instead of ignoring it like everyone else, this 
</I>&gt;<i> &gt; &gt; should be more robust, so that a valid timing line always begins a 
</I>&gt;<i> &gt; &gt; new cue. Personally, I'd prefer if it is simply ignored and that we 
</I>&gt;<i> &gt; &gt; use some form of in-cue markup for styling hooks.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The IDs are useful for referencing cues from script, so I haven't 
</I>&gt;<i> &gt; removed them. I've also left the parsing as is for when neither the 
</I>&gt;<i> &gt; first nor second line is a timing line, since that gives us a lot of 
</I>&gt;<i> &gt; headroom for future extensions (we can do anything so long as the 
</I>&gt;<i> &gt; second line doesn't start with a timestamp and &quot;--&gt;&quot; and another 
</I>&gt;<i> &gt; timestamp).
</I>&gt;<i> 
</I>&gt;<i> In the case of feeding future extensions to current parsers, it's way 
</I>&gt;<i> better fallback behavior to simply ignore the unrecognized second line 
</I>&gt;<i> than to discard the entire cue. The current behavior seems unnecessarily 
</I>&gt;<i> strict and makes the parser more complicated than it needs to be. My 
</I>&gt;<i> preference is just ignore anything preceding the timing line, but even 
</I>&gt;<i> if we must have IDs it can still be made simpler and more robust than 
</I>&gt;<i> what is currently spec'ed.
</I>
If we just ignore content until we hit a line that happens to look like a 
timing line, then we are much more constrained in what we can do in the 
future. For example, we couldn't introduce a &quot;comment block&quot; syntax, since 
any comment containing a timing line wouldn't be ignored. On the other 
hand if we keep the syntax as it is now, we can introduce a comment block 
just by having its first line include a &quot;--&gt;&quot; but not have it match the 
timestamp syntax, e.g. by having it be &quot;--&gt; COMMENT&quot; or some such.

Looking at the parser more closely, I don't really see how doing anything 
more complex than skipping the block entirely would be simpler than what 
we have now, anyway.


On Mon, 3 Jan 2011, Glenn Maynard wrote:
&gt;<i>
</I>&gt;<i> By the way, the WebSRT hit from Google 
</I>&gt;<i> (<A HREF="http://www.whatwg.org/specs/web-apps/current-work/websrt.html">http://www.whatwg.org/specs/web-apps/current-work/websrt.html</A>) is 404.  
</I>&gt;<i> I've had to read it out of the Google cache, since I'm not sure where it 
</I>&gt;<i> went.
</I>
I added a redirect.


&gt;<i> Inline comments (not just line comments) in subtitles are very important 
</I>&gt;<i> for collaborative editing: for leaving notes about a translation, noting 
</I>&gt;<i> where editing is needed or why a change was made, and so on.
</I>&gt;<i> 
</I>&gt;<i> If a DOM-like interface is specified for this (presumably this will 
</I>&gt;<i> happen later), being able to access inline comments like DOM comment 
</I>&gt;<i> nodes would be very useful for visual editors, to allow displaying 
</I>&gt;<i> comments and to support features like &quot;seek to next comment&quot;.
</I>
We can add comments pretty easily (e.g. we could say that &quot;&lt;!&quot; starts a 
comment and &quot;&gt;&quot; ends it -- that's already being ignored by the current 
parser), if people really need them. But are comments really that useful? 
Did SRT have problem due to not supporting inline comments? (Or did it 
support inline comments?)


On Tue, 4 Jan 2011, Glenn Maynard wrote:
&gt;<i> On Tue, Jan 4, 2011 at 4:24 AM, Philip J&#195;&#164;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt; 
</I>&gt;<i> wrote:
</I>&gt;<i> &gt; If you need an intermediary format while editing, you can just use any 
</I>&gt;<i> &gt; syntax you like and have the editor treat it specially.
</I>&gt;<i> 
</I>&gt;<i> If I'd need to write my own parser to write an editor for it, that's one 
</I>&gt;<i> thing--but I hope I wouldn't need to create yet another ad hoc caption 
</I>&gt;<i> format, mirroring the features of this one, just to work around a lack 
</I>&gt;<i> of inline comments.
</I>
An editor would need a custom parser anyway to make sure it round-tripped 
syntax errors, presumably.


&gt;<i> The cue text already vaguely resembles HTML.  What about &lt;!-- comments 
</I>&gt;<i> --&gt;?  It's universally understood, and doesn't require any new escape 
</I>&gt;<i> mechanisms.
</I>
The current parser would end a comment at the first &quot;&gt;&quot;, but so long as 
you didn't have a &quot;&gt;&quot; in the comment, &quot;&lt;!--...--&gt;&quot; would work fine within 
cue text. (We would have to be careful in standalone blocks to define it 
in such a way that it could not be confused with a timing line.)


On Wed, 5 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> The question is rather if the comments should be exposed as DOM comment 
</I>&gt;<i> nodes in getCueAsHTML, which seems to be what you're asking for. That 
</I>&gt;<i> would only be possible if comments were only allowed inside the cue 
</I>&gt;<i> text, which means that you couldn't comment out entire cues, as such:
</I>&gt;<i>
</I>&gt;<i> 00:00.000 --&gt; 00:01.000
</I>&gt;<i> one
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i> 00:02.000 --&gt; 00:03.000
</I>&gt;<i> two
</I>&gt;<i> */
</I>&gt;<i> 
</I>&gt;<i> 00:04.000 --&gt; 00:05.000
</I>&gt;<i> three
</I>&gt;<i> 
</I>&gt;<i> Therefore, my thinking is that comments should be removed during parsing 
</I>&gt;<i> and not be exposed to any layer above it.
</I>
We can support both, if there's really demand for it.

For example:

 00:00.000 --&gt; 00:01.000
 one &lt;! inline comment &gt; one
 
 COMMENT--&gt;
 00:02.000 --&gt; 00:03.000
 two; this is entirely
 commented out
 
 &lt;! this is the ID line
 00:04.000 --&gt; 00:05.000
 three; last line is a &quot;&gt;&quot;
 which is part of the cue
 and is not a comment.
 &gt;

The above would work today in a conforming UA. The question really is what 
parts of this do we want to support and what do we not care enough about.


On Wed, 5 Jan 2011, Anne van Kesteren wrote:
&gt;<i> On Wed, 05 Jan 2011 10:58:56 +0100, Philip J&#195;&#164;genstedt 
</I>&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt; wrote:
</I>&gt;<i> &gt; Therefore, my thinking is that comments should be removed during 
</I>&gt;<i> &gt; parsing and not be exposed to any layer above it.
</I>&gt;<i> 
</I>&gt;<i> CSS does that too. It has not caused problems so far. It does mean 
</I>&gt;<i> editing tools need a slightly different DOM, but that is always the case 
</I>&gt;<i> as they want to preserve whitespace details, etc., too. At least editors 
</I>&gt;<i> that have both a text and visual interface.
</I>
Right.


On Fri, 14 Jan 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> We are concerned, however, about the introduction of WebVTT as a 
</I>&gt;<i> universal captioning format *when used outside browsers*. Since a subset 
</I>&gt;<i> of CSS features is required to bring HTML5 video captions on par with TV 
</I>&gt;<i> captions, non-browser applications will need to support these CSS 
</I>&gt;<i> features, too. However, we do not believe that external CSS files are an 
</I>&gt;<i> acceptable solution for non-browser captioning and therefore think that 
</I>&gt;<i> those CSS features (see [1]) should eventually be made part of the 
</I>&gt;<i> WebVTT specification.
</I>&gt;<i> 
</I>&gt;<i> [1] <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#the-">http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#the-</A>'::cue'-pseudo-element
</I>
I'm not sure what you mean by &quot;made part of the WebVTT specification&quot;, but 
if you mean that WebVTT should support inline CSS, that does seem line 
something we can add, e.g. using syntax like this:

   WEBVTT

   STYLE--&gt;
   ::cue(v[voice=Bob]) { color: green; }
   ::cue(c.narration) { font-style: italic; }
   ::cue(c.narration i) { font-style: normal; }

   00:00.000 --&gt; 00:02.000
   Welcome.

   00:02.500 --&gt; 00:05.000
   To WebVTT.

I suggest we wait until WebVTT and '::cue' in particular have shipped in 
at least one browser and been demonstrated as being useful before adding 
this kind of feature though.


&gt;<i> 1. Introduce file-wide metadata
</I>&gt;<i> 
</I>&gt;<i> WebVTT requires a structure to add header-style metadata. We are here 
</I>&gt;<i> talking about lists of name-value pairs as typically in use for header 
</I>&gt;<i> information. The metadata can be optional, but we need a defined means 
</I>&gt;<i> of adding them.
</I>&gt;<i> 
</I>&gt;<i> Required attributes in WebVTT files should be the main language in use 
</I>&gt;<i> and the kind of data found in the WebVTT file - information that is 
</I>&gt;<i> currently provided in the &lt;track&gt; element by the @srclang and @kind 
</I>&gt;<i> attributes. These are necessary to allow the files to be interpreted 
</I>&gt;<i> correctly by non-browser applications, for transcoding or to determine 
</I>&gt;<i> if a file was created as a caption file or something else, in particular 
</I>&gt;<i> the @kind=metadata. @srclang also sets the base directionality for BiDi 
</I>&gt;<i> calculations.
</I>&gt;<i>
</I>&gt;<i> Further metadata fields that are typically used by authors to keep 
</I>&gt;<i> specific authoring information or usage hints are necessary, too. As 
</I>&gt;<i> examples of current use see the format of MPlayer mpsub&#161;&#175;s header 
</I>&gt;<i> metadata [2], EBU STL&#161;&#175;s General Subtitle Information block [3], and 
</I>&gt;<i> even CEA-608&#161;&#175;s Extended Data Service with its StartDate, Station, 
</I>&gt;<i> Program, Category and TVRating information [4]. Rather than specifying a 
</I>&gt;<i> specific subset of potential fields we recommend to just have the means 
</I>&gt;<i> to provide name-value pairs and leave it to the negotiation between the 
</I>&gt;<i> author and the publisher which fields they expect of each other.
</I>&gt;<i>
</I>&gt;<i> [2] <A HREF="http://www.mplayerhq.hu/DOCS/tech/mpsub.sub">http://www.mplayerhq.hu/DOCS/tech/mpsub.sub</A>
</I>&gt;<i> [3] <A HREF="https://docs.google.com/viewer?a=v&amp;q=cache:UKnzJubrIh8J:tech.ebu.ch/docs/tech/tech3264.pdf">https://docs.google.com/viewer?a=v&amp;q=cache:UKnzJubrIh8J:tech.ebu.ch/docs/tech/tech3264.pdf</A>
</I>&gt;<i> [4] <A HREF="http://edocket.access.gpo.gov/cfr_2007/octqtr/pdf/47cfr15.119.pdf">http://edocket.access.gpo.gov/cfr_2007/octqtr/pdf/47cfr15.119.pdf</A>
</I>
I don't understand the use cases here.

CSS and JS don't have anything like this, why should WebVTT? What problem 
is this solving? How did SRT solve this problem?


&gt;<i> 2. Introduce file-wide cue settings
</I>&gt;<i> 
</I>&gt;<i> At the moment if authors want to change the default display of cues,
</I>&gt;<i> they can only set them per cue (with the D:, S:, L:, A: and T:. cue
</I>&gt;<i> settings) or have to use an external CSS file through a HTML page with
</I>&gt;<i> the ::cue pseudo-element. In particular when considering that all
</I>&gt;<i> Asian language files would require a &#161;&#176;D:vertical&#161;&#177; marker, it becomes
</I>&gt;<i> obvious that this replication of information in every cue is
</I>&gt;<i> inefficient and a waste of bandwidth, storage, and application speed.
</I>&gt;<i> A cue setting default section should be introduced into a file
</I>&gt;<i> header/setup area of WebVTT which will avoid such replication.
</I>&gt;<i> 
</I>&gt;<i> An example document with cue setting defaults in the header could look
</I>&gt;<i> as follows:
</I>&gt;<i> ==
</I>&gt;<i> WEBVTT
</I>&gt;<i> Language=zh
</I>&gt;<i> Kind=Caption
</I>&gt;<i> CueSettings= A:end D:vertical
</I>&gt;<i> 
</I>&gt;<i> 00:00:15.000 --&gt; 00:00:17.950
</I>&gt;<i> &#212;&#218;&#215;&#243;&#177;&#223;&#206;&#210;&#195;&#199;&#191;&#201;&#210;&#212;&#191;&#180;&#181;&#189;...
</I>&gt;<i> 
</I>&gt;<i> 00:00:18.160 --&gt; 00:00:20.080
</I>&gt;<i> &#212;&#218;&#211;&#210;&#177;&#223;&#206;&#210;&#195;&#199;&#191;&#201;&#210;&#212;&#191;&#180;&#181;&#189;...
</I>&gt;<i> 
</I>&gt;<i> 00:00:20.110 --&gt; 00:00:21.960
</I>&gt;<i> ...&#178;&#182;&#211;&#172;&#178;&#221;&#208;&#181;.
</I>&gt;<i> ==
</I>&gt;<i> 
</I>&gt;<i> Note that you might consider that the solution to this problem is to use 
</I>&gt;<i> external CSS to specify a change to all cues. However, this is not 
</I>&gt;<i> acceptable for non-browser applications and therefore not an acceptable 
</I>&gt;<i> solution to this problem.
</I>
Adding defaults seems like a reasonable feature. We could add this just by 
adding the ability to have a block in a VTT file like this:

   WEBVTT

   DEFAULTS --&gt; A:vertical A:end

   00:00.000 --&gt; 00:02.000
   This is vertical and end-aligned.

   00:02.500 --&gt; 00:05.000
   As is this.

   DEFAULTS --&gt; A:start

   00:05.500 --&gt; 00:07.000
   This is horizontal and start-aligned.

However, again I suggest that we wait until WebVTT has been deployed in at 
least one browser before adding more features like this.


&gt;<i> * positioning: Generally the way in which we need positioning to work is 
</I>&gt;<i> to provide an anchor position for the text and then explain in which 
</I>&gt;<i> direction font size changes and the addition of more text allows the 
</I>&gt;<i> text segment to grow. It seems that the line position cue (L) provides a 
</I>&gt;<i> baseline position and the alignment cue (A) provides the growing 
</I>&gt;<i> direction start/middle/end. Can we just confirm this understanding?
</I>
It's more the other way around: the line boxes are laid out and then the 
resulting line boxes are positioned according to the A: and L: lines. In 
particular, the L: lines when given with a % character position the line 
boxes in the same manner that CSS background-position positions the 
background image, and L: lines without a % character set the position of 
the line boxes based on the height of the first line box. A: lines then 
just set the position of these line boxes relative to the other dimension.


&gt;<i> * fontsize: When changing text size in relation to the video changing 
</I>&gt;<i> size or resolution, we need to make sure not to reduce the text size 
</I>&gt;<i> below a specific font size for readability reasons. And we also need to 
</I>&gt;<i> make sure not to make it larger than a specific font size, since 
</I>&gt;<i> otherwise it will dominate the display. We usually want the text to be 
</I>&gt;<i> at least Xpx, but no bigger than Ypx. Also, one needs to pay attention 
</I>&gt;<i> to the effect that significant player size changes have on relative 
</I>&gt;<i> positioning - in particular for the minimum caption text size. Dealing 
</I>&gt;<i> with min and max sizes is missing from the current specification in our 
</I>&gt;<i> understanding.
</I>
That's a CSS implementation issue. Minimum font sizes are commonly 
supported in CSS implementations. Maximum font sizes would be similar.


&gt;<i> * bidi text: In our experience from YouTube, we regularly see captions 
</I>&gt;<i> that contain mixed languages/directionality, such as Hebrew captions 
</I>&gt;<i> that have a word of English in it. How do we allow for bidi text inside 
</I>&gt;<i> cues? How do we change directionality mid-cue? Do we deal with the 
</I>&gt;<i> zero-width LTR-mark and RTL-mark unicode characters? It would be good to 
</I>&gt;<i> explain how these issues are dealt with in WebVTT.
</I>
There's nothing special about how they work in WebVTT; they are handled 
the same as in CSS.


&gt;<i> * internationalisation: D:vertical and D:vertical-lr seem to only work 
</I>&gt;<i> for vertical text - how about horizontal-rl? For example, Hebrew is a 
</I>&gt;<i> prime example of a language being written from right to left 
</I>&gt;<i> horizontally. Is that supported and how?
</I>
What exactly would horizontal-rl do?


&gt;<i> * naming: The usage of single letter abbreviations for cue settings has 
</I>&gt;<i> created quite a discussion here at Google. We all agree that file-wide 
</I>&gt;<i> cue settings are required and that this will reduce the need for 
</I>&gt;<i> cue-specific cue settings. We can thus afford a bit more readability in 
</I>&gt;<i> the cue settings. We therefore believe that it would be better if the 
</I>&gt;<i> cue settings were short names rather than single letter codes. This 
</I>&gt;<i> would be more like CSS, too, and easier to learn and get right. In the 
</I>&gt;<i> interface description, the 5 dimensions have proper names which could be 
</I>&gt;<i> re-used (&#161;&#176;direction&#161;&#177;, &#161;&#176;linePosition&#161;&#177;, &#161;&#176;textPosition&#161;&#177;, &#161;&#176;size&#161;&#177; and 
</I>&gt;<i> &#161;&#176;align&quot;). We therefore recommend replacing the single-letter cue 
</I>&gt;<i> commands with these longer names.
</I>
That would massively bloat these files and make editing them a huge pain, 
as far as I can tell. I agree that defaults would make it better, but many 
cues would still need their own positioning and sizing information, and 
anything beyond a very few letters would IMHO quickly become far too 
verbose for most people. &quot;L&quot;, &quot;A&quot;, and &quot;S&quot; are pretty mnemonic, &quot;T&quot; would 
quickly become familiar to people writing cues, and &quot;D&quot; is only going to 
be relevant to some authors but for those authors it's pretty 
self-explanatory as well, since the value is verbose.

What I really would like to do is use &quot;X&quot; and &quot;Y&quot; instead of &quot;T&quot; and &quot;L&quot;, 
but those terms would be very confusing when we flip the direction, which 
is why I used the less obvious &quot;T&quot; and &quot;L&quot;.


&gt;<i> * textcolor: In particular on European TV it is common to distinguish 
</I>&gt;<i> between speakers by giving their speech different colors. The following 
</I>&gt;<i> colors are supported by EBU STL, CEA-608 and CEA-708 and should be 
</I>&gt;<i> supported in WebVTT without the use of external CSS: black, red, green, 
</I>&gt;<i> yellow, blue, magenta, cyan, and white. As default we recommend white on 
</I>&gt;<i> a grey transparent background.
</I>
This is supported as 'color' and 'background'.


&gt;<i> * underline: EBU STL, CEA-608 and CEA-708 support underlining of 
</I>&gt;<i> characters.
</I>
I've added support for 'text-decoration'.


&gt;<i> The underline character is also particularly important for some Asian 
</I>&gt;<i> languages.
</I>
Could you elaborate on this?


&gt;<i> Please make it possible to provide text underlines without the use of 
</I>&gt;<i> CSS in WebVTT.
</I>
Why without CSS?


&gt;<i> * blink: As much as we would like to discourage blinking subtitles, they 
</I>&gt;<i> are actually a core requirement for EBU STL and CEA-608/708 captions and 
</I>&gt;<i> in use in particular for emergency messages and similar highly important 
</I>&gt;<i> information. Blinking can be considered optional for implementation, but 
</I>&gt;<i> we should allow for it in the standard.
</I>
This is part of 'text-decoration'.


&gt;<i> * font face: CEA-708 provides a choice of eight font tags: undefined, 
</I>&gt;<i> monospaced serif, proportional serif, monospaced sans serif, 
</I>&gt;<i> proportional sans serif, casual, cursive, small capital. These fonts 
</I>&gt;<i> should be available for WebVTT as well. Is this the case?
</I>
Yes.


&gt;<i> We are not sure about the best solution to these needs. Would it be best 
</I>&gt;<i> to introduce specific tags for these needs?
</I>
CSS seems to handle these needs adequately.


&gt;<i> We have a couple of recommendations for changes mostly for aesthetic and 
</I>&gt;<i> efficiency reasons. We would like to point out that Google is very 
</I>&gt;<i> concerned with the dense specification of data and every surplus 
</I>&gt;<i> character, in particular if it is repeated a lot and doesn&#161;&#175;t fulfill a 
</I>&gt;<i> need, should be removed to reduce the load created on worldwide 
</I>&gt;<i> networking and storage infrastructures and help render Web pages faster.
</I>
This seems to contradict your earlier request to make the languge more 
verbose...


&gt;<i> * Time markers: WebVTT time stamps follow no existing standard for time 
</I>&gt;<i> markers. Has the use of NPT as introduced by RTSP[5] for time markers 
</I>&gt;<i> been considered (in particular npt-hhmmss)?
</I>&gt;<i> 
</I>&gt;<i> [5] <A HREF="http://www.ietf.org/rfc/rfc2326.txt">http://www.ietf.org/rfc/rfc2326.txt</A>
</I>
WebVTT follows the SRT format, with commas replaced by periods for 
consistency with the rest of the platform.


&gt;<i> * Suggest dropping &#161;&#176;--&gt;&#161;&#177;: In the context of HTML, &#161;&#176;--&gt;&#161;&#177; is an end 
</I>&gt;<i> comment marker. It may confuse Web developers and parsers if such a sign 
</I>&gt;<i> is used as a separator. For example, some translation tools expect HTML 
</I>&gt;<i> or XML-based interchange formats and interpret the &#161;&#176;&gt;&#161;&#177; as part of a 
</I>&gt;<i> tag. Also, common caption convention often uses &#161;&#176;&gt;&#161;&#177; to represent 
</I>&gt;<i> speaker identification. Thus it is more difficult to write a filter 
</I>&gt;<i> which correctly escapes &#161;&#176;--&gt;&#161;&#177; but retains &#161;&#176;&gt;&#161;&#177; for speaker ID.
</I>
&quot;--&gt;&quot; seems pretty mnemonic to me. I don't see why we'd want to drop it.


&gt;<i> * Duration specification: WebVTT time stamps are always absolute time 
</I>&gt;<i> stamps calculated in relation to the base time of synchronisation with 
</I>&gt;<i> the media resource. While this is simple to deal with for machines, it 
</I>&gt;<i> is much easier for hand-created captions to deal with relative time 
</I>&gt;<i> stamps for cue end times and for the timestamp markers within cues. Cue 
</I>&gt;<i> start times should continue to stay absolute time stamps. Timestamp 
</I>&gt;<i> markers within cues should be relative to the cue start time. Cue end 
</I>&gt;<i> times should be possible to be specified either as absolute or relative 
</I>&gt;<i> timestamps. The relative time stamps could be specified through a prefix 
</I>&gt;<i> of &#161;&#176;+&#161;&#177; in front of a &#161;&#176;ss.mmm&#161;&#177; second and millisecond specification. 
</I>&gt;<i> These are not only simpler to read and author, but are also more compact 
</I>&gt;<i> and therefore create smaller files.
</I>
I think if anything is absolute, it doesn't really make anything much 
simpler for anything else to be relative, to be honest. Take the example 
you give here:

&gt;<i> An example document with relative timestamps is:
</I>&gt;<i> ==
</I>&gt;<i> WEBVTT
</I>&gt;<i> Language=en
</I>&gt;<i> Kind=Subtitle
</I>&gt;<i> 
</I>&gt;<i> 00:00:15.000   +2.950
</I>&gt;<i> At the left we can see...
</I>&gt;<i> 
</I>&gt;<i> 00:00:18.160    +1.920
</I>&gt;<i> At the right we can see the...
</I>&gt;<i> 
</I>&gt;<i> 00:00:20.110   +1.850
</I>&gt;<i> ...the &lt;+0.400&gt;head-&lt;+0.800&gt;snarlers
</I>&gt;<i> ==
</I>
If the author were to change the first time stamp because the video gained 
a 30 second advertisement at the start, then he would still need to change 
the hundreds of subseqent timestamps for all the additional cues. What 
does the author gain from not having to change the relative stamps? It's 
not like he's going to be doing it by hand, and once a tool is involved, 
the tool can change everything just as easily.


&gt;<i> We are happy to see the introduction of the magic file identifier for 
</I>&gt;<i> WebVTT which will make it easier to identify the file format. We do not 
</I>&gt;<i> believe the &#161;&#176;FILE&#161;&#177; part of the string is necessary.
</I>
I have removed it.


&gt;<i> However, we recommend to also introduce a format version number that the 
</I>&gt;<i> file adheres to, e.g. &#161;&#176;WEBVTT 0.7&#161;&#177;.
</I>
Version numbers are an antipattern on the Web, so I have not added one.


&gt;<i> This helps to make non-browser systems that parse such files become 
</I>&gt;<i> aware of format changes.
</I>
The format will never change in a non-backwards-compatible fashion once it 
is deployed, so that is not a concern.


&gt;<i> It can also help identify proprietary standard metadata sets as used by 
</I>&gt;<i> a specific company, such as &#161;&#176;WEBVTT 0.7 ABC-meta1&#161;&#177; which could signify 
</I>&gt;<i> that the file adheres to WEBVTT 0.7 format specification with the 
</I>&gt;<i> ABC-meta1 metadata schema.
</I>
If we add metadata, then that can be handled just by having the metadata 
include that information itself.


&gt;<i> CEA-708 captions support automatic line wrapping in a more sophisticated 
</I>&gt;<i> way than WebVTT -- see <A HREF="http://en.wikipedia.org/wiki/CEA-708#Word_wrap.">http://en.wikipedia.org/wiki/CEA-708#Word_wrap.</A>
</I>&gt;<i> 
</I>&gt;<i> In our experience with YouTube we have found that in certain situations 
</I>&gt;<i> this type of automatic line wrapping is very useful. Captions that were 
</I>&gt;<i> authored for display in a full-screen video may contain too many words 
</I>&gt;<i> to be displayed fully within the actual video presentation (note that 
</I>&gt;<i> mobile / desktop / internet TV devices may each have a different amount 
</I>&gt;<i> of space available, and embedded videos may be of arbitrary sizes). 
</I>&gt;<i> Furthermore, user-selected fonts or font sizes may be larger than 
</I>&gt;<i> expected, especially for viewers who need larger print.
</I>&gt;<i> 
</I>&gt;<i> WebVTT as currently specified wraps text at the edge of their containing 
</I>&gt;<i> blocks, regardless of the value of the 'white-space' property, even if 
</I>&gt;<i> doing so requires splitting a word where there is no line breaking 
</I>&gt;<i> opportunity. This will tend to create poor quality captions.  For 
</I>&gt;<i> languages where it makes sense, line wrapping should only be possible at 
</I>&gt;<i> carriage return, space, or hyphen characters, but not on &nbsp; 
</I>&gt;<i> characters.  (Note that CEA-708 also contains non-breaking space and 
</I>&gt;<i> non-breaking transparent space characters to help control wrapping.) 
</I>&gt;<i> However, this algorithm will not necessarily work for all languages.
</I>&gt;<i> 
</I>&gt;<i> We therefore suggest that a better solution for line wrapping would be 
</I>&gt;<i> to use the existing line wrapping algorithms of browsers, which are 
</I>&gt;<i> presumably already language-sensitive.
</I>&gt;<i> 
</I>&gt;<i> [Note: the YouTube line wrapping algorithm goes even further by 
</I>&gt;<i> splitting single caption cues into multiple cues if there is too much 
</I>&gt;<i> text to reasonably fit within the area. YouTube then adjusts the times 
</I>&gt;<i> of these caption cues so they appear sequentially.  Perhaps this could 
</I>&gt;<i> be mentioned as another option for server-side tools.]
</I>
I've adjusted the text in the spec to more clearly require that 
line-breaking follow normal CSS rules but with the additional requirement 
that there not be overflow, which is what I had intended.


&gt;<i> 1. Pop-on/paint-on/roll-up support
</I>&gt;<i> 
</I>&gt;<i> Three different types of captions are common on TV: pop-on, roll-up and 
</I>&gt;<i> paint-on. Captions according to CEA-608/708 need to support captions of 
</I>&gt;<i> all three of these types. We believe they are already supported in 
</I>&gt;<i> WebVTT, but see a need to re-confirm.
</I>&gt;<i> 
</I>&gt;<i> For pop-on captions, a complete caption cue is timed to appear at a 
</I>&gt;<i> certain time and disappear a few seconds later. This is the typical way 
</I>&gt;<i> in which captions are presented and also how WebVTT/&lt;track&gt; works in our 
</I>&gt;<i> understanding. Is this correct?
</I>
As far as I understand, yes.


&gt;<i> For roll-up captions, individual lines of captions are presented 
</I>&gt;<i> successively with older lines moving up a line to make space for new 
</I>&gt;<i> lines underneath. Assuming we understand the WebVTT rendering rules 
</I>&gt;<i> correctly, WebVTT would identify each of these lines as an individual, 
</I>&gt;<i> but time-overlapping cue with the other cues. As more cues are created 
</I>&gt;<i> and overlap in time, newer cues are added below the currently visible 
</I>&gt;<i> ones and move the currently visible ones up, basically creating a 
</I>&gt;<i> roll-up effect. If this is a correct understanding, then this is an 
</I>&gt;<i> acceptable means of supporting roll-up captions.
</I>
I am not aware of anything currently in the WebVTT specification which 
will cause a cue to move after it has been placed on the video, so I do 
not believe this is a correct understanding.

However, you can always have a cue be replaced by a cue with the same text 
but on a higher line, if you're willing to do some preprocessing on the 
subtitle file. It won't be a smoothly animated scroll, but it would work.

If there is convincing evidence that this kind of subtitle is used on the 
Web, though, we can support it more natively. So far I've only seen it in 
legacy scenarios that do not really map to expected WebVTT use cases.

For supporting those legacy scenarios, you need script anyway (to handle, 
e.g., backspace and moving the cursor). If you have script, doing 
scrolling is possible either by moving the cue, or by not using the 
default UA rendering of the cues at all and doing it manually (e.g. using 
&lt;div&gt;s or &lt;canvas&gt;).


&gt;<i> Finally, for paint-on captions, individual letters or words are 
</I>&gt;<i> displayed successively on screen. WebVTT supports this functionality 
</I>&gt;<i> with the cue timestamps &lt;xx:xx:xx.xxx&gt;, which allows to specify 
</I>&gt;<i> characters or words to appear with a delay from within a cue. This 
</I>&gt;<i> essentially realizes paint-on captions. Is this correct?
</I>
Yes.


&gt;<i> (Note that we suggest using relative timestamps inside cues to make this 
</I>&gt;<i> feature more usable.)
</I>
It makes it modestly easier to do by hand, but hand-authoring a &quot;paint-on&quot; 
style caption seems like a world of pain regardless of the timestamp 
format we end up using, so I'm not sure it's a good argument for 
complicating the syntax with a second timestamp format.


&gt;<i> The HTML spec specifies that it is not allowed to have two tracks that 
</I>&gt;<i> provide the same kind of data for the same language (potentially empty) 
</I>&gt;<i> and for the same label (potentially empty). However, we need 
</I>&gt;<i> clarification on what happens if there is a duplicate track, ie: does 
</I>&gt;<i> the most recent one win or the first one or will both be made available 
</I>&gt;<i> in the UI and JavaScript?
</I>
They are both available.


&gt;<i> The spec only states that the combination of {kind, type, label} must be 
</I>&gt;<i> unique. It doesn't say what happens if they are not.
</I>
Nothing different happens if they are not than if they are. It's just a 
conformance requirement.


&gt;<i> Further, the spec says nothing about duplicate labels altogether - what 
</I>&gt;<i> is a browser supposed to do when two tracks have been marked with the 
</I>&gt;<i> same label?
</I>
That same as it does if they have different labels.


&gt;<i> It is very important that there is a possibility for users to 
</I>&gt;<i> auto-activate tracks. Which track is chosen as the default track to 
</I>&gt;<i> activate depends on the language preferences of the user. The user is 
</I>&gt;<i> assumed to have a list of language preferences which leads this choice.
</I>
I've added a &quot;default&quot; attribute so that sites can control this.


&gt;<i> In YouTube, if any tracks exist that match the first language
</I>&gt;<i> preference, the first of those is used as the default.  A track with
</I>&gt;<i> no name sorts ahead of one with a name.  The sorting is done according
</I>&gt;<i> to that language's collation order. In order to override this you
</I>&gt;<i> would need (1) a default=true attribute for a track which gives it
</I>&gt;<i> precedence if its language matches, and (2) a way to force the
</I>&gt;<i> language preference. If no tracks exist for the first language pref,
</I>&gt;<i> the second language pref is checked, and so on.
</I>&gt;<i> 
</I>&gt;<i> If the user's language preferences are known, and there are no tracks
</I>&gt;<i> in that language, you have other options:
</I>&gt;<i>   (1) offer to do auto-translation (or just do it)
</I>&gt;<i>   (2) use a track in the same language that the video's audio is in (if known)
</I>&gt;<i>   (3) if only one track, use the first available track
</I>&gt;<i> 
</I>&gt;<i> Also make sure the language choice can be overriden by the user
</I>&gt;<i> through interaction.
</I>&gt;<i> 
</I>&gt;<i> We&#161;&#175;d like to make sure this or a similar algorithm is the recommended
</I>&gt;<i> way in which browsers deal with caption tracks.
</I>
This seems to me to be a user agent quality of implementation issue. User 
preferences almost by definition can't be interoperable, so it's not 
something we can specify.


&gt;<i> As far as we understand, you can currently address all cues through 
</I>&gt;<i> ::cue and you can address a cue part through ::cue-part(&lt;voice&gt; || 
</I>&gt;<i> &lt;part&gt; || &lt;position&gt; || &lt;future-compatibility&gt;). However, if we 
</I>&gt;<i> understand correctly, it doesn&#161;&#175;t seem to be possible to address an 
</I>&gt;<i> individual cue through CSS, even though cues have individual 
</I>&gt;<i> identifiers. This is either an oversight or a misunderstanding on our 
</I>&gt;<i> parts. Can you please clarify how it is possible to address an 
</I>&gt;<i> individual cue through CSS?
</I>
I've made the ID referencable from the ::cue() selector argument as an ID 
on the anonymous root element.


&gt;<i> Our experience with automated caption creation and positioning on 
</I>&gt;<i> YouTube indicates that it is almost impossible to always place the 
</I>&gt;<i> captions out of the way of where a user may be interested to look at. We 
</I>&gt;<i> therefore allow users to dynamically move the caption rendering area to 
</I>&gt;<i> a different viewport position to reveal what is underneath. We recommend 
</I>&gt;<i> such drag-and-drop functionality also be made available for TimedTrack 
</I>&gt;<i> captions on the Web, especially when no specific positioning information 
</I>&gt;<i> is provided.
</I>
I've added text to explicitly allow this.


On Sat, 22 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> Indeed, repeating settings on each cue would be annoying. However, 
</I>&gt;<i> file-wide settings seems like it would easily be too broad, and you'd 
</I>&gt;<i> have to explicitly reverse the effect on the cues where you don't want 
</I>&gt;<i> it to apply. Maybe classes of cue settings or some kind of macros would 
</I>&gt;<i> work better.
</I>
My assumption is that similar cues will typically be grouped together, so 
that one could introduce the group with a &quot;DEFAULTS&quot; block and then 


&gt;<i> Nitpick: Modern Chinese, including captions, is written left-to-right, 
</I>&gt;<i> top-to-bottom, just like English.
</I>
Indeed. I don't expect there will be much vertical text captioning. I 
added it primarily to support some esoteric Anime cases.



&gt;<i> That the intra-cue timings are relative but the timing lines are 
</I>&gt;<i> absolute has bugged me a bit, so if the distinction was more obvious 
</I>&gt;<i> just from the syntax, that'd be great!
</I>
They're all absolute.


&gt;<i> [for the file signature] &quot;WebSRT&quot; is prettier than &quot;WEBSRT&quot;.
</I>
The idea is not to be pretty, the idea is to stand out. :-)


&gt;<i> I'm inclined to say that we should normalize all whitespace during 
</I>&gt;<i> parsing and not have explicit line breaks at all. If people really want 
</I>&gt;<i> two lines, they should use two cues. In practice, I don't know how well 
</I>&gt;<i> that would fare, though. What other solutions are there?
</I>
I think we definitely need line breaks, e.g. for cases like:

  -- Do you want to go to the zoo?
  -- Yes!
  -- Then put your shoes on!

...which is quite common style in some locales.

However, I agree that we should encourage people to let browsers wrap the 
lines. Not sure how to encourage that more.


On Sun, 23 Jan 2011, Glenn Maynard wrote:
&gt;<i>
</I>&gt;<i> It should be possible to specify language per-cue, or better, per block 
</I>&gt;<i> of text mid-cue.  Subtitles making use of multiple languages are common, 
</I>&gt;<i> and it should be possible to apply proper font selection and word 
</I>&gt;<i> wrapping to all languages in use, not just the primary language.
</I>
It's not clear to me that we need language information to apply proper 
font selection and word wrapping, since CSS doesn't do it.


&gt;<i> When both English subtitles and Japanese captions are on screen, it 
</I>&gt;<i> would be very bad to choose a Chinese font for the Japanese text, and 
</I>&gt;<i> worse to choose a Western font and use it for everything, even if 
</I>&gt;<i> English is the predominant language in the file.
</I>
Can't you get around this using explicit styles, e.g. against classes? 
Unless this really is going to be a common problem, I'm not particularly 
concerned about it.


On Mon, 24 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> Multi-languaged subtitles/captions seem to be extremely uncommon, 
</I>&gt;<i> unsurprisingly, since you have to understand all the languages to be 
</I>&gt;<i> able to read them.
</I>&gt;<i> 
</I>&gt;<i> The case you mention isn't a problem, you just specify Japanese as the 
</I>&gt;<i> main language.
</I>
Indeed.


&gt;<i> There are a few other theoretical cases:
</I>&gt;<i> 
</I>&gt;<i> * Multi-language CJK captions. I've never seen this, but outside of 
</I>&gt;<i> captioning, it seems like the foreign script is usually transcribed to 
</I>&gt;<i> the native script (e.g. writing Japanese names with simplified Chinese 
</I>&gt;<i> characters).
</I>&gt;<i> 
</I>&gt;<i> * Use of Japanese or Chinese words in a mostly non-CJK subtitles. This 
</I>&gt;<i> would make correct glyph selection impossible, but I've never seen it.
</I>&gt;<i> 
</I>&gt;<i> * Voice synthesis of e.g. mixed English/French captions. Given that this 
</I>&gt;<i> would only be useful to be people who know both languages, it seem not 
</I>&gt;<i> worth complicating the format for.
</I>
Agreed on all fronts.


&gt;<i> Do you have any examples of real-world subtitles/captions that would 
</I>&gt;<i> benefit from more fine-grained language information?
</I>
This kind of information would indeed be useful.


On Mon, 24 Jan 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> They're very common in anime fansubs:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://img339.imageshack.us/img339/2681/screenshotgg.jpg">http://img339.imageshack.us/img339/2681/screenshotgg.jpg</A>
</I>&gt;<i> 
</I>&gt;<i> The text on the left is a transcription, the top is a transliteration, 
</I>&gt;<i> and the bottom is a translation.
</I>
Aren't these three separate text tracks?


&gt;<i> I'm pretty sure I've also seen cases of translation notes mixing 
</I>&gt;<i> languages within the same caption, eg. &quot;jinja (&#231;&#165;&#158;&#231;&#164;&#190;): shrine&quot;, but 
</I>&gt;<i> it's less common and I don't have an example handy.
</I>
Mixing one CJK language with one non-CJK language seems fine. That should 
always work, assuming you specify good fonts in the CSS.


&gt;<i> &gt; The case you mention isn't a problem, you just specify Japanese as the 
</I>&gt;<i> &gt; main language. There are a few other theoretical cases:
</I>&gt;<i> 
</I>&gt;<i> Then you're indicating that English text is Japanese, which I'd expect 
</I>&gt;<i> to cause UAs to render everything with a Japanese font.  That's what 
</I>&gt;<i> happens when I load English text in Firefox and force SJIS: everything 
</I>&gt;<i> is rendered in MS PGothic.  That's probably just what Japanese users 
</I>&gt;<i> want for English text mixed in with Japanese text, too--but it's 
</I>&gt;<i> generally not what English users want with the reverse.
</I>
I don't understand why we can't have good typography for CJK and non-CJK 
together. Surely there are fonts that get both right?


On Mon, 24 Jan 2011, Glenn Maynard wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; [ use multiple tracks ]
</I>&gt;<i>
</I>&gt;<i> Personally I'd prefer that, but it would require a good deal of metadata 
</I>&gt;<i> support--marking which tracks are meant to be used together, tagging 
</I>&gt;<i> auxilliary track types so browsers can choose (eg. an &quot;English subtitles 
</I>&gt;<i> with no song caption tracks&quot; option), and so on.  I'm sure that's a 
</I>&gt;<i> non-starter (and I'd agree).
</I>
It's not that much metadata. It's far less effort than making the 
subtitles in the first place.


&gt;<i> I don't think you should need to resort to fine-grained font control to get
</I>&gt;<i> reasonable default fonts.
</I>
I agree entirely, but I don't think you should need to resort to 
fine-grained language tagging either...


&gt;<i> The above--semantics vs. presentation--brings something else to mind.  
</I>&gt;<i> One of the harder things to subtitle well is when you have two 
</I>&gt;<i> conversations talking on top of each other.  This is generally done by 
</I>&gt;<i> choosing a vertical spot for each conversation (generally augmented with 
</I>&gt;<i> a color), so the viewer can easily follow one or the other.  Setting the 
</I>&gt;<i> line position *sort of* lets you do this, but that's hard to get right, 
</I>&gt;<i> since you don't know how far apart to put them.  You'd have to err 
</I>&gt;<i> towards putting them too far apart (guessing the maximum number of lines 
</I>&gt;<i> text might be wrapped to, and covering up much more of the screen than 
</I>&gt;<i> usually needed), or putting one set on the top of the screen (making it 
</I>&gt;<i> completely impossible to read both at once, rather than just 
</I>&gt;<i> challenging).
</I>&gt;<i> 
</I>&gt;<i> If I remember correctly, SSA files do this with a hack: wherever there's 
</I>&gt;<i> a blank spot in one or the other conversation, a transparent dummy cue 
</I>&gt;<i> is added to keep the other conversation in the correct relative spot, so 
</I>&gt;<i> the two conversations don't swap places.
</I>&gt;<i> 
</I>&gt;<i> I mention this because it comes to mind as something well-authored, 
</I>&gt;<i> well-rendered subtitles need to get right, and I'm curious if there's a 
</I>&gt;<i> reliable way to do this currently with WebVTT.  If this isn't handled, 
</I>&gt;<i> some scenes just fall apart.
</I>
It's intended to be done using the L: feature to pick the lines. If the 
cues have more line wrapping than the author expected, it'll break. The 
only way around that would be to go through the whole file (or at least, 
the whole scene, somehow marked up as such) pre-rendering each cue to work 
out what the maximum line heights would be and then using that offset for 
each cue, etc, but that seems like a whole lot of complexity for a minor 
use case. Is line wrapping really going to be that unpredictable?


On Mon, 24 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> My main point here is that the use cases are so marginal. If there were 
</I>&gt;<i> more compelling ones, it's not hard to support intra-cue language 
</I>&gt;<i> settings using syntax like &lt;lang en&gt;bla&lt;/lang&gt; or similar.
</I>
Indeed.


On Mon, 24 Jan 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> Here's one that I think was done very well, rendered statically to make 
</I>&gt;<i> sure we're all seeing the same thing:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://zewt.org/~glenn/multiple%20conversation%20example.mpg">http://zewt.org/~glenn/multiple%20conversation%20example.mpg</A>
</I>&gt;<i> 
</I>&gt;<i> The results are pretty straightforward.  One always stays on top, one 
</I>&gt;<i> always stays on the bottom, and most of the time the spacing between the 
</I>&gt;<i> two is correct--the normal distance the UA uses between two vertical 
</I>&gt;<i> captions (which would be lost by specifying the line height explicitly).  
</I>&gt;<i> Combined with the separate coloring (which is already possible, of 
</I>&gt;<i> course), it's possible to read both conversations and intuitively track 
</I>&gt;<i> which is which, and it's also very easy to just pick one or the other to 
</I>&gt;<i> read.
</I>
As far as I can tell, the WebVTT algorithm would handle this case pretty 
well. 


&gt;<i> One example of how this can be tricky: at 0:17, a caption on the bottom 
</I>&gt;<i> wraps and takes two lines, which then pushes the line at 0:19 upward 
</I>&gt;<i> (that part's simple enough).  If instead the top part had appeared 
</I>&gt;<i> first, the renderer would need to figure out in advance to push it 
</I>&gt;<i> upwards, to make space for the two-line caption underneith it.  
</I>&gt;<i> Otherwise, the captions would be forced to switch places.
</I>
Right, without lookahead I don't know how you'd solve it. With lookahead 
things get pretty dicey pretty quickly.


On Mon, 24 Jan 2011, Tab Atkins Jr. wrote:
&gt;<i> 
</I>&gt;<i> Right now, the WebVTT spec handles this by writing the text in white on 
</I>&gt;<i> top of a partially-transparent black background.  The text thus never 
</I>&gt;<i> has contrast troubles, at the cost of a dark block covering up part of 
</I>&gt;<i> the display.
</I>&gt;<i> 
</I>&gt;<i> Stroking text is easy, though.  Webkit has an experimental property for 
</I>&gt;<i> doing it directly.  Using existing CSS, it's easy to adapt text-shadow 
</I>&gt;<i> to produce a good outline - just make four shadows, offset by 1px in 
</I>&gt;<i> each direction, and you're good.
</I>
WebVTT allows both text-shadow and text-outline.


On Wed, 9 Feb 2011, Silvia Pfeiffer wrote:
&gt;<i>
</I>&gt;<i> We're trying to avoid the need for multiple transcodings and are trying 
</I>&gt;<i> to achieve something like the following pipeline: broadcast captions -&gt; 
</I>&gt;<i> transcode to WebVTT -&gt; show in browser -&gt; transcode to broadcast devices 
</I>&gt;<i> -&gt; show
</I>
Why not just do:

   broadcast captions -&gt; transcode to WebVTT -&gt; show in browser

...for browsers and:

   broadcast captions -&gt; show

...for legacy broadcast devices?


In any case the amount of legacy broadcast captions pales in comparison to 
the volume of new captions we will see for the Web. I'm not really 
convinced that legacy broadcast captions are an important concern here.


&gt;<i> What is the argument against using &lt;u&gt; in captions?
</I>
What is the argument _for_ using &lt;u&gt; in captions? We don't add features 
due to a lack of reasons not to. We add features due to a plethora of 
reasons to do so.


&gt;<i> &gt; [ foolip suggests using multiple cues to do blinking ]
</I>&gt;<i> 
</I>&gt;<i> But from a captioning/subtitling point of view it's probably hard to 
</I>&gt;<i> convert that back to blinking text, since we've just lost the semantic 
</I>&gt;<i> by ripping it into multiple cues (and every program would use different 
</I>&gt;<i> ways of doing this).
</I>
I do not think round-tripping legacy broadcast captions through WebVTT is 
an important use case. If that is something that we should support, then 
we should first establish why it is an important use case, and then 
reconsider WebVTT within that context, rather than adding features to 
handle it piecemeal.


&gt;<i> I guess what we are discovering is that we can define the general format 
</I>&gt;<i> of WebVTT for the Web, but that there may be an additional need to 
</I>&gt;<i> provide minimum implementation needs (a &quot;profile&quot; if you want - as much 
</I>&gt;<i> as I hate this word).
</I>
Personally I have nothing against the word &quot;profile&quot;, but I do have 
something against providing for &quot;minimum implemenatation needs&quot;.

Interoperability means everything works the same everywhere.


&gt;<i> [re versioning the file format]
</I>&gt;<i> In a contract between a caption provider and a caption consumer (I am 
</I>&gt;<i> talking about companies here), the caption consumer will want to tell 
</I>&gt;<i> the caption provider what kind of features they expect the caption files 
</I>&gt;<i> to contain and features they want avoided. This links back to the 
</I>&gt;<i> earlier identified need for &quot;profiles&quot;. This is actually probably 
</I>&gt;<i> something outside the scope of this group, but I am sure there is a need 
</I>&gt;<i> for such a feature, in particular if we want to keep the development of 
</I>&gt;<i> the WebVTT specification open for future extensions.
</I>
I don't see why there would be a need for anything beyond &quot;make sure it 
works with deployed software&quot;, maybe with that being explicitly translated 
to specific features and workarounds for known bugs, e.g. &quot;you can use 
ruby, but make sure you don't have timestamps out of order&quot;.

This, however, has no correlation to versions of the format.


On Mon, 14 Feb 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; [line wrapping]
</I>&gt;<i>
</I>&gt;<i> There's still plenty of room for improvements in line wrapping, though. 
</I>&gt;<i> It seems to me that the main reason that people line wrap captions 
</I>&gt;<i> manually is to avoid getting two lines of very different length, as that 
</I>&gt;<i> looks quite unbalanced. There's no way to make that happen with CSS, and 
</I>&gt;<i> AFAIK it's not done by the WebVTT rendering spec either.
</I>
WebVTT just defers to CSS for this. I agree that it would be nice for CSS 
to allow UAs to do more clever things here and (more importantly) for UAs 
to actually do more clever things here.


On Tue, 15 Feb 2011, Silvia Pfeiffer wrote:
&gt;<i> foolip wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sure, it's already handled by the current parsing spec, since it 
</I>&gt;<i> &gt; ignores everything up to the first blank line.
</I>&gt;<i> 
</I>&gt;<i> That's not quite how I'm reading the spec.
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#webvtt-0">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#webvtt-0</A>
</I>&gt;<i> allows
</I>&gt;<i> &quot;Optionally, either a U+0020 SPACE character or a U+0009 CHARACTER
</I>&gt;<i> TABULATION (tab) character followed by any number of characters that
</I>&gt;<i> are not U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)
</I>&gt;<i> characters.&quot;
</I>&gt;<i> after the &quot;WEBVTT FILE&quot; magic.
</I>&gt;<i> To me that reads like all of the extra stuff has to be on the same line.
</I>&gt;<i> I'd prefer if this read &quot;any character except for two WebVTT line
</I>&gt;<i> terminators&quot;, then it would all be ready for such header-style
</I>&gt;<i> metadata.
</I>
That's the syntax rules. It's not the parser.


&gt;<i> I'm told &lt;u&gt; is fairly common in traditional captions.
</I>
I've never seen it. Do you have any data on this?


&gt;<i> &gt; Personally, I think we're going to see more and more devices running 
</I>&gt;<i> &gt; full browsers with webfonts support, and that this isn't going to be a 
</I>&gt;<i> &gt; big problem.
</I>&gt;<i> 
</I>&gt;<i> I tend to agree and in fact I see that as the shiny future. Just not 
</I>&gt;<i> quite yet.
</I>
We're not quite at WebVTT yet either. Currently, there's more support for 
WebFonts than WebVTT.


On Tue, 15 Feb 2011, Glenn Maynard wrote:
&gt;<i>
</I>&gt;<i> I think that, no matter what you do, people will insert line breaks in 
</I>&gt;<i> cues.  I'd follow the HTML model here: convert newlines to spaces and 
</I>&gt;<i> have a separate, explicit line break like &lt;br&gt; if needed, so people 
</I>&gt;<i> don't manually line-break unless they actually mean to.
</I>
The line-breaks-are-line-breaks feature is one of the features that 
originally made SRT seem like a good idea. It still seems like the neatest 
way of having a line break.


&gt;<i> Related to line breaking, should there be an &nbsp; escape?  Inserting 
</I>&gt;<i> nbsp literally into files is somewhat annoying for authoring, since 
</I>&gt;<i> they're indistinguishable from regular spaces.
</I>
How common would &nbsp; be?


On Thu, 10 Feb 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> Further discussions at Google indicate that it would be nice to make 
</I>&gt;<i> more components optional. Can we have something like this:
</I>&gt;<i> 
</I>&gt;<i>       [[h*:]mm:]ss[.[d[c[m]]]  | s*[.d[c[m]]]
</I>&gt;<i> 
</I>&gt;<i> Examples:
</I>&gt;<i>     23  = 23 seconds
</I>&gt;<i>     23.2  = 23 sec, 1 decisec
</I>&gt;<i>     1:23.45   = 1 min, 23 sec, 45 centisec
</I>&gt;<i>     123.456  = 123 sec, 456 millisec
</I>
Currently the syntax is [h*:]mm:ss.sss; what's the advantage of making 
this more complicated? It's not like most subtitled clips will be shorter 
than a minute. Also, why would we want to support multiple redundant ways 
of expressing the same time? (e.g. 01:00.000 and 60.000)

Readability of VTT files seems like it would be helped by consistency, 
which suggests using the same format everywhere, as much as possible.


On Sun, 16 Jan 2011, Mark Watson wrote:
&gt;<i> 
</I>&gt;<i> I have been looking at how the video element might work in an adaptive 
</I>&gt;<i> streaming context where the available media are specified with some kind 
</I>&gt;<i> of manifest file (e.g. MPEG DASH Media Presentation Description) rather 
</I>&gt;<i> than in HTML.
</I>&gt;<i> 
</I>&gt;<i> In this context there may be choices available as to what to present, 
</I>&gt;<i> many but not all related to accessibility:
</I>&gt;<i>
</I>&gt;<i> - multiple audio languages
</I>&gt;<i> - text tracks in multiple languages
</I>&gt;<i> - audio description of video
</I>&gt;<i> - video with open captions (in various languages)
</I>&gt;<i> - video with sign language
</I>&gt;<i> - audio with directors commentary
</I>&gt;<i> - etc.
</I>&gt;<i> 
</I>&gt;<i> It seems natural that for text tracks, loading the manifest could cause 
</I>&gt;<i> the video element to be populated with associated &lt;track&gt; elements, 
</I>&gt;<i> allowing the application to discover the choices and activate/deactivate 
</I>&gt;<i> the tracks.
</I>
Not literal &lt;track&gt; elements, hopefully, but in-band text tracks (known as 
&quot;media-resource-specific text track&quot; in the spec).


&gt;<i> But this seems just for text tracks. I know discussions are underway on 
</I>&gt;<i> what to do for other media types, but my question is whether it would be 
</I>&gt;<i> better to have a consistent solution for selection amongst the available 
</I>&gt;<i> media that applies for all media types ?
</I>
They're pretty different from each other, so I don't know that one 
solution would make sense for all of these.

Does the current solution (the videoTracks, audioTracks, and textTracks 
attributes) adequately address your concern?


On Mon, 17 Jan 2011, Jeroen Wijering wrote:
&gt;<i> 
</I>&gt;<i> We are getting some questions from JW Player users that HTML5 video is 
</I>&gt;<i> quite wasteful on bandwidth for longer videos (think 10min+). This 
</I>&gt;<i> because browsers download the entire movie once playback starts, 
</I>&gt;<i> regardless of whether a user pauses the player. If throttling is used, 
</I>&gt;<i> it seems very conservative, which means a lot of unwatched video is in 
</I>&gt;<i> the buffer when a user unloads a video.
</I>&gt;<i> 
</I>&gt;<i> I did a simple test with a 10 minute video: playing it; pausing after 30 
</I>&gt;<i> seconds and checking download progress after another 30 seconds. With 
</I>&gt;<i> all browsers (Firefox 4, Safari 5, Chrome 8, Opera 11, iOS 4.2), the 
</I>&gt;<i> video would indeed be fully downloaded after 60 seconds. Some throttling 
</I>&gt;<i> seems to be applied by Safari / iOS, but this could also be bandwidth 
</I>&gt;<i> fluctuations on my side. Either way, all browsers downloaded the 10min 
</I>&gt;<i> video while only 30 seconds were being watched.
</I>&gt;<i> 
</I>&gt;<i> The HTML5 spec is a bit generic on this topic, allowing mechanisms such 
</I>&gt;<i> as stalling and throttling but not requiring them, or prescribing a 
</I>&gt;<i> scripting interface:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#concept-media-load-resource">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#concept-media-load-resource</A>
</I>
Right, this is an area that is left up to implementations; a quality of 
implementation issue.


&gt;<i> A suggestion would be to implement / expose a property called 
</I>&gt;<i> &quot;downloadBufferTarget&quot;. It would be the amount of video in seconds the 
</I>&gt;<i> browser tries to keep in the download buffer.
</I>
Wouldn't this be very situation-specific? e.g. if I know I'm about to go 
into a tunnel for five minutes, I want five minutes of buffered data. If 
my connection has a high packet loss rate and could stall for upwards of 
10 seconds, I want way more than 10 seconds in my buffer. If my connection 
is such that I can't download data in realtime, I want the whole video in 
my buffer. If my connection is such that I have 8ms latency to the video 
server and enough bandwidth to transfer the whole four hour file in 3 
seconds, then really I don't need anything in my buffer.


On Mon, 17 Jan 2011, Roger H&#229;gensen wrote:
&gt;<i> On 2011-01-17 18:36, Markus Ernst wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Could this be done at the user side, e.g. with some browser setting? 
</I>&gt;<i> &gt; Or even by a &quot;stop downloading&quot; control in the player? An intuitive 
</I>&gt;<i> &gt; user control would be separate stop and pause buttons, as we know them 
</I>&gt;<i> &gt; from tape and CD players. Pause would then behave as it does now, 
</I>&gt;<i> &gt; while stop would cancel downloading.
</I>&gt;<i> 
</I>&gt;<i> I think that's the right way to do it, this should be in the hands of 
</I>&gt;<i> the user and exposed as a preference in the browsers.
</I>
Agreed.


&gt;<i> Although exposing (read only?) the user's preferred buffer setting to 
</I>&gt;<i> the HTML App/Plugin etc. would be a benefit I guess as the desired 
</I>&gt;<i> buffering could be communicated back to the streaming server for example 
</I>&gt;<i> for a better bandwidth utilization.
</I>
How would the information be used?


On Mon, 17 Jan 2011, Zachary Ozer wrote:
&gt;<i>
</I>&gt;<i> What no one has mentioned so far is that the real issue isn't the 
</I>&gt;<i> network utilization or the memory capacity of the devices, it's 
</I>&gt;<i> bandwidth cost.
</I>&gt;<i> 
</I>&gt;<i> The big issue for publishers is that they're incurring higher costs when 
</I>&gt;<i> using the &lt;video&gt; tag, which is a disincentive for adoption.
</I>&gt;<i> 
</I>&gt;<i> Since there are situations where both the publisher and the user are 
</I>&gt;<i> potentially incurring bandwidth costs (or have other limitations), we 
</I>&gt;<i> could allow the publisher to specify downloadBufferTarget and the user 
</I>&gt;<i> to specify a setting in the browser's config. The browser would then 
</I>&gt;<i> actually buffer min(user setting, downloadBufferTarget). At that point 
</I>&gt;<i> there would probably need to be another read-only property that 
</I>&gt;<i> specified what value the browser is currently using as it's buffer 
</I>&gt;<i> length, but maybe the getter for downloadBufferTarget is sufficient.
</I>
I think before we get something that elaborate set up, we should just try 
getting preload=&quot;&quot; implemented. :-) That might be sufficent.


On Tue, 18 Jan 2011, Robert O'Callahan wrote:
&gt;<i>
</I>&gt;<i> One solution that could work here is to honour dynamic changes to 
</I>&gt;<i> 'preload', so switching preload to 'none' would stop buffering. Then a 
</I>&gt;<i> script could do that, for example, after the user has paused the video 
</I>&gt;<i> for ten seconds. The script could also look at 'buffered' to make its 
</I>&gt;<i> decision.
</I>
If browsers want to do that I'm quite happy to add something explicitly to 
that effect to the spec. Right now the spec doesn't disallow it.


On Wed, 19 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i>
</I>&gt;<i> The only difference between preload=none and preload=metadata is how 
</I>&gt;<i> much is fetched if the user doesn't interact at all with the video. Once 
</I>&gt;<i> the user has begun playing, I think the two mean the same thing: &quot;please 
</I>&gt;<i> don't waste my bandwidth more than necessary&quot;. In other words, I think 
</I>&gt;<i> that for preload=metadata, browsers should be somewhat conservative even 
</I>&gt;<i> after playback has begun, not going all the way to the preload=auto 
</I>&gt;<i> behavior.
</I>
The descriptions are somewhat loose, but something like this could work, 
yes. (Though I'd say after playing preload=metadata and preload=auto are 
the same and preload=none is the one that says to avoid bandwidth usage, 
but that's just an artifact of the way I wrote the descriptions.)


On Tue, 18 Jan 2011, Zachary Ozer wrote:
&gt;<i> 
</I>&gt;<i> Currently, there's no way to stop / limit the browser from buffering - 
</I>&gt;<i> once you hit play, you start downloading and don't stop until the 
</I>&gt;<i> resource is completely loaded. This is largely the same as Flash, save 
</I>&gt;<i> the fact that some browsers don't respect the preload attribute. (Side 
</I>&gt;<i> note: I also haven't found a browser that stops loading the resource 
</I>&gt;<i> even if you destroy the video tag.)
</I>&gt;<i> 
</I>&gt;<i> There have been a few suggestions for how to deal with this, but most 
</I>&gt;<i> have revolved around using downloadBufferTarget - a settable property 
</I>&gt;<i> that determines how much video to buffer ahead in seconds. Originally, 
</I>&gt;<i> it was suggested that the content producers should have control over 
</I>&gt;<i> this, but most seem to favor the client retaining some control since 
</I>&gt;<i> they are the most likely to be in low bandwidth situations. (Publishers 
</I>&gt;<i> who want strict bandwidth control could use a more advanced server and 
</I>&gt;<i> communication layer ala YouTube).
</I>&gt;<i> 
</I>&gt;<i> The simplest enhancement would be to honor the downloadBufferTarget only 
</I>&gt;<i> when readyState=HAVE_ENOUGH_DATA and playback is paused, as this would 
</I>&gt;<i> imply that there is not a low bandwidth situation.
</I>
It seems the simplest enhancement would be to have the browsers do the 
right thing (e.g. download enough to get to HAVE_ENOUGH_DATA and stop if 
the video is paused, or some such), not to add a feature that all Web 
authors would have to handle.


On Tue, 18 Jan 2011, Boris Zbarsky wrote:
&gt;<i> 
</I>&gt;<i> In general, depending on finalizers to release resources (which is 
</I>&gt;<i> what's happening here) is not really a workable setup.  Maybe we need an 
</I>&gt;<i> api to explicitly release the data on an audio/video tag?
</I>
The spec suggests removing the element's src=&quot;&quot; attribute and &lt;source&gt; 
elements and then calling the element's load() method.

The spec also suggests that implementors release all resources used by a 
media element when that media element is an orphan when the event loop 
spins.

See the &quot;Best practices for authors using media elements&quot; and &quot;Best 
practices for implementors of media elements&quot; sections.


On Wed, 19 Jan 2011, Andy Berkheimer wrote:
&gt;<i> 
</I>&gt;<i> In the case where the viewer does not have enough bandwidth to stream
</I>&gt;<i> the video in realtime, there are two basic options for the experience:
</I>&gt;<i> - buffer the majority of the video (per Glenn and Boris' discussion)
</I>&gt;<i> - switch to a lower bitrate that can be streamed in realtime
</I>&gt;<i> 
</I>&gt;<i> This thread has focused primarily of the first option and this is an 
</I>&gt;<i> experience that we see quite a bit.  This is the option favored amongst 
</I>&gt;<i> enthusiasts and power users, and also makes sense when a viewer has made 
</I>&gt;<i> a purchase with an expectation of quality.  And there's always the 
</I>&gt;<i> possibility that the user does not have enough bandwidth for even the 
</I>&gt;<i> lowest available bitrate.
</I>&gt;<i> 
</I>&gt;<i> But the second option is the experience that the majority of our viewers 
</I>&gt;<i> expect.
</I>&gt;<i> 
</I>&gt;<i> The ideal interface would have a reasonable default behavior but give an 
</I>&gt;<i> application the ability to implement either experience depending on user 
</I>&gt;<i> preference (or lack thereof), viewing context, etc.
</I>
Agreed. This is the kind of thing that a good streaming protocol can 
negotiate in realtime.


&gt;<i> I believe Chrome's current implementation _does_ stall the HTTP 
</I>&gt;<i> connection (stop reading from the socket interface but keep it open) 
</I>&gt;<i> after some amount of readahead - a magic hardcoded constant. We've run 
</I>&gt;<i> into issues there - their browser readahead buffer is too small and 
</I>&gt;<i> causing a lot of underruns.
</I>
It's early days. File bugs!


&gt;<i> No matter how much data you pass between client and server, there's 
</I>&gt;<i> always some useful playback state that the client knows and the server 
</I>&gt;<i> does not - or the server's view of the state is stale.  This is 
</I>&gt;<i> particularly true if there's an HTTP proxy between the user agent and 
</I>&gt;<i> the server.  Any behavior that could be implemented through an advanced 
</I>&gt;<i> server/communication layer can be achieved in a simpler, more robust 
</I>&gt;<i> fashion with a solid buffer management implementation that provides 
</I>&gt;<i> &quot;advanced&quot; control through javascript and attributes.
</I>
The main difference is that a protocol will typically be implemented a few 
times by experienced programmers writing servers and clients, which will 
then be deployed and used by less experienced (in this kind of thing) Web 
developers, while if we just expose it to JavaScript, the people 
implementing it will be a combination of experienced library authors and 
those same Web developers, and the result will likely be less successful.

However, the two aren't mutually exclusive. We could do one and then later 
(or at the same time) do the other.


On Tue, 18 Jan 2011, Roger H&#195;&#165;gensen wrote:
&gt;<i>
</I>&gt;<i> It may sound odd but in low storage space situations, it may be 
</I>&gt;<i> necessary to unbuffer what has been played. Is this supported at all 
</I>&gt;<i> currently?
</I>
Yes.


&gt;<i> I think that the buffering should basically be a &quot;moving window&quot; (I hope 
</I>&gt;<i> most here are familiar with this term?), and that the size of the moving 
</I>&gt;<i> window should be determined by storage space and bandwidth and browser 
</I>&gt;<i> preference and server preference, plus make sure the window supports 
</I>&gt;<i> skipping anywhere without needing to buffer up to it, and avoid 
</I>&gt;<i> buffering from the start just because the user skipped back a little to 
</I>&gt;<i> catch something they missed (another annoyance). This is the only 
</I>&gt;<i> logical way to do this really. Especially since HTTP 1.1 has byterange 
</I>&gt;<i> support there is nothing preventing it from being implemented, and I 
</I>&gt;<i> assume other popular streaming protocols supports byterange as well?
</I>
Implementations are allowed to do that.


On Tue, 18 Jan 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> I think that's indeed one obvious improvement, i.e. when going to pause 
</I>&gt;<i> stat, stop buffering when readyState=HAVE_ENOUGH_DATA (i.e. we have 
</I>&gt;<i> reached canplaythrough state).
</I>
The spec allows this already.


&gt;<i> However, again, I don't think that's sufficient. Because we will also 
</I>&gt;<i> buffer during playback and it is possible that we buffer fast enough to 
</I>&gt;<i> have buffered e.g. the whole of a 10min video by the time we hit pause 
</I>&gt;<i> after 1 min and stop watching. That's far beyond canplaythrough and 
</I>&gt;<i> that's 9min worth of video download wasted bandwidth. This is where the 
</I>&gt;<i> suggested downloadBufferTarget would make sense. It would basically 
</I>&gt;<i> specify how much more to download beyond HAVE_ENOUGH_DATA before pausing 
</I>&gt;<i> the download.
</I>
I don't understand how a site can know what the right value is for this. 
Users aren't going to understand that they have to control the buffering 
if (e.g.) they're about to go into a tunnel and they want to make sure 
it's buffered all the way through. It should just work, IMHO.


On Tue, 18 Jan 2011, David Singer wrote:
&gt;<i>
</I>&gt;<i> If you want a more tightly coupled supply/consume protocol, then use 
</I>&gt;<i> one.  As long as it's implemented by client and server, you're on.
</I>&gt;<i> 
</I>&gt;<i> Note that the current move of the web towards download in general and 
</I>&gt;<i> HTTP in particular is due in no small part to the fact that getting more 
</I>&gt;<i> tightly coupled protocols -- actually, any protocol other than HTTP -- 
</I>&gt;<i> out of content servers, across firewalls, through NATs, and into clients 
</I>&gt;<i> is...still a nightmare.  So, we've been given a strong incentive by all 
</I>&gt;<i> those to use HTTP.  It's sad that some of them are not happy with that 
</I>&gt;<i> result, but it's going to be hard to change now.
</I>
Agreed, though in practice there are certainly ways to get two-way 
protocols through. WebSocket does a pretty good job, for example. But 
designing a protocol for this is out of scope for this list, really.


On Tue, 18 Jan 2011, David Singer wrote:
&gt;<i> 
</I>&gt;<i> In RTSP-controlled RTP, there is a tight relationship between the play 
</I>&gt;<i> point, and play state, the protocol state (delivering data or paused) 
</I>&gt;<i> and the data delivered (it is delivered in precisely real-time, and 
</I>&gt;<i> played and discarded shortly after playing).  The server delivers very 
</I>&gt;<i> little more data than is actually watched.
</I>&gt;<i> 
</I>&gt;<i> In HTTP, however, the entire resource is offered to the client, and 
</I>&gt;<i> there is no protocol to convey play/paused back to the server, and the 
</I>&gt;<i> typical behavior when offered a resource in HTTP is to make a simple 
</I>&gt;<i> binary decision to either load it (all) or not load it (at all).  So, by 
</I>&gt;<i> providing a media resource over HTTP, the server should kinda be 
</I>&gt;<i> expecting this 'download' behavior.
</I>&gt;<i> 
</I>&gt;<i> Not only that, but if my client downloads as much as possible as soon as 
</I>&gt;<i> possible and caches as much as possible, and yours downloads as little 
</I>&gt;<i> as possible as late as possible, you may get brownie points from the 
</I>&gt;<i> server owner, but I get brownie points from my local user -- the person 
</I>&gt;<i> I want to please if I am a browser vendor.  There is every incentive to 
</I>&gt;<i> be resilient and 'burn' bandwidth to achieve a better user experience.
</I>&gt;<i> 
</I>&gt;<i> Servers are at liberty to apply a 'throttle' to the supply, of course 
</I>&gt;<i> (&quot;download as fast as you like at first, but after a while I'll only 
</I>&gt;<i> supply at roughly the media rate&quot;).  They can suggest that the client be 
</I>&gt;<i> a little less aggressive in buffering, but it's easily ignored and the 
</I>&gt;<i> incentive is to ignore it.
</I>&gt;<i> 
</I>&gt;<i> So I tend to return to &quot;if you want more tightly-coupled behavior, use a 
</I>&gt;<i> more tightly-coupled protocol&quot;...
</I>
Indeed.


On Wed, 19 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> The 3 preload states imply 3 simple buffering strategies:
</I>&gt;<i> 
</I>&gt;<i> none: don't touch the network at all
</I>&gt;<i> preload: buffer as little as possible while still reaching readyState
</I>&gt;<i> HAVE_METADATA
</I>&gt;<i> auto: buffer as fast and much as possible
</I>
&quot;auto&quot; isn't &quot;as fast and much as possible&quot;, it's &quot;as fast and much as 
will make the user happy&quot;. In some configurations, it might be the same as 
&quot;none&quot; (e.g. if the user is paying by the byte and hates video).


&gt;<i> However, the state we're discussing is when the user has begun playing the
</I>&gt;<i> video. The spec doesn't talk about it, but I call it:
</I>&gt;<i> 
</I>&gt;<i> invoked: buffer as little as possible without readyState dropping below
</I>&gt;<i> HAVE_FUTURE_DATA (in other words: being able to play from currentTime to
</I>&gt;<i> duration at playbackRate without waiting for the network)
</I>
There's also a fifth state, let's call it &quot;aggressive&quot;, where even while 
playing the video the UA is trying to download the whole thing in case the 
connection drops.


&gt;<i> If the available bandwidth exceeds the bandwidth of the resource, some 
</I>&gt;<i> kind of throttling must eventually be used. There are mainly 2 options 
</I>&gt;<i> for doing this:
</I>&gt;<i> 
</I>&gt;<i> 1. Throttle at the TCP level by not reading data from the socket (not at all
</I>&gt;<i> to suspend, or at a controlled rate to buffer ahead)
</I>&gt;<i> 2. Use HTTP byte ranges, making many smaller requests with any kind of
</I>&gt;<i> throttling at the TCP level
</I>
There's also option 3, to handle the fifth state above: don't throttle.


&gt;<i> When HTTP byte ranges are used to achieve bandwidth management, it's 
</I>&gt;<i> hard to talk about a single downloadBufferTarget that is the number of 
</I>&gt;<i> seconds buffered ahead. Rather, there might be an upper and lower limit 
</I>&gt;<i> within which the browser tries to stay, so that each request can be of a 
</I>&gt;<i> reasonable size. Neither an author-provided minumum or maximum value can 
</I>&gt;<i> be followed particularly closely, but could possibly be taken as a hint 
</I>&gt;<i> of some sort.
</I>
Would it be a more useful hint than &quot;preload&quot;? I'm skeptical about adding 
many hints with no requirements. If there's some specific further 
information we can add, though, it might make sense to add more features 
to &quot;preload&quot;.


&gt;<i> The above buffering strategies are still not enough, because users seem 
</I>&gt;<i> to expect that in a low-bandwidth situation, the video will keep 
</I>&gt;<i> buffering until they can watch it through to the end. These seem to be 
</I>&gt;<i> the options for solving the problem:
</I>&gt;<i> 
</I>&gt;<i> * Make sites that want this behavior set .preload='auto' in the 'paused' 
</I>&gt;<i> event handler
</I>&gt;<i>
</I>&gt;<i> * Add an option in the context menu to &quot;Preload Video&quot; or some such
</I>&gt;<i>
</I>&gt;<i> * Cause an invoked (see dfn above) but paused video to behave like 
</I>&gt;<i> preload=auto
</I>&gt;<i>
</I>&gt;<i> * As above, but only when the available bandwidth is limited
</I>&gt;<i> 
</I>&gt;<i> I don't think any of these solutions are particularly good, so any input 
</I>&gt;<i> on other options is very welcome!
</I>
If users expect something, it seems logical that it should just happen. I 
don't have a problem with saying that it should depend on preload=&quot;&quot;, 
though. If you like I can make the spec explicitly describe what the 
preload=&quot;&quot; hints mean while video is playing, too.


On Wed, 19 Jan 2011, Zachary Ozer wrote:
&gt;<i> 
</I>&gt;<i> What if, instead of trying to solve this problem, we leave it up to the 
</I>&gt;<i> publishers. The current behavior would be unchanged, but we could add 
</I>&gt;<i> explicit bandwidth management API calls, ie startBuffer() and 
</I>&gt;<i> stopBuffer(). This would let developers / site publishers control how 
</I>&gt;<i> much to buffer and when.
</I>
We couldn't depend on it (most people presumably won't want to do anything 
but give the src=&quot;&quot; of their video).


&gt;<i> We might also consider leaning on users a bit to tell us what they want. 
</I>&gt;<i> For example, I think people are pretty used to hitting play and then 
</I>&gt;<i> pause to buffer until the end of the video. What if we just used our 
</I>&gt;<i> bandwidth heuristics while in the play state, and buffered blindly when 
</I>&gt;<i> a pause occurs less than X seconds into a video? I won't argue that this 
</I>&gt;<i> is a wonderful solution (or a habit we should encourage), but I figured 
</I>&gt;<i> I'd throw a random idea out there&#226;&#128;&#166;
</I>
That seems like pretty ugly UI. :-)


On Thu, 20 Jan 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> I think that pausing shouldn't affect read-ahead buffering behavior.  
</I>&gt;<i> I'd suggest another preload value, preload=buffer, sitting between 
</I>&gt;<i> &quot;metadata&quot; and &quot;auto&quot;.  In addition to everything loaded by &quot;metadata&quot;, 
</I>&gt;<i> it also fills the read-ahead buffer (whether the video is playing or 
</I>&gt;<i> not).
</I>&gt;<i> 
</I>&gt;<i> - If a page wants prebuffering only (not full preloading), it sets 
</I>&gt;<i> preload=buffer.  This can be done even when the video is paused, so when 
</I>&gt;<i> the user presses play, the video starts instantly without pausing for a 
</I>&gt;<i> server round-trip like preload=metadata.
</I>
So this would be to buffer enough to play through assuming the network 
remains at the current bandwidth, but no more?


&gt;<i> - If a page wants prebuffering while playing, but unlimited buffering when
</I>&gt;<i> paused (per Zachary's suggestion), it sets preload=buffer when playing and
</I>&gt;<i> preload=auto when paused.
</I>
Again, note that &quot;auto&quot; doesn't mean &quot;buffer everything&quot;, it means &quot;do 
whatever is best for the user&quot;.

I don't mind adding new values if the browser vendors are going to use 
them.


On Sat, 22 Jan 2011, David Singer wrote:
&gt;<i>
</I>&gt;<i> When the HTML5 states were first proposed, I went through a careful 
</I>&gt;<i> exercise to make sure that they were reasonably delivery-technology 
</I>&gt;<i> neutral, i.e. that they applied equally well if say RTSP/RTP was used, 
</I>&gt;<i> some kind of dynamic streaming, simple HTTP, and so on.
</I>&gt;<i> 
</I>&gt;<i> I am concerned that we all tend to assume that HTML==HTTP, but the 
</I>&gt;<i> source URL for the media might have any protocol type, and the HTML 
</I>&gt;<i> attributes, states etc. should apply (or clearly not apply) to anything.
</I>&gt;<i> 
</I>&gt;<i> Assuming only HTTP, in the markup, is not a good direction.
</I>
Agreed.


On Thu, 20 Jan 2011, Matthew Gregan wrote:
&gt;<i> 
</I>&gt;<i> The media seek algorithm (4.8.10.9) states that the current playback 
</I>&gt;<i> position should be set to the new playback position during the 
</I>&gt;<i> asynchronous part of the algorithm, just before the seeking event is 
</I>&gt;<i> fired. [...]
</I>
On Thu, 20 Jan 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> There have been two non-trivial changes to the seeking algorithm in the 
</I>&gt;<i> last year:
</I>&gt;<i> 
</I>&gt;<i> Discussed at <A HREF="http://lists.w3.org/Archives/Public/public-html/2010Feb/0003.html">http://lists.w3.org/Archives/Public/public-html/2010Feb/0003.html</A>
</I>&gt;<i> lead to <A HREF="http://html5.org/r/4868">http://html5.org/r/4868</A>
</I>&gt;<i> 
</I>&gt;<i> Discussed at <A HREF="http://lists.w3.org/Archives/Public/public-html/2010Jul/0217.html">http://lists.w3.org/Archives/Public/public-html/2010Jul/0217.html</A>
</I>&gt;<i> lead to <A HREF="http://html5.org/r/5219">http://html5.org/r/5219</A>
</I>
Yeah. In particular, sometimes there's no way for the UA to know 
asynchronously if the seek can be done, which is why the attribute is set 
after the method returns. It's not ideal, but the alternative is not 
always implementable.


&gt;<i> With that said, it seems like there's nothing that guarantees that the 
</I>&gt;<i> asynchronous section doesn't start running while the script is still 
</I>&gt;<i> running.
</I>
Yeah. It's not ideal, but I don't really see what we can do about it.


&gt;<i> It's also odd that currentTime is updated before the seek has actually 
</I>&gt;<i> been completed, but the reason for this is that the UI should show the 
</I>&gt;<i> new position.
</I>
Not just the UI. The current position is what the browser is trying to 
play; if the current position didn't move, then the browser wouldn't be 
trying to play it.


On Fri, 4 Feb 2011, Matthew Gregan wrote:
&gt;<i> 
</I>&gt;<i> For anyone following along, the behaviour has now been changed in the 
</I>&gt;<i> Firefox 4 nightly builds.
</I>
On Mon, 24 Jan 2011, Robert O'Callahan wrote:
&gt;<i> 
</I>&gt;<i> I agree. I think we should change behavior to match author expectations 
</I>&gt;<i> and the other implementations, and let the spec change to match.
</I>
How do you handle the cases where it's not possible?


If all the browsers can do it, I'm all for going back to having 
currentTime change synchronosuly.


On Sat, 29 Jan 2011, Lubomir Toshev wrote:
&gt;<i> 
</I>&gt;<i> [W]hen the video tag has embedded browser controls displayed and I click 
</I>&gt;<i> anywhere on the controls, they cause a video tag click event. If I want 
</I>&gt;<i> to toggle play/pause on video area click, then I cannot do this, because 
</I>&gt;<i> clicking on the play control button, fires play, then click event fires 
</I>&gt;<i> for video tag and when I toggle It pauses. So this behavior that every 
</I>&gt;<i> popular flash player has cannot be achieved. There is no way to 
</I>&gt;<i> understand that the click.target is the embedded browser controls area. 
</I>&gt;<i> I think that a nice improvement will be to expose this information, in 
</I>&gt;<i> the target, that it actually is embedded browser controls. Or clicking 
</I>&gt;<i> the embedded browser controls should not produce a click event for video 
</I>&gt;<i> tag. After all browser controls are native and do not have 
</I>&gt;<i> representation in the DOM. Let me know what do you think about this?
</I>
On Sat, 29 Jan 2011, Aryeh Gregor wrote:
&gt;<i> 
</I>&gt;<i> Well, to begin with, you could just use your own controls rather than 
</I>&gt;<i> the browser's built-in controls.  Then you have no problem.  If you're 
</I>&gt;<i> using the browser's built-in controls, maybe you should stick with the 
</I>&gt;<i> browser's control conventions throughout, which presumably doesn't 
</I>&gt;<i> include toggling play/pause on click.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure this is a broad enough problem to warrant exposing the 
</I>&gt;<i> extra information in the target.  Are there any other use-cases for such 
</I>&gt;<i> info?
</I>
On Sun, 30 Jan 2011, Lubomir Toshev wrote:
&gt;<i>
</I>&gt;<i> To elaborate a bit, I'm a control developer and I have my own custom 
</I>&gt;<i> controls. But we want to allow for the customer to use the default 
</I>&gt;<i> browser controls if they want to. This can be done by switching an 
</I>&gt;<i> option in my jQuery widget - browserControls - true/false. Or through 
</I>&gt;<i> browser context menu shown by default on right click. So I'm trying to 
</I>&gt;<i> be flexible enough for the customer.
</I>&gt;<i> 
</I>&gt;<i> I was thinking about this
</I>&gt;<i> 1) that adding a transparent overlay over the browser controls 
</I>&gt;<i> Or
</I>&gt;<i> 2) to detect the click position and if it is some pixels away from the 
</I>&gt;<i> bottom of the video tag
</I>&gt;<i> 
</I>&gt;<i> will fix this, but every browser has different height for its embedded 
</I>&gt;<i> controls and I should hardcode this height in my code, which is just not 
</I>&gt;<i> manageable.
</I>&gt;<i> 
</I>&gt;<i> I can always add a limitation when using browser controls, toggle 
</I>&gt;<i> play/pause on video area click will be turned off, but I want to achieve 
</I>&gt;<i> similar behavior in all the browsers no matter whether they use embedded 
</I>&gt;<i> controls or not.
</I>&gt;<i> 
</I>&gt;<i> So I think this tiny click.target thing will be very useful.
</I>
On Sun, 30 Jan 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> Even as a bad hack it's simply not possible; for example, there's no way 
</I>&gt;<i> to tell whether a pop-out volume control is open or not.
</I>&gt;<i> 
</I>&gt;<i> I think the primary use case browser controls are meant for is when 
</I>&gt;<i> scripting isn't available at all.  They aren't very useful when you're 
</I>&gt;<i> using any kind of scripts with the video.  Another problem, related to 
</I>&gt;<i> your other post about captioning, is that it's impossible to put 
</I>&gt;<i> anything between the video and the controls, so your captions will draw 
</I>&gt;<i> *on top of* browser controls.
</I>
On Mon, 31 Jan 2011, Simon Pieters wrote:
&gt;<i> 
</I>&gt;<i> See <A HREF="http://lists.w3.org/Archives/Public/public-html/2009Jun/0395.html">http://lists.w3.org/Archives/Public/public-html/2009Jun/0395.html</A>
</I>&gt;<i> 
</I>&gt;<i> I suggested that the browser would not generate an event at all when 
</I>&gt;<i> using the native controls. Seemingly there was no reply to Hixie's 
</I>&gt;<i> request for opinion from other implementors.
</I>
On Mon, 31 Jan 2011, Glenn Maynard wrote:
&gt;<i>
</I>&gt;<i> There are other meaningful ways to respond to these events; for example, 
</I>&gt;<i> to pull its container to the top of the draw order if it's a floating 
</I>&gt;<i> window. I should be able to capture mousedown on the container to do 
</I>&gt;<i> this, regardless of content.
</I>
On Mon, 31 Jan 2011, Simon Pieters wrote:
&gt;<i> 
</I>&gt;<i> How about just suppressing activation events like click?
</I>
On Mon, 31 Jan 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> That makes more sense than suppressing the entire mousedown/mouseup 
</I>&gt;<i> events (and keydown, touchstart, etc).
</I>&gt;<i> 
</I>&gt;<i> Also, it means you can completely emulate the event behavior of the 
</I>&gt;<i> default browser controls with scripts: preventDefault on mousedown to 
</I>&gt;<i> prevent click events.  That's probably not what you actually want to do, 
</I>&gt;<i> but it means the default controls aren't doing anything special: their 
</I>&gt;<i> effect on events can be understood entirely in terms of what scripted 
</I>&gt;<i> events can already do.
</I>
On Mon, 31 Jan 2011, Lubomir Toshev wrote:
&gt;<i>
</I>&gt;<i> I totally agree that events should not be raised, when they originate 
</I>&gt;<i> from the native browser controls. This would make it much simpler. I 
</I>&gt;<i> filed the same bug for Opera 11 last week.
</I>
As with the post Simon cites above, I'm happy to do this kind of thing, if 
multiple vendors agree that it makes sense. If you would like this to be 
done, I recommend getting other browser vendors to tell me it sounds good!


On Sat, 29 Jan 2011, Lubomir Toshev wrote:
&gt;<i> 
</I>&gt;<i> [V]ideo should expose API for currentFrame, so that when control 
</I>&gt;<i> developers want to add support for subtitles on their own, to be able to 
</I>&gt;<i> support formats that display the subtitles according to the current 
</I>&gt;<i> video frame. This is a limitation to the current design of the video 
</I>&gt;<i> tag.
</I>
On Sun, 30 Jan 2011, Lubomir Toshev wrote:
&gt;<i>
</I>&gt;<i> We were trying to add support for subtitles for our player control that 
</I>&gt;<i> uses video tag as its base. There are two popular subtitle formats *.srt 
</I>&gt;<i> which uses currentTime to show the subtitles where they should be. Like 
</I>&gt;<i> 0:01:00 - 0:01:30 - &quot;What a nice hotel.&quot; While the other popular format 
</I>&gt;<i> is *.sub which uses the currentFrame to show the proper subtitles. Like 
</I>&gt;<i> {45600}, {45689} - &quot;What a nice hotel&quot;. And if I want to add this 
</I>&gt;<i> support it would be good if video tag exposes currentFrame, so that I 
</I>&gt;<i> can show properly the subtitles in a span positioned over the video. Now 
</I>&gt;<i> does it make more sense?
</I>&gt;<i> 
</I>&gt;<i> I know video will have embedded subtitle support, but I think that it 
</I>&gt;<i> should be flexible enough to allow building such features like the one 
</I>&gt;<i> above. What do you think? To me this is worth adding because, it should 
</I>&gt;<i> be really easy to implement?
</I>
We'll probably add that along with the metrics, when we add those, if 
there's a strong use case for it. I'm not sure that supporting frame-based 
subtitles is a good use case though.


On Mon, 14 Feb 2011, David Flanagan wrote:
&gt;<i>
</I>&gt;<i> The draft specification defines 20+ medial event handler IDL attributes 
</I>&gt;<i> on HTMLElement.  These events are non-bubbling and are always targeted 
</I>&gt;<i> at &lt;audio&gt; and &lt;video&gt; tags, so I wonder if they wouldn't be better 
</I>&gt;<i> defined on HTMLMediaElement instead.
</I>
All event handlers are on HTMLElement, to make implementations easier and 
to make it the platform simpler.


On Tue, 15 Feb 2011, David Flanagan wrote:
&gt;<i> 
</I>&gt;<i> Fair enough, though I do think it will confuse developers who will think 
</I>&gt;<i> that those media events bubble.  (I'll be documenting them as properties 
</I>&gt;<i> of HTMLMediaElement).
</I>
Whether an event bubbles or not is up to the place that dispatches the 
event, not the place that hears the event.


&gt;<i> What about Document and Window?  What's the justification for defining 
</I>&gt;<i> the media event handler attributes on those objects?
</I>
Same. It allows the same logic to be used everywhere.


On Mon, 14 Feb 2011, Kevin Marks wrote:
&gt;<i> On Mon, Feb 14, 2011 at 2:39 PM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; On Fri, 19 Nov 2010, Per-Erik Brodin wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; We are about to start implementing stream.record() and 
</I>&gt;<i> &gt; &gt; StreamRecorder. The spec currently says that &#226;&#128;&#156;the file must be in 
</I>&gt;<i> &gt; &gt; a format supported by the user agent for use in audio and video 
</I>&gt;<i> &gt; &gt; elements&#226;&#128;&#157; which is a reasonable restriction. However, there is 
</I>&gt;<i> &gt; &gt; currently no way to set the output format of the resulting File that 
</I>&gt;<i> &gt; &gt; you get from recorder.stop(). It is unlikely that specifying a 
</I>&gt;<i> &gt; &gt; default format would be sufficient if you in addition to container 
</I>&gt;<i> &gt; &gt; formats and codecs consider resolution, color depth, frame rate etc. 
</I>&gt;<i> &gt; &gt; for video and sample size and rate, number of channels etc. for 
</I>&gt;<i> &gt; &gt; audio.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Perhaps an argument should be added to record() that specifies the 
</I>&gt;<i> &gt; &gt; output format from StreamRecorder as a MIME type with parameters? 
</I>&gt;<i> &gt; &gt; Since record() should probably throw when an unsupported type is 
</I>&gt;<i> &gt; &gt; supplied, it would perhaps be useful to have a canRecordType() or 
</I>&gt;<i> &gt; &gt; similar to be able to test for supported formats.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I haven't added anything here yet, mostly because I've no idea what to 
</I>&gt;<i> &gt; add. The ideal situation here is that we have one codec that everyone 
</I>&gt;<i> &gt; can read and write and so don't need anything, but that may be 
</I>&gt;<i> &gt; hopelessly optimistic.
</I>&gt;<i> 
</I>&gt;<i> That isn't the ideal, as it locks us into the current state of the art 
</I>&gt;<i> forever. The ideal is to enable multiple codecs +formats that can be 
</I>&gt;<i> swapped out over time. That said, uncompressed audio is readily 
</I>&gt;<i> codifiable, and we could pick a common file format, sample rate, 
</I>&gt;<i> bitdepth and channel caount specification.
</I>
It doesn't lock us in to one format, we can always add more formats later. 
Right now, we have zero formats, so one format would be a huge step up.


On Fri, 4 Mar 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> On Thu, 03 Mar 2011 22:15:58 +0100, Aaron Colwell &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">acolwell at google.com</A>&gt; 
</I>&gt;<i> wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I was looking at the resource fetch 
</I>&gt;<i> &gt; algorithm&lt;<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#concept-media-load-resource">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#concept-media-load-resource</A>&gt;section 
</I>&gt;<i> &gt; and fetching resources 
</I>&gt;<i> &gt; &lt;<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#fetch">http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#fetch</A>&gt; 
</I>&gt;<i> &gt; sections of the HTML5 spec to determine what the proper behavior is 
</I>&gt;<i> &gt; for handling redirects. Both YouTube and Vimeo do 302 redirects to 
</I>&gt;<i> &gt; different hostnames from the URLs specified in the src attribute. It 
</I>&gt;<i> &gt; looks like the spec says that playback should fail in these cases 
</I>&gt;<i> &gt; because they are from different origins (Section 2.7 Fetching 
</I>&gt;<i> &gt; resources bullet 7). This leads me to a few questions.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 1. Is my interpretation of the spec correct? Sample YouTube &amp; Vimeo URLs are
</I>&gt;<i> &gt;   shown below.
</I>&gt;<i> &gt;   YouTube : src      : <A HREF="http://v22.lscache6.c.youtube.com/videoplayback?">http://v22.lscache6.c.youtube.com/videoplayback?</A> ...
</I>&gt;<i> &gt;             redirect : <A HREF="http://tc.v22.cache6.c.youtube.com/videoplayback?">http://tc.v22.cache6.c.youtube.com/videoplayback?</A>
</I>&gt;<i> &gt; ...
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;   Vimeo   : src      : <A HREF="http://player.vimeo.com/play_redirect?">http://player.vimeo.com/play_redirect?</A> ...
</I>&gt;<i> &gt;             redirect : <A HREF="http://av.vimeo.com/05">http://av.vimeo.com/05</A> ...
</I>&gt;<i> 
</I>&gt;<i> Yes, from what I can tell you're correct, but I think it's not 
</I>&gt;<i> intentional. The behavior was changed by &lt;<A HREF="http://html5.org/r/5111">http://html5.org/r/5111</A>&gt; in 
</I>&gt;<i> 2010-06-25, and this is the first time I've noticed it. Opera (and I 
</I>&gt;<i> assume most if not all other browsers) already supports HTTP redirects 
</I>&gt;<i> for &lt;video&gt; and I don't think it makes much sense to disallow it. For 
</I>&gt;<i> security purposes, the origin of the resource is considered to be the 
</I>&gt;<i> final destination, not any of the origins in the redirect chain.
</I>
This was fixed recently.


On Fri, 18 Mar 2011, Eric Winkelman wrote:
&gt;<i> 
</I>&gt;<i> For in-band metadata tracks, there is neither a standard way to 
</I>&gt;<i> represent the type of metadata in the HTMLTrackElement interface nor is 
</I>&gt;<i> there a standard way to represent multiple different types of metadata 
</I>&gt;<i> tracks.
</I>
There can be a standard way. The idea is that all the types of metadata 
tracks that browsers will support should be specified so that all browsers 
can map them the same way. I'm happy to work with anyone interested in 
writing such a mapping spec, just let me know.


&gt;<i> Proposal:
</I>&gt;<i> 
</I>&gt;<i> For TimedTextTracks with kind=metadata the @label attribute should 
</I>&gt;<i> contain a MIME type for the metadata and that a track only contain Cues 
</I>&gt;<i> created from metadata of that MIME type.
</I>&gt;<i> 
</I>&gt;<i> This implies that streams with multiple types of metadata require the 
</I>&gt;<i> creation of multiple metadata track objects, one for each MIME type.
</I>
This might make sense if we had a defined way of getting such a MIME type 
(and assuming you're talking about the IDL attributes, not the content 
attributes).


On Tue, 22 Mar 2011, Eric Winkelman wrote:
&gt;<i> 
</I>&gt;<i> Ah, yes, now I understand the confusion.  Within the whatwg specs, the 
</I>&gt;<i> word &quot;attribute&quot; is generally used and I was trying to be consistent.
</I>
The WHATWG specs refer to content attributes (those on elements) and IDL 
attributes (those on objects, which generate properties in JS). The @foo 
syntax is never used in the WHATWG specs. It's usually used in a W3C 
context just to refer to content attributes, by analogy to the XPath 
syntax. (Personally I prefer foo=&quot;&quot; since it's less ambiguous.)


On Mon, 21 Mar 2011, Eric Winkelman wrote:
&gt;<i> 
</I>&gt;<i> No, I'm not saying that, but as far as I can tell from the spec, it is 
</I>&gt;<i> undefined how the user agent should map in-band data to metadata tracks.  
</I>&gt;<i> I am proposing that the algorithm should be that different types of data 
</I>&gt;<i> should go into different Timed Text Tracks, and that the track's @label 
</I>&gt;<i> should reflect the type.
</I>
To the extent that it is defined, it is defined here:

   <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete.html#sourcing-in-band-text-tracks">http://www.whatwg.org/specs/web-apps/current-work/complete.html#sourcing-in-band-text-tracks</A>

But the theory, as mentioned above, is that specific types of in-band 
metadata tracks would have explicit specs written to define how the 
mapping is done.


&gt;<i> Recent updates to the spec, section 4.8.10.12.2 
</I>&gt;<i> (<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#sourcing-in-band-text-tracks">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#sourcing-in-band-text-tracks</A>) 
</I>&gt;<i> appear to address my concern in step 2:
</I>&gt;<i> 
</I>&gt;<i> &quot;2.  Set the new text track's kind, label, and language based on the 
</I>&gt;<i> semantics of the relevant data, as defined by the relevant 
</I>&gt;<i> specification.&quot;
</I>&gt;<i> 
</I>&gt;<i> Provided that the relevant specification defines the metadata type 
</I>&gt;<i> encoding to be put in the label, e.g. application/x-eiss, 
</I>&gt;<i> application/x-scte35, application/x-contentadvisory, etc.
</I>
Well the problem is that there typically is no applicable specification, 
or that it is too vague.


On Tue, 22 Mar 2011, Lachlan Hunt wrote:
&gt;<i>
</I>&gt;<i> This is regarding the recently added audioTracks and videoTracks APIs to 
</I>&gt;<i> the HTMLMediaElement.
</I>&gt;<i> 
</I>&gt;<i> The design of these APIs seems to be done a little strangely, in that 
</I>&gt;<i> dealing with each track is done by passing an index to each method on 
</I>&gt;<i> the TrackList interfaces, rather than treating the audioTracks and 
</I>&gt;<i> videoTracks as collections of individual audio/video track objects. This 
</I>&gt;<i> design is inconsistent with the design of the TextTrack interface, and 
</I>&gt;<i> seems sub-optimal.
</I>
It is intended to avoid an explosion of objects. TextTrack needs to be an 
object because it has separate state, gets targetted for events, has 
different versions (e.g. MutableTextTrack), etc. Audio and Video tracks 
are, on the other hand, rather trivial constructs.


&gt;<i> The use of ExclusiveTrackList for videoTracks also seems rather 
</I>&gt;<i> limiting. What about cases where the second video track is a 
</I>&gt;<i> sign-language track, or some other video overlay.
</I>
You use a separate &lt;video&gt; element.

I considered this in some depth. The main problem is that you end up 
having to define a layout mechanism for videos if you allow multiple 
videos to be enabled from script (e.g. consider what the behaviour should 
be if you enable the main video, then the PiP sign language video, then 
disable the main video. What is the intrinsic dimension of the &lt;video&gt; 
element? Does it matter if you do it in a different order?).

By making &lt;video&gt; be a single video's output layer, we can bypass many of 
these problems without removing expressibility (the author can still 
support multiple PiP videos).


&gt;<i> There are also the use cases for controlling the volume of individual 
</I>&gt;<i> tracks that are not addressed by the current spec design.
</I>
Can you elaborate on these use cases?

My assumption has been that on the long term, i you want to manipulate 
specific audio tracks, you would use an &lt;audio&gt; element and plug it into 
the Audio API for separate processing.


On Sat, 2 Apr 2011, Bruce Lawson wrote:
&gt;<i>
</I>&gt;<i> From a comment in a blog post of mine about longdesc 
</I>&gt;<i> (<A HREF="http://www.brucelawson.co.uk/2011/longdesc-in-html5/comment-page-1/#comment-749853">http://www.brucelawson.co.uk/2011/longdesc-in-html5/comment-page-1/#comment-749853</A>) 
</I>&gt;<i> I'm wondering if this is an appropriate used of &lt;details&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;details&gt;
</I>&gt;<i>   &lt;summary&gt;
</I>&gt;<i>   &lt;img src=chart.png alt=&quot;Graph of percentage of total U.S.
</I>&gt;<i> non-institutionalized population age 16-64 declaring one or more
</I>&gt;<i> disabilities&quot;&gt;
</I>&gt;<i>   &lt;/summary&gt;
</I>&gt;<i> &lt;p&gt;The bar graph shows the percentage of total U.S. noninsitutionalized
</I>&gt;<i> population age 16-64 declaring one or more disabilities. The percentage
</I>&gt;<i> value for each category is as follows:&lt;/p&gt;
</I>&gt;<i> 				&lt;ul&gt;
</I>&gt;<i> 					&lt;li&gt;Total declaring one or more
</I>&gt;<i> disabilities: 18.6 percent &lt;/li&gt;
</I>&gt;<i> 					&lt;li&gt;Sensory (visual and hearing): 2.3
</I>&gt;<i> percent&lt;/li&gt;
</I>&gt;<i> 					&lt;li&gt;Physical: 6.2 percent&lt;/li&gt;
</I>&gt;<i> 					&lt;li&gt;Mental: 3.8 percent&lt;/li&gt;
</I>&gt;<i> 					&lt;li&gt;Self-care: 1.8 percent&lt;/li&gt;
</I>&gt;<i> 					&lt;li&gt;Diffuculty going outside the home:
</I>&gt;<i> 6.4 percent&lt;/li&gt;
</I>&gt;<i> 					&lt;li&gt;Employment disability: 11.9
</I>&gt;<i> percent&lt;/li&gt;
</I>&gt;<i> 				&lt;/ul&gt;
</I>&gt;<i> 				&lt;p&gt;data retrieved from &lt;a
</I>&gt;<i> href=&quot;<A HREF="http://www.census.gov/prod/2003pubs/c2kbr-17.pdf">http://www.census.gov/prod/2003pubs/c2kbr-17.pdf</A>&quot; title=&quot;Link to
</I>&gt;<i> External Site&quot; class=&quot;external&quot;&gt;2000 U.S. Census&lt;span&gt; -
</I>&gt;<i>          external link&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</I>&gt;<i> &lt;/details&gt;
</I>&gt;<i> 
</I>&gt;<i> .. thereby acting as a discoverable-by-anyone longdesc. (The example is
</I>&gt;<i> adapted from the longdesc example at
</I>&gt;<i> <A HREF="http://webaim.org/techniques/images/longdesc#longdesc">http://webaim.org/techniques/images/longdesc#longdesc</A>)
</I>&gt;<i> 
</I>&gt;<i> Note to grumpy people: I'm not trying to advocate abolishing longdesc,
</I>&gt;<i> just seeeing whether details can be used as an alternative.
</I>
It's a bit weird, but sure.

(Well, except for your alt=&quot;&quot; text, which is a title=&quot;&quot;, not an alt=&quot;&quot;.)


On Sat, 2 Apr 2011, John Foliot wrote:
&gt;<i> 
</I>&gt;<i> Interesting question. Referring to the spec, I think that you may have 
</I>&gt;<i> in fact uncovered a bug in the text. The spec states:
</I>&gt;<i> 
</I>&gt;<i> 	&quot;The user agent should allow the user to request that the details 
</I>&gt;<i> be shown or hidden.&quot;
</I>&gt;<i> 
</I>&gt;<i> The problem (or potential problem) here is that the behaviour is defined 
</I>&gt;<i> in visual terms -
</I>
The spec explicitly says that these terms have non-visual meaning.


On Mon, 4 Apr 2011, Bjartur Thorlacius wrote:
&gt;<i>
</I>&gt;<i> IMO, the specification of the &lt;details&gt; element is overly focused on 
</I>&gt;<i> expected renderings. Rather than explicitly defining the semantics of 
</I>&gt;<i> &lt;details&gt; with or without an @open attribute, and with or without a 
</I>&gt;<i> &lt;summary&gt; child, sane renderings for medium to large displays whith whom 
</I>&gt;<i> the user can interact are described, and usage is to be inferred 
</I>&gt;<i> therefrom. This is suboptimal, as it allows hiding &lt;details open&gt;s on 
</I>&gt;<i> small output windows but shoulds against it as strongly as ignoring 
</I>&gt;<i> addition of the open attribute. Note that the &lt;details&gt; element 
</I>&gt;<i> represents a disclosure widget, but the contents are nowhere defined 
</I>&gt;<i> (neither as additional information (that a user-agent may or may not 
</I>&gt;<i> render, depending on factors such as scarcity of screen estate), nor as 
</I>&gt;<i> spoiling information that shouldn't be provided to the user without 
</I>&gt;<i> explicit consent). I regard the two different use cases as different, 
</I>&gt;<i> even though vendors might implement both with { binding: details; } on 
</I>&gt;<i> some media. &lt;Details&gt; can't serve both. It's often spoken of as if 
</I>&gt;<i> intended for something else than the YouTube video description use case. 
</I>&gt;<i> &lt;Details&gt; mustn't be used for hiding spoilers, or else browsers won't be 
</I>&gt;<i> able to intelligently choose to render the would-be concealed contents.
</I>
I've clarified &lt;details&gt; to be better defined in this respect. I hope it 
addresses your concern.


On Fri, 22 Apr 2011, Dimitri Glazkov wrote:
&gt;<i>
</I>&gt;<i> I wonder if it makes sense to introduce a set of pseudo-classes on the 
</I>&gt;<i> video/audio elements, each reflecting a state of the media on the 
</I>&gt;<i> controls (playing/paused/error/etc.)? Then, we could use just CSS to 
</I>&gt;<i> style media controls (whether native or custom), and not have to listen 
</I>&gt;<i> to DOM events just to tweak their appearance.
</I>
On Sat, 23 Apr 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> With a sufficiently large set of pseudo-classes it might be possible to 
</I>&gt;<i> do *display* most of the interesting state, but how would you *change* 
</I>&gt;<i> the state without using scripts? Play/pause, seek, volume, etc...
</I>
On Sat, 23 Apr 2011, Dimitri Glazkov wrote:
&gt;<i> 
</I>&gt;<i> This is not the goal of using pseudo-classes: they just provide you with 
</I>&gt;<i> a uniform way to react to changes.
</I>
On Sat, 23 Apr 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> In other words, one would still have to rely heavily on scripts to 
</I>&gt;<i> actually implement custom controls?
</I>&gt;<i> 
</I>&gt;<i> Also, how would one style a progress bar using pseudo-classes? How about 
</I>&gt;<i> a displaying elapsed/remaining time on the form MM:SS?
</I>
On Sat, 23 Apr 2011, Dimitri Glazkov wrote:
&gt;<i> 
</I>&gt;<i> I am not in any way trying to invent a magical way to style media 
</I>&gt;<i> controls entirely in CSS. Just trying to make the job of controls 
</I>&gt;<i> developers easier and use CSS where it's well... useful? :)
</I>
On Sat, 23 Apr 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> Very well, what specific set pseudo-classes do you think would be 
</I>&gt;<i> useful?
</I>
On Sat, 23 Apr 2011, Dimitri Glazkov wrote:
&gt;<i> 
</I>&gt;<i> I can infer what would be useful from WebKit's media controls as a first 
</I>&gt;<i> stab?
</I>
On Mon, 25 Apr 2011, Silvia Pfeiffer wrote:
&gt;<i>
</I>&gt;<i> A markup and CSS example would make things clearer. How do you think it 
</I>&gt;<i> would look?
</I>
On Sun, 24 Apr 2011, Dimitri Glazkov wrote:
&gt;<i>
</I>&gt;<i> Based on WebKit's current media controls, let's start with these pseudo-classes:
</I>&gt;<i> 
</I>&gt;<i> Play state:
</I>&gt;<i> - loading
</I>&gt;<i> - playing
</I>&gt;<i> - streaming
</I>&gt;<i> - error
</I>&gt;<i> 
</I>&gt;<i> Capabilities:
</I>&gt;<i> - no-audio
</I>&gt;<i> - no-video
</I>&gt;<i> - has-closed-captioning
</I>&gt;<i> 
</I>&gt;<i> So, to show a status message while the control is loading or streaming
</I>&gt;<i> and hide when it's done:
</I>&gt;<i> 
</I>&gt;<i> video -webkit-media-controls-status-display {
</I>&gt;<i>     display: none;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> video:loading -webkit-media-controls-status-display, video:streaming
</I>&gt;<i> -webkit-media-controls-status-display {
</I>&gt;<i>     display: initial;
</I>&gt;<i>     ...
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> Similarly, to hide volume controls when there's no audio:
</I>&gt;<i> 
</I>&gt;<i> video:no-audio -webkit-media-controls-volume-slider-container {
</I>&gt;<i>     display: none;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> Once I put these pseudo-classes in place for WebKit, a lot of the code in 
</I>&gt;<i> <A HREF="http://codesearch.google.com/codesearch/p#OAMlx_jo-ck/src/third_party/WebKit/Source/WebCore/html/shadow/MediaControlRootElement.cpp&amp;exact_package=chromium">http://codesearch.google.com/codesearch/p#OAMlx_jo-ck/src/third_party/WebKit/Source/WebCore/html/shadow/MediaControlRootElement.cpp&amp;exact_package=chromium</A> 
</I>&gt;<i> will go away, being replaced with straight CSS.
</I>
Sounds to me like a poor man's XBL. I'd much rather see this addressed 
using a full-on binding solution, since it seems like it would be only a 
little more complex yet orders of magnitude more powerful.


On Fri, 13 May 2011, Narendra Sisodiya wrote:
&gt;<i> 
</I>&gt;<i> What i want is a general purpose synchronize mechanism when resource 
</I>&gt;<i> like (text, video, graphics, etc) will be played over a general purpose 
</I>&gt;<i> timer (timeline) with interaction..
</I>&gt;<i> 
</I>&gt;<i> Ex -
</I>&gt;<i> 
</I>&gt;<i>        &lt;resource type=&quot;html&quot; src=&quot;asd.html&quot; x=&quot;50%&quot;  y=&quot;50%&quot;  width=&quot;10%&quot;
</I>&gt;<i> height=&quot;10%&quot; z=&quot;6&quot; xpath=&quot;page1&quot; tIn=&quot;5000ms&quot; tOut=&quot;9400ms&quot;
</I>&gt;<i> inEffect=&quot;fadein&quot; outEffect=&quot;fadeout&quot; inEffectDur=&quot;1000ms&quot;
</I>&gt;<i> outEffectDur=&quot;3000ms&quot;/&gt;
</I>&gt;<i> 
</I>&gt;<i>        &lt;resource type=&quot;html&quot; src=&quot;Indian.ogv&quot; x=&quot;50%&quot;  y=&quot;50%&quot;  width=&quot;10%&quot;
</I>&gt;<i> height=&quot;10%&quot; z=&quot;6&quot; xpath=&quot;page2&quot; tIn=&quot;5000ms&quot; tOut=&quot;9400ms&quot;
</I>&gt;<i> inEffect=&quot;fadein&quot; outEffect=&quot;fadeout&quot; inEffectDur=&quot;1000ms&quot;
</I>&gt;<i> outEffectDur=&quot;3000ms&quot;/&gt;
</I>
Sounds like SMIL. I recommend looking into SMIL and SVG (which includes 
parts of SMIL).


On Fri, 13 May 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i>
</I>&gt;<i> Problem:
</I>&gt;<i> 
</I>&gt;<i> &lt;video src=&quot;video.webm&quot;&gt;&lt;/video&gt;
</I>&gt;<i> ...
</I>&gt;<i> &lt;script&gt;
</I>&gt;<i> document.querySelector('video').oncanplay = function() {
</I>&gt;<i>  /* will it run? */
</I>&gt;<i> };
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i> 
</I>&gt;<i> In the above the canplay event can be replaced with many others, like 
</I>&gt;<i> loadedmetadata and loadeddata. Whether or not the event handler has been 
</I>&gt;<i> registered by the time the event is fired depends on how fast decoding 
</I>&gt;<i> is, how fast the network is and how much &quot;...&quot; there is.
</I>
Yes, if you add an event listener in a task that runs after the task that 
fires the event could have run, you won't always catch the event.

That's just a bug in the JS.


On Fri, 13 May 2011, Henri Sivonen wrote:
&gt;<i> 
</I>&gt;<i> &lt;iframe src=foo.html&gt;&lt;/iframe&gt;
</I>&gt;<i> &lt;script&gt;
</I>&gt;<i> document.querySelector('iframe').onload = function() {
</I>&gt;<i>    /* will it run? */
</I>&gt;<i> };
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i> has the same problem. The solution is using the onload markup attribute
</I>&gt;<i> that calls a function declared in an earlier &lt;script&gt;:
</I>&gt;<i> 
</I>&gt;<i> &lt;script&gt;
</I>&gt;<i> function iframeLoaded() {
</I>&gt;<i>   /* It will run! */
</I>&gt;<i> }
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i> &lt;iframe src=foo.html onload=iframeLoaded()&gt;&lt;/iframe&gt;
</I>
Exactly.


On Sat, 14 May 2011, Ojan Vafai wrote:
&gt;<i> 
</I>&gt;<i> If someone proposed a workable solution, browser would likely implement 
</I>&gt;<i> it. I can't think of a backwards-compatible solution to this, so I agree 
</I>&gt;<i> that developers just need to learn the that this is a bad pattern. I 
</I>&gt;<i> could imagine browsers logging a warning to the console in these cases, 
</I>&gt;<i> but I worry that it would fire too much in today's web.
</I>
Indeed.


&gt;<i> It's unfortunate that you need to use an inline event handler instead of 
</I>&gt;<i> one registered via addEventListener to avoid the race condition. 
</I>&gt;<i> Exposing something to the platform like jquery's live event handlers ( 
</I>&gt;<i> <A HREF="http://api.jquery.com/live/">http://api.jquery.com/live/</A>) could mitigate this problem in practice, 
</I>&gt;<i> e.g. it would be just as easy or easier to register the event handler 
</I>&gt;<i> before the element is created.
</I>
You can also work around it by setting src=&quot;&quot; from script after you've 
used addEventListener, or by checking the state manually after you've 
added the handler and calling the handler if it is too late (though you 
have to be aware of the situation where the event is actually already 
scheduled and you added the listener between the time it was scheduled and 
the time it fired, so your function really has to be idempotent).


On Sun, 15 May 2011, Olli Pettay wrote:
&gt;<i> 
</I>&gt;<i> There is no need to use inline event handler.
</I>&gt;<i> One can always add capturing listener to window for example.
</I>&gt;<i> window.addEventListener(&quot;canplay&quot;,
</I>&gt;<i>   function(e) {
</I>&gt;<i>     if (e.target == document.querySelector('video') {
</I>&gt;<i>       // Do something.
</I>&gt;<i>     }
</I>&gt;<i>   }
</I>&gt;<i> , true);
</I>&gt;<i> And just do that before the &lt;video&gt; element occurs in the page.
</I>&gt;<i> That is simple, IMHO.
</I>
Indeed, that is another option.


&gt;<i> (I wonder why the &quot;Firing a simple event named e&quot; defaults to 
</I>&gt;<i> non-bubbling. It makes many things harder than they should be.)
</I>
The default is arbitrary and doesn't affect the platform (since I have 
to decide with each event whether to use the default or not). Changing the 
default would make no difference (I'd just have to go to every site that 
calls the algorithm and switch it from &quot;bubbles&quot; to nothing and nothing to 
&quot;does not bubble&quot;).


On Sun, 15 May 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> If a MediaController is being used it's more complicated; there seems to 
</I>&gt;<i> be no way to query the readyState of a MediaController (almost, but not 
</I>&gt;<i> quite, the &quot;most recently reported readiness state&quot;), or to get a list 
</I>&gt;<i> of slaved media elements from a MediaController without searching for 
</I>&gt;<i> them by hand.
</I>
If you're scripting the MediaController, the assumption is that you 
created it so there's no problem. The impled MediaControllers are for the 
declarative case where you don't need scripting at all.


On Mon, 16 May 2011, Simon Pieters wrote:
&gt;<i> 
</I>&gt;<i> The state can have changed before the event has actually fired, since 
</I>&gt;<i> state changes are sync but the events are queued. So if the script 
</I>&gt;<i> happens to run in between then func is run twice.
</I>
That's true.


On Mon, 16 May 2011, Remy Sharp wrote:
&gt;<i> 
</I>&gt;<i> Now you're right, whoever pointed out the 7am alarm example, if you 
</I>&gt;<i> attach the event too late, then you'll miss the boat.  However, it's a 
</I>&gt;<i> chicken an egg situation.  You don't have the DOM so you can't attach 
</I>&gt;<i> the event handler, and if you do have the DOM, the damn event has fired 
</I>&gt;<i> already.
</I>&gt;<i> 
</I>&gt;<i> What's the fix?  Well, the work arounds are certainly viable, again from 
</I>&gt;<i> an everyman developer point of view:
</I>&gt;<i> 
</I>&gt;<i> 1) Attach higher up, on the window object and listen for the 
</I>&gt;<i> canplay/loadedmetadata/etc and check the event.target
</I>&gt;<i>
</I>&gt;<i> 2) Attach an inline event handler (not nice, but will do)
</I>&gt;<i> 
</I>&gt;<i> The fix?  Since ultimately we have exactly the same potential &quot;bug&quot; with 
</I>&gt;<i> image load events
</I>
Not just those, also iframes, own document navigation, sockets, XHR, 
anything that does asynchronous work, in fact.


&gt;<i> is to update the specification and make it clear: that depending on the 
</I>&gt;<i> speed of the connection and decoding, the following &quot;xyz&quot; events can 
</I>&gt;<i> fire **before** your script runs.  Therefore, here's a couple of work 
</I>&gt;<i> arounds - or just be aware.
</I>
I don't really know where to put this that would actually help.


On Tue, 17 May 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> Still, I don't think just advocacy is any kind of solution. Given that 
</I>&gt;<i> you (the co-author of an HTML5 book) make certain assumptions about the 
</I>&gt;<i> outcome of this race condition, it's safe to assume that hoards of web 
</I>&gt;<i> developers will do the same.
</I>&gt;<i> 
</I>&gt;<i> To target this specific pattern, one hypothetical solution would be to 
</I>&gt;<i> special-case the first script that attaches event handlers to a &lt;video&gt; 
</I>&gt;<i> element. After it has run, all events that were already fired before the 
</I>&gt;<i> script are fired again. However, this seems awfully messy if the script 
</I>&gt;<i> also observes readyState or networkState. It might also interfere with 
</I>&gt;<i> browsers that use scripts behind the scenes to implement the native 
</I>&gt;<i> controls.
</I>&gt;<i> 
</I>&gt;<i> Although a kludge, another solution might be to block events from being fired
</I>&gt;<i> until x more bytes of the document have been parsed or it has finished
</I>&gt;<i> loading.
</I>
On Wed, 18 May 2011, Robert O'Callahan wrote:
&gt;<i> 
</I>&gt;<i> For certain kinds of events (&quot;load&quot;, the video events, maybe more), 
</I>&gt;<i> delay the firing of such events until, say, after DOMContentLoaded has 
</I>&gt;<i> fired. If you're careful you might be able to make this a strict subset 
</I>&gt;<i> of the behaviors currently allowed by the spec ... i.e. you're 
</I>&gt;<i> pretending that your frame, image and video loads simply didn't complete 
</I>&gt;<i> until after DOMContentLoaded fired in the outer page. That would mean 
</I>&gt;<i> it's compatible with properly-written legacy content ... if there is 
</I>&gt;<i> any.
</I>&gt;<i> 
</I>&gt;<i> Of course I have no idea whether that approach is actually feasible :-). 
</I>&gt;<i> It obviously isn't compatible with what browsers currently do, so 
</I>&gt;<i> authors wouldn't want to rely on it for a long time if ever.
</I>
These don't seem like workable solutions. We can't delay load events for 
every image on the Web, surely. Remembering every event that's ever fired 
for any &lt;img&gt; or &lt;video&gt; just in case a handler is later attached seems a 
bit intractable, too.

This has been a problem since JavaScript was added in the 90s. I find it 
hard to believe that we have to suddenly fix it now.


On Tue, 24 May 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> Ian and I had a brief conversation recently where I mentioned a problem 
</I>&gt;<i> with extended text descriptions with screen readers (and worse still 
</I>&gt;<i> with braille devices) and the suggestion was that the &quot;paused for user 
</I>&gt;<i> interaction&quot; state of a media element may be the solution. I would like 
</I>&gt;<i> to pick this up and discuss in detail how that would work to confirm my 
</I>&gt;<i> sketchy understanding.
</I>&gt;<i> 
</I>&gt;<i> *The use case:*
</I>&gt;<i> 
</I>&gt;<i> In the specification for media elements we have a &lt;track&gt; kind of
</I>&gt;<i> &quot;descriptions&quot;, which are:
</I>&gt;<i> &quot;Textual descriptions of the video component of the media resource,
</I>&gt;<i> intended for audio synthesis when the visual component is unavailable
</I>&gt;<i> (e.g. because the user is interacting with the application without a
</I>&gt;<i> screen while driving, or because the user is blind). Synthesized as a
</I>&gt;<i> separate audio track.&quot;
</I>&gt;<i> 
</I>&gt;<i> I'm for now assuming that the synthesis will be done through a screen
</I>&gt;<i> reader and not through the browser itself, thus making the
</I>&gt;<i> descriptions available to users as synthesized audio or as braille if
</I>&gt;<i> the screen reader is set up for a braille device.
</I>&gt;<i> 
</I>&gt;<i> The textual descriptions are provided as chunks of text with a start
</I>&gt;<i> and a end time (so-called &quot;cues&quot;). The cues are processed during video
</I>&gt;<i> playback as the video's playback time starts to fall within the time
</I>&gt;<i> frame of the cue. Thus, it is expected the that cues are consumed
</I>&gt;<i> during the cue's time frame and are not present any more when the end
</I>&gt;<i> time of the cue is reached, so they don't conflict with the video's
</I>&gt;<i> normal audio.
</I>&gt;<i> 
</I>&gt;<i> However, on many occasions, it is not possible to consume the cue text
</I>&gt;<i> in the given time frame. In particular not in the following
</I>&gt;<i> situations:
</I>&gt;<i> 
</I>&gt;<i> 1. The screen reader takes longer to read out the cue text than the
</I>&gt;<i> cue's time frame provides for. This is particularly the case with long
</I>&gt;<i> cue text, but also when the screen reader's reading rate is slower
</I>&gt;<i> than what the author of the cue text expected.
</I>&gt;<i> 
</I>&gt;<i> 2. The braille device is used for reading. Since reading braille is
</I>&gt;<i> much slower than listening to read-out text, the cue time frame will
</I>&gt;<i> invariably be too short.
</I>&gt;<i> 
</I>&gt;<i> 3. The user seeked right into the middle of a cue and thus the time
</I>&gt;<i> frame that is available for reading out the cue text is shorter than
</I>&gt;<i> the cue author calculated with.
</I>&gt;<i> 
</I>&gt;<i> Correct me if I'm wrong, but it seems that what we need is a way for
</I>&gt;<i> the screen reader to pause the video element from continuing to play
</I>&gt;<i> while the screen reader is still busy delivering the cue text. (In
</I>&gt;<i> a11y talk: what is required is a means to deal with &quot;extended
</I>&gt;<i> descriptions&quot;, which extend the timeline of the video.) Once it's
</I>&gt;<i> finished presenting, it can resume the video element's playback.
</I>
Is it a requirement that the user be able to use the regular video pause, 
play, rewind, etc, controls to seek inside the extended descriptions, or 
should they literally pause the video while playing, with the audio 
descriptions being controlled by the same UI as the screen reader?


&gt;<i> IIUC, a video is &quot;paused for user interaction&quot; basically when the UA has 
</I>&gt;<i> decided to pause the video without the user asking to pause it (i.e. the 
</I>&gt;<i> paused attribute is false) and the pausing happened not for network 
</I>&gt;<i> buffering reasons, but for other reasons. IIUC one concrete situation 
</I>&gt;<i> where this state is used is when the UA has reached the end of the 
</I>&gt;<i> resource and is waiting for more data to come (e.g. on a live stream).
</I>
That latter state is not &quot;paused for user interaction&quot;, it's just stalled 
due to lack of data. The rest is accurate though.


&gt;<i> To use &quot;paused for user interaction&quot; for extending descriptions, we need 
</I>&gt;<i> to introduce a means for the screen reader to tell the UA to pause the 
</I>&gt;<i> video when it reaches the end of the cue and it's still busy delivering 
</I>&gt;<i> a cue's text. Then, as it finishes, it will un-pause the video to let it 
</I>&gt;<i> continue playing.
</I>&gt;<i> 
</I>&gt;<i> To me it sounds like a feasible solution.
</I>&gt;<i> 
</I>&gt;<i> The screen reader could even provide a user setting and a short-cut so a 
</I>&gt;<i> user can decide that they don't want this pausing to happen or that they 
</I>&gt;<i> want to move on from the current cue.
</I>&gt;<i> 
</I>&gt;<i> Another advantage of this approach is that e.g. a deaf-blind user could 
</I>&gt;<i> hook up their braille device such that it will deliver the extended 
</I>&gt;<i> descriptions and also deliver captions through braille with such 
</I>&gt;<i> extension pausing happening. (Not sure that such a user would even want 
</I>&gt;<i> to play the video, but it would be possible.)
</I>&gt;<i> 
</I>&gt;<i> Now, I think there is one problem though (at least as far as I can 
</I>&gt;<i> tell). Right now, IIUC, screen readers are only passive listeners on the 
</I>&gt;<i> UA. They don't influence the behaviour of the UA. The accessibility API 
</I>&gt;<i> is basically only a one-way street from the UA to the AT. I wonder if 
</I>&gt;<i> that is a major inhibitor of using this approach or whether it's easy 
</I>&gt;<i> for UAs to overcome this limitation? (Or if such a limitation even 
</I>&gt;<i> exists - I don't know enough about how AT work...).
</I>&gt;<i> 
</I>&gt;<i> Is that an issue? Are there other issues that I have overlooked?
</I>
That seems to be entirely an implementation issue.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>


















































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031897.html">[whatwg] Blacklist for regsiterProtocolHandler()
</A></li>
	<LI>Next message: <A HREF="074171.html">[whatwg] Video feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31916">[ date ]</a>
              <a href="thread.html#31916">[ thread ]</a>
              <a href="subject.html#31916">[ subject ]</a>
              <a href="author.html#31916">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
