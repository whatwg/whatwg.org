<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] whatwg Digest, Vol 94, Issue 44
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20whatwg%20Digest%2C%20Vol%2094%2C%20Issue%2044&In-Reply-To=%3C4F206C4B.7090702%40jumis.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="034504.html">
   <LINK REL="Next"  HREF="034506.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] whatwg Digest, Vol 94, Issue 44</H1>
<!--htdig_noindex-->
    <B>Charles Pritchard</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20whatwg%20Digest%2C%20Vol%2094%2C%20Issue%2044&In-Reply-To=%3C4F206C4B.7090702%40jumis.com%3E"
       TITLE="[whatwg] whatwg Digest, Vol 94, Issue 44">chuck at jumis.com
       </A><BR>
    <I>Wed Jan 25 12:55:39 PST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="034504.html">[whatwg] whatwg Digest, Vol 94, Issue 45
</A></li>
        <LI>Next message: <A HREF="034506.html">[whatwg] Requests for new elements for comments
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34505">[ date ]</a>
              <a href="thread.html#34505">[ thread ]</a>
              <a href="subject.html#34505">[ subject ]</a>
              <a href="author.html#34505">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On 1/25/12 7:39 AM, <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">whatwg-request at lists.whatwg.org</A> wrote:
&gt;&gt;<i> &gt;  Generally, I think that often a hybrid approach to Canvas, where you draw
</I>&gt;&gt;<i> &gt;  into multiple Canvas elements and use CSS transforms, animations (and now
</I>&gt;&gt;<i> &gt;  filters) for positioning and effects can give you the best of both worlds...
</I>&gt;&gt;<i> &gt;
</I>&gt;<i> I disagree. I would much rather see filter functionality available to both
</I>&gt;<i> Canvas and CSS. That functionality is clearly in both Canvas' and CSS'
</I>&gt;<i> wheelhouses, and since they are both implemented by the browser vendor, why
</I>&gt;<i> not have that low-level functionality available to both Canvas and CSS? It
</I>&gt;<i> seems crazy to me to have that low-level code sitting in the browser and
</I>&gt;<i> then restrict it to CSS. Why would anyone want to do that?
</I>

Implementers may run shaders on the GPU.

You don't want to have your canvas bitmap uploaded to the gpu, filtered, 
then sent back to the cpu. There are undefined issues on quality. The 
image may be compressed in transit. The CSS layer is a very much 
separated from the Canvas rasterization process. This is a good thing.

I did ask about adding filters to Canvas years ago, I think in '09. So I 
want you to know, I am supportive. I worked on a large project with 
dozens of filters and blend modes atop Canvas and WebGL.

I want to write pixel shaders in JS so as to maintain backward 
compatibility and use the pixel shader with CSS semantics.

It does not help with the low level code issue you're talking about. But 
that's an area that's always been difficult. We have no direct access to 
deflate, either, nor many of the other low-level code assets sitting in 
the browser. With deflate, we could reasonably construct RGB and Indexed 
PNGs. But we don't have it, and that's ok.

Robert O has done a lot of work on Workers running filters on an &lt;audio&gt; 
stream:
<A HREF="https://dvcs.w3.org/hg/audio/raw-file/tip/streams/StreamProcessing.html">https://dvcs.w3.org/hg/audio/raw-file/tip/streams/StreamProcessing.html</A>

We can extend that proposal to work on Uint8ClampedArray (previously, 
CanvasPixelArray) and/or a Uint32Array.
It may be more efficient to treat the data as a Uint32Array. Fast is 
good. It'd work on &lt;video&gt; and &lt;canvas&gt;.

JS with typed arrays, especially Uint32Array, can be optimized very well 
by the compiler, and it can run across multiple cores. It's unlikely 
that the hard coded UA implementation of a few filter effects will have 
the long-term value of script shaders.

-Charles
</PRE>


































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="034504.html">[whatwg] whatwg Digest, Vol 94, Issue 45
</A></li>
	<LI>Next message: <A HREF="034506.html">[whatwg] Requests for new elements for comments
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34505">[ date ]</a>
              <a href="thread.html#34505">[ thread ]</a>
              <a href="subject.html#34505">[ subject ]</a>
              <a href="author.html#34505">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
