<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Dynamic content accessibility in HTML today
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=%5Bwhatwg%5D%20Dynamic%20content%20accessibility%20in%20HTML%20today&In-Reply-To=44EC4535.7030702%40cam.ac.uk">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007117.html">
   <LINK REL="Next"  HREF="007156.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Dynamic content accessibility in HTML today</H1>
<!--htdig_noindex-->
    <B>Matthew Raymond</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=%5Bwhatwg%5D%20Dynamic%20content%20accessibility%20in%20HTML%20today&In-Reply-To=44EC4535.7030702%40cam.ac.uk"
       TITLE="[whatwg] Dynamic content accessibility in HTML today">mattraymond at earthlink.net
       </A><BR>
    <I>Thu Aug 24 00:02:25 PDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="007117.html">[whatwg] Dynamic content accessibility in HTML today
</A></li>
        <LI>Next message: <A HREF="007156.html">[whatwg] Dynamic content accessibility in HTML today
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7150">[ date ]</a>
              <a href="thread.html#7150">[ thread ]</a>
              <a href="subject.html#7150">[ subject ]</a>
              <a href="author.html#7150">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>James Graham wrote:
&gt;<i> Matthew Raymond wrote:
</I>&gt;&gt;&gt;<i> Show me a spec that says that in a normative way. It is merely a &quot;best 
</I>&gt;&gt;&gt;<i> practice&quot;. Class names, in general, are meaningless and meaningful class 
</I>&gt;&gt;&gt;<i> names should not be part of the core specification.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    The reason that semantic class names are &quot;best practice&quot; is because
</I>&gt;&gt;<i> class names that are purely for presentational effects are less useful
</I>&gt;&gt;<i> when using alternate or user style sheets.
</I>&gt;<i> 
</I>&gt;<i> That's a purely &quot;human factor&quot; though. There's no reason you can't use &lt;div 
</I>&gt;<i> class=&quot;bigredtext&quot;&gt; and style it with an Aural style sheet. Or indeed with a 
</I>&gt;<i> visual stylesheet to present the text in small, blue letters. It's just /likely/ 
</I>&gt;<i> to make your document harder to understand if you do that.
</I>
   If you have a class name that's purely presentational and has no real
meaning, why would anyone go out of their way to change its
presentation? It's more likely that the class name has at least some
marginal semantic meaning and that the author merely chose a poor name
for the class. How often do you go in and tweak your user style sheet
just to make red text blue?

   (Granted, there may be reasons if you're color blind, but it would
make more sense for user agents to have special features for color blind
individuals, like changing red text to blue automatically. Any
presentational name will likely be be fairly unique to the document or
author, so just using the user style sheet will mean adding at least one
selector per website.)

&gt;&gt;<i> In fact,
</I>&gt;&gt;<i> a presentational class name might be applied to elements that have
</I>&gt;&gt;<i> different semantics just because the author wanted to use the same style
</I>&gt;&gt;<i> for all the elements, giving the impression that elements are related
</I>&gt;&gt;<i> even when they're not.
</I>&gt;<i> 
</I>&gt;<i> That would be an acceptable use of class. It would probably be poor design 
</I>&gt;<i> (because later the author might want to restyle the elements separately) but 
</I>&gt;<i> that's not our problem.
</I>
   In actuality, it's probably poor selector design as well. It may be
possible to style those specific elements without using the
presentational class name at all.

&gt;<i> Indeed a nominal requirement that class names map to
</I>&gt;<i> semantics would be impractical; there exists no 1:1 mapping between the 
</I>&gt;<i> semantics of an element and the way it is presented within a particular document
</I>
   There is no 1-to-1 mapping between a class name and its presentation...

|<i> p.classname { /* One style. */ }
</I>|<i> h1.classname { /* Another style. */ }
</I>
   How a style sheet author chooses to style content, whether in a
|<i>class| attribute or not, is irrelevant with regards to whether or not
</I>that content has semantic meaning.

&gt;<i> (e.g. I might want 7 &lt;h2&gt; elements 3 being styled with a left float and red text 
</I>&gt;<i> and 4 being styled with a right float and green text).
</I>
   Random changes the styling of elements within the document is a bad
idea for presentation, let alone for semantics. If you have such a shift
in the presentation of the document content, it's probably because the
content has changed context in some way, such as it being in a new
section of the document, and not because the author just felt like
making something green and float right. In the situation above, the
author could have just as easily used a selector containing the ID of
the parent section instead of creating a class.

&gt;<i> Any attempt to formalise the class attribute beyond &quot;it takes arbitrary values&quot; 
</I>&gt;<i> is imho misguided and doomed to failure.
</I>
   The fact that we can't completely eliminate non-semantic class names
doesn't mean that we can't require that class names _should_ be
semantic. Furthermore, even when classes are intended purely for
presentation, the presentation itself may be an unconscious indication
of semantic meaning. By allowing semantic predefined class names and
encouraging their use, authors need replace their
less-semantically-named-but-nevertheless-semantic classes.

&gt;&gt;&gt;<i> Of course, if you plan to put all the semantics of a document in the 
</I>&gt;&gt;&gt;<i> class names, we could do away with many elements. Do you object to &lt;div 
</I>&gt;&gt;&gt;<i> class=&quot;h1&quot;&gt; as a replacement for &lt;h1&gt;?
</I>[ Snipped my nonsensical initial reply. ]

   How is |role| any different?...

|<i> &lt;div role=&quot;html:h1&quot;&gt;...&lt;/div&gt;
</I>
   This is a false argument. We have to define what should be a role and
what should be in markup whether we use |class| to declare them or
|<i>role|. It's orthogonal to the topic at hand.
</I>
&gt;&gt;&gt;&gt;<i>    The values for |role| are nothing more than a new set of class names,
</I>&gt;&gt;&gt;&gt;<i> and there is nothing preventing the user from putting in unidentified
</I>&gt;&gt;&gt;&gt;<i> |role| values for presentational purposes and then styling them via CSS
</I>&gt;&gt;&gt;&gt;<i> using attribute selectors. So aside from being mildly harder to select
</I>&gt;&gt;&gt;&gt;<i> from CSS, |role| values are potentially no more semantic than |class|
</I>&gt;&gt;&gt;&gt;<i> values.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Authors can misuse anything. &lt;h1 style=&quot;font-size:12px; 
</I>&gt;&gt;&gt;<i> font-weight:normal;&quot;&gt;This is the main text of my document put in a 
</I>&gt;&gt;&gt;<i> heading so that search bots think that it's really relevant and useful&lt;/h1&gt;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    What you fail to understand is that user agents will have to have
</I>&gt;&gt;<i> means of handling the misuse,
</I>&gt;<i> 
</I>&gt;<i> No. I'm pretty sure I do understand that.
</I>
   You give no such indication. Some of the arguments you make against
|<i>class|, for instance, apply equally to |role|.
</I>
&gt;&gt;<i> which means that many of the differences
</I>&gt;&gt;<i> between |role| and |class| are more conceptual than practical.
</I>&gt;<i> 
</I>&gt;<i> Not really (but don't take that as meaning that conceptual differences are 
</I>&gt;<i> unimportant! The difference between semantics and presentation is more 
</I>&gt;<i> conceptual than practical: a human will get the semantics - what is a header and 
</I>&gt;<i> what isn't, for example - from the presentation, not the 'semantics' embedded in 
</I>&gt;<i> the markup).
</I>
   Then we agree that some &quot;presentational&quot; class names may actually
have semantic meaning...

&gt;<i> Practically, class is an attribute in widespread use without any
</I>&gt;<i> regard for the information required by accessibility tools. That means many 
</I>&gt;<i> pages could already be using class=&quot;tab&quot; where their role attribute would be 
</I>&gt;<i> &quot;tabpanel&quot;.
</I>
   The |role| specification requires that all roles not immediately
defined in the draft have name spaces, so if we use the same convention
with class, this is a irrelevant. There's no motivation for authors to
associate a namespace with a correct namespace URL, then use that
namespace for presentational class names. It's insane.

   As for the non-namespaced values in the spec, most are covered by
markup in Web Applications 1.0.

&gt;<i> Practically the class attribute is valuable in making arbitrary 
</I>&gt;<i> groups of elements suitable for selection by CSS or scripts - this has nothing 
</I>&gt;<i> to do with semantics of any kind.
</I>
   Scripting is a means of implementing roles, and there's nothing in
the HTML specification preventing user agents from performing &quot;general
purpose processing&quot; in a script-independent manner.

&gt;<i> Practically, the presence of a role attribute 
</I>&gt;<i> implies that a group of elements should be interpreted as a particular component 
</I>&gt;<i> of a UI widget, significantly altering the interpretation of that subtree - 
</I>&gt;<i> justification enough for a new attribute (and, in some cases, for whole new 
</I>&gt;<i> /elements/)- and that other attributes on the element will be interpreted as 
</I>&gt;<i> ancillary information about that widget.
</I>
   The language of the |role| specification is actually unclear. The
intro indicates that |role| can be used to &quot;describe the semantic
meaning&quot; of elements, while Section 3 says the following:

   &quot;It is used by applications and assistive technologies to determine
the purpose of UI widgets.&quot;

   It does not, however, specify that it cannot be used for purposes
unrelated to widgets. I think the working draft needs to be clarified if
the attribute is only intended to provide widget-related semantics.
Also, I don't think just &quot;role&quot; properly communicates that it's for
widget purposes. Considering the way it's being used in Firefox, I'd say
 something like &quot;wairole&quot; makes more sense. Besides, how many different
namespaces do you need for widget behavior???

|<i> &lt;span tabindex=&quot;0&quot;
</I>|<i>       wairole=&quot;checkbox&quot;
</I>|<i>       waistate=&quot;checked&quot;
</I>|<i>       onkeydown=&quot;return checkBoxEvent(event);&quot;
</I>|<i>       onclick=&quot;return checkBoxEvent(event);&quot;&gt;
</I>|<i>   Any checkbox label
</I>|<i> &lt;/span&gt;
</I>
   Something that bothers me about the wairole stuff, though, is that it
assumes specific widgets with specific properties. It's beginning to
look a lot like we're defining specific widgets and behaviors rather
than specifying semantics. One could look at this like a canned widget
binding rather than actual semantics. One has to wonder if this isn't
simply a way of improving DHTML widgets until XBL 2.0 arrives.

   So perhaps the &quot;semantic meaning&quot; talked about in the |role| working
draft intro really is just hot air. Is role is just a way of turning this...

|<i> &lt;wai:sitemap&gt;
</I>|<i>   &lt;nav&gt;
</I>|<i>     &lt;ul&gt; ... &lt;/ul&gt;
</I>|<i>   &lt;/nav&gt;
</I>|<i> &lt;/wai:sitemap&gt;
</I>
...into this...

|<i> &lt;ul role=&quot;navigations wai:sitemap&quot;&gt; ... &lt;/ul&gt;
</I>
   ...thus allowing you to overload an element without all that pesky
nesting and such?

   I'm not really in favor of this kind of overloading. My instincts
tell me that mapping multiple elements from multiple namespaces onto one
element would be a real nightmare.

&gt;&gt;&gt;&gt;<i>    However, let's assume that people would only use semantic values in
</I>&gt;&gt;&gt;&gt;<i> |role|. What becomes of |class|? We use it only for styling? That won't
</I>&gt;&gt;&gt;&gt;<i> work, because HTML is supposed to be semantic.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> We use it for it's purpose - to provide hooks to enable presentational 
</I>&gt;&gt;&gt;<i> languages to couple to arbitrary groups of elements on a page. This kind 
</I>&gt;&gt;&gt;<i> of non-semantic hook is _necessary_ so that the temptation to abuse the 
</I>&gt;&gt;&gt;<i> semantic elements is greatly reduced.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    The use case for such classes will become progressively smaller as
</I>&gt;&gt;<i> XBL2 is introduced and CSS improves.
</I>&gt;<i> 
</I>&gt;<i> Why do anything today when in several decades you might not have to bother? I 
</I>&gt;<i> mean it's just happenstance that [no one] is expected to need an assistive 
</I>&gt;<i> technology until 2050 or whenever CSS4+XBL2 are maturely implemented and, 
</I>&gt;<i> through a programme of extensive brainwashing, authors start doing the correct 
</I>&gt;<i> thing rather than the easy thing.
</I>
   Your argument isn't valid. You suggest that I wish to do nothing,
when in fact I'm offering an alternative that recycles existing role
definitions. The code for searching a |class| string for specific role
names can't be any different than the code for |role|. The |class| and
|<i>role| elements have nearly identical problems when used for the same
</I>purpose. The code burden for roles is essentially the same regardless of
which attribute you use, accept that with |role| you have to add an
attribute.

   Besides, you're arguing that we should implement an attribute that
effectively deprecates the |class| attribute because |class| will
continue to be used in the immediate future. This is not unlike arguing
that &lt;font&gt; will continue to be used after the introduction of CSS,
except that in this case I don't feel you've demonstrated a clear
advantage for the new technology like you could with CSS.

&gt;&gt;&gt;&gt;<i>    So what we end up doing is replacing |class| with an attribute named
</I>&gt;&gt;&gt;&gt;<i> |role| that has more rules but otherwise does the same thing.
</I>&gt;&gt;&gt;<i> No. We add an attribute which conveys specific semantics (&quot;this element 
</I>&gt;&gt;&gt;<i> is being used as a UI widget of a particular type). We standardize some
</I>&gt;&gt;&gt;<i> well-researched values for that element that are applicable to the needs 
</I>&gt;&gt;&gt;<i> of non-visual UAs in the real world.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    All of this could be done with |class|. The sole purpose for |role|
</I>&gt;&gt;<i> is to separate presentational classes from semantic classes. 
</I>&gt;<i> 
</I>&gt;<i> No. It. Is. Not. It is to provide a means to indicate that certain collections 
</I>&gt;<i> of elements on a page should be interpreted as a particular type of UI widget, 
</I>&gt;<i> /not/ as marked-up prose.
</I>
   As I have stated, I think the working draft needs clarification on
this point.

&gt;<i> Class cannot fulfil that role without being
</I>&gt;<i> significantly overburdened with multiple functionalities.
</I>
   It's already &quot;overburdened&quot; with those functionalities. Take a look
at just about _ANY_ microformat. I'm not trying to overburden class. Nor
will |role| unburden |class| if its sole use is for UI widget roles.
</PRE>


<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007117.html">[whatwg] Dynamic content accessibility in HTML today
</A></li>
	<LI>Next message: <A HREF="007156.html">[whatwg] Dynamic content accessibility in HTML today
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7150">[ date ]</a>
              <a href="thread.html#7150">[ thread ]</a>
              <a href="subject.html#7150">[ subject ]</a>
              <a href="author.html#7150">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
