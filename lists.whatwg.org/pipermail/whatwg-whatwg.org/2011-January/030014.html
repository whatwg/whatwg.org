<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] HTML5 video: frame accuracy / SMPTE
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20HTML5%20video%3A%20frame%20accuracy%20/%20SMPTE&In-Reply-To=%3Cop.vppicta7sr6mfa%40nog%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030012.html">
   <LINK REL="Next"  HREF="030030.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] HTML5 video: frame accuracy / SMPTE</H1>
<!--htdig_noindex-->
    <B>Philip J&#228;genstedt</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20HTML5%20video%3A%20frame%20accuracy%20/%20SMPTE&In-Reply-To=%3Cop.vppicta7sr6mfa%40nog%3E"
       TITLE="[whatwg] HTML5 video: frame accuracy / SMPTE">philipj at opera.com
       </A><BR>
    <I>Sat Jan 22 03:03:55 PST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="030012.html">[whatwg] HTML5 video: frame accuracy / SMPTE
</A></li>
        <LI>Next message: <A HREF="030030.html">[whatwg] HTML5 video: frame accuracy / SMPTE
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30014">[ date ]</a>
              <a href="thread.html#30014">[ thread ]</a>
              <a href="subject.html#30014">[ subject ]</a>
              <a href="author.html#30014">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Sat, 22 Jan 2011 11:01:26 +0100, Glenn Maynard &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">glenn at zewt.org</A>&gt; wrote:

&gt;<i> On Sat, Jan 22, 2011 at 4:23 AM, Philip J&#228;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt;  
</I>&gt;<i> wrote:
</I>&gt;&gt;&gt;<i> Should there be any consistency requirements for fast seeking?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Suppose you have a format that's high-bitrate but cheap to decode.
</I>&gt;&gt;&gt;<i> Accurately seeking is fast if the data is already buffered, but slow
</I>&gt;&gt;&gt;<i> if not, since it's limited by bandwidth and not CPU.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> An implementation might decide to snap to a keyframe if the needed
</I>&gt;&gt;&gt;<i> data isn't yet buffered, so it doesn't spend several seconds
</I>&gt;&gt;&gt;<i> downloading all of the data; but if it the data is already buffered,
</I>&gt;&gt;&gt;<i> to seek precisely.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> This could have unexpected side-effects.  Should this be allowed?  I'd
</I>&gt;&gt;&gt;<i> suggest that fast seeking should always be consistent with itself, at
</I>&gt;&gt;&gt;<i> least for a particular video instance.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I don't think that any consideration should be given to what is already
</I>&gt;&gt;<i> buffered and not, as it's always faster to seek to what's buffered so  
</I>&gt;&gt;<i> that
</I>&gt;&gt;<i> would simply make it impossible to seek into the unbuffered parts. Also,
</I>&gt;&gt;<i> it'd require the demuxer (which is where seeking happens) to have  
</I>&gt;&gt;<i> knowledge
</I>&gt;&gt;<i> of the transport layer.
</I>&gt;<i>
</I>&gt;<i> What I'm asking, though, is whether implementations should be
</I>&gt;<i> expressly forbidden from doing this sort of thing, by requiring that
</I>&gt;<i> fast seeking to a given time on the same video element always lands on
</I>&gt;<i> the same place.  (Aside from changes to seekable; this requirement
</I>&gt;<i> would be after the new playback position is clamped to seekable, not
</I>&gt;<i> before.)
</I>&gt;<i>
</I>&gt;<i> That guarantees that:
</I>&gt;<i>
</I>&gt;<i> video.seekMode = &quot;fast&quot;;
</I>&gt;<i> function f() {
</I>&gt;<i>     video.currentTime = 10;
</I>&gt;<i>     setTimeout(f, 5000);
</I>&gt;<i> }
</I>&gt;<i> f();
</I>&gt;<i>
</I>&gt;<i> will always seek to the same position, and never choose different
</I>&gt;<i> positions due to a too-clever seek algorithm allowing more precise
</I>&gt;<i> seeking as more data is buffered.
</I>&gt;<i>
</I>
Ah, thanks for clarifying. It might be a bit odd for the spec to forbid  
being too clever, but I think that in practice always seeking to the same  
point is much easier, so that's what would be implemented. It would indeed  
be bad if one browser always managed to seek one frame ahead even when  
using fast seeking, and another always seeks to a nearby keyframe/key  
unit/index point/whatever.

-- 
Philip J&#228;genstedt
Core Developer
Opera Software
</PRE>



<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030012.html">[whatwg] HTML5 video: frame accuracy / SMPTE
</A></li>
	<LI>Next message: <A HREF="030030.html">[whatwg] HTML5 video: frame accuracy / SMPTE
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30014">[ date ]</a>
              <a href="thread.html#30014">[ thread ]</a>
              <a href="subject.html#30014">[ subject ]</a>
              <a href="author.html#30014">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
