<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] localStorage feedback
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20localStorage%20feedback&In-Reply-To=%3C5dd9e5c50911031137g3336ab81n30698324fa42bb9b%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="066218.html">
   <LINK REL="Next"  HREF="066221.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] localStorage feedback</H1>
<!--htdig_noindex-->
    <B>Jeremy Orlow</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20localStorage%20feedback&In-Reply-To=%3C5dd9e5c50911031137g3336ab81n30698324fa42bb9b%40mail.gmail.com%3E"
       TITLE="[whatwg] localStorage feedback">jorlow at chromium.org
       </A><BR>
    <I>Tue Nov  3 11:37:36 PST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="066218.html">[whatwg] localStorage feedback
</A></li>
        <LI>Next message: <A HREF="066221.html">[whatwg] localStorage feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#66220">[ date ]</a>
              <a href="thread.html#66220">[ thread ]</a>
              <a href="subject.html#66220">[ subject ]</a>
              <a href="author.html#66220">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Tue, Nov 3, 2009 at 9:51 AM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt; wrote:

&gt;<i> On Mon, Nov 2, 2009 at 3:46 PM, Robert O'Callahan &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">robert at ocallahan.org</A>&gt;wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> On Tue, Nov 3, 2009 at 6:36 AM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 1a) Given a page (domain A) containing an iframe (domain B), have the
</I>&gt;&gt;&gt;<i> outer page navigate the inner frame to &quot;about:blank&quot;.  This navigation
</I>&gt;&gt;&gt;<i> completes synchronously, and the unload handler for the iframe runs before
</I>&gt;&gt;&gt;<i> the navigation request completes.  This is true of all browsers.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 1b) Suppose the inner page has a pending XMLHttpRequest when the outer
</I>&gt;&gt;&gt;<i> frame navigates the inner frame.  The XHR's onabort handler would run before
</I>&gt;&gt;&gt;<i> the navigation to &quot;about:blank&quot; completes.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> These are really the same problem: synchronous cross-domain about:blank
</I>&gt;&gt;<i> navigation. If navigation to about:blank has to be synchronous, then I guess
</I>&gt;&gt;<i> it needs to drop the lock, at least in the cross-domain case.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That's correct.  My point is simple:  Here is another case where nesting
</I>&gt;<i> can happen that hadn't been foreseen.  Trying to foresee all such issues is
</I>&gt;<i> difficult.
</I>&gt;<i>
</I>&gt;<i> Will we just keep amending the spec each time we find such a possible case?
</I>&gt;<i>
</I>&gt;<i> I think it is far saner to say that any nesting leads to unlocking the
</I>&gt;<i> storage mutex.  The spec can then list cases where this nesting might occur.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 2) Set a break point in the Mozilla JS debugger.  This runs a nested event
</I>&gt;&gt;&gt;<i> loop each time you single step so that it can drive the rest of the browser
</I>&gt;&gt;&gt;<i> UI.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 3) Install a Firefox extension that runs a nested event loop in response
</I>&gt;&gt;&gt;<i> to an event generated by content.  I debugged many Firefox crashes resulting
</I>&gt;&gt;&gt;<i> from extensions that do this kind of thing for various reasons.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> These are internal Mozilla issues and should not be allowed to influence
</I>&gt;&gt;<i> the design of the Web platform. They'll probably change for multi-process
</I>&gt;&gt;<i> anyway.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> OK, but my point is that the spec should afford implementors with the
</I>&gt;<i> ability to unlock the storage mutex at other times for reasons not mentioned
</I>&gt;<i> in the spec.
</I>&gt;<i>
</I>
If we do this, we need to re-visit ways that scripts can tell whether the
lock has been dropped.  I can't remember which idea was most in favor last
time we talked about it, but a counter that increments every time
LocalStorage is unlocked sticks out in my mind.  (Scripts can check the
counter, do something that could cause unlocking, and then verify the
counter is still the same after.)  Another option that just came to mind is
to have some flag that says &quot;throw an exception whenever there's been
a serialization violation&quot;.

Just to be clear for those following along at home: If we (Chrome) implement
the storage mutex for the next version of Chrome, it'll have to be the way
Darin's describing (mainly for schedule based reasons).  It would be nice to
eventually fix all the cases that cause unnecessary unlocking, but that's
going to take a while.

 I'm not convinced.  Look at Google Maps and street view.  Gmail uses more
&gt;&gt;&gt;<i> Flash now than it used to.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For new features, sure. But are they reimplementing existing browser-based
</I>&gt;&gt;<i> functionality to use plugins instead?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I think it is sufficient to just talk in the context of new features.  A JS
</I>&gt;<i> library or component grows a new feature that suddenly starts using a
</I>&gt;<i> plugin.  Now, API calls that were not supposed to touch plugins start
</I>&gt;<i> touching plugins, and the storage mutex gets dropped.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> What will you do for Gecko when it supports content processes?
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Implement the spec, I hope!
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It seems odd to me that this behavior was put into the spec without any
</I>&gt;&gt;&gt;<i> implementation experience to guide it.  The only multi-process
</I>&gt;&gt;&gt;<i> implementations that I know of do not have a storage mutex.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Lots of things are in the spec without implementation experience. I think
</I>&gt;&gt;<i> we have time to collect more experience on this issue with multi-process
</I>&gt;&gt;<i> browsers and revise the spec in light of it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> OK.  Please note my objection to the storage mutex.
</I>&gt;<i>
</I>
And mine.  :-)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20091103/06a4d5df/attachment-0001.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20091103/06a4d5df/attachment-0001.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="066218.html">[whatwg] localStorage feedback
</A></li>
	<LI>Next message: <A HREF="066221.html">[whatwg] localStorage feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#66220">[ date ]</a>
              <a href="thread.html#66220">[ thread ]</a>
              <a href="subject.html#66220">[ subject ]</a>
              <a href="author.html#66220">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
