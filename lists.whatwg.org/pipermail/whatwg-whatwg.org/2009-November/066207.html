<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] &lt;model/&gt;: A 3D Equivalent to &lt;img/&gt;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%3Cmodel/%3E%3A%20A%203D%20Equivalent%20to%20%3Cimg/%3E&In-Reply-To=%3Cd7e38f950911021919t40cf4626w1331696e0a05d9b4%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="066206.html">
   <LINK REL="Next"  HREF="066184.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] &lt;model/&gt;: A 3D Equivalent to &lt;img/&gt;</H1>
<!--htdig_noindex-->
    <B>Brian Blakely</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%3Cmodel/%3E%3A%20A%203D%20Equivalent%20to%20%3Cimg/%3E&In-Reply-To=%3Cd7e38f950911021919t40cf4626w1331696e0a05d9b4%40mail.gmail.com%3E"
       TITLE="[whatwg] &lt;model/&gt;: A 3D Equivalent to &lt;img/&gt;">anewpage.media at gmail.com
       </A><BR>
    <I>Mon Nov  2 19:19:59 PST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="066206.html">[whatwg] &lt;model/&gt;: A 3D Equivalent to &lt;img/&gt;
</A></li>
        <LI>Next message: <A HREF="066184.html">[whatwg] pushState / replaceState nits
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#66207">[ date ]</a>
              <a href="thread.html#66207">[ thread ]</a>
              <a href="subject.html#66207">[ subject ]</a>
              <a href="author.html#66207">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>CYp,

We are speaking about a native, semantic 3D media type.  It is
inherently compatible with 3D CSS and requires no additional code to
display.  This is very different from a 2D rendering based on 3D
properties (as with VRML and &lt;canvas/&gt;).

-Brian


2009/11/2 CYp &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">tccyp86 at hotmail.com</A>&gt;:
&gt;<i> * 2D bitmaps are only partially compatible with 3D CSS - they are still
</I>&gt;<i> always flat
</I>&gt;&gt;&gt;<i>3D object  will finally be present as a 2d bitmap. there are always a
</I>&gt;&gt;&gt;<i> process called rendering.
</I>&gt;&gt;&gt;<i>you idea may be similar with the VRML, such as Box(x,y,z,w,l,h) but VRML
</I>&gt;&gt;&gt;<i> still need some ActiveX to render it into bitmap.
</I>&gt;<i> * This includes &lt;canvas/&gt;, which is still a 2D bitmap, not actually a 3D
</I>&gt;<i> object
</I>&gt;&gt;&gt;<i> people now are working on the  CanvasRenderingContext3D,but rendering
</I>&gt;&gt;&gt;<i> efficiency is a big problem I think.
</I>&gt;<i> ________________________________
</I>&gt;<i> From: <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">anewpage.media at gmail.com</A>
</I>&gt;<i> Date: Mon, 2 Nov 2009 14:16:37 -0500
</I>&gt;<i> To: <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">workmad3 at gmail.com</A>
</I>&gt;<i> CC: <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">whatwg at lists.whatwg.org</A>
</I>&gt;<i> Subject: Re: [whatwg] &lt;model/&gt;: A 3D Equivalent to &lt;img/&gt;
</I>&gt;<i>
</I>&gt;<i> David,
</I>&gt;<i>
</I>&gt;<i> Excellent perspectives, and there are certainly format decisions that have
</I>&gt;<i> to be made as a matter of course, just as there have been for &lt;video/&gt;.
</I>&gt;<i>
</I>&gt;<i> I do not agree with two of your points:
</I>&gt;<i>
</I>&gt;<i> * A static 3D rendering is equal to a 2D bitmap
</I>&gt;<i> * JavaScript is necessary to display 3D content
</I>&gt;<i>
</I>&gt;<i> My brief counter-points:
</I>&gt;<i>
</I>&gt;<i> * 2D bitmaps are only partially compatible with 3D CSS - they are still
</I>&gt;<i> always flat
</I>&gt;<i> * This includes &lt;canvas/&gt;, which is still a 2D bitmap, not actually a 3D
</I>&gt;<i> object
</I>&gt;<i>
</I>&gt;<i> A JavaScript-Only Approach is Inferior Because:
</I>&gt;<i>
</I>&gt;<i> * &lt;canvas/&gt; is being purposed as a viewport into 3D content, a function the
</I>&gt;<i> browser itself should serve
</I>&gt;<i> * 3D HTML/CSS is more facilitative to 3D design work than 3D JavaScript
</I>&gt;<i> alone
</I>&gt;<i> * Using only 3D JavaScript, the code required in order to serve rich user
</I>&gt;<i> interfaces is bandwidth intensive, working against one of the key benefits
</I>&gt;<i> of using web standards
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Explanation and Supporting Examples
</I>&gt;<i> ----------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> These assumptions are partially the fault of my primordial example, as that
</I>&gt;<i> example's purpose was to illustrate these concepts clearly, not demonstrate
</I>&gt;<i> an application of the technology.  The goal of &lt;model/&gt; is not merely to
</I>&gt;<i> serve 3D content, but to allow designers and developers to *lay out web
</I>&gt;<i> content and applications in 3D*.  Let's think of this concept as &quot;3D HTML&quot;.
</I>&gt;<i>
</I>&gt;<i> &lt;canvas/&gt; is not a solution.  It is rendering 3D content inside a viewport,
</I>&gt;<i> when the browser itself should be a viewport to 3D content.  One
</I>&gt;<i> alternative, creating a giant &lt;canvas/&gt; and filling it with fallback
</I>&gt;<i> content, is coding twice - not good.
</I>&gt;<i>
</I>&gt;<i> The foundations of 3D CSS (a la Webkit -
</I>&gt;<i> <A HREF="http://webkit.org/blog/386/3d-transforms/">http://webkit.org/blog/386/3d-transforms/</A>) and 3D JavaScript (WebGL/O3D) are
</I>&gt;<i> being laid out, but there is no HTML equivalent to cement a truly 3D design
</I>&gt;<i> platform on the web.
</I>&gt;<i>
</I>&gt;<i> If we draw 3D design to its logical conclusion, rich user interfaces, then
</I>&gt;<i> the usefulness and necessity of 3D HTML becomes more apparent.  I will
</I>&gt;<i> support this statement with an advanced example, which will demonstrate the
</I>&gt;<i> inadequacies of 2D design, and the gaps in currently-existing potential
</I>&gt;<i> standards.
</I>&gt;<i>
</I>&gt;<i> DISPLAYING THE SOLAR SYSTEM IN A 3/4 VIEW
</I>&gt;<i> ----------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> The below snippets will illustrate how a page would lay out such an
</I>&gt;<i> interface in three ways:  1) A 2D implementation you will see today; 2) a
</I>&gt;<i> combination of fictional 3D HTML and 3D CSS; 3) only 3D CSS, 3D JavaScript
</I>&gt;<i> and &lt;canvas/&gt;.
</I>&gt;<i>
</I>&gt;<i> On hover, each planet will rotate about its own axis.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 2D HTML &amp; CSS
</I>&gt;<i> -----------------------
</I>&gt;<i>
</I>&gt;<i> &lt;style&gt;
</I>&gt;<i>
</I>&gt;<i> ul {
</I>&gt;<i>     * Background image of space
</I>&gt;<i> }
</I>&gt;<i> li {
</I>&gt;<i>     * Absolutely positioned to correlate perspective
</I>&gt;<i> }
</I>&gt;<i> a {
</I>&gt;<i>     * Block
</I>&gt;<i>     * Negative indentation, hiding text
</I>&gt;<i> }
</I>&gt;<i> a.(planet name) {
</I>&gt;<i>     * Background image of each planet
</I>&gt;<i>     * Height/Width of each background image (alternatively a large
</I>&gt;<i> height/width in the anchor definition above, centering each image on X,Y
</I>&gt;<i> axes)
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> &lt;/style&gt;
</I>&gt;<i>
</I>&gt;<i> &lt;h1&gt;The Solar System in 3/4&lt;/h1&gt;
</I>&gt;<i> &lt;ul&gt;
</I>&gt;<i>     &lt;li&gt;
</I>&gt;<i>         &lt;a class=&quot;sun&quot; href=&quot;sun.html&quot;&gt;The Sun&lt;/a&gt;
</I>&gt;<i>     &lt;/li&gt;
</I>&gt;<i>     &lt;li&gt;
</I>&gt;<i>         &lt;a class=&quot;mercury&quot; href=&quot;mercury.html&quot;&gt;Mercury&lt;/a&gt;
</I>&gt;<i>     &lt;/li&gt;
</I>&gt;<i>     &lt;li&gt;
</I>&gt;<i>         &lt;a class=&quot;venus&quot; href=&quot;venus.html&quot;&gt;Venus&lt;/a&gt;
</I>&gt;<i>     &lt;/li&gt;
</I>&gt;<i>     ...
</I>&gt;<i> &lt;/ul&gt;
</I>&gt;<i>
</I>&gt;<i> &lt;script&gt;
</I>&gt;<i>     * Slideshow background script attached to each anchor, listening for
</I>&gt;<i> mouseover and mouseout
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 3D HTML &amp; CSS (notes in parentheses)
</I>&gt;<i> -----------------------
</I>&gt;<i>
</I>&gt;<i> &lt;style&gt;
</I>&gt;<i>
</I>&gt;<i> div {
</I>&gt;<i>     * Background image of space
</I>&gt;<i> }
</I>&gt;<i> ul {
</I>&gt;<i>     * Rotate to 3/4 view (We can no longer display a background on this
</I>&gt;<i> element, because it will become wafer-like when rotated; a &lt;model/&gt; will
</I>&gt;<i> maintain its desired shape, as it is really 3D.)
</I>&gt;<i> }
</I>&gt;<i> model {
</I>&gt;<i>     (some of the work will already be done for you by the ul rotation)
</I>&gt;<i>     * Rotate to proper perspective
</I>&gt;<i>     * Translate to desired depth/position
</I>&gt;<i>
</I>&gt;<i>     (in the syntax of -webkit-transition and -webkit-rotate, currently in
</I>&gt;<i> use today)
</I>&gt;<i>     * transition: rotate 3s ease-out;
</I>&gt;<i> }
</I>&gt;<i> model:hover {
</I>&gt;<i>     * rotateY(360deg);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> &lt;/style&gt;
</I>&gt;<i>
</I>&gt;<i> &lt;h1&gt;The Solar System in 3/4&lt;h1&gt;
</I>&gt;<i> &lt;div&gt;
</I>&gt;<i>     &lt;ul&gt;
</I>&gt;<i>         &lt;li&gt;
</I>&gt;<i>             &lt;a href=&quot;sun.html&quot;&gt;
</I>&gt;<i>                 &lt;model src=&quot;sun.xml&quot; alt=&quot;The Sun&quot; /&gt;
</I>&gt;<i>             &lt;/a&gt;
</I>&gt;<i>         &lt;/li&gt;
</I>&gt;<i>         &lt;li&gt;
</I>&gt;<i>             &lt;a href=&quot;mercury.html&quot;&gt;
</I>&gt;<i>                 &lt;model src=&quot;mercury.xml&quot; alt=&quot;Mercury&quot; /&gt;
</I>&gt;<i>             &lt;/a&gt;
</I>&gt;<i>         &lt;/li&gt;
</I>&gt;<i>         &lt;li&gt;
</I>&gt;<i>             &lt;a href=&quot;venus.html&quot;&gt;
</I>&gt;<i>                 &lt;model src=&quot;venus.xml&quot; alt=&quot;Venus&quot; /&gt;
</I>&gt;<i>             &lt;/a&gt;
</I>&gt;<i>         &lt;/li&gt;
</I>&gt;<i>         ...
</I>&gt;<i>     &lt;/ul&gt;
</I>&gt;<i> &lt;/div&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 3D JAVASCRIPT, 2D HTML &amp; CSS
</I>&gt;<i> -----------------------------------------------
</I>&gt;<i>
</I>&gt;<i> &lt;style&gt;
</I>&gt;<i>
</I>&gt;<i> canvas {
</I>&gt;<i>     * Height/Width of viewport
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> &lt;/style&gt;
</I>&gt;<i>
</I>&gt;<i> &lt;h1&gt;The Solar System in 3/4&lt;/h1&gt;
</I>&gt;<i> &lt;canvas id=&quot;solar-system&quot;&gt;
</I>&gt;<i>     &lt;!-- ALT CONTENT FOR BROWSERS NOT SUPPORTING &lt;canvas/&gt; --&gt;
</I>&gt;<i>     (Herein: Code from Example 1)
</I>&gt;<i> &lt;/canvas&gt;
</I>&gt;<i>
</I>&gt;<i> &lt;script&gt;
</I>&gt;<i>     (the following is a non-custom snippet from O3D's &quot;simple&quot; example --
</I>&gt;<i> webGL's implementation is slightly cleaner)
</I>&gt;<i>
</I>&gt;<i> function loadFile(context, path) {
</I>&gt;<i>   function callback(pack, parent, exception) {
</I>&gt;<i>     enableInput(true);
</I>&gt;<i>     if (exception) {
</I>&gt;<i>       alert(&quot;Could not load: &quot; + path + &quot;\n&quot; + exception);
</I>&gt;<i>       g_loadingElement.innerHTML = &quot;loading failed.&quot;;
</I>&gt;<i>     } else {
</I>&gt;<i>       g_loadingElement.innerHTML = &quot;loading finished.&quot;;
</I>&gt;<i>       // Generate draw elements and setup material draw lists.
</I>&gt;<i>       o3djs.pack.preparePack(pack, g_viewInfo);
</I>&gt;<i>       var bbox = o3djs.util.getBoundingBoxOfTree(g_client.root);
</I>&gt;<i>       g_camera.target = g_math.lerpVector(bbox.minExtent, bbox.maxExtent,
</I>&gt;<i> 0.5);
</I>&gt;<i>       var diag = g_math.length(g_math.subVector(bbox.maxExtent,
</I>&gt;<i>                                                 bbox.minExtent));
</I>&gt;<i>       g_camera.eye = g_math.addVector(g_camera.target, [0, 0, 1.5 * diag]);
</I>&gt;<i>       g_camera.nearPlane = diag / 1000;
</I>&gt;<i>       g_camera.farPlane = diag * 10;
</I>&gt;<i>       setClientSize();
</I>&gt;<i>       updateCamera();
</I>&gt;<i>       updateProjection();
</I>&gt;<i>
</I>&gt;<i>       // Manually connect all the materials' lightWorldPos params to the
</I>&gt;<i> context
</I>&gt;<i>       var materials = pack.getObjectsByClassName('o3d.Material');
</I>&gt;<i>       for (var m = 0; m &lt; materials.length; ++m) {
</I>&gt;<i>         var material = materials[m];
</I>&gt;<i>         var param = material.getParam('lightWorldPos');
</I>&gt;<i>         if (param) {
</I>&gt;<i>           param.bind(g_lightPosParam);
</I>&gt;<i>         }
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       g_finished = true;  // for selenium
</I>&gt;<i>
</I>&gt;<i>       // Comment out the next line to dump lots of info.
</I>&gt;<i>       if (false) {
</I>&gt;<i>         o3djs.dump.dump('---dumping context---\n');
</I>&gt;<i>         o3djs.dump.dumpParamObject(context);
</I>&gt;<i>
</I>&gt;<i>         o3djs.dump.dump('---dumping root---\n');
</I>&gt;<i>         o3djs.dump.dumpTransformTree(g_client.root);
</I>&gt;<i>
</I>&gt;<i>         o3djs.dump.dump('---dumping render root---\n');
</I>&gt;<i>         o3djs.dump.dumpRenderNodeTree(g_client.renderGraphRoot);
</I>&gt;<i>
</I>&gt;<i>         o3djs.dump.dump('---dump g_pack shapes---\n');
</I>&gt;<i>         var shapes = pack.getObjectsByClassName('o3d.Shape');
</I>&gt;<i>         for (var t = 0; t &lt; shapes.length; t++) {
</I>&gt;<i>           o3djs.dump.dumpShape(shapes[t]);
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         o3djs.dump.dump('---dump g_pack materials---\n');
</I>&gt;<i>         var materials = pack.getObjectsByClassName('o3d.Material');
</I>&gt;<i>         for (var t = 0; t &lt; materials.length; t++) {
</I>&gt;<i>           o3djs.dump.dump (
</I>&gt;<i>               '  ' + t + ' : ' + materials[t].className +
</I>&gt;<i>               ' : &quot;' + materials[t].name + '&quot;\n');
</I>&gt;<i>           o3djs.dump.dumpParams(materials[t], '    ');
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         o3djs.dump.dump('---dump g_pack textures---\n');
</I>&gt;<i>         var textures = pack.getObjectsByClassName('o3d.Texture');
</I>&gt;<i>         for (var t = 0; t &lt; textures.length; t++) {
</I>&gt;<i>           o3djs.dump.dumpTexture(textures[t]);
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         o3djs.dump.dump('---dump g_pack effects---\n');
</I>&gt;<i>         var effects = pack.getObjectsByClassName('o3d.Effect');
</I>&gt;<i>         for (var t = 0; t &lt; effects.length; t++) {
</I>&gt;<i>           o3djs.dump.dump ('  ' + t + ' : ' + effects[t].className +
</I>&gt;<i>                   ' : &quot;' + effects[t].name + '&quot;\n');
</I>&gt;<i>           o3djs.dump.dumpParams(effects[t], '    ');
</I>&gt;<i>         }
</I>&gt;<i>       }
</I>&gt;<i>     }
</I>&gt;<i>   }
</I>&gt;<i>     ...
</I>&gt;<i>
</I>&gt;<i>     (and on, literally, for pages)
</I>&gt;<i> &lt;/script&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> While the paradigms of HTML are inherently dimensionless, media types are
</I>&gt;<i> not.  CSS and JavaScript are embracing 3D in their own ways, HTML is
</I>&gt;<i> obviously not giving its due diligence.  Tons of JS just to open a 3D
</I>&gt;<i> viewport in HTML is far from what I would consider a complete spec.  The
</I>&gt;<i> wafer-boxes that 3D CSS produce are an ill of HTML, not of CSS.
</I>&gt;<i>
</I>&gt;<i> -Brian MB
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Mon, Nov 2, 2009 at 4:46 AM, David Workman &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">workmad3 at gmail.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;<i> I'm in perfect agreement regarding the rational behind having a model tag as
</I>&gt;<i> I agree with having more semantic tags in HTML. However, I don't think a
</I>&gt;<i> model tag would work as described as it would provide no real extra benefits
</I>&gt;<i> and would just confuse document authors.
</I>&gt;<i>
</I>&gt;<i> The reason I feel this is basically down to the fact that 3d models don't
</I>&gt;<i> have a visual representation in the same way that images do. A 3d model file
</I>&gt;<i> is just a list of data that needs rendering into a 2d image for display.
</I>&gt;<i> There isn't really a standardised way to do this (not in the same way as
</I>&gt;<i> with images, with standardised png, jpg, bmp, etc. as well known and
</I>&gt;<i> commonplace formats with commonplace methods of display), and on top of that
</I>&gt;<i> it isn't a 3d model you a displaying, but a 2d representation (i.e. an
</I>&gt;<i> &lt;img&gt;). If the representation is static, it isn't really a 3d model as it's
</I>&gt;<i> just a 2d image, and if it isn't static then you need scripting support,
</I>&gt;<i> drawing support, rendering and the whole host of items that require
</I>&gt;<i> javascript hooks and would logically make such a model more suited to a 3d
</I>&gt;<i> canvas (which I believe is to be supported eventually under a normal
</I>&gt;<i> &lt;canvas&gt; tag). As such, I don't see a place for a &lt;model&gt; tag in the current
</I>&gt;<i> environment as a merely semantic element, and adding more than just
</I>&gt;<i> semantics to the tag would be overlapping it with other efforts.
</I>&gt;<i>
</I>&gt;<i> David W.
</I>&gt;<i>
</I>&gt;<i> ________________________________
</I>&gt;<i> &#20840;&#26032; Windows 7&#65306;&#23547;&#25214;&#26368;&#36866;&#21512;&#24744;&#30340; PC&#12290; &#20102;&#35299;&#35814;&#24773;&#12290;
</I>
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="066206.html">[whatwg] &lt;model/&gt;: A 3D Equivalent to &lt;img/&gt;
</A></li>
	<LI>Next message: <A HREF="066184.html">[whatwg] pushState / replaceState nits
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#66207">[ date ]</a>
              <a href="thread.html#66207">[ thread ]</a>
              <a href="subject.html#66207">[ subject ]</a>
              <a href="author.html#66207">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
