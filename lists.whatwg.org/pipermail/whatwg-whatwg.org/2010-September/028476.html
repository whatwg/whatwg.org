<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Timed tracks: feedback compendium
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Timed%20tracks%3A%20feedback%20compendium&In-Reply-To=%3CPine.LNX.4.64.1009030127270.3392%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="070813.html">
   <LINK REL="Next"  HREF="070687.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Timed tracks: feedback compendium</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Timed%20tracks%3A%20feedback%20compendium&In-Reply-To=%3CPine.LNX.4.64.1009030127270.3392%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] Timed tracks: feedback compendium">ian at hixie.ch
       </A><BR>
    <I>Tue Sep  7 16:19:17 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="070813.html">[whatwg] ArrayBuffer and ByteArray questions
</A></li>
        <LI>Next message: <A HREF="070687.html">[whatwg] Timed tracks: feedback compendium
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28476">[ date ]</a>
              <a href="thread.html#28476">[ thread ]</a>
              <a href="subject.html#28476">[ subject ]</a>
              <a href="author.html#28476">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
On Fri, 23 Jul 2010, Sam Dutton wrote:
&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; The addCueRange() API has been removed and replaced with a feature 
</I>&gt;<i> &gt;&gt; based on the subtitle mechanism. &lt;&lt;
</I>&gt;<i> 
</I>&gt;<i> Do you mean the use of timed track cues?
</I>
Yes.


&gt;<i> A couple of minor queries re 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#the-track-element:">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#the-track-element:</A>
</I>&gt;<i> 
</I>&gt;<i> * 'time track' is referred to a couple of times -- it's not clear why 
</I>&gt;<i> this is used instead of 'timed track'
</I>
Fixed.


&gt;<i> * 'the WebSRT file must WebSRT file using cue text' -- I guess this 
</I>&gt;<i> should be 'the WebSRT file must be a WebSRT file using cue text'
</I>
Fixed.


On Fri, 23 Jul 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> I'm not a fan of pauseOnExit, though, mostly because it seems 
</I>&gt;<i> non-trivial to implement. Since it is last in the argument list of 
</I>&gt;<i> TimedTrackCue, it will be easy to just ignore when implementing. I still 
</I>&gt;<i> don't think the use cases for it are enough to motivate the 
</I>&gt;<i> implementation cost.
</I>
Really? It seems like automatically pausing video half-way would be a very 
common thing to do; e.g. to play an interstitial ad, or to play a specific 
sound effect in a sound file containing multiple sound effects, or to play 
a video up to the point where the user has to make a choice or has to ask 
to move on to the next slide. There's basically no good way to do this 
kind of thing without this feature.


&gt;<i> &gt; On Fri, 31 Jul 2009, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; * It is unclear, which of the given alternative text tracks in 
</I>&gt;<i> &gt; &gt; different languages should be displayed by default when loading an 
</I>&gt;<i> &gt; &gt; &lt;itext&gt; resource. A @default attribute has been added to the &lt;itext&gt; 
</I>&gt;<i> &gt; &gt; elements to allow for the Web content author to tell the browser 
</I>&gt;<i> &gt; &gt; which &lt;itext&gt; tracks he/she expects to be displayed by default. If 
</I>&gt;<i> &gt; &gt; the Web author does not specify such tracks, the display depends on 
</I>&gt;<i> &gt; &gt; the user agent (UA - generally the Web browser): for accessibility 
</I>&gt;<i> &gt; &gt; reasons, there should be a field that allows users to always turn 
</I>&gt;<i> &gt; &gt; display of certain &lt;itext&gt; categories on. Further, the UA is set to 
</I>&gt;<i> &gt; &gt; a default language and it is this default language that should be 
</I>&gt;<i> &gt; &gt; used to select which &lt;itext&gt; track should be displayed.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; It's not clear to me that we need a way to do this; by default 
</I>&gt;<i> &gt; presumably tracks would all be off unless the user wants them, in 
</I>&gt;<i> &gt; which case the user's preferences are paramount. That's what I've 
</I>&gt;<i> &gt; specced currently. However, it's easy to override this from script.
</I>&gt;<i> 
</I>&gt;<i> It seems to me that this is much like &lt;video autoplay&gt; in that if we 
</I>&gt;<i> don't provide a markup solution, everyone will use scripts and it will 
</I>&gt;<i> be more difficult for the UA to override with user prefs.
</I>
What would we need for this then? Just a way to say &quot;by the way, in 
addition to whatever the user said, also turn this track on&quot;? Or do we 
need something to say &quot;by default, override the user's preferences for 
this video and instead turn on this track and turn off all others&quot;? Or 
something else? It's not clear to me what the use case is where this 
would be useful declaratively.


&gt;<i> &gt; On Fri, 31 Jul 2009, Philip J&#228;genstedt wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; * Security. What restrictions should apply for cross-origin loading?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Currently the files have to be same-origin. My plan is to wait for 
</I>&gt;<i> &gt; CORS to be well established and then use it for timed tracks, video 
</I>&gt;<i> &gt; files, images on &lt;canvas&gt;, text/event-stream resources, etc.
</I>&gt;<i> 
</I>&gt;<i> If I'm interpreting the track fetch algorithm correctly cross-origin is 
</I>&gt;<i> strictly enforced and treated as a network error. This is different from 
</I>&gt;<i> e.g. &lt;img&gt; and &lt;video&gt;, but it seems to make things simpler, so I'm fine 
</I>&gt;<i> with that. It also ensures that JavaScript fallback handling of &lt;track&gt; 
</I>&gt;<i> won't fail just because of cross-origin in XHR.
</I>
Right. The difference between captions and video data is that you can get 
a heck of a lot more data out of a caption file. Similarly, we wouldn't 
expose the captions from cross-origin files to script (oops, I had 
forgotten to block that -- fixed!) without CORS opt-in.


&gt;<i> &gt; &gt; * Complexity. There is no limit to the complexity one could argue 
</I>&gt;<i> &gt; &gt; for (bouncing ball multi-color karaoke with fan 
</I>&gt;<i> &gt; &gt; translations/annotations anyone?). We should accept that some use 
</I>&gt;<i> &gt; &gt; cases will require creative use of scripts/SVG/etc and not even try 
</I>&gt;<i> &gt; &gt; to solve them up-front. Draw a line and stick to it.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Agreed. Hopefully you agree with where I drew the line! :-)
</I>&gt;<i> 
</I>&gt;<i> Actually, I think both karaoke (in-cue timestamps) and ruby are 
</I>&gt;<i> borderline, but it depends on how difficult it is to implement.
</I>
FWIW, a lot of the use cases that were found (see the wiki), and that I 
saw over the few weeks that I was doing this, had intracue timing. We 
don't have to have it, obviously, but it doesn't look especially hard to 
do and if we can do it I think it'd be a good win. However, if it is 
indeed more work than it appears to be, then we can totally drop it.


&gt;<i> One thing in particular to note about karaoke is that even with in-cue 
</I>&gt;<i> timestamps, CSS still won't be enough to get the typical effect of 
</I>&gt;<i> &quot;wiping&quot; individual characters from one style to another, since the 
</I>&gt;<i> smallest unit you can style is a single character. To get that effect 
</I>&gt;<i> you'd have to render the characters in two styles and then cut them 
</I>&gt;<i> together (with &lt;canvas&gt; or just clipping &lt;div&gt;s). Arguably, this is a 
</I>&gt;<i> presentation issue that could be fixed without changing WebSRT.
</I>
Yes, it seems to me that that is the kind of thing we should add in 
transitions -- making the transition be spatial, so that instead of 
gradually going from red to blue, it snaps from red to blue but does so 
gradually more and more to the right, say.


&gt;<i> &gt; On Thu, 15 Apr 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Further, SRT has no way to specify which language it is written in
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; What's the use case?
</I>&gt;<i> 
</I>&gt;<i> As hints for font selection
</I>
Are independent SRT processors really going to do per-language font 
selection? How do they do it today?


&gt;<i> and speech synthesis.
</I>
Are independent SRT processors really going to do audio descriptions any 
time soon? I've only ever seen this in highly experimental settings.


&gt;<i> [...] the positioning of individual cues is still not controlled by CSS 
</I>&gt;<i> but rather by e.g. L:50%.
</I>
I considered this issue carefully when speccing WebSRT. My conclusion 
(after watching a lot more TV than I'm used to) was that in practice 
subtitle positioning is not strictly a presentational issue -- that is, 
you can't just swap one set of styles for another and have equally good 
results, you have to control the positioning on a per-cue basis regardless 
of the styling. This is because you have to avoid burnt-in text, or 
overlap burnt-in text, or because you need to align text with a speaker, 
or show which audio channel the text came from (e.g. for people talking 
off camera in a very directional sense), etc.


&gt;<i> &gt; &gt; I'm also confused about the removal of the chapter tracks. These are 
</I>&gt;<i> &gt; &gt; also time-aligned text files and again look very similar to SRT.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I've also included support for chapters. Currently this support is not 
</I>&gt;<i> &gt; really fully fleshed out; in particular it's not defined how a UA 
</I>&gt;<i> &gt; should get chapter names out of the WebSRT file. I would like 
</I>&gt;<i> &gt; implementation feedback on this topic -- what do browser vendors 
</I>&gt;<i> &gt; envisage exposing in their UI when it comes to chapters? Just markers 
</I>&gt;<i> &gt; in the timeline? A dropdown of times? Chapter titles? Styled, 
</I>&gt;<i> &gt; unstyled?
</I>&gt;<i> 
</I>&gt;<i> A sorted list of chapters in a context menu at minimum, with the name of 
</I>&gt;<i> the chapter and probably the time where it starts. More fancy things on 
</I>&gt;<i> the timeline would be cool, but given that it's going to look completely 
</I>&gt;<i> different in all browsers and not be stylable I wonder if there's much 
</I>&gt;<i> point to it.
</I>
Ok, I've defined that you just grab the raw text to get the chapter name.


&gt;<i> Finally, random feedback:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#attr-track-kind">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#attr-track-kind</A>
</I>&gt;<i> 
</I>&gt;<i> The distinction between subtitles and captions isn't terribly clear.
</I>&gt;<i> 
</I>&gt;<i> It says that subtitles are translations, but plain transcriptions 
</I>&gt;<i> without cues for the hard of hearing would also be subtitles.
</I>&gt;<i> 
</I>&gt;<i> How does one categorize translations that are for the HoH?
</I>
I've tried to clarify this.


&gt;<i> Alternatively, might it not be better to simply use the voice &quot;sound&quot; 
</I>&gt;<i> for this and let the default stylesheet hide those cues? When writing 
</I>&gt;<i> subtitles I don't want the maintenance overhead of 2 different versions 
</I>&gt;<i> that differ only by the inclusion of [doorbell rings] and similar. 
</I>&gt;<i> Honestly, it's more likely that I just wouldn't bother with 
</I>&gt;<i> accessibility for the HoH at all. If I could add it with &lt;sound&gt;doorbell 
</I>&gt;<i> rings, it's far more likely I would do that, as long as it isn't 
</I>&gt;<i> rendered by default. This is my preferred solution, then keeping only 
</I>&gt;<i> one of kind=subtitles and kind=captions. Enabling the HoH-cues could 
</I>&gt;<i> then be a global preference in the browser, or done from the context 
</I>&gt;<i> menu of individual videos.
</I>
I don't disagree with this, but I fear it might be too radical a step for 
the caption-authoring community to take at this point.


&gt;<i> If we must have both kind=subtitles and kind=captions, then I'd suggest 
</I>&gt;<i> making the default subtitles, as that is without a doubt the most common 
</I>&gt;<i> kind of timed text. Making captions the default only means that most 
</I>&gt;<i> timed text will be mislabeled as being appropriate for the HoH when it 
</I>&gt;<i> is not.
</I>
Ok, I've changed the default. However, I'm not fighting this battle if it 
comes up again, and will just change it back if people don't defend having 
this as the default. (And then change it back again if the browsers pick 
&quot;subtitles&quot; in their implementations after all, of course.)

Note that captions aren't just for users that are hard-of-hearing. Most of 
the time when I use timed tracks, I want captions, because the reason I 
have them enabled is that I have the sound muted.


On Fri, 23 Jul 2010, Sam Dutton wrote:
&gt;<i>
</I>&gt;<i> Is trackgroup out of the spec?
</I>
What is trackgroup?


On Fri, 23 Jul 2010, Henri Sivonen wrote:
&gt;<i> 
</I>&gt;<i> &gt; - A set of rules and processing models to hold it all together.
</I>&gt;<i> 
</I>&gt;<i> Is it intentional that WebSRT doesn't come with any examples?
</I>
Only insofar as I prefer to not do non-normative material until such time 
as the normative material is someone stable. :-)


&gt;<i> &gt; - Keep implementation costs for standalone players low.
</I>&gt;<i> 
</I>&gt;<i> I think this should be a non-goal. It seems to me that trying to cater 
</I>&gt;<i> for non-browser user agents or non-Web uses in Web specs leads to bad 
</I>&gt;<i> Web specs. I think by optimizing for standalone players WebSRT falls 
</I>&gt;<i> into one of the common traps for Web specs. I think we should design for 
</I>&gt;<i> the Web (where the rendering is done by browser engines).
</I>
I think that would be somewhat arrogant. :-) We can keep implementation 
costs for standalone players low without making bad specs -- we just have 
to _also_ design for browsers. I think WebSRT does pretty well on this 
front, in fact.


&gt;<i> &gt; - Use existing technologies where appropriate.
</I>&gt;<i> [...]
</I>&gt;<i> &gt; - Try as much as possible to have things Just Work.
</I>&gt;<i> 
</I>&gt;<i> I think by specifying a standalone cue text parser WebSRT fails on these 
</I>&gt;<i> counts compared to reusing the HTML fragment parsing algorithm for 
</I>&gt;<i> parsing cue text.
</I>
HTML parsing is a disaster zone that we should avoid at all costs, IMHO. I 
certainly don't think it would make any sense to propagate that format 
into anywhere where we don't absolutely have to propagate it.


&gt;<i> Specifying a new parser for turning HTML-like tags into a tree structure 
</I>&gt;<i> that can be used as the input of a CSS formatter fails to reuse existing 
</I>&gt;<i> technologies where appropriate (though obviously we disagree on what's 
</I>&gt;<i> &quot;appropriate&quot;).
</I>
I agree with the parenthetical. :-)


&gt;<i> &gt; I first researched (with some help from various other contributors - 
</I>&gt;<i> &gt; thanks!) what kinds of timed tracks were common. The main classes of 
</I>&gt;<i> &gt; use cases I tried to handle were plain text subtitles (translations) 
</I>&gt;<i> &gt; and captions (transcriptions) with minimal inline formatting and 
</I>&gt;<i> &gt; karaoke support, chapter markers so that browsers could provide quick 
</I>&gt;<i> &gt; jumps to points in the video, text-driven audio descriptions, and 
</I>&gt;<i> &gt; application- specific timed data.
</I>&gt;<i> 
</I>&gt;<i> Why karaoke and application-specific data? Those both seem like feature 
</I>&gt;<i> creep compared to the core cases of subtitles and captions.
</I>
Karaoke is very cheap and addresses a lot of use cases; application- 
specific data is even cheaper and also addreses a lot of other use cases.


&gt;<i> &gt; If we don't use HTML wholesale, then there's really no reason to use 
</I>&gt;<i> &gt; HTML at all. (And using HTML wholesale is not really an option, as you 
</I>&gt;<i> &gt; say above.)
</I>&gt;<i> 
</I>&gt;<i> I disagree. The most obvious way of reusing existing infrastructure in 
</I>&gt;<i> browsers, the most obvious way of getting support for future syntax 
</I>&gt;<i> changes that support attributes or new tag names and the most obvious 
</I>&gt;<i> way to get error handling that behaves in the way the appearance of the 
</I>&gt;<i> syntax suggests is to reuse the HTML fragment parsing algorithm for 
</I>&gt;<i> parsing the cue text.
</I>
HTML parsing is one of the most convoluted, quirk-laden, unintuitive and 
expensive syntaxes... Its extensibility story is a disaster (there's so 
many undocumented and continually evolving constraints that any addition 
is massively expensive), its implementation drags with it all kinds of 
crazy dependencies on the DOM, event loop interactions, scripting, and so 
forth, and it has a highly inconsistent syntax.

I'm not at all convinced reusing it would be &quot;obvious&quot;.


&gt;<i> &gt; I've defined some CSS extensions to allow us to use CSS with SRT.
</I>&gt;<i> 
</I>&gt;<i> The new CSS pseudos would be unnecessary if each cue formed a DOM by 
</I>&gt;<i> parsing &quot;&lt;!DOCTYPE html&gt;&quot; as HTML (to get a skeleton DOM in the 
</I>&gt;<i> standards mode) and then document.body.innerHTML were set to the cue 
</I>&gt;<i> text.
</I>
You'd still need the past/future pseudos, and a way to jump into the cue 
from the regular DOM.


&gt;<i> &gt; It would also result in some pretty complicated situations, like 
</I>&gt;<i> &gt; captions containing &lt;video&gt;s themselves.
</I>&gt;<i> 
</I>&gt;<i> If the processing is defined in terms of nested browsing contexts, the 
</I>&gt;<i> task queue and innerHTML setter, the &quot;right&quot; behavior falls out of that.
</I>
That has not worked out so well for us in the past. (Just ask roc how well 
the behaviour of combining &lt;iframe&gt;s and SVG transforms fell out of 
defining things in terms of previously-implemented constructs.)

On Sun, 25 Jul 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> I think if we have a mixed set of .srt files out there, some of which 
</I>&gt;<i> are old-style srt files (with line numbers, without WebSRT markup) and 
</I>&gt;<i> some are WebSRT files with all the bells and whistles and with 
</I>&gt;<i> additional external CSS files, we create such a mess for that existing 
</I>&gt;<i> ecosystem that we won't find much love.
</I>
I'm not sure our goal is to find love here, but in general I would agree 
that it would be better to have one format than two. I don't see why we 
wouldn't just have one format here though. The idea of WebSRT is to be 
sufficiently backwards-compatible that that is possible.


On Mon, 26 Jul 2010, Silvia Pfeiffer wrote:
&gt;<i> &gt; On Thu, 16 Jul 2009, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt;&gt; * the &quot;type&quot; attribute is meant to both identify the mime type of the 
</I>&gt;<i> &gt;&gt; format and the character set used in the file.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; It's not clear that the former is useful. The latter may be useful; I 
</I>&gt;<i> &gt; haven't supported that yet.
</I>&gt;<i> 
</I>&gt;<i> If the element is to support a single format in a single character set, 
</I>&gt;<i> then there is no need for a MIME type. So, we need to be clear whether 
</I>&gt;<i> we want to restrict our option here for multiple formats.
</I>
As specified the spec supports multiple formats, it just only talks about 
WebSRT currently. (If it becomes likely that browsers will have different 
sets of supported formats, we can add a type=&quot;&quot; attribute to help browsers 
find the right files without checking each one, but that's not necessary 
unless that becomes a likely problem.)


&gt;<i> &gt;&gt; The character set question is actually a really difficult problem to 
</I>&gt;<i> &gt;&gt; get right, because srt files are created in an appropriate character 
</I>&gt;<i> &gt;&gt; set for the language, but there is no means to store in a srt file 
</I>&gt;<i> &gt;&gt; what character set was used in its creation. That's a really bad 
</I>&gt;<i> &gt;&gt; situation to be in for the Web server, who can then only take an 
</I>&gt;<i> &gt;&gt; educated guess. By giving the ability to the HTML author to specify 
</I>&gt;<i> &gt;&gt; the charset of the srt file with the link, this can be solved.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yeah, if this is a use case people are concerned about, then I agree 
</I>&gt;<i> &gt; that a solution at the markup level makes sense.
</I>&gt;<i> 
</I>&gt;<i> If we really are to use WebSRT because (amongst other reasons) it allows 
</I>&gt;<i> reuse of existing srt files, then we need to introduce a means to 
</I>&gt;<i> provide the charset, since almost none of the srt files in the wild that 
</I>&gt;<i> I have looked at were in UTF-8, but in all sorts of other character 
</I>&gt;<i> sets. Another solution to this problem would be to have WebSRT know what 
</I>&gt;<i> charset their characters are in - then we don't need to add such 
</I>&gt;<i> information to the &lt;track&gt; element. It will still not work with legacy 
</I>&gt;<i> SRT files though.
</I>
I've added a charset=&quot;&quot; attribute to allow authors to provide the 
character encoding for legacy SRT files. WebSRT files are required to be 
UTF-8, however (legacy SRT files that are not UTF-8 are considered 
non-conforming).


&gt;<i> You mention that karaoke and lyrics are supported by WebSRT, so could we 
</I>&gt;<i> add them to the track kinds?
</I>
Why would they need new script kinds? Isn't &quot;subtitles&quot; enough?


&gt;<i> In the proposal at 
</I>&gt;<i> <A HREF="http://www.w3.org/WAI/PF/HTML/wiki/Media_TextAssociations">http://www.w3.org/WAI/PF/HTML/wiki/Media_TextAssociations</A> a @media 
</I>&gt;<i> attribute was suggested. The idea is that the @media attribute would 
</I>&gt;<i> contain a media query describe what user environment, e.g. what devices 
</I>&gt;<i> the text track is suitable for. If for example subtitles require a 
</I>&gt;<i> minimum of 30 characters width to be displayed properly, but certain 
</I>&gt;<i> devices cannot support this, the subtitles would be pretty useless on 
</I>&gt;<i> such a device. Seeing as the &lt;source&gt; elements on media elements have 
</I>&gt;<i> that attribute, too, it wouldn't be too difficult to implement the same 
</I>&gt;<i> here.
</I>&gt;<i> 
</I>&gt;<i> Is this a &quot;v2&quot; feature or is it considered to be added?
</I>
I think we should probably wait to see how well media=&quot;&quot; gets used with 
&lt;source&gt; before adding it to &lt;track&gt;, but I don't have any strong feelings 
on this front.


&gt;<i> (NOTE: there is a typo in section 4.8.10.10.5 when describing 
</I>&gt;<i> MutableTimedTrack - in the green box, addCue() is repeated, but the 
</I>&gt;<i> second one should be called removeCue() ).
</I>
Fixed.


&gt;<i> I wonder about the order in which &lt;track&gt; elements, mutable tracks, and 
</I>&gt;<i> in-band TimedTracks are held. 4.8.10.10.1 states the above order (i.e. 
</I>&gt;<i> &lt;track&gt; first, then mutable, then in-band). That &lt;track&gt; comes first 
</I>&gt;<i> makes sense, since it is possible that different browsers choose 
</I>&gt;<i> different media resources which may have different in-band tracks. Thus, 
</I>&gt;<i> at least the numbering across the TimedTracks from &lt;track&gt; elements is 
</I>&gt;<i> consistent. However, the in-band tracks will be available after the 
</I>&gt;<i> media resource has been parsed, while the mutable tracks are 
</I>&gt;<i> script-created and could be created dynamically through user 
</I>&gt;<i> interaction. Does that mean, that the index of the in-band tracks can 
</I>&gt;<i> change during the course of the Web page depending on how many mutable 
</I>&gt;<i> tracks are available at a time?
</I>
The order can always change, e.g. if a &lt;track&gt; element is dynamically 
inserted.


&gt;<i> I would probably also more explicitly state that in-band tracks are only 
</I>&gt;<i> chosen out of the media resource that is in @currentSrc.
</I>
How could the spec be interpreted otherwise? The only place that invokes 
the &quot;steps to expose a media-resource-specific timed track&quot; algorithm 
happens deep in the processing of the media resource.


&gt;<i> I am concerned about the definition of the TimedTrackCue. 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#timedtrackcue">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#timedtrackcue</A>
</I>&gt;<i> 
</I>&gt;<i> It has the following IDL attributes:
</I>&gt;<i>   readonly attribute DOMString direction;
</I>&gt;<i>   readonly attribute boolean snapToLines;
</I>&gt;<i>   readonly attribute long linePosition;
</I>&gt;<i>   readonly attribute long textPosition;
</I>&gt;<i>   readonly attribute long size;
</I>&gt;<i>   readonly attribute DOMString alignment;
</I>&gt;<i> 
</I>&gt;<i> All of these are related to CSS attributes and I wonder how that 
</I>&gt;<i> interacts. For example, what if the @direction says &quot;vertical&quot; and the 
</I>&gt;<i> CSS attribute for the cue says direction:rtl; ?
</I>
The .direction IDL attribute has more to do with the 'writing-mode' CSS 
property than 'direction', but in any case, the interaction is defined in 
detail in the rendering section.


&gt;<i> I am also confused about the snapToLines and linePosition attributes: 
</I>&gt;<i> IIUC the linePosition is meant to be either a percentage of the video 
</I>&gt;<i> dimensions or a line position relative to the first line of the cue. 
</I>&gt;<i> Does that latter mean an offset from where the first line of the cue 
</I>&gt;<i> should theoretically be?
</I>
See the rendering section for the formal definition.


&gt;<i> What is the purpose of it?
</I>
It allows people to specifically put cues on specific lines knowing that 
they will not overlap with each other. For example, in a scene with much 
overlapping dialog, you could put all the text of one person on line -4, 
and all the text of another on -2, and provided you only used two lines 
per cue, you'd know that they would be rendered in a consistent manner 
each time, rather than jumping up or down based on what other cues 
happened to be up at the time the cue came up.


&gt;<i> Does the earlier mean that we can only provide text for video and not 
</I>&gt;<i> for audio, which has no dimensions?
</I>
If you want the browser to render cues, you have to use a &lt;video&gt; element 
so that there is somewhere to render them. You can play audio with the 
&lt;video&gt; element, and you can use &lt;audio&gt; and manually render the cues from 
JS if desired.

We could provide an API dedicated to making it easier to render cues 
manually if desired (firing an event or callback with the actual cue for 
each cue that shows, for example).


&gt;<i> What if we have a lyrics file for a piece of music? Can that not be 
</I>&gt;<i> rendered?
</I>
Sure, it works the same as subtitles.


&gt;<i> And what if we wanted to render captions underneath a video rather than 
</I>&gt;<i> inside video dimensions? Can that be achieved somehow?
</I>
You'd need to script it, currently. (I didn't see many (any?) cases of 
this in my research, so I didn't provide a declarative solution.)


&gt;<i> In <A HREF="http://www.mail-archive.com/whatwg@lists.whatwg.org/msg10395.html">http://www.mail-archive.com/whatwg@lists.whatwg.org/msg10395.html</A>
</I>&gt;<i> Dave Singer wrote:
</I>&gt;<i> &gt; Linking into a cue-range would be using its beginning or end as a seek 
</I>&gt;<i> &gt; point, or its duration as a restricted view of the media (&quot;only show 
</I>&gt;<i> &gt; me cue-range called InTheBathroom&quot;). Linking out of a cue-range would 
</I>&gt;<i> &gt; be establishing a click-through URL that would be dispatched directly 
</I>&gt;<i> &gt; if the user clicked on the media during that range (dispatched without 
</I>&gt;<i> &gt; script).
</I>&gt;<i> 
</I>&gt;<i> I believe in these use cases, too.
</I>
My reply in:

   <A HREF="http://www.mail-archive.com/whatwg@lists.whatwg.org/msg10469.html">http://www.mail-archive.com/whatwg@lists.whatwg.org/msg10469.html</A>

...still applies.


&gt;<i> It is possible to jump to a cue range through its number in the list in 
</I>&gt;<i> the media element using JavaScript and setting the @currentTime to that 
</I>&gt;<i> cue range's start time. However, it has not yet been defined whether 
</I>&gt;<i> there is a relationship between media fragment URIs and timed tracks. 
</I>&gt;<i> The media framgent URI specification has such URIs defined as e.g. 
</I>&gt;<i> <A HREF="http://example.com/video.ogv#id=">http://example.com/video.ogv#id=</A>&quot;InTheBathroom&quot; and cues have a textual 
</I>&gt;<i> identifier, so we can put these two together to enable this. Such URIs 
</I>&gt;<i> will then be able to be used in the @src attribute or a media element 
</I>&gt;<i> and focus the view on that cue, just like temporal media fragments do 
</I>&gt;<i> with a random time range.
</I>
I'm not sure I follow. Presumably this is all for in-band timed tracks, in 
which case the HTML spec isn't really involved.


&gt;<i> For linking out of a cue, there is a need to allow having hyperlinks in 
</I>&gt;<i> cues. IIUC this is currently only possible by using a HTML-style markup 
</I>&gt;<i> in the cue, declaring the cue as kind=metadata and calling 
</I>&gt;<i> getCueAsSource() on the cue, then running your own overlays and shoving 
</I>&gt;<i> the retrieved text to the innerHTML of that overlay.
</I>
Having a hyperlink in a cue seems like really bad UI (having any temporal 
interactive UI is typically highly inaccessible, and is generally only 
considered a good idea in games). If you want to make the whole video 
into a link (as Dave suggested in the e-mail above, if I understood it 
correctly) then you don't need anything to do with timed tracks.


&gt;<i> While that works, it seems like a lot of hoops to jump through just to 
</I>&gt;<i> be able to use a bit of HTML markup - in particular having to run your 
</I>&gt;<i> own overlay. Could we introduce a kind=htmlfragment type where it is 
</I>&gt;<i> obvious that the text is HTML and that the fragment parser can be run 
</I>&gt;<i> automatically and display it through the given display mechanisms?
</I>
I would on the contrary think that that would be something we should 
_discourage_, not encourage!


&gt;<i> Many existing subtitle formats and similar media-time-aligned text 
</I>&gt;<i> formats contain file-wide name-value pairs that explain metadata for the 
</I>&gt;<i> complete resource. An example are Lyrics files, e.g.
</I>&gt;<i> 
</I>&gt;<i> On Tue, 20 Apr 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Lyrics (LRC) files typically look like this:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; [ti:Can't Buy Me Love]
</I>&gt;<i> &gt; [ar:Beatles, The]
</I>&gt;<i> &gt; [au:Lennon &amp; McCartney]
</I>&gt;<i> &gt; [al:Beatles 1 - 27 #1 Singles]
</I>&gt;<i> &gt; [by:Wooden Ghost]
</I>&gt;<i> &gt; [re:A2 Media Player V2.2 lrc format]
</I>&gt;<i> &gt; [ve:V2.20]
</I>&gt;<i> &gt; [00:00.45]Can't &lt;00:00.75&gt;buy &lt;00:00.95&gt;me &lt;00:01.40&gt;love,
</I>&gt;<i> &gt; &lt;00:02.60&gt;love&lt;00:03.30&gt;, &lt;00:03.95&gt;love, &lt;00:05.30&gt;love&lt;00:05.60&gt;
</I>&gt;<i> &gt; [00:05.70]&lt;00:05.90&gt;Can't &lt;00:06.20&gt;buy &lt;00:06.40&gt;me &lt;00:06.70&gt;love,
</I>&gt;<i> &gt; &lt;00:08.00&gt;love&lt;00:08.90&gt;
</I>&gt;<i> 
</I>&gt;<i> You can see that there are title, artist, author, album, related 
</I>&gt;<i> content, version and similar metadata information headers on this file. 
</I>&gt;<i> Other examples contain copyright information and usage rights - 
</I>&gt;<i> important information to understand and deal with when distributing 
</I>&gt;<i> media-time-aligned text files on a medium such as the Web.
</I>
I don't really see why we would want to embed this in a timed track. Even 
in HTML embedding this kind of information has never taken off. We would 
need to have very compelling use cases, implementation experience, and 
implementation committements to move in such a direction, IMHO.


&gt;<i> I would think it'd be good to define a standard means of extracting 
</I>&gt;<i> plain text out of any type of cue, so it will be possible to hand this 
</I>&gt;<i> to e.g. the accessibility API for reading back.
</I>
Getting the raw data is already possible, unless I misunderstood what you 
meant.


&gt;<i> I would actually like to see an interface where the chapter makers can 
</I>&gt;<i> be used for navigation through the media resource, e.g. as you are 
</I>&gt;<i> playing back the media file, you can press SHIFT-rightarrow and 
</I>&gt;<i> SHIFT-leftarrow to navigate back and forth within a track (in 
</I>&gt;<i> particularly within a chapter track). This is particularly important for 
</I>&gt;<i> blind users.
</I>
That's up to the browsers.


&gt;<i> &gt; In WebSRT, this would be:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  10:00.000 --&gt; 20:00.000
</I>&gt;<i> &gt;  { title: &quot;Chapter 2&quot;, description: &quot;Some blah relating to chapter 2&quot;, image: &quot;/images/chapter2.png&quot; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  20:00.000 --&gt; 30:00.000
</I>&gt;<i> &gt;  { title: &quot;Chapter 3&quot;, description: &quot;Chapter 3 blah&quot;, image: &quot;/images/chapter3.png&quot; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; (Here I'm assuming that you want to store the data as JSON. For 
</I>&gt;<i> &gt; kind=metadata files, you can put anything you want in the cue so long 
</I>&gt;<i> &gt; as you don't have a blank line in there.)
</I>&gt;<i> 
</I>&gt;<i> I think it is a powerful idea to have a track kind that allows for 
</I>&gt;<i> everything. This provides a platform to put absolutely anything into a 
</I>&gt;<i> time-aligned form for a media resource. The standardisation aspect about 
</I>&gt;<i> it is the means in which the association between the data and the media 
</I>&gt;<i> resource happens, such that at least the cues can be extracted in a 
</I>&gt;<i> standard manner. However, it opens up an issue about parsing and 
</I>&gt;<i> display.
</I>&gt;<i> 
</I>&gt;<i> What would be displayed for such a JSON markup in an overlay?
</I>
Nothing. It's for script.


&gt;<i> Also, the parser for the cue data in the case of kind=metadata would not 
</I>&gt;<i> be part of what the browser offers, so somebody using this approach 
</I>&gt;<i> would need to provide their own JSON parser for the data before they can 
</I>&gt;<i> do anything useful with it. Is there a plan to offer existing parser 
</I>&gt;<i> functionality of the Web browser (e.g. RSS parsing, or Firefox's native 
</I>&gt;<i> JSON parser, or the HTML fragment parser) to the user for this kind of 
</I>&gt;<i> data in some way?
</I>
That seems unrelated to timed tracks. JSON, HTML, and XML parsing are 
already available to scripts.


&gt;<i> Since the @mode IDL attribute of an individual TimedTrack can take on 
</I>&gt;<i> the value &quot;showing&quot; for several tracks at a time and all tracks of kind 
</I>&gt;<i> &quot;subtitle&quot; or &quot;caption&quot; will be displayed, it is possible that multiple 
</I>&gt;<i> TimedTracks are displaying cues at the same time. The display mechanism 
</I>&gt;<i> at 14.3.2.1 deals with this, which is really cool. However, I wonder if 
</I>&gt;<i> there is a limit to the number of tracks we want to allow rendering for 
</I>&gt;<i> at the same time
</I>
The limit currently is as many as can fit.


&gt;<i> &gt; Currently the files have to be same-origin. My plan is to wait for 
</I>&gt;<i> &gt; CORS to be well established and then use it for timed tracks, video 
</I>&gt;<i> &gt; files, images on &lt;canvas&gt;, text/event-stream resources, etc.
</I>&gt;<i> 
</I>&gt;<i> I would indeed like to see the possibility to re-use tracks from other 
</I>&gt;<i> locations, such that e.g. a video can be published by one site, but 
</I>&gt;<i> another site provides all the subtitles for it.
</I>
That is clearly a needed feature. As noted above, as soon as CORS is well 
established, I plan to use it in a number of places in HTML.


&gt;<i> I think it's untenable that we can only render TimedTracks on top of the 
</I>&gt;<i> video viewport (see 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/rendering.html#timed-tracks-0">http://www.whatwg.org/specs/web-apps/current-work/complete/rendering.html#timed-tracks-0</A>). 
</I>&gt;<i> There is no means of rendering for audio and no means of rendering 
</I>&gt;<i> outside the video element.
</I>
What's the use case?


&gt;<i> The rendering and CSS styling approach with ::cue described in 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/rendering.html#timed-tracks-0">http://www.whatwg.org/specs/web-apps/current-work/complete/rendering.html#timed-tracks-0</A> 
</I>&gt;<i> is only defined on WebSRT. That means that there is no styling possible 
</I>&gt;<i> for TimedTracks that come from a different format (assuming we may allow 
</I>&gt;<i> other formats in future).
</I>
Styling such formats would be quite possible, it just has to be defined.


&gt;<i> Also, it implies that there is no styling possible for in-band 
</I>&gt;<i> TimedTracks and for MutableTimedTracks.
</I>
For in-band timed tracks, the styling is whatever is defined for that 
format of track. For MutableTimedTracks, it's the same as WebSRT.


&gt;<i> I think this is a bit restrictive and would rather we define a mechanism 
</I>&gt;<i> to allow CSS styling of cues that come from any type of TimedTrack, and 
</I>&gt;<i> thus make the CSS styling part independent of the format.
</I>
I don't know how to do that.


&gt;<i> Also, the actual CSS properties that are allowed are very restrictive
</I>
Yes, I welcome implementation feedback on this so that the list can be 
extended. I just put in some basic properties for now.


&gt;<i> IMO that defeats the reason for using CSS. The argument that all of CSS, 
</I>&gt;<i> including future extensions, will be available to TimedTracks is only 
</I>&gt;<i> half-true: the use of CSS is restricted to the given list here, so it's 
</I>&gt;<i> not making use of all of CSS and its not automatically extensible. I 
</I>&gt;<i> think that's a poor use of the opportunity that CSS poses.
</I>
Well, we can't make certain things available (like 'float') without 
significantly complicating the model (arguably without fatally 
complicating the model), so clearly (IMHO) we need some limits. However, 
I'm very happy to keep this list updated over time.


On Tue, 27 Jul 2010, Silvia Pfeiffer wrote:
&gt;<i>
</I>&gt;<i> The @kind attribute is currently serving several purposes. This may be 
</I>&gt;<i> ok, but we need to be aware of it and maybe include a note in its 
</I>&gt;<i> description about it.
</I>&gt;<i> 
</I>&gt;<i> Firstly, the @kind attribute describes semantically what the track is: a 
</I>&gt;<i> subtitle, caption, textual description, chapters or &quot;metadata&quot; (i.e. 
</I>&gt;<i> &quot;anything&quot;) track.
</I>&gt;<i> 
</I>&gt;<i> Secondly, the @kind attribute implies whether the track will be 
</I>&gt;<i> displayed: subtitle and caption are rendered (right now just for the 
</I>&gt;<i> video viewport, but I am hoping we can make this more general), chapters 
</I>&gt;<i> are probably rendered with the controls, and textual descriptions and 
</I>&gt;<i> &quot;metadata&quot; are not rendered.
</I>&gt;<i>
</I>&gt;<i> Thirdly, the @kind attribute implies what parser will be used on the 
</I>&gt;<i> cues: subtitle, caption and chapters are parsed as simple markup, 
</I>&gt;<i> chapters are parsed as just plain text stripped of any markup (so speech 
</I>&gt;<i> synthesizers and braille devices can deal with it), and &quot;metadata&quot; is 
</I>&gt;<i> parsed as arbitrary data for script use only.
</I>
These all seem like different facets of the same thing. It's like saying 
that the element name (&lt;ol&gt;, &lt;textarea&gt;, &lt;pre&gt;) affects the semantic, the 
rendering, and the parsing. Or similarly with MIME types.


&gt;<i> I think by understanding this and by making this explicit in the spec, 
</I>&gt;<i> we can more clearly decide what track kinds are still missing and also 
</I>&gt;<i> what we actually need to implement.
</I>
I'm not sure what to add to make this clearer. Can you elaborate?


On Sat, 7 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> I think there's a typo in the description of the TimedTrack mode at 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#timed-track-mode.">http://www.whatwg.org/specs/web-apps/current-work/complete/video.html#timed-track-mode.</A> 
</I>&gt;<i> It says:
</I>&gt;<i> 
</I>&gt;<i> Hidden
</I>&gt;<i> 
</I>&gt;<i> Indicates that the timed track is active, but that the user agent is not 
</I>&gt;<i> actively displaying the cues. If no attempt has yet been made to obtain 
</I>&gt;<i> the track's cues, the user will perform such an attempt momentarily. The 
</I>&gt;<i> user agent is maintaining a list of which cues are active, and events 
</I>&gt;<i> are being fired accordingly.
</I>&gt;<i> 
</I>&gt;<i> But I think it should be &quot;the user *agent* will perform such an attempt 
</I>&gt;<i> momentarily.&quot;
</I>
Fixed.


On Tue, 27 Jul 2010, Sam Dutton wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; The addCueRange() API has been removed and replaced with a feature 
</I>&gt;<i> &gt; based on the subtitle mechanism.
</I>&gt;<i>
</I>&gt;<i> I'm not sure what this means -- are you referring to timed track cues?
</I>
addCueRange() was an old API in the spec. You can do the same things with 
the new MutableTimedTrack API.


&gt;<i> Couple of minor queries:
</I>&gt;<i> * 'time track' is referred to a couple of times in the spec -- it's not 
</I>&gt;<i> clear why this is used instead of 'timed track'
</I>
Fixed.


&gt;<i> * 'the WebSRT file must WebSRT file using cue text' -- I guess this 
</I>&gt;<i> should be 'the WebSRT file must be a WebSRT file using cue text'
</I>
Fixed.


&gt;<i> Also -- is trackgroup out of the spec?
</I>
What is trackgroup?


On Fri, 6 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> Note that the subtitling community has traditionally been using the 
</I>&gt;<i> Subrip (srt) or SubViewer (sub) formats as a simple format and 
</I>&gt;<i> SubStation alpha (ssa/ass) as the comprehensive format. Aegisub, the 
</I>&gt;<i> successor of SubStation Alpha, is still the most popular subtitling 
</I>&gt;<i> software and ASS is the currently dominant format. However, even this 
</I>&gt;<i> community is right now developing a new format called AS6. This shows 
</I>&gt;<i> that the subtitling community also hasn't really converged on a &quot;best&quot; 
</I>&gt;<i> format yet.
</I>
Also it's worth noting that the SubStation Alpha formats are very 
presentational in nature, and do not follow the HTML school of semantic 
language design at all. That is the main reason I didn't use those formats 
for HTML &lt;video&gt; captions.


&gt;<i> So, given this background and the particular needs that we have with 
</I>&gt;<i> implementing support for a time-synchronized text format in the Web 
</I>&gt;<i> context, it would probably be best to start a new format from a clean 
</I>&gt;<i> slate rather than building it on an existing format.
</I>
I don't follow your reasoning here. As you said, SRT is a common subset of 
most of the formats you listed; why would the conclusion not be that we 
should therefore work with SRT?


&gt;<i> In contrast to being flexible about what goes into the cues, WebSRT is 
</I>&gt;<i> completely restrictive and non-extensible in all the content that is 
</I>&gt;<i> outside the cues. In fact, no content other than comments are allowed 
</I>&gt;<i> outside the cues.
</I>
None is allowed today, but it would be relatively straight-forward to 
introduce metadata before the cues (or even in between the cues). For 
example, we could add defaults:

   *
   DEFAULTS
   L:-1 T:50% A:middle

   00:00:20,000 --&gt; 00:00:24,400
   Altocumulus clouds occur between six thousand

   00:00:24,600 --&gt; 00:00:27,800 
   and twenty thousand feet above ground level.

We could add metadata (here using a different syntax that is similarly 
backwards-compatible with what the spec parser does today):

   @charset --&gt; win-1252
   @language --&gt; en-US

   00:00:20,000 --&gt; 00:00:24,400
   Altocumulus clouds occur between six thousand

   00:00:24,600 --&gt; 00:00:27,800 
   and twenty thousand feet above ground level.

There are a variety of syntaxes we could use. So long as whatever we do is 
backwards compatible with what the first set of deployed parsers do, we're 
fine.
   
Currently comments aren't allowed, but we could add those too (e.g. by 
saying that any block of text that doesn't contain a &quot;--&gt;&quot; is a comment).


&gt;<i> * there is no possibility to add file-wide metadata to WebSRT; things 
</I>&gt;<i> about authoring and usage rights as well as information about the media 
</I>&gt;<i> resource that the file relates to should be kept within the file. Almost 
</I>&gt;<i> all subtitle and caption format have the possibility for such metadata
</I>
This is something we could add if there is a clear use case, but I'm not 
sure that there is. Why does SRT not have it today?

 
&gt;<i> and we know from image, music and video resources how important it is to 
</I>&gt;<i> have the ability to keep such metadata inside the resource.
</I>
Do we? I thought from image, music, and video we learnt that it didn't 
make much difference! :-)


&gt;<i> * there is no language specification for a WebSRT resource; while this 
</I>&gt;<i> will not be a problem when used in conjunction with a &lt;track&gt; element, 
</I>&gt;<i> it still is a problem when the resource is used just by itself, in 
</I>&gt;<i> particular as a hint for font selection and speech synthesis.
</I>
I didn't find many formats with a language specifier; is it really that 
much of a problem? Again, we can add it if it turns out to be a problem, 
but since our main concern here is the Web, I don't see much point adding 
this complexity to SRT if it isn't complexity that the SRT community 
needs.


&gt;<i> * there is no style sheet association for a WebSRT resource; this can be 
</I>&gt;<i> resolved by having the style sheet linked into the Web page where the 
</I>&gt;<i> resource is used with the video, but that's not possible when the 
</I>&gt;<i> resource is used by itself. It needs something like a &lt;link&gt; to a CSS 
</I>&gt;<i> resource inside the WebSRT file.
</I>
Do standalone SRT players want to support CSS? If not, it doesn't much 
matter.


&gt;<i> * there is no magic identifier for a WebSRT resource, i.e. what the 
</I>&gt;<i> &lt;wmml&gt; element is for WMML. This makes it almost impossible to create a 
</I>&gt;<i> program to tell what file type this is, in particular since we have made 
</I>&gt;<i> the line numbers optional. We could use &quot;--&gt;&quot; as an indicator, but it's 
</I>&gt;<i> not a good signature.
</I>
Yeah, that's a problem. I considered adding &quot;WEBSRT&quot; at the start of every 
file but we couldn't use it reliably since WebSRT parsers presumably want 
to support SRT using the same parser, and that has no signature.

(Note that XML, and anything based on XML, as well as HTML, JS, and CSS, 
have no signature either. It's a common problem of text formats.)


&gt;<i> * there is no means to identify which parser is required in the cues (is 
</I>&gt;<i> it &quot;plain text&quot;, &quot;minimal markup&quot;, or &quot;anything&quot;?) and therefore it is 
</I>&gt;<i> not possible for an application to know how it should parse the cues.
</I>
Timed track cues are not context-free. In standalone players, the user 
says to play a particular cue file, so using the &quot;cue text&quot; mode is a good 
assumption (why would you give mplayer a metadata cue file to display?). 
Browsers have the &lt;track&gt; context.


&gt;<i> * there is no version number on the format, thus it will be difficult to 
</I>&gt;<i> introduce future changes.
</I>
Version numbers are an antipattern in multivendor formats. This is an 
intentional feature, not an unfortunate omission. HTML itself has dropped 
the version number in its format; CSS has never had one. Most programming 
languages don't have one.


&gt;<i> I can understand that the definition of WebSRT took inspiration from SRT 
</I>&gt;<i> for creating a simple format. But realistically most SRT files will not 
</I>&gt;<i> be conformant WebSRT files because they are not written in UTF-8. 
</I>
I don't think they need to be conforming. They're already published. 
Conformance is just a quality assurance tool, it's only relevant for 
documents being written in the future.


&gt;<i> Further, realistically, all WebSRT files that use more than just the 
</I>&gt;<i> plain text markup are not conformant SRT files.
</I>
What's a &quot;conformant SRT file&quot;?


&gt;<i> So, let's stop pretending there is compatibility and just call WebSRT a 
</I>&gt;<i> new format.
</I>
Compatibility has nothing to do with conformance. It has to do with what 
user agents do. As far as I can tell, WebSRT is backwards-compatible with 
legacy SRT user agents, and legacy SRT files are compatible with WebSRT 
user agents as described by the spec.


&gt;<i> In fact, the subtitling community itself has already expressed their 
</I>&gt;<i> objections to building an extension of SRT, see 
</I>&gt;<i> <A HREF="http://forum.doom9.org/showthread.php?p=1396576">http://forum.doom9.org/showthread.php?p=1396576</A> , so we shouldn't try to 
</I>&gt;<i> enforce something that those for whom it was done don't want.
</I>
The subtitling community in question is looking for a presentational 
format. I think it is very reasonable to say that SRT is not interesting 
for that purpose. However, a presentational format isn't, as far as I can 
tell, suitable for the Web.


&gt;<i> * the mime type of WebSRT resources should be a different mime type to 
</I>&gt;<i> SRT files, since they are so fundamentally different; e.g. text/websrt
</I>
That's what I originally suggested, and you said we should use text/srt 
because it is what people use, even though it's not registered. I think 
you were right; it makes no sense to invent a new MIME type here.


&gt;<i> * the file extension of WebSRT resources should be different from SRT 
</I>&gt;<i> files, e.g. wsrt
</I>
Extensions are irrelevant on the Web. People can use whatever extension 
they want.


&gt;<i> Right now, there is &quot;plain text&quot;, &quot;minimum markup&quot; and &quot;anything&quot; 
</I>&gt;<i> allowed in the cues.
</I>
As far as I can tell there's just two modes -- plain text and text with 
WebSRT markup.


&gt;<i> Seeing as WebSRT is built with the particular purpose of bringing 
</I>&gt;<i> time-synchronized text for HTML5 media elements, it makes no sense to 
</I>&gt;<i> exclude all the capabilities of HTML.
</I>
I would on the contrary say that it makes no sense to take on all the HTML 
baggage when all we want to do is introduce subtitles to video. :-)


&gt;<i> Also, with all the typical parsers and renderers available in UAs, 
</I>&gt;<i> support of innerHTML in cues should be simple to implement.
</I>
Nothing is ever simple when it involves an HTML parser.


&gt;<i> The argument that offline applications don't support it is not relevant 
</I>&gt;<i> since we have no influence on whether standalone media applications will 
</I>&gt;<i> actually follow the HTML5 format choice.
</I>
Standalone video players almost certainly won't want to embed a Web 
browser, sure. With WebSRT as currently designed, you can target 
standalone browsers without them having to change at all, and they can 
adopt the new features with minimum effort. We might even be able to bring 
a greater level of interoperability to the standalone media apps, if we're 
lucky (it would be purely luck of course; that isn't a goal).


&gt;<i> That WebSRT with &quot;plain text&quot; and &quot;minimal markup&quot; can be supported 
</I>&gt;<i> easily in standalone media applications is a positive side effect, but 
</I>&gt;<i> not an aim in itself for HTML5 and it should have no influence on our 
</I>&gt;<i> choices.
</I>
It should have influence, but maybe not much.


&gt;<i> In the current form, WebSRT only makes limited use of existing CSS. I 
</I>&gt;<i> see particularly the following limitations:
</I>&gt;<i> 
</I>&gt;<i> * no use of the positioning functionality is made and instead a new 
</I>&gt;<i> means of positioning is introduced; it would be nicer to just have this 
</I>&gt;<i> reuse CSS functionality. It would also avoid having to repeat the 
</I>&gt;<i> positioning information on every single cue.
</I>
It doesn't make sense to position cues with CSS, because the position of 
cues is an intrinsic part of the cue semantic. Where a cues appears can 
change the plot of a show, for example (was it the evil twin who said 
something or the good twin?).


&gt;<i> * little use of formatting functionality is made by restricting it to 
</I>&gt;<i> only use 'color', 'text-shadow', 'text-outline', 'background', 'outline' 
</I>&gt;<i> and 'font'
</I>
The restrictions are mostly artificial and should be extended once we 
better understand the constraints here.


&gt;<i> * cue-related metadata (&quot;voice&quot;) could be made more generic; why not 
</I>&gt;<i> reuse &quot;class&quot;?
</I>
I don't know what this means. What is &quot;class&quot; and how does it differ from 
&quot;voice&quot;?


&gt;<i> * there is no definition of the &quot;canvas&quot; dimensions that the cues are 
</I>&gt;<i> prepared for (width/height) and expected to work with other than saying 
</I>&gt;<i> it is the video dimensions - but these can change and the proportions 
</I>&gt;<i> should be changed with that
</I>
I don't understand. It's all defined in terms of percentages of the video 
dimensions.


&gt;<i> * it is not possible to associate CSS styles with segments of text, but 
</I>&gt;<i> only with a whole cue using ::cue-part; it's thus not possible to just 
</I>&gt;<i> highlight a single word in a cue
</I>
It is (just use &lt;b&gt; to highlight the word). It's not possible to style 
lots of parts differently, though, because there are no attribute- 
analogues on the tags in WebSRT currently.


&gt;<i> * when HTML markup is used in cues, as the specification stands, that 
</I>&gt;<i> markup is not parsed and therefore cannot be associated with CSS; again, 
</I>&gt;<i> this can be fixed by making innerHTML in cues valid
</I>
It also doesn't styling XML in cues, or rendering SVG, or XSL:FO... I 
don't see why that's a problem.


&gt;<i> * I noticed that it is not possible to make a language association with 
</I>&gt;<i> segments of text and thus it is not possible to have text with mixed 
</I>&gt;<i> languages.
</I>
Are mixed language subtitles common? I don't know that I've ever seen 
that.


&gt;<i> * Is it possible to reuse the HTML font systems?
</I>
What is the HTML font system?


&gt;<i> Having proposed a xml-based format, it would be good to understand 
</I>&gt;<i> reasons for why it is not a good idea and why a plain text format that 
</I>&gt;<i> has no structure other than that provided through newlines and start/end 
</I>&gt;<i> time should be better and more extensible.
</I>
I don't understand what you mean by structure.

XML in general is a terrible authoring format. I don't see why we'd want 
to reuse XML for captions.


On Fri, 6 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> I really like the idea of letting everything before the first timestamp 
</I>&gt;<i> in WebSRT be interpreted as the header. I'd want to use it like this:
</I>&gt;<i> 
</I>&gt;<i> # author: Fan Subber
</I>&gt;<i> # voices: &lt;1&gt; Boy
</I>&gt;<i> #         &lt;2&gt; Girl
</I>&gt;<i> 
</I>&gt;<i> 01:23:45.678 --&gt; 01:23:46.789
</I>&gt;<i> &lt;1&gt; Hello
</I>&gt;<i> 
</I>&gt;<i> 01:23:48.910 --&gt; 01:23:49.101
</I>&gt;<i> &lt;2&gt; Hello
</I>&gt;<i> 
</I>&gt;<i> It's not critical that the format of the header be machine-readable, but 
</I>&gt;<i> we could of course make up a key-value syntax, use JSON, or something 
</I>&gt;<i> else.
</I>
We could put blocks like that anywhere we need to in a future version, so 
long as we design the format of such blocks such that they don't conflict 
with what the parser does today.


On Fri, 6 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> I'm not particularly fond of the current voice markup, mainly for 2 
</I>&gt;<i> reasons:
</I>&gt;<i> 
</I>&gt;<i> First, a cue can only have 1 voice, which makes it impossible to style 
</I>&gt;<i> cues spoken/sung simultaneously by 2 or more voices. There's a karaoke 
</I>&gt;<i> example of this in 
</I>&gt;<i> &lt;<A HREF="http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA#Multiple_voices">http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA#Multiple_voices</A>&gt;
</I>
That's just two cues.


&gt;<i> I would prefer if voices could be mixed, as such:
</I>&gt;<i> 
</I>&gt;<i> 00:01.000 --&gt; 00:02.000
</I>&gt;<i> &lt;1&gt; Speaker 1
</I>&gt;<i> 
</I>&gt;<i> 00:03.000 --&gt; 00:04.000
</I>&gt;<i> &lt;2&gt; Speaker 2
</I>&gt;<i> 
</I>&gt;<i> 00:05.000 --&gt; 00:06.000
</I>&gt;<i> &lt;1&gt;&lt;2&gt; Speaker 1+2
</I>
What's the use case?


&gt;<i> Second, it makes it impossible to target a smaller part of the cue for 
</I>&gt;<i> styling. We have &lt;i&gt; and &lt;b&gt;, but there are also cases where part of the 
</I>&gt;<i> cue should be in a different color, see 
</I>&gt;<i> &lt;<A HREF="http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA#Multiple_colors">http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA#Multiple_colors</A>&gt;
</I>
Well you can always restyle &lt;i&gt; or &lt;b&gt;.


&gt;<i> If one allows multiple voices, it's not hard to predict that people will 
</I>&gt;<i> start using magic numbers just to work around this, which would both be 
</I>&gt;<i> wrong semantically and ugly to look at:
</I>&gt;<i> 
</I>&gt;<i> 00:01.000 --&gt; 00:02.000
</I>&gt;<i> &lt;1&gt; I like &lt;1234&gt;blue&lt;/1234&gt; words.
</I>&gt;<i> 
</I>&gt;<i> They'd then target 1234 with CSS to color it blue.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure of the best solution. I'd quite like the ability to use 
</I>&gt;<i> arbitrary voices, e.g. to use the names/initials of the speaker rather 
</I>&gt;<i> than a number, or to use e.g. &lt;shouting&gt; in combination with CSS :before 
</I>&gt;<i> { content 'Shouting: ' } or similar to adapt the display for different 
</I>&gt;<i> audiences (accessibility, basically).
</I>
Yeah, there are some difficult-to-satisfy constraints here. On the one 
hand having a predefined set of voices leads to better semantics, 
usability for authors, and accessibility; on the other hand we need 
something open-ended because we can't think of everything. We also have to 
make sure we don't enable voices to conflict with future tag names, so 
whatever we do that's open-ended would have to use a specific syntax (like 
being all numbers, which is what I currenlty have). I'm not sure how to 
improve on what we have now, but it's certainly not perfect.


On Wed, 11 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> What should numerical voices be replaced with? Personally I'd much 
</I>&gt;<i> rather write &lt;philip&gt; and &lt;silvia&gt; to mark up a conversation between us 
</I>&gt;<i> two, as I think it'd be quite hard to keep track of the numbers if 
</I>&gt;<i> editing subtitles with many different speakers.
</I>
We could say that a custom voice has to start with some punctuation or 
other, say &lt;:philip&gt;?


On Wed, 11 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> In HTML it is &lt;span class=&quot;philip&quot;&gt;..&lt;/span&gt; and &lt;span 
</I>&gt;<i> class=&quot;silvia&quot;&gt;...&lt;/span&gt;. I don't see anything wrong with that. And 
</I>&gt;<i> it's only marginally longer than &lt;philip&gt; ... &lt;/philip&gt; and 
</I>&gt;<i> &lt;silvia&gt;...&lt;/silvia&gt;.
</I>
It's quite a lot more verbose than what the spec has now... (just &quot;&lt;1&gt;&quot;.)


On Thu, 12 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> The core &quot;problem&quot; is that WebSRT is far too compatible with existing 
</I>&gt;<i> SRT usage. Regardless of the file extension and MIME type used, it's 
</I>&gt;<i> quite improbable that anyone will have different parsers for the same 
</I>&gt;<i> format. Once media players have been forced to handle the extra markup 
</I>&gt;<i> in WebSRT (e.g. by ignoring it, as many already do) the two formats will 
</I>&gt;<i> be the same, and using WebSRT markup in .srt files will just work, so 
</I>&gt;<i> that's what people will do. We may avoid being seen as arrogant 
</I>&gt;<i> format-hijackers, but the end result is two extensions and two different 
</I>&gt;<i> MIME types that mean exactly the same thing.
</I>
I think we'll look equally arrogant if we ignore years of experience with 
subtitling formats and just make up an entirely new format. It's not like 
the world is short of subtitling formats.


On Wed, 18 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i>
</I>&gt;<i> It actually burns down to the question: do we want the simple SRT format 
</I>&gt;<i> to survive as its own format and be something that people can rely upon 
</I>&gt;<i> as not having &quot;weird stuff&quot; in it - or do we not. I believe that it's 
</I>&gt;<i> important that it survives.
</I>
Does that format still exist? Is it materially different than WebSRT?


On Sat, 21 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> It's not just about implementation cost - it's also the problem of 
</I>&gt;<i> maintaining another spec that can grow to have eventually all the 
</I>&gt;<i> features that HTML5 has and more. Do you really eventually want to 
</I>&gt;<i> re-spec and re-implement a whole innerHTML parser plus the extra &lt;t&gt; 
</I>&gt;<i> element when we start putting &lt;svg&gt; and &lt;canvas&gt; and all sorts of other 
</I>&gt;<i> more complex HTML features into captions? Just because the &lt;t&gt; element 
</I>&gt;<i> is making trouble now? Is this really the time to re-invent HTML?
</I>
No, it's not. We should never let subtitles get that crazy.


On Mon, 23 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> I don't expect that SVG, &lt;canvas&gt;, images, etc will ever natively be 
</I>&gt;<i> made part of captions. Rather, I would hope that the metadata state 
</I>&gt;<i> together with scripts is used. If we think that e.g. images in captions 
</I>&gt;<i> are an important use case, then WebSRT is not a good solution.
</I>
Indeed.


&gt;<i> If we allow arbitrary HTML and expect browsers to handle it well, it 
</I>&gt;<i> adds some complexity. For example, any videos and images in the cue 
</I>&gt;<i> would have to be fully loaded and ready to be decoded by the time the 
</I>&gt;<i> cue is to be shown, which I really don't want to implement the logic 
</I>&gt;<i> for. Simply having an iframe-like container where the document is 
</I>&gt;<i> replaced for each cue wouldn't be enough, rather one would have to 
</I>&gt;<i> create one document per cue during parsing and wait for all of those to 
</I>&gt;<i> finish loading before beginning playback. I'm not sure, but I'm guessing 
</I>&gt;<i> that amounts to significant memory overhead.
</I>
Quite.


&gt;<i> As an aside, I personally see it as a good things that &lt;font&gt; *doesn't* 
</I>&gt;<i> work in WebSRT, whereas it would using an HTML parser.
</I>
Agreed!


&gt;<i> Deployed SRT uses &lt;i&gt;, &lt;b&gt;, &lt;font&gt; and &lt;u&gt;. WebSRT adds &lt;ruby&gt;, &lt;rt&gt; and 
</I>&gt;<i> &lt;1&gt;...&lt;infinity&gt;, extensions which are very much in line with the 
</I>&gt;<i> existing format and already &quot;works&quot; in many players (in the sense that 
</I>&gt;<i> they are ignored, not rendered). I wouldn't call that a huge mess.
</I>
Yes.


On Tue, 24 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> I believe [SVG etc] will be [added to WebSRT]. But since we are only 
</I>&gt;<i> looking at the ways in which captions and subtitles are used currently, 
</I>&gt;<i> we haven't accepted this as an important use case, which is fair enough. 
</I>&gt;<i> I am considering likely future use though, which is always hard to 
</I>&gt;<i> argue.
</I>
In all my research for subtitles, I found very few cases of anything like 
this. Even DVDs, whose subtitle tracks are just hardcoded bitmap images, 
don't do anything fancy with them... just plain text and italics, 
generally. Why haven't people started doing fancy stuff with subtitles in 
all the years that we've had TVs? It's not like they can't do it.

My guess is that the real reason is that when you get so fancy that you're 
including graphics and the like, you're no longer doing timed tracks, 
you're just doing content, and the right thing to do is to either burn it 
in, or consider it a separate construct animated on top of the video, e.g. 
an &lt;svg:video&gt; and SMIL.


&gt;<i> It is not at all similar to HTML4 and HTML5. A Web browser cannot 
</I>&gt;<i> suddenly stop working for a Web page, just because it has some extra 
</I>&gt;<i> functionality in it. Thus, the HTML format has been developed such that 
</I>&gt;<i> it can be extended without breaking existing stuff. We can guarantee 
</I>&gt;<i> that no browser will break because that is the way in which the format 
</I>&gt;<i> has been specified.
</I>
It's the way it's specified now, but it wasn't before.


&gt;<i> No such thing has happened for SRT and there is simply no way to 
</I>&gt;<i> guarantee that all new WebSRT files will work in all existing SRT 
</I>&gt;<i> software, because SRT has not been specified as a extensible format and 
</I>&gt;<i> because there is no agreement between all parties that have implemented 
</I>&gt;<i> SRT support as to how extensions should be made.
</I>
There's almost as much agreement as with HTML4, as far as I can tell. 
Maybe a little less, but the format is so much simpler that it doesn't 
matter as much.


On Tue, 24 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> Here's the SRT research I promised: 
</I>&gt;<i> <A HREF="http://blog.foolip.org/2010/08/20/srt-research/">http://blog.foolip.org/2010/08/20/srt-research/</A>
</I>
Awesome! Thanks for this.

Addressing points in the same order:

 - charset: resolved by introducing a charset override.

 - blank lines not separating cues: I couldn't find a client that 
   supported missing the blank line, so I didn't support that. It's a 
   small number of files, and a small number of cues within those files, 
   I presume, so I'm not too worried.

 - overlapping cues: supporting these is pretty important, so files with 
   overlapping cues will just have some weird artefects on playback.

The remaining data is interesting but seems to be consistent with our 
expectations before WebSRT was specced.


On Wed, 25 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> Yeah, I'm totally for adding a hint as to what format is in the cue. 
</I>&gt;<i> Then, a WebSRT file can be identified as to what it contains.
</I>
Can't it be identified just by looking? Or looking at its name? I don't 
really understand what problem this is solving. It's not like people are 
loading up random SRT files and seeing what they are; specific SRT files 
are sought out for use with specific videos.


&gt;<i> [...] I think logically text/websrt makes more sense with a .wsrt 
</I>&gt;<i> extension. Then, also SRT files can be served as text/websrt to allow 
</I>&gt;<i> them to take part in the WebSRT infrastructure if indeed they will 
</I>&gt;<i> continue to be valid WebSRT files.
</I>
I don't understand the problem with text/srt. Why should we invent our own 
type? People already use text/srt. It smacks of &quot;not invented here&quot; to 
start making up our own types. You convinced me of this. :-)


&gt;<i> Incidentally, [is it] a problem if WebSRT files are served as 
</I>&gt;<i> text/plain, i.e. will the browser not identify them as subtitle files?
</I>
On Wed, 25 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> &quot;The tasks queued by the fetching algorithm on the networking task 
</I>&gt;<i> source to process the data as it is being fetched must examine the 
</I>&gt;<i> resource's Content Type metadata, once it is available, if it ever is. 
</I>&gt;<i> If no Content Type metadata is ever available, or if the type is not 
</I>&gt;<i> recognised as a timed track format, then the resource's format must be 
</I>&gt;<i> assumed to be unsupported (this causes the load to fail, as described 
</I>&gt;<i> below).&quot;
</I>&gt;<i> 
</I>&gt;<i> In other words, browsers should have a whitelist of supported text track 
</I>&gt;<i> format, just like they should for audio and video formats. (Note though 
</I>&gt;<i> that Safari and Chrome ignore the MIME type for audio/video and will 
</I>&gt;<i> likely continue to do so.)
</I>&gt;<i> 
</I>&gt;<i> It seems to that a side-effect of this is that it will be impossible to 
</I>&gt;<i> test &lt;track&gt; on a local file system, as there's no MIME type and 
</I>&gt;<i> browsers aren't allowed to sniff. Surely this can't be the intention, 
</I>&gt;<i> Hixie?
</I>
Local file systems generally use extensions to declare file types (at 
least, on Windows and Mac OS X).


On Thu, 26 Aug 2010, Chris Double wrote:
&gt;<i> 
</I>&gt;<i> Firefox (in the case of video) uses file extensions to identify video
</I>&gt;<i> files. We have an internal maping of file extensions to mime types. We
</I>&gt;<i> don't sniff the content. I imagine we'd do the same with whatever file
</I>&gt;<i> extension is used for WebSRT.
</I>
(I assume this is only for the filesystem, not data from the wire!)


On Wed, 25 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i>
</I>&gt;<i> Yes, I have no problem with that. Though I believe we have overloaded 
</I>&gt;<i> @kind with too much meaning as I already mentioned earlier. I think it 
</I>&gt;<i> would make more sense to pull the different dimensions into different 
</I>&gt;<i> attributes:
</I>&gt;<i>
</I>&gt;<i> - @type or @format for the format of the cue
</I>&gt;<i>
</I>&gt;<i> - @kind for the semantic meaning of it (subtitle, caption, karaoke etc) 
</I>&gt;<i> - one track could even satisfy several needs, so this would be a lit of 
</I>&gt;<i> kinds
</I>&gt;<i>
</I>&gt;<i> - and finally the visual rendering problem, which could possibly be 
</I>&gt;<i> solved by providing a link to a div or p where the data should be 
</I>&gt;<i> rendered alternatively to the default. Right now, audio and metadata 
</I>&gt;<i> tracks get no rendering at all and I see that as a problem.
</I>
I don't understand. What combinations do you think make sense that aren't 
already supported by the few kind=&quot;&quot; values? We don't want to have lots of 
meaningless combinations, we just make authoring harder and make it more 
likely that there'll be bogus content and implementation bugs in edge 
cases, which we'll all end up having to copy, etc.


On Wed, 25 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> The main reason to care about the MIME type is some kind of &quot;doing the 
</I>&gt;<i> right thing&quot; by not letting people get away with misconfigured servers. 
</I>&gt;<i> Sometimes I feel it's just a waste of everyone's time though, it would 
</I>&gt;<i> generally be less work for both browsers and authors to not bother.
</I>
Agreed. Not sure what to do for WebSRT though, since there's no good way 
to recognise a WebSRT file as opposed to some other format.


On Thu, 26 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> You misunderstand my intent. I am by no means suggesting that no WebSRT 
</I>&gt;<i> content is treated as SRT by any application. All I am asking for is a 
</I>&gt;<i> different file extension and a different mime type and possibly a magic 
</I>&gt;<i> identifier such that *authoring* applications (and authors) can clearly 
</I>&gt;<i> designate this to be a different format, in particular if they include 
</I>&gt;<i> new features.
</I>
Wouldn't an authoring application just have two (or more) different &quot;save 
as&quot; or &quot;export&quot; format options? &quot;Save as SRT with no formatting&quot;, &quot;Save as 
SRT with &lt;b&gt; only&quot;, &quot;Save as WebSRT&quot;, or whatnot. Or a list of checkboxes 
for standalone user agents to be compatible with, so that it can pick the 
common subset.


&gt;<i> Then a *playback application* has the chance to identify them as a 
</I>&gt;<i> different format and provide a specific parser for it, instead of 
</I>&gt;<i> failing like Totem. They can also decide to extend their existing SRT 
</I>&gt;<i> parser to support both WebSRT and SRT. And I also have no issue with a 
</I>&gt;<i> user deciding to give a WebSRT file a go by renaming it to .srt.
</I>
I think you think there's more difference between WebSRT and SRT than 
there is. In practice, there is less difference between WebSRT and the 
equivalent SRT file than there is between two random SRT files today. The 
difference between WebSRT and SRT is well within the &quot;error bars&quot; of what 
SRT is today.


&gt;<i> By keeping WebSRT and SRT as different formats we give the applications 
</I>&gt;<i> a choice to support either, or both in the same parser. If we don't, we 
</I>&gt;<i> force them to deal in a single parser with all the oddities of SRT 
</I>&gt;<i> formats as well as all the extra features and all the extensibility of 
</I>&gt;<i> WebSRT.
</I>
I don't understand what the difference would be.


On Thu, 26 Aug 2010, Henri Sivonen wrote:
&gt;<i> 
</I>&gt;<i> Why wouldn't it always be a superior solution for all parties to do the 
</I>&gt;<i> following:
</I>&gt;<i>
</I>&gt;<i>  1) Make sure WebSRT never requires processing that'd require rendering 
</I>&gt;<i> a substantial body of legacy .srt content in a broken way. (This would 
</I>&gt;<i> require supporting non-UTF-8 encodings by sniffing as well as supporting 
</I>&gt;<i> &lt;font&gt; and &lt;u&gt;, which would happen &quot;for free&quot; if my innerHTML proposal 
</I>&gt;<i> were adopted.)
</I>&gt;<i>
</I>&gt;<i>  2) Make playback software that supports WebSRT only have a WebSRT code 
</I>&gt;<i> path and use that code path for legacy .srt content as well.
</I>&gt;<i>
</I>&gt;<i> ?
</I>
I agree that that would be simplest. I disagree that you'd have to support 
&lt;font&gt; and &lt;u&gt; to do that; I don't think losing colour or underlining is 
&quot;breaking&quot;, and it apparently affects less than 5% of files. The encoding 
thing is basically resolved for Web browsers; I don't know that we can do 
much to resolve it for standalone players with legacy SRT files.


On Tue, 24 Aug 2010, Henri Sivonen wrote:
&gt;<i> 
</I>&gt;<i> I'm rather unconvinced by the voice markup as well. As far as I can 
</I>&gt;<i> tell, the voice markup is syntactic sugar for class for practical 
</I>&gt;<i> purposes. (I don't give much value to arguments that voices are more 
</I>&gt;<i> semantic than classes if the pratical purpose in to achieve visual 
</I>&gt;<i> effects for caption rendering.) Common translation subtitling works just 
</I>&gt;<i> fine without voice identification and (based on information in this 
</I>&gt;<i> thread) the original .srt doesn't have voices.
</I>
About 3% of SRT files effectively have voices, through the use of &lt;font&gt;. 
If you include &lt;i&gt; in SRT files as equivalent to a voice with some special 
purpose like &quot;narrator&quot;, then it's more like 50%.

I think &lt;narrator&gt; is a better way of doing it than &lt;i&gt;, personally.


&gt;<i> If voices are really needed for captioning use cases, I think it makes 
</I>&gt;<i> sense to balance the rarity of that need within the captioning 
</I>&gt;<i> spherewith the complexity of introducing syntactic sugar over the class 
</I>&gt;<i> attribute and the class selector.
</I>
It's not syntactic sugar, since it's the only way. It's just a different 
syntax for a similar concept (indeed, just like element names are a 
different syntax for a similar concept!).


On Wed, 25 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> How would the Web browser or in fact any parsing application know what 
</I>&gt;<i> to do with the cues? This is actually a question for WebSRT. Unless 
</I>&gt;<i> there is a hint as to how to parse the stuff in the cue, it would need 
</I>&gt;<i> to do something like &quot;content sniffing&quot; to find out if it's &quot;JSON&quot; or 
</I>&gt;<i> &quot;plain text&quot; or &quot;minimal markup&quot;. Right now, the hint for how to parse 
</I>&gt;<i> the cue in WebSRT comes from the track @kind attribute. That is not 
</I>&gt;<i> helpful for a stand-alone application.
</I>
Standalone applications get told which tracks to display, and always 
display them as subtitles/captions, so this point is moot as far as I can 
tell.


&gt;<i> [...] You're also excluding roll-on captions then which is a feature of 
</I>&gt;<i> live broadcasting.
</I>
It isn't clear to me that an external file would be a good solution for 
live broadcasting, so I'm not sure this really matters.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>

















<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="070813.html">[whatwg] ArrayBuffer and ByteArray questions
</A></li>
	<LI>Next message: <A HREF="070687.html">[whatwg] Timed tracks: feedback compendium
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28476">[ date ]</a>
              <a href="thread.html#28476">[ thread ]</a>
              <a href="subject.html#28476">[ subject ]</a>
              <a href="author.html#28476">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
