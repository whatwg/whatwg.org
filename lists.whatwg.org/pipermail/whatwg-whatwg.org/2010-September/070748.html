<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Timed tracks: feedback compendium
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Timed%20tracks%3A%20feedback%20compendium&In-Reply-To=%3CAANLkTi%3D9MTpsAQecpMTvfCeXuaL6be8tUCMh0skyqFaq%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="070697.html">
   <LINK REL="Next"  HREF="070752.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Timed tracks: feedback compendium</H1>
<!--htdig_noindex-->
    <B>Silvia Pfeiffer</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Timed%20tracks%3A%20feedback%20compendium&In-Reply-To=%3CAANLkTi%3D9MTpsAQecpMTvfCeXuaL6be8tUCMh0skyqFaq%40mail.gmail.com%3E"
       TITLE="[whatwg] Timed tracks: feedback compendium">silviapfeiffer1 at gmail.com
       </A><BR>
    <I>Thu Sep  9 06:08:43 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="070697.html">[whatwg] Timed tracks: feedback compendium
</A></li>
        <LI>Next message: <A HREF="070752.html">[whatwg] Timed tracks: feedback compendium
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70748">[ date ]</a>
              <a href="thread.html#70748">[ thread ]</a>
              <a href="subject.html#70748">[ subject ]</a>
              <a href="author.html#70748">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Wed, Sep 8, 2010 at 9:19 AM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:

&gt;<i>
</I>&gt;<i> On Fri, 23 Jul 2010, Philip J&#228;genstedt wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm not a fan of pauseOnExit, though, mostly because it seems
</I>&gt;<i> &gt; non-trivial to implement. Since it is last in the argument list of
</I>&gt;<i> &gt; TimedTrackCue, it will be easy to just ignore when implementing. I still
</I>&gt;<i> &gt; don't think the use cases for it are enough to motivate the
</I>&gt;<i> &gt; implementation cost.
</I>&gt;<i>
</I>&gt;<i> Really? It seems like automatically pausing video half-way would be a very
</I>&gt;<i> common thing to do; e.g. to play an interstitial ad, or to play a specific
</I>&gt;<i> sound effect in a sound file containing multiple sound effects, or to play
</I>&gt;<i> a video up to the point where the user has to make a choice or has to ask
</I>&gt;<i> to move on to the next slide. There's basically no good way to do this
</I>&gt;<i> kind of thing without this feature.
</I>&gt;<i>
</I>
Also, some text cues will be fairly long and thus certain users cannot read
them within the allocated time for the cue. So, making a pauseOnExit()
available is a good thing for accessibility.



&gt;<i>
</I>&gt;<i> &gt; &gt; On Fri, 31 Jul 2009, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; * It is unclear, which of the given alternative text tracks in
</I>&gt;<i> &gt; &gt; &gt; different languages should be displayed by default when loading an
</I>&gt;<i> &gt; &gt; &gt; &lt;itext&gt; resource. A @default attribute has been added to the &lt;itext&gt;
</I>&gt;<i> &gt; &gt; &gt; elements to allow for the Web content author to tell the browser
</I>&gt;<i> &gt; &gt; &gt; which &lt;itext&gt; tracks he/she expects to be displayed by default. If
</I>&gt;<i> &gt; &gt; &gt; the Web author does not specify such tracks, the display depends on
</I>&gt;<i> &gt; &gt; &gt; the user agent (UA - generally the Web browser): for accessibility
</I>&gt;<i> &gt; &gt; &gt; reasons, there should be a field that allows users to always turn
</I>&gt;<i> &gt; &gt; &gt; display of certain &lt;itext&gt; categories on. Further, the UA is set to
</I>&gt;<i> &gt; &gt; &gt; a default language and it is this default language that should be
</I>&gt;<i> &gt; &gt; &gt; used to select which &lt;itext&gt; track should be displayed.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; It's not clear to me that we need a way to do this; by default
</I>&gt;<i> &gt; &gt; presumably tracks would all be off unless the user wants them, in
</I>&gt;<i> &gt; &gt; which case the user's preferences are paramount. That's what I've
</I>&gt;<i> &gt; &gt; specced currently. However, it's easy to override this from script.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; It seems to me that this is much like &lt;video autoplay&gt; in that if we
</I>&gt;<i> &gt; don't provide a markup solution, everyone will use scripts and it will
</I>&gt;<i> &gt; be more difficult for the UA to override with user prefs.
</I>&gt;<i>
</I>&gt;<i> What would we need for this then? Just a way to say &quot;by the way, in
</I>&gt;<i> addition to whatever the user said, also turn this track on&quot;? Or do we
</I>&gt;<i> need something to say &quot;by default, override the user's preferences for
</I>&gt;<i> this video and instead turn on this track and turn off all others&quot;? Or
</I>&gt;<i> something else? It's not clear to me what the use case is where this
</I>&gt;<i> would be useful declaratively.
</I>&gt;<i>
</I>

You have covered all the user requirements and that is good. They should
dominate all other settings. But I think we have neglected the authors. What
about tracks that the author has defined and wants activated by default for
those users that don't have anything else specified in their user
requirements? For example, if an author knows that the audio on their video
is pretty poor and they want the subtitles to be on by default (because
otherwise a user may miss that they are available and they may miss what is
going on), then currently they have to activate it with script.

A user whose preferences are not set will thus see this track. For a user
whose preferences are set, the browser will turn on the appropriate tracks
additionally or alternatively if there is a more appropriate track in the
same language (e.g. a caption track over the default subtitle track). If we
do this with script, will it not have the wrong effect and turn off what the
browser has selected, so is not actually expressing author preferences, but
is doing an author override?



&gt;<i> &gt; &gt; On Thu, 15 Apr 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; Further, SRT has no way to specify which language it is written in
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; What's the use case?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As hints for font selection
</I>&gt;<i>
</I>&gt;<i> Are independent SRT processors really going to do per-language font
</I>&gt;<i> selection? How do they do it today?
</I>&gt;<i>
</I>
In VLC there is an &quot;Advanced Open File...&quot; option in which you can open a
subtitle file with the video and set the following parameters:
* FPS
* delay
* font size
* subtitle alignment
* subtitle text encoding which chooses the charset.



&gt;<i> &gt; and speech synthesis.
</I>&gt;<i>
</I>&gt;<i> Are independent SRT processors really going to do audio descriptions any
</I>&gt;<i> time soon? I've only ever seen this in highly experimental settings.
</I>&gt;<i>
</I>
Once this is usable in the Web context, accessibility people will jump at
this opportunity. It has not been possible before. You should see the
excitement I always get from blind people when I demonstrate the Elephants
Dream video with text audio descriptions. It will totally take off.


&gt;<i> [...] the positioning of individual cues is still not controlled by CSS
</I>&gt;<i> &gt; but rather by e.g. L:50%.
</I>&gt;<i>
</I>&gt;<i> I considered this issue carefully when speccing WebSRT. My conclusion
</I>&gt;<i> (after watching a lot more TV than I'm used to) was that in practice
</I>&gt;<i> subtitle positioning is not strictly a presentational issue -- that is,
</I>&gt;<i> you can't just swap one set of styles for another and have equally good
</I>&gt;<i> results, you have to control the positioning on a per-cue basis regardless
</I>&gt;<i> of the styling. This is because you have to avoid burnt-in text, or
</I>&gt;<i> overlap burnt-in text, or because you need to align text with a speaker,
</I>&gt;<i> or show which audio channel the text came from (e.g. for people talking
</I>&gt;<i> off camera in a very directional sense), etc.
</I>&gt;<i>
</I>
I agree. However, what stops us from specifying the positioning in CSS? Why
a new mechanism? The output of rendering the cues ends up as a set of CSS
boxes anyway.



&gt;<i> &gt; Alternatively, might it not be better to simply use the voice &quot;sound&quot;
</I>&gt;<i> &gt; for this and let the default stylesheet hide those cues? When writing
</I>&gt;<i> &gt; subtitles I don't want the maintenance overhead of 2 different versions
</I>&gt;<i> &gt; that differ only by the inclusion of [doorbell rings] and similar.
</I>&gt;<i> &gt; Honestly, it's more likely that I just wouldn't bother with
</I>&gt;<i> &gt; accessibility for the HoH at all. If I could add it with &lt;sound&gt;doorbell
</I>&gt;<i> &gt; rings, it's far more likely I would do that, as long as it isn't
</I>&gt;<i> &gt; rendered by default. This is my preferred solution, then keeping only
</I>&gt;<i> &gt; one of kind=subtitles and kind=captions. Enabling the HoH-cues could
</I>&gt;<i> &gt; then be a global preference in the browser, or done from the context
</I>&gt;<i> &gt; menu of individual videos.
</I>&gt;<i>
</I>&gt;<i> I don't disagree with this, but I fear it might be too radical a step for
</I>&gt;<i> the caption-authoring community to take at this point.
</I>&gt;<i>
</I>
I think we have to get over the notion that the existing subtitling
community is our target for this format. In fact, the new subtitling
community are all the Web developers out there. They are the ones we should
target and for them we should make things easier.


&gt;<i> If we must have both kind=subtitles and kind=captions, then I'd suggest
</I>&gt;<i> &gt; making the default subtitles, as that is without a doubt the most common
</I>&gt;<i> &gt; kind of timed text. Making captions the default only means that most
</I>&gt;<i> &gt; timed text will be mislabeled as being appropriate for the HoH when it
</I>&gt;<i> &gt; is not.
</I>&gt;<i>
</I>&gt;<i> Ok, I've changed the default. However, I'm not fighting this battle if it
</I>&gt;<i> comes up again, and will just change it back if people don't defend having
</I>&gt;<i> this as the default. (And then change it back again if the browsers pick
</I>&gt;<i> &quot;subtitles&quot; in their implementations after all, of course.)
</I>&gt;<i>
</I>&gt;<i> Note that captions aren't just for users that are hard-of-hearing. Most of
</I>&gt;<i> the time when I use timed tracks, I want captions, because the reason I
</I>&gt;<i> have them enabled is that I have the sound muted.
</I>&gt;<i>
</I>
Hmm, you both have good points. Maybe we should choose something as the
default that is not visible on screen, such as &quot;descriptions&quot;? That would
avoid the issue and make it explicit for people who provide captions or
subtitles that they have to make a choice.


&gt;<i> &gt; - Use existing technologies where appropriate.
</I>&gt;<i> &gt; [...]
</I>&gt;<i> &gt; &gt; - Try as much as possible to have things Just Work.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I think by specifying a standalone cue text parser WebSRT fails on these
</I>&gt;<i> &gt; counts compared to reusing the HTML fragment parsing algorithm for
</I>&gt;<i> &gt; parsing cue text.
</I>&gt;<i>
</I>&gt;<i> HTML parsing is a disaster zone that we should avoid at all costs, IMHO. I
</I>&gt;<i> certainly don't think it would make any sense to propagate that format
</I>&gt;<i> into anywhere where we don't absolutely have to propagate it.
</I>&gt;<i>
</I>
A WebSRT authoring application does not have to create all markup that a
HTML fragment parser supports. It would only use what it sees necessary for
the use cases that it targets.

Browsers are WebSRT players that will consume the HTML fragments created by
such authoring applications.
In addition, browsers will also be able to consume richer HTML fragments
that were created as time-aligned overlays for video  with more fancy
styling by Web developers. Something like
<A HREF="http://people.mozilla.com/~prouget/demos/vp8/">http://people.mozilla.com/~prouget/demos/vp8/</A> (you need Firefox for it).
Where it says &quot;This movie will eat your planet&quot;, you could have fancy timed
text.

Just as much as there is a need for basic captions and subtitles, there is
also a need for fancy time-aligned HTML fragments. It would be very strange
if, in order to get that working, people would need to use the &quot;metadata&quot;
part of the WebSRT spec.


&gt;<i> &gt; If we don't use HTML wholesale, then there's really no reason to use
</I>&gt;<i> &gt; &gt; HTML at all. (And using HTML wholesale is not really an option, as you
</I>&gt;<i> &gt; &gt; say above.)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I disagree. The most obvious way of reusing existing infrastructure in
</I>&gt;<i> &gt; browsers, the most obvious way of getting support for future syntax
</I>&gt;<i> &gt; changes that support attributes or new tag names and the most obvious
</I>&gt;<i> &gt; way to get error handling that behaves in the way the appearance of the
</I>&gt;<i> &gt; syntax suggests is to reuse the HTML fragment parsing algorithm for
</I>&gt;<i> &gt; parsing the cue text.
</I>&gt;<i>
</I>&gt;<i> HTML parsing is one of the most convoluted, quirk-laden, unintuitive and
</I>&gt;<i> expensive syntaxes... Its extensibility story is a disaster (there's so
</I>&gt;<i> many undocumented and continually evolving constraints that any addition
</I>&gt;<i> is massively expensive), its implementation drags with it all kinds of
</I>&gt;<i> crazy dependencies on the DOM, event loop interactions, scripting, and so
</I>&gt;<i> forth, and it has a highly inconsistent syntax.
</I>&gt;<i>
</I>&gt;<i> I'm not at all convinced reusing it would be &quot;obvious&quot;.
</I>&gt;<i>
</I>
It is obvious to anyone who is not on a standards body. :-)

But seriously: all the things you mention above are advantages: all this
stuff has been solved for HTML and will not have to be solved again if we
reuse it. Anything new will inevitably go through a similar development
path. I don't see this as the opportunity to re-invent HTML when in fact for
anyone out there HTML is working just fine.


On Sun, 25 Jul 2010, Silvia Pfeiffer wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; I think if we have a mixed set of .srt files out there, some of which
</I>&gt;<i> &gt; are old-style srt files (with line numbers, without WebSRT markup) and
</I>&gt;<i> &gt; some are WebSRT files with all the bells and whistles and with
</I>&gt;<i> &gt; additional external CSS files, we create such a mess for that existing
</I>&gt;<i> &gt; ecosystem that we won't find much love.
</I>&gt;<i>
</I>&gt;<i> I'm not sure our goal is to find love here, but in general I would agree
</I>&gt;<i> that it would be better to have one format than two. I don't see why we
</I>&gt;<i> wouldn't just have one format here though. The idea of WebSRT is to be
</I>&gt;<i> sufficiently backwards-compatible that that is possible.
</I>&gt;<i>
</I>
With &quot;finding love&quot; I referred to your expressed goals:
 - Keep implementation costs for standalone players low.
 - Use existing technologies where appropriate.
 - Try as much as possible to have things Just Work.

With WebSRT, we will have one label for two different types of files: the
old-style SRT files and the new WebSRT files. Just putting a single label on
them doesn't mean it is one format, in particular when most old files will
not be conformant to the new label and many new files will not play in the
software created for the old spec.



&gt;<i> On Mon, 26 Jul 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt; On Thu, 16 Jul 2009, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt;&gt; * the &quot;type&quot; attribute is meant to both identify the mime type of the
</I>&gt;<i> &gt; &gt;&gt; format and the character set used in the file.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; It's not clear that the former is useful. The latter may be useful; I
</I>&gt;<i> &gt; &gt; haven't supported that yet.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If the element is to support a single format in a single character set,
</I>&gt;<i> &gt; then there is no need for a MIME type. So, we need to be clear whether
</I>&gt;<i> &gt; we want to restrict our option here for multiple formats.
</I>&gt;<i>
</I>&gt;<i> As specified the spec supports multiple formats, it just only talks about
</I>&gt;<i> WebSRT currently. (If it becomes likely that browsers will have different
</I>&gt;<i> sets of supported formats, we can add a type=&quot;&quot; attribute to help browsers
</I>&gt;<i> find the right files without checking each one, but that's not necessary
</I>&gt;<i> unless that becomes a likely problem.)
</I>&gt;<i>
</I>
OK, understood.



&gt;<i> &gt; &gt;&gt; The character set question is actually a really difficult problem to
</I>&gt;<i> &gt; &gt;&gt; get right, because srt files are created in an appropriate character
</I>&gt;<i> &gt; &gt;&gt; set for the language, but there is no means to store in a srt file
</I>&gt;<i> &gt; &gt;&gt; what character set was used in its creation. That's a really bad
</I>&gt;<i> &gt; &gt;&gt; situation to be in for the Web server, who can then only take an
</I>&gt;<i> &gt; &gt;&gt; educated guess. By giving the ability to the HTML author to specify
</I>&gt;<i> &gt; &gt;&gt; the charset of the srt file with the link, this can be solved.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Yeah, if this is a use case people are concerned about, then I agree
</I>&gt;<i> &gt; &gt; that a solution at the markup level makes sense.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If we really are to use WebSRT because (amongst other reasons) it allows
</I>&gt;<i> &gt; reuse of existing srt files, then we need to introduce a means to
</I>&gt;<i> &gt; provide the charset, since almost none of the srt files in the wild that
</I>&gt;<i> &gt; I have looked at were in UTF-8, but in all sorts of other character
</I>&gt;<i> &gt; sets. Another solution to this problem would be to have WebSRT know what
</I>&gt;<i> &gt; charset their characters are in - then we don't need to add such
</I>&gt;<i> &gt; information to the &lt;track&gt; element. It will still not work with legacy
</I>&gt;<i> &gt; SRT files though.
</I>&gt;<i>
</I>&gt;<i> I've added a charset=&quot;&quot; attribute to allow authors to provide the
</I>&gt;<i> character encoding for legacy SRT files. WebSRT files are required to be
</I>&gt;<i> UTF-8, however (legacy SRT files that are not UTF-8 are considered
</I>&gt;<i> non-conforming).
</I>&gt;<i>
</I>
This supports my understanding that SRT files are a different format to
WebSRT files.



&gt;<i> &gt; You mention that karaoke and lyrics are supported by WebSRT, so could we
</I>&gt;<i> &gt; add them to the track kinds?
</I>&gt;<i>
</I>&gt;<i> Why would they need new script kinds? Isn't &quot;subtitles&quot; enough?
</I>&gt;<i>
</I>
Interesting idea.

This actually gets back to the issue that I have mentioned before: we are
actually overloading the meaning of the @kind attribute with many different
things:
* what the data is semantically: subtitle, caption, textual description,
chapters or &quot;metadata&quot; (i.e. &quot;anything&quot;)
* whether the data will be visually displayed
* how the data will be parsed

What if, from a semantic viewpoint, people want to have subtitles or
captions always show, but not karaoke or lyrics? I *think* putting karaoke
and lyrics in one pot is ok, but I wonder if we can just throw subtitles and
karaoke in one pot. I'll have to think about it...


&gt;<i> Does the earlier mean that we can only provide text for video and not
</I>
&gt;<i> for audio, which has no dimensions?
</I>&gt;<i>
</I>&gt;<i> If you want the browser to render cues, you have to use a &lt;video&gt; element
</I>&gt;<i> so that there is somewhere to render them. You can play audio with the
</I>&gt;<i> &lt;video&gt; element, and you can use &lt;audio&gt; and manually render the cues from
</I>&gt;<i> JS if desired.
</I>&gt;<i>
</I>
I see. That wasn't obvious to me, but I can see how that might makes sense.


We could provide an API dedicated to making it easier to render cues
&gt;<i> manually if desired (firing an event or callback with the actual cue for
</I>&gt;<i> each cue that shows, for example).
</I>&gt;<i>
</I>
I think that might be a good idea. How would you suggest? Is the oncuechange
not sufficient?



&gt;<i> &gt; And what if we wanted to render captions underneath a video rather than
</I>&gt;<i> &gt; inside video dimensions? Can that be achieved somehow?
</I>&gt;<i>
</I>&gt;<i> You'd need to script it, currently. (I didn't see many (any?) cases of
</I>&gt;<i> this in my research, so I didn't provide a declarative solution.)
</I>&gt;<i>
</I>
I've seen it done often on the Web, in particular for descriptions (or timed
transcripts) - it won't appear on TV or desktop caption applications though,
for obvious reasons.

For example, the descriptions on TED are rendered into a container that is
not overlayed onto the video: e.g.
<A HREF="http://www.ted.com/talks/dan_cobley_what_physics_taught_me_about_marketing.html(click">http://www.ted.com/talks/dan_cobley_what_physics_taught_me_about_marketing.html(click</A>
the interactive transcript on the right to display it).
Or the interactive transcript on youtube is timed text that is not rendered
on top of the video but in a box underneath: e.g.
<A HREF="http://www.youtube.com/watch?v=nF3yhZrtLRw">http://www.youtube.com/watch?v=nF3yhZrtLRw</A> .
For captions and subtitles it's less common, but rendering it underneath the
video rather than on top of it is not uncommon, e.g.
<A HREF="http://nihseniorhealth.gov/video/promo_qt300.html">http://nihseniorhealth.gov/video/promo_qt300.html</A> or
<A HREF="http://www.fs.fed.us/greatestgood/film/moviefiles/TheGreatestGood_Tr_C_L.movor">http://www.fs.fed.us/greatestgood/film/moviefiles/TheGreatestGood_Tr_C_L.movor</A>
<A HREF="http://www.veotag.com/player/Default.aspx?mode=sample&amp;sid=1&amp;pid={516D49AA-72F4-4DA6-91BA-6D225C2782D8">http://www.veotag.com/player/Default.aspx?mode=sample&amp;sid=1&amp;pid={516D49AA-72F4-4DA6-91BA-6D225C2782D8</A>}.



&gt;<i> &gt; It is possible to jump to a cue range through its number in the list in
</I>&gt;<i> &gt; the media element using JavaScript and setting the @currentTime to that
</I>&gt;<i> &gt; cue range's start time. However, it has not yet been defined whether
</I>&gt;<i> &gt; there is a relationship between media fragment URIs and timed tracks.
</I>&gt;<i> &gt; The media framgent URI specification has such URIs defined as e.g.
</I>&gt;<i> &gt; <A HREF="http://example.com/video.ogv#id=">http://example.com/video.ogv#id=</A>&quot;InTheBathroom&quot; and cues have a textual
</I>&gt;<i> &gt; identifier, so we can put these two together to enable this. Such URIs
</I>&gt;<i> &gt; will then be able to be used in the @src attribute or a media element
</I>&gt;<i> &gt; and focus the view on that cue, just like temporal media fragments do
</I>&gt;<i> &gt; with a random time range.
</I>&gt;<i>
</I>&gt;<i> I'm not sure I follow. Presumably this is all for in-band timed tracks, in
</I>&gt;<i> which case the HTML spec isn't really involved.
</I>&gt;<i>
</I>
Yes, I don't think w can make it work for external tracks. It's a media
fragment URI thing, so potentially something for browser vendors to
implement. But indeed, this was taking a jump into the future a bit.



&gt;<i> &gt; For linking out of a cue, there is a need to allow having hyperlinks in
</I>&gt;<i> &gt; cues. IIUC this is currently only possible by using a HTML-style markup
</I>&gt;<i> &gt; in the cue, declaring the cue as kind=metadata and calling
</I>&gt;<i> &gt; getCueAsSource() on the cue, then running your own overlays and shoving
</I>&gt;<i> &gt; the retrieved text to the innerHTML of that overlay.
</I>&gt;<i>
</I>&gt;<i> Having a hyperlink in a cue seems like really bad UI (having any temporal
</I>&gt;<i> interactive UI is typically highly inaccessible, and is generally only
</I>&gt;<i> considered a good idea in games). If you want to make the whole video
</I>&gt;<i> into a link (as Dave suggested in the e-mail above, if I understood it
</I>&gt;<i> correctly) then you don't need anything to do with timed tracks.
</I>&gt;<i>
</I>
You can always pause the presentation to follow a given hyperlink. It's
definitely better than having to re-type a URL, which is what is currently
happening in many of the timed annotations in YouTube that leave YouTube. I
don't see why this is bad UI design. In fact, for people with accessibility
issues it is much easier to stop a video and activate a hyperlink than
having to re-type a given hyperlink in captions, subtitles, or worse: in
descriptions. I see the need to support hyperlinks in cues as really
important for accessibility and usability reasons.


&gt;<i> While that works, it seems like a lot of hoops to jump through just to
</I>&gt;<i> &gt; be able to use a bit of HTML markup - in particular having to run your
</I>&gt;<i> &gt; own overlay. Could we introduce a kind=htmlfragment type where it is
</I>&gt;<i> &gt; obvious that the text is HTML and that the fragment parser can be run
</I>&gt;<i> &gt; automatically and display it through the given display mechanisms?
</I>&gt;<i>
</I>&gt;<i> I would on the contrary think that that would be something we should
</I>&gt;<i> _discourage_, not encourage!
</I>&gt;<i>
</I>
All that is going to achieve is that we will end up with HTML fragments in
metadata type cues and have to deal with them through JavaScript. I'd much
prefer we have a defined way of dealing with this situation rather than
having it be created inconsistently in JS libraries.


&gt;<i> Many existing subtitle formats and similar media-time-aligned text
</I>&gt;<i> &gt; formats contain file-wide name-value pairs that explain metadata for the
</I>&gt;<i> &gt; complete resource. An example are Lyrics files, e.g.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On Tue, 20 Apr 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Lyrics (LRC) files typically look like this:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; [ti:Can't Buy Me Love]
</I>&gt;<i> &gt; &gt; [ar:Beatles, The]
</I>&gt;<i> &gt; &gt; [au:Lennon &amp; McCartney]
</I>&gt;<i> &gt; &gt; [al:Beatles 1 - 27 #1 Singles]
</I>&gt;<i> &gt; &gt; [by:Wooden Ghost]
</I>&gt;<i> &gt; &gt; [re:A2 Media Player V2.2 lrc format]
</I>&gt;<i> &gt; &gt; [ve:V2.20]
</I>&gt;<i> &gt; &gt; [00:00.45]Can't &lt;00:00.75&gt;buy &lt;00:00.95&gt;me &lt;00:01.40&gt;love,
</I>&gt;<i> &gt; &gt; &lt;00:02.60&gt;love&lt;00:03.30&gt;, &lt;00:03.95&gt;love, &lt;00:05.30&gt;love&lt;00:05.60&gt;
</I>&gt;<i> &gt; &gt; [00:05.70]&lt;00:05.90&gt;Can't &lt;00:06.20&gt;buy &lt;00:06.40&gt;me &lt;00:06.70&gt;love,
</I>&gt;<i> &gt; &gt; &lt;00:08.00&gt;love&lt;00:08.90&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; You can see that there are title, artist, author, album, related
</I>&gt;<i> &gt; content, version and similar metadata information headers on this file.
</I>&gt;<i> &gt; Other examples contain copyright information and usage rights -
</I>&gt;<i> &gt; important information to understand and deal with when distributing
</I>&gt;<i> &gt; media-time-aligned text files on a medium such as the Web.
</I>&gt;<i>
</I>&gt;<i> I don't really see why we would want to embed this in a timed track. Even
</I>&gt;<i> in HTML embedding this kind of information has never taken off. We would
</I>&gt;<i> need to have very compelling use cases, implementation experience, and
</I>&gt;<i> implementation committements to move in such a direction, IMHO.
</I>&gt;<i>
</I>
Dublin Core has been a huge success. Every archive in the world uses that
kind of metadata. I am confused what you mean by metadata in HTML hasn't
taken off. I believe it's only search engines that stopped using metadata
and only because people started mis-using the system. That search engines
stopped using meta elements is a good thing and gave the use of the meta
element back to what it is for: providing machine-readable information, not
for SEO. Such metadata is also relevant to audio and video, just look at the
success of ID3 tags or Vorbis Comment. Similarly, we will need this
capability in timed text files.

I do wonder if Sam Dutton has an opinion on this and may even be keen on
implementation commitment? Sam?


&gt;<i> I would think it'd be good to define a standard means of extracting
</I>&gt;<i> &gt; plain text out of any type of cue, so it will be possible to hand this
</I>&gt;<i> &gt; to e.g. the accessibility API for reading back.
</I>&gt;<i>
</I>&gt;<i> Getting the raw data is already possible, unless I misunderstood what you
</I>&gt;<i> meant.
</I>&gt;<i>
</I>
What I meant is to have a getter in TimedTrackCueList that will not return
the cue with its specific markup (WebSRT, JSON or HTML fragment), but
stripped off any of the special markers. This can be very interesting when
wanting to shoot something through to speech recognition or so.


&gt;<i> The rendering and CSS styling approach with ::cue described in
</I>
&gt;<i>
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/complete/rendering.html#timed-tracks-0">http://www.whatwg.org/specs/web-apps/current-work/complete/rendering.html#timed-tracks-0</A>
</I>&gt;<i> &gt; is only defined on WebSRT. That means that there is no styling possible
</I>&gt;<i> &gt; for TimedTracks that come from a different format (assuming we may allow
</I>&gt;<i> &gt; other formats in future).
</I>&gt;<i>
</I>&gt;<i> Styling such formats would be quite possible, it just has to be defined.
</I>&gt;<i>
</I>
... and implemented by the browsers, I guess.


&gt;<i> I think this is a bit restrictive and would rather we define a mechanism
</I>&gt;<i> &gt; to allow CSS styling of cues that come from any type of TimedTrack, and
</I>&gt;<i> &gt; thus make the CSS styling part independent of the format.
</I>&gt;<i>
</I>&gt;<i> I don't know how to do that.
</I>&gt;<i>
</I>
I believe when you said &quot;it just has to be defined&quot;, that actually answered
this question.



&gt;<i> &gt; I think by understanding this and by making this explicit in the spec,
</I>
&gt;<i> we can more clearly decide what track kinds are still missing and also
</I>&gt;<i> &gt; what we actually need to implement.
</I>&gt;<i>
</I>&gt;<i> I'm not sure what to add to make this clearer. Can you elaborate?
</I>&gt;<i>
</I>
What I meant by this was that in section
<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#attr-track-kindwhere">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#attr-track-kindwhere</A>
@kind is introduced, there is no mention about the implications of
choosing between these @kind attributes. E.g. if I chose a &quot;description&quot;,
then it will not be visible unless I implement that in JavaScript - that is
a pretty big implication that I only found out when I finally got to reading
the rendering section. Also, that section does not provide any hint on what
type of markup will be expected in the cue text - I think that is also a
pretty big implication that should be mentioned in that section.


On Fri, 6 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; Note that the subtitling community has traditionally been using the
</I>&gt;<i> &gt; Subrip (srt) or SubViewer (sub) formats as a simple format and
</I>&gt;<i> &gt; SubStation alpha (ssa/ass) as the comprehensive format. Aegisub, the
</I>&gt;<i> &gt; successor of SubStation Alpha, is still the most popular subtitling
</I>&gt;<i> &gt; software and ASS is the currently dominant format. However, even this
</I>&gt;<i> &gt; community is right now developing a new format called AS6. This shows
</I>&gt;<i> &gt; that the subtitling community also hasn't really converged on a &quot;best&quot;
</I>&gt;<i> &gt; format yet.
</I>&gt;<i>
</I>&gt;<i> Also it's worth noting that the SubStation Alpha formats are very
</I>&gt;<i> presentational in nature, and do not follow the HTML school of semantic
</I>&gt;<i> language design at all. That is the main reason I didn't use those formats
</I>&gt;<i> for HTML &lt;video&gt; captions.
</I>&gt;<i>
</I>
The new AS6 format is probably more of a semantic language than SubStation
Alpha. BTW: it also includes metadata.


&gt;<i> So, given this background and the particular needs that we have with
</I>&gt;<i> &gt; implementing support for a time-synchronized text format in the Web
</I>&gt;<i> &gt; context, it would probably be best to start a new format from a clean
</I>&gt;<i> &gt; slate rather than building it on an existing format.
</I>&gt;<i>
</I>&gt;<i> I don't follow your reasoning here. As you said, SRT is a common subset of
</I>&gt;<i> most of the formats you listed; why would the conclusion not be that we
</I>&gt;<i> should therefore work with SRT?
</I>&gt;<i>
</I>
SRT is not a subset format-wise of the formats listed about. It is a subset
functionality-wise only.



&gt;<i> &gt; In contrast to being flexible about what goes into the cues, WebSRT is
</I>&gt;<i> &gt; completely restrictive and non-extensible in all the content that is
</I>&gt;<i> &gt; outside the cues. In fact, no content other than comments are allowed
</I>&gt;<i> &gt; outside the cues.
</I>&gt;<i>
</I>&gt;<i> None is allowed today, but it would be relatively straight-forward to
</I>&gt;<i> introduce metadata before the cues (or even in between the cues). For
</I>&gt;<i> example, we could add defaults:
</I>&gt;<i>
</I>&gt;<i>   *
</I>&gt;<i>   DEFAULTS
</I>&gt;<i>   L:-1 T:50% A:middle
</I>&gt;<i>
</I>&gt;<i>   00:00:20,000 --&gt; 00:00:24,400
</I>&gt;<i>   Altocumulus clouds occur between six thousand
</I>&gt;<i>
</I>&gt;<i>   00:00:24,600 --&gt; 00:00:27,800
</I>&gt;<i>   and twenty thousand feet above ground level.
</I>&gt;<i>
</I>&gt;<i> We could add metadata (here using a different syntax that is similarly
</I>&gt;<i> backwards-compatible with what the spec parser does today):
</I>

&gt;<i>   @charset --&gt; win-1252
</I>&gt;<i>   @language --&gt; en-US
</I>&gt;<i>
</I>&gt;<i>   00:00:20,000 --&gt; 00:00:24,400
</I>&gt;<i>   Altocumulus clouds occur between six thousand
</I>&gt;<i>
</I>&gt;<i>   00:00:24,600 --&gt; 00:00:27,800
</I>&gt;<i>   and twenty thousand feet above ground level.
</I>&gt;<i>
</I>&gt;<i>
</I>
When I read the following:
&quot;A WebSRT file body consists of an optional U+FEFF BYTE ORDER MARK (BOM)
character, followed by zero or more WebSRT line
terminators&lt;<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#websrt-line-terminator">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#websrt-line-terminator</A>&gt;,
followed by zero or more WebSRT
cues&lt;<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#websrt-cue">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#websrt-cue</A>&gt;
separated
from each other by two or more WebSRT line
terminators&lt;<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#websrt-line-terminator">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#websrt-line-terminator</A>&gt;,
followed by zero or more WebSRT line
terminators&lt;<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#websrt-line-terminator">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#websrt-line-terminator</A>&gt;
.&quot;
then that doesn't imply for me that we can add anything in front of the
WebSRT cues without breaking the spec, or that we can define cues that are
not time ranges around the &quot;--&gt;&quot; sign.

I would be very happy in particular with the addition of metadata in this
way.

If the DEFAULTS proposal implies something like inline specified default
styling and positioning (like inline CSS), then that may be useful, too.


There are a variety of syntaxes we could use. So long as whatever we do is
&gt;<i> backwards compatible with what the first set of deployed parsers do, we're
</I>&gt;<i> fine.
</I>&gt;<i>
</I>&gt;<i> Currently comments aren't allowed, but we could add those too (e.g. by
</I>&gt;<i> saying that any block of text that doesn't contain a &quot;--&gt;&quot; is a comment).
</I>&gt;<i>
</I>
I must be very confused, but I seemed to remember a comment line being one
that starts with a &quot;;&quot; having been defined for WebSRT. I don't know where
that notion came from and I apologize. I am not actually fussed about adding
comments.


&gt;<i> * there is no possibility to add file-wide metadata to WebSRT; things
</I>&gt;<i> &gt; about authoring and usage rights as well as information about the media
</I>&gt;<i> &gt; resource that the file relates to should be kept within the file. Almost
</I>&gt;<i> &gt; all subtitle and caption format have the possibility for such metadata
</I>&gt;<i>
</I>&gt;<i> This is something we could add if there is a clear use case, but I'm not
</I>&gt;<i> sure that there is. Why does SRT not have it today?
</I>&gt;<i>
</I>
Because SRT is a quick hack and the simplest format possible that fulfills
not even bare needs. :-)
But seriously: most formats have metadata and I would rather go with those
experiences than with SRT in this respect.



&gt;<i> &gt; and we know from image, music and video resources how important it is to
</I>&gt;<i> &gt; have the ability to keep such metadata inside the resource.
</I>&gt;<i>
</I>&gt;<i> Do we? I thought from image, music, and video we learnt that it didn't
</I>&gt;<i> make much difference! :-)
</I>&gt;<i>
</I>
I think ID3 is very successful, in particular in iTunes, see
<A HREF="http://en.wikipedia.org/wiki/ITunes#File_metadata">http://en.wikipedia.org/wiki/ITunes#File_metadata</A> . The vorbiscomment header
on Xiph files enjoys a similar popularity. And the huge success of EXIF for
images - written by every single digital photo camera and used by every
single photo application. They make a huge difference.




&gt;<i> &gt; * there is no style sheet association for a WebSRT resource; this can be
</I>&gt;<i> &gt; resolved by having the style sheet linked into the Web page where the
</I>&gt;<i> &gt; resource is used with the video, but that's not possible when the
</I>&gt;<i> &gt; resource is used by itself. It needs something like a &lt;link&gt; to a CSS
</I>&gt;<i> &gt; resource inside the WebSRT file.
</I>&gt;<i>
</I>&gt;<i> Do standalone SRT players want to support CSS? If not, it doesn't much
</I>&gt;<i> matter.
</I>&gt;<i>
</I>
Stand-alone SRT players wouldn't want to see any of the WebSRT extensions.
Stand-alone WebSRT players - if we define the styling to be in CSS - would
probably want to support whatever is in WebSRT - if that includes CSS, then
that's it. But any of this is just guesswork until we have implementations.


&gt;<i> * there is no magic identifier for a WebSRT resource, i.e. what the
</I>&gt;<i> &gt; &lt;wmml&gt; element is for WMML. This makes it almost impossible to create a
</I>&gt;<i> &gt; program to tell what file type this is, in particular since we have made
</I>&gt;<i> &gt; the line numbers optional. We could use &quot;--&gt;&quot; as an indicator, but it's
</I>&gt;<i> &gt; not a good signature.
</I>&gt;<i>
</I>&gt;<i> Yeah, that's a problem. I considered adding &quot;WEBSRT&quot; at the start of every
</I>&gt;<i> file but we couldn't use it reliably since WebSRT parsers presumably want
</I>&gt;<i> to support SRT using the same parser, and that has no signature.
</I>&gt;<i>
</I>
I continue to doubt that you can support WebSRT without changing your SRT
parser. Thus, you might as well make such a change and make it easy for SRT
parsers to identify that it's a WebSRT file to parse and not legacy SRT.


(Note that XML, and anything based on XML, as well as HTML, JS, and CSS,
&gt;<i> have no signature either. It's a common problem of text formats.)
</I>&gt;<i>
</I>
Well, there are typical things to parse at the head of XML files, such as
processing instructions or
&lt;!DOCTYPE html&gt;
&lt;html
These *are* magic identifiers.


&gt;<i> * there is no means to identify which parser is required in the cues (is
</I>&gt;<i> &gt; it &quot;plain text&quot;, &quot;minimal markup&quot;, or &quot;anything&quot;?) and therefore it is
</I>&gt;<i> &gt; not possible for an application to know how it should parse the cues.
</I>&gt;<i>
</I>&gt;<i> Timed track cues are not context-free. In standalone players, the user
</I>&gt;<i> says to play a particular cue file, so using the &quot;cue text&quot; mode is a good
</I>&gt;<i> assumption (why would you give mplayer a metadata cue file to display?).
</I>&gt;<i>
</I>
Because it is a .srt file and thus assumed to be supported by mplayer.


&gt;<i> Browsers have the &lt;track&gt; context.
</I>&gt;<i>
</I>
Yes, indeed, this is not a problem for browsers.


&gt;<i> * there is no version number on the format, thus it will be difficult to
</I>&gt;<i> &gt; introduce future changes.
</I>&gt;<i>
</I>&gt;<i> Version numbers are an antipattern in multivendor formats. This is an
</I>&gt;<i> intentional feature, not an unfortunate omission. HTML itself has dropped
</I>&gt;<i> the version number in its format; CSS has never had one. Most programming
</I>&gt;<i> languages don't have one.
</I>&gt;<i>
</I>
I've accepted this, though I can still see it being useful outside the Web.
But I can see the advantages and disadvantages and I can live without a
version number.



&gt;<i> &gt; I can understand that the definition of WebSRT took inspiration from SRT
</I>&gt;<i> &gt; for creating a simple format. But realistically most SRT files will not
</I>&gt;<i> &gt; be conformant WebSRT files because they are not written in UTF-8.
</I>&gt;<i>
</I>&gt;<i> I don't think they need to be conforming. They're already published.
</I>&gt;<i> Conformance is just a quality assurance tool, it's only relevant for
</I>&gt;<i> documents being written in the future.
</I>&gt;<i>
</I>
Conformance is also a problem if players and other tools do not accept files
that are not conformant. I would think Web browser will be highly
restrictive in what they accept - otherwise the spec isn't quite so useful
and we are starting to do quirks again.



&gt;<i> &gt; Further, realistically, all WebSRT files that use more than just the
</I>&gt;<i> &gt; plain text markup are not conformant SRT files.
</I>&gt;<i>
</I>&gt;<i> What's a &quot;conformant SRT file&quot;?
</I>&gt;<i>
</I>
Lacking all other formal registrations, it is what Wikipedia defines
<A HREF="http://en.wikipedia.org/wiki/SubRip">http://en.wikipedia.org/wiki/SubRip</A> . :-)
But to be serious again: just because a format doesn't have a formal
registration doesn't mean that it's not specified. For years, this forum
post has been used as the specification of SRT:
<A HREF="http://forum.doom9.org/archive/index.php/t-73953.html">http://forum.doom9.org/archive/index.php/t-73953.html</A> and it has been all
that the community needed. It's suboptimal, but it's not an invitation to
re-define the format.


&gt;<i> So, let's stop pretending there is compatibility and just call WebSRT a
</I>&gt;<i> &gt; new format.
</I>&gt;<i>
</I>&gt;<i> Compatibility has nothing to do with conformance. It has to do with what
</I>&gt;<i> user agents do. As far as I can tell, WebSRT is backwards-compatible with
</I>&gt;<i> legacy SRT user agents, and legacy SRT files are compatible with WebSRT
</I>&gt;<i> user agents as described by the spec.
</I>&gt;<i>
</I>
Legacy SRT files contain many different character sets, which makes them
non-conformant to WebSRT. I would not think that new WebSRT implementations
like what the Web browsers will need to implement should make exceptions
from the spec to support non-conformant files and become compatible with
legacy SRT files. That to me again confirms that these are two different
formats. Yes, they can be supported by the same piece of code, but that
doesn't make them the same format.



&gt;<i> &gt; In fact, the subtitling community itself has already expressed their
</I>&gt;<i> &gt; objections to building an extension of SRT, see
</I>&gt;<i> &gt; <A HREF="http://forum.doom9.org/showthread.php?p=1396576">http://forum.doom9.org/showthread.php?p=1396576</A> , so we shouldn't try to
</I>&gt;<i> &gt; enforce something that those for whom it was done don't want.
</I>&gt;<i>
</I>&gt;<i> The subtitling community in question is looking for a presentational
</I>&gt;<i> format. I think it is very reasonable to say that SRT is not interesting
</I>&gt;<i> for that purpose. However, a presentational format isn't, as far as I can
</I>&gt;<i> tell, suitable for the Web.
</I>&gt;<i>
</I>
I am not concerned here with what type of new format they want. I am
concerned about them expressing that it is not desirable to redefine SRT.


&gt;<i> * the mime type of WebSRT resources should be a different mime type to
</I>&gt;<i> &gt; SRT files, since they are so fundamentally different; e.g. text/websrt
</I>&gt;<i>
</I>&gt;<i> That's what I originally suggested, and you said we should use text/srt
</I>&gt;<i> because it is what people use, even though it's not registered. I think
</I>&gt;<i> you were right; it makes no sense to invent a new MIME type here.
</I>&gt;<i>
</I>
I don't seem to remember that discussion. Maybe it was a misunderstanding
and I thought you were asking what the mime type of the original SRT files
were. I certainly would not have suggested using it for a new format.


&gt;<i> * the file extension of WebSRT resources should be different from SRT
</I>&gt;<i> &gt; files, e.g. wsrt
</I>&gt;<i>
</I>&gt;<i> Extensions are irrelevant on the Web. People can use whatever extension
</I>&gt;<i> they want.
</I>&gt;<i>
</I>

Excellent. They are relevant outside the Web, so if we can at least agree to
have WebSRT resources have a different extension, I would be very happy with
that.



&gt;<i> &gt; Right now, there is &quot;plain text&quot;, &quot;minimum markup&quot; and &quot;anything&quot;
</I>&gt;<i> &gt; allowed in the cues.
</I>&gt;<i>
</I>&gt;<i> As far as I can tell there's just two modes -- plain text and text with
</I>&gt;<i> WebSRT markup.
</I>&gt;<i>
</I>
@kind=metadata  tracks can have &quot;anything&quot; in them, which is what I regarded
as the third type of markup.

&gt;<i> Seeing as WebSRT is built with the particular purpose of bringing
</I>&gt;<i> &gt; time-synchronized text for HTML5 media elements, it makes no sense to
</I>&gt;<i> &gt; exclude all the capabilities of HTML.
</I>&gt;<i>
</I>&gt;<i> I would on the contrary say that it makes no sense to take on all the HTML
</I>&gt;<i> baggage when all we want to do is introduce subtitles to video. :-)
</I>&gt;<i>
</I>
We are introducing functionality for text and events that are executed in a
time-synchronized manner with media elements - this is broader than just
subtitles.


&gt;<i> In the current form, WebSRT only makes limited use of existing CSS. I
</I>&gt;<i> &gt; see particularly the following limitations:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; * no use of the positioning functionality is made and instead a new
</I>&gt;<i> &gt; means of positioning is introduced; it would be nicer to just have this
</I>&gt;<i> &gt; reuse CSS functionality. It would also avoid having to repeat the
</I>&gt;<i> &gt; positioning information on every single cue.
</I>&gt;<i>
</I>&gt;<i> It doesn't make sense to position cues with CSS, because the position of
</I>&gt;<i> cues is an intrinsic part of the cue semantic. Where a cues appears can
</I>&gt;<i> change the plot of a show, for example (was it the evil twin who said
</I>&gt;<i> something or the good twin?).
</I>&gt;<i>
</I>
When I say &quot;CSS&quot; I mean the CSS means of providing in-line @style
information. That is just a different means of providing positioning and
styling information in a cue.



&gt;<i> &gt; * cue-related metadata (&quot;voice&quot;) could be made more generic; why not
</I>&gt;<i> &gt; reuse &quot;class&quot;?
</I>&gt;<i>
</I>&gt;<i> I don't know what this means. What is &quot;class&quot; and how does it differ from
</I>&gt;<i> &quot;voice&quot;?
</I>&gt;<i>
</I>
I am talking about the @class attribute in use by all HTML elements. It
could be used with a &lt;span&gt; to provide voice metadata and it would be more
flexible than &quot;voice&quot; because it can be associated with text fragments, not
with whole lines of text.


&gt;<i> * I noticed that it is not possible to make a language association with
</I>
&gt;<i> segments of text and thus it is not possible to have text with mixed
</I>&gt;<i> &gt; languages.
</I>&gt;<i>
</I>&gt;<i> Are mixed language subtitles common? I don't know that I've ever seen
</I>&gt;<i> that.
</I>&gt;<i>
</I>
I have seen several caption files that have at least two languages, possibly
even in the same cue. You even have some at
<A HREF="http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA.">http://wiki.whatwg.org/wiki/Use_cases_for_timed_tracks_rendered_over_video_by_the_UA.</A>


&gt;<i> * Is it possible to reuse the HTML font systems?
</I>&gt;<i>
</I>&gt;<i> What is the HTML font system?
</I>&gt;<i>
</I>
Basically stuff defined here:
<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#fonts-and-colors">http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#fonts-and-colors</A>



&gt;<i> On Thu, 12 Aug 2010, Philip J&#228;genstedt wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The core &quot;problem&quot; is that WebSRT is far too compatible with existing
</I>&gt;<i> &gt; SRT usage. Regardless of the file extension and MIME type used, it's
</I>&gt;<i> &gt; quite improbable that anyone will have different parsers for the same
</I>&gt;<i> &gt; format. Once media players have been forced to handle the extra markup
</I>&gt;<i> &gt; in WebSRT (e.g. by ignoring it, as many already do) the two formats will
</I>&gt;<i> &gt; be the same, and using WebSRT markup in .srt files will just work, so
</I>&gt;<i> &gt; that's what people will do. We may avoid being seen as arrogant
</I>&gt;<i> &gt; format-hijackers, but the end result is two extensions and two different
</I>&gt;<i> &gt; MIME types that mean exactly the same thing.
</I>&gt;<i>
</I>&gt;<i> I think we'll look equally arrogant if we ignore years of experience with
</I>&gt;<i> subtitling formats and just make up an entirely new format. It's not like
</I>&gt;<i> the world is short of subtitling formats.
</I>&gt;<i>
</I>
No matter how we twist it, WebSRT *is* a new format to the subtitling world.


On Wed, 18 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; It actually burns down to the question: do we want the simple SRT format
</I>&gt;<i> &gt; to survive as its own format and be something that people can rely upon
</I>&gt;<i> &gt; as not having &quot;weird stuff&quot; in it - or do we not. I believe that it's
</I>&gt;<i> &gt; important that it survives.
</I>&gt;<i>
</I>&gt;<i> Does that format still exist? Is it materially different than WebSRT?
</I>&gt;<i>
</I>
What do you mean? All existing SRT files adhere to the simple form of SRT.
None of the adhere to the WebSRT specification.



&gt;<i> On Sat, 21 Aug 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; It's not just about implementation cost - it's also the problem of
</I>&gt;<i> &gt; maintaining another spec that can grow to have eventually all the
</I>&gt;<i> &gt; features that HTML5 has and more. Do you really eventually want to
</I>&gt;<i> &gt; re-spec and re-implement a whole innerHTML parser plus the extra &lt;t&gt;
</I>&gt;<i> &gt; element when we start putting &lt;svg&gt; and &lt;canvas&gt; and all sorts of other
</I>&gt;<i> &gt; more complex HTML features into captions? Just because the &lt;t&gt; element
</I>&gt;<i> &gt; is making trouble now? Is this really the time to re-invent HTML?
</I>&gt;<i>
</I>&gt;<i> No, it's not. We should never let subtitles get that crazy.
</I>&gt;<i>
</I>
Hmm, where have I heard that said before ...
<A HREF="http://www.ibiblio.org/pioneers/lee.html">http://www.ibiblio.org/pioneers/lee.html</A>
&quot;Berners-Lee was concerned over some of the new directions the Web was
taking. There were decided differences between his original vision and the
visions of Andreesen and the Netscape crowd. The Web was designed to be a
serious medium.&quot;
I think it's a myth to believe one has control over the path a technology
will take and in which way it will be used.


On Mon, 23 Aug 2010, Philip J&#228;genstedt wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; I don't expect that SVG, &lt;canvas&gt;, images, etc will ever natively be
</I>&gt;<i> &gt; made part of captions. Rather, I would hope that the metadata state
</I>&gt;<i> &gt; together with scripts is used. If we think that e.g. images in captions
</I>&gt;<i> &gt; are an important use case, then WebSRT is not a good solution.
</I>&gt;<i>
</I>&gt;<i> Indeed.
</I>&gt;<i>
</I>
Images in captions will be used, I can guarantee that.



&gt;<i> &gt; If we allow arbitrary HTML and expect browsers to handle it well, it
</I>&gt;<i> &gt; adds some complexity. For example, any videos and images in the cue
</I>&gt;<i> &gt; would have to be fully loaded and ready to be decoded by the time the
</I>&gt;<i> &gt; cue is to be shown, which I really don't want to implement the logic
</I>&gt;<i> &gt; for. Simply having an iframe-like container where the document is
</I>&gt;<i> &gt; replaced for each cue wouldn't be enough, rather one would have to
</I>&gt;<i> &gt; create one document per cue during parsing and wait for all of those to
</I>&gt;<i> &gt; finish loading before beginning playback. I'm not sure, but I'm guessing
</I>&gt;<i> &gt; that amounts to significant memory overhead.
</I>&gt;<i>
</I>&gt;<i> Quite.
</I>&gt;<i>
</I>
People will do it with HTML in the metadata and then decode it through
JavaScript and throw it at a the HTML fragment parser, including all the
side effects that may have and that they will have to deal with. I'm sure
this will eventually catch up with us. Would it not be better to think about
it now and address it - in particular if you are saying that WebSRT is not
the right solution for this?



&gt;<i> On Tue, 24 Aug 2010, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I believe [SVG etc] will be [added to WebSRT]. But since we are only
</I>&gt;<i> &gt; looking at the ways in which captions and subtitles are used currently,
</I>&gt;<i> &gt; we haven't accepted this as an important use case, which is fair enough.
</I>&gt;<i> &gt; I am considering likely future use though, which is always hard to
</I>&gt;<i> &gt; argue.
</I>&gt;<i>
</I>&gt;<i> In all my research for subtitles, I found very few cases of anything like
</I>&gt;<i> this. Even DVDs, whose subtitle tracks are just hardcoded bitmap images,
</I>&gt;<i> don't do anything fancy with them... just plain text and italics,
</I>&gt;<i> generally. Why haven't people started doing fancy stuff with subtitles in
</I>&gt;<i> all the years that we've had TVs? It's not like they can't do it.
</I>&gt;<i>
</I>
SVG on the TV? All that was possible was teletext type graphics and indeed,
people did a lot of graphics there, e.g.
<A HREF="http://www.google.com.au/images?q=teletext">http://www.google.com.au/images?q=teletext</A> .


My guess is that the real reason is that when you get so fancy that you're
&gt;<i> including graphics and the like, you're no longer doing timed tracks,
</I>&gt;<i> you're just doing content, and the right thing to do is to either burn it
</I>&gt;<i> in, or consider it a separate construct animated on top of the video, e.g.
</I>&gt;<i> an &lt;svg:video&gt; and SMIL.
</I>&gt;<i>
</I>
There was no authoring format available for such things that anything would
support to display. Even the more complex caption formats were really not
supported in any player. Putting it on the Web is a game changer. It will be
easy to author (plenty of people know how to author HTML and will be able to
throw HTML fragments into WebSRT cues) and it will be easy to display (using
some JavaScript and the framework we're putting in place).



&gt;<i> On Wed, 25 Aug 2010, Philip J&#228;genstedt wrote:
</I>
&gt;<i>
</I>&gt;<i> &gt; The main reason to care about the MIME type is some kind of &quot;doing the
</I>&gt;<i> &gt; right thing&quot; by not letting people get away with misconfigured servers.
</I>&gt;<i> &gt; Sometimes I feel it's just a waste of everyone's time though, it would
</I>&gt;<i> &gt; generally be less work for both browsers and authors to not bother.
</I>&gt;<i>
</I>&gt;<i> Agreed. Not sure what to do for WebSRT though, since there's no good way
</I>&gt;<i> to recognise a WebSRT file as opposed to some other format.
</I>&gt;<i>
</I>
You could put the &quot;WebSRT&quot; string at the start as proposed earlier.


On Thu, 26 Aug 2010, Silvia Pfeiffer wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; You misunderstand my intent. I am by no means suggesting that no WebSRT
</I>&gt;<i> &gt; content is treated as SRT by any application. All I am asking for is a
</I>&gt;<i> &gt; different file extension and a different mime type and possibly a magic
</I>&gt;<i> &gt; identifier such that *authoring* applications (and authors) can clearly
</I>&gt;<i> &gt; designate this to be a different format, in particular if they include
</I>&gt;<i> &gt; new features.
</I>&gt;<i>
</I>&gt;<i> Wouldn't an authoring application just have two (or more) different &quot;save
</I>&gt;<i> as&quot; or &quot;export&quot; format options? &quot;Save as SRT with no formatting&quot;, &quot;Save as
</I>&gt;<i> SRT with &lt;b&gt; only&quot;, &quot;Save as WebSRT&quot;, or whatnot. Or a list of checkboxes
</I>&gt;<i> for standalone user agents to be compatible with, so that it can pick the
</I>&gt;<i> common subset.
</I>&gt;<i>
</I>
Yes, that sounds sensible. So let's make sure they cannot be confused or
overwrite each other by giving WebSRT files a .wsrt extension and keeping
the legacy format with a .srt extension.


&gt;<i> Then a *playback application* has the chance to identify them as a
</I>&gt;<i> &gt; different format and provide a specific parser for it, instead of
</I>&gt;<i> &gt; failing like Totem. They can also decide to extend their existing SRT
</I>&gt;<i> &gt; parser to support both WebSRT and SRT. And I also have no issue with a
</I>&gt;<i> &gt; user deciding to give a WebSRT file a go by renaming it to .srt.
</I>&gt;<i>
</I>&gt;<i> I think you think there's more difference between WebSRT and SRT than
</I>&gt;<i> there is. In practice, there is less difference between WebSRT and the
</I>&gt;<i> equivalent SRT file than there is between two random SRT files today. The
</I>&gt;<i> difference between WebSRT and SRT is well within the &quot;error bars&quot; of what
</I>&gt;<i> SRT is today.
</I>&gt;<i>
</I>
A WebSRT file with JSON in the cues is more different to anything that is
called .srt today.


&gt;<i> By keeping WebSRT and SRT as different formats we give the applications
</I>&gt;<i> &gt; a choice to support either, or both in the same parser. If we don't, we
</I>&gt;<i> &gt; force them to deal in a single parser with all the oddities of SRT
</I>&gt;<i> &gt; formats as well as all the extra features and all the extensibility of
</I>&gt;<i> &gt; WebSRT.
</I>&gt;<i>
</I>&gt;<i> I don't understand what the difference would be.
</I>&gt;<i>
</I>
An authoring application that loads a WebSRT file should support all
features of WebSRT, even the metadata type and should know what to do with
it. If such a file is clearly marked as .wsrt, the authoring application has
a chance to do the right thing with the file and allow you to continue
editing your JSON content in a special interface for it. If such a file is
marked as .srt, it will just use the cues as they are as caption text. Worse
still: if we have thrown any type of XML into  the cues, all the tags will
be stripped.

Cheers,
Silvia.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20100909/d605a84c/attachment-0002.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20100909/d605a84c/attachment-0002.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="070697.html">[whatwg] Timed tracks: feedback compendium
</A></li>
	<LI>Next message: <A HREF="070752.html">[whatwg] Timed tracks: feedback compendium
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#70748">[ date ]</a>
              <a href="thread.html#70748">[ thread ]</a>
              <a href="subject.html#70748">[ subject ]</a>
              <a href="author.html#70748">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
