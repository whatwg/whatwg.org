<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] WebVTT feedback (and some other &lt;video&gt; feedback that	snuck in)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20WebVTT%20feedback%20%28and%20some%20other%20%3Cvideo%3E%20feedback%20that%0A%09snuck%20in%29&In-Reply-To=%3CPine.LNX.4.64.1111290013290.9078%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="076285.html">
   <LINK REL="Next"  HREF="076286.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] WebVTT feedback (and some other &lt;video&gt; feedback that	snuck in)</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20WebVTT%20feedback%20%28and%20some%20other%20%3Cvideo%3E%20feedback%20that%0A%09snuck%20in%29&In-Reply-To=%3CPine.LNX.4.64.1111290013290.9078%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] WebVTT feedback (and some other &lt;video&gt; feedback that	snuck in)">ian at hixie.ch
       </A><BR>
    <I>Thu Dec  1 16:34:15 PST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="076285.html">[whatwg] API design restrictions due to barewords in onxxx=&quot;&quot; attributes
</A></li>
        <LI>Next message: <A HREF="076286.html">[whatwg] WebVTT feedback (and some other &lt;video&gt; feedback that	snuck in)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34026">[ date ]</a>
              <a href="thread.html#34026">[ thread ]</a>
              <a href="subject.html#34026">[ subject ]</a>
              <a href="author.html#34026">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
Please note that WebVTT has moved to a Community Group. The specification 
is now here:

   <A HREF="http://dev.w3.org/html5/webvtt/">http://dev.w3.org/html5/webvtt/</A>

I recommend sending further feedback on this specification to the CG's 
mailing list:

   <A HREF="http://lists.w3.org/Archives/Public/public-texttracks/">http://lists.w3.org/Archives/Public/public-texttracks/</A>


On Thu, 2 Jun 2011, Glenn Maynard wrote:
&gt;<i> On Thu, Jun 2, 2011 at 7:28 PM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; We can add comments pretty easily (e.g. we could say that &quot;&lt;!&quot; starts 
</I>&gt;<i> &gt; a comment and &quot;&gt;&quot; ends it -- that's already being ignored by the 
</I>&gt;<i> &gt; current parser), if people really need them. But are comments really 
</I>&gt;<i> &gt; that useful? Did SRT have problem due to not supporting inline 
</I>&gt;<i> &gt; comments? (Or did it support inline comments?)
</I>&gt;<i> 
</I>&gt;<i> I've only worked with SSA subtitles (fansubbing), where {text in braces} 
</I>&gt;<i> effectively worked as a comment.  We used them a lot to communicate 
</I>&gt;<i> between editors on a phrase-by-phrase basis.
</I>&gt;<i> 
</I>&gt;<i> But for that use case, using hidden spans makes more sense, since you 
</I>&gt;<i> can toggle them on and off to view them inline, etc.
</I>&gt;<i> 
</I>&gt;<i> Given that, I'd be fine with a comment format that doesn't allow mid-cue 
</I>&gt;<i> comments, if it makes the format simpler.
</I>
Well right now we don't &quot;allow&quot; comments at all, but we do technically 
support them both at the inline and block level, so we can add them later 
if there's a good use case.

There is some discussion of use cases for comments here:

   <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=14552">http://www.w3.org/Bugs/Public/show_bug.cgi?id=14552</A>


&gt;<i> &gt;&gt; The text on the left is a transcription, the top is a 
</I>&gt;<i> &gt;&gt; transliteration, and the bottom is a translation.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Aren't these three separate text tracks?
</I>&gt;<i> 
</I>&gt;<i> They're all in the same track, in practice, since media players don't 
</I>&gt;<i> play multiple subtitle tracks.
</I>&gt;<i> 
</I>&gt;<i> It's true that having them in separate tracks would be better, so they 
</I>&gt;<i> can be disabled individually.  This is probably rare enough that it 
</I>&gt;<i> should just be sorted out with scripts, at least to start.
</I>
Since we support multiple tracks, I think that's sufficient.


&gt;<i> &gt; It's not clear to me that we need language information to apply proper 
</I>&gt;<i> &gt; font selection and word wrapping, since CSS doesn't do it.
</I>&gt;<i> 
</I>&gt;<i> But it doesn't have to, since HTML does this with @lang.
</I>
HTML doesn't do any font selection or word wrapping.

Per the HTML and CSS specs, lang=&quot;&quot; has no effect on rendering.


&gt;<i> &gt; Mixing one CJK language with one non-CJK language seems fine. That 
</I>&gt;<i> &gt; should always work, assuming you specify good fonts in the CSS.
</I>&gt;<i> 
</I>&gt;<i> The font is ultimately in the user's control.  I tell Firefox to always 
</I>&gt;<i> use Tahoma for Western text and MS Gothic for Japanese text, ignoring 
</I>&gt;<i> the often ugly site-specified fonts.
</I>
Yeah, you won't be able to do that with WebVTT, at least not today.


&gt;<i> The most straightforward solution would seems to be having @lang be a 
</I>&gt;<i> CSS property; I don't know the rationale for this being done by HTML 
</I>&gt;<i> instead.
</I>
Language is a property of the content, it's not a presentation feature 
that could change based on the device, media, author whim, etc.


&gt;<i> &gt; I don't understand why we can't have good typography for CJK and 
</I>&gt;<i> &gt; non-CJK together. Surely there are fonts that get both right?
</I>&gt;<i> 
</I>&gt;<i> I've never seen a Japanese font that didn't look terrible for English 
</I>&gt;<i> text.  Also, I don't want my font selection to be severely limited due 
</I>&gt;<i> to the need to use a single font for both languages, instead of using 
</I>&gt;<i> the right font for the right text.
</I>
Instead of working around poor fonts in all our various languages, we 
should just fix the fonts.


&gt;<i> &gt;&gt; One example of how this can be tricky: at 0:17, a caption on the 
</I>&gt;<i> &gt;&gt; bottom wraps and takes two lines, which then pushes the line at 0:19 
</I>&gt;<i> &gt;&gt; upward (that part's simple enough). &#194;&#160;If instead the top part had 
</I>&gt;<i> &gt;&gt; appeared first, the renderer would need to figure out in advance to 
</I>&gt;<i> &gt;&gt; push it upwards, to make space for the two-line caption underneith 
</I>&gt;<i> &gt;&gt; it. Otherwise, the captions would be forced to switch places.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Right, without lookahead I don't know how you'd solve it. With 
</I>&gt;<i> &gt; lookahead things get pretty dicey pretty quickly.
</I>&gt;<i> 
</I>&gt;<i> The problem is that, at least here, the whole scene is nearly 
</I>&gt;<i> incomprehensible if the top/bottom arrangement isn't maintained. Lacking 
</I>&gt;<i> anything better, I suspect authors would use similar brittle hacks with 
</I>&gt;<i> WebVTT.
</I>
Authors who want to handle this can specify explicitly which lines each 
cue should appear on. That's already supported. But I don't see any way to 
do this automatically in a sane manner.


&gt;<i> &gt;&gt; I think that, no matter what you do, people will insert line breaks 
</I>&gt;<i> &gt;&gt; in cues. &#194;&#160;I'd follow the HTML model here: convert newlines to spaces 
</I>&gt;<i> &gt;&gt; and have a separate, explicit line break like &lt;br&gt; if needed, so 
</I>&gt;<i> &gt;&gt; people don't manually line-break unless they actually mean to.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The line-breaks-are-line-breaks feature is one of the features that 
</I>&gt;<i> &gt; originally made SRT seem like a good idea. It still seems like the 
</I>&gt;<i> &gt; neatest way of having a line break.
</I>&gt;<i> 
</I>&gt;<i> But does this matter?  Line breaks within a cue are relatively uncommon 
</I>&gt;<i> in my experience (perhaps it's different for other languages), compared 
</I>&gt;<i> to how many people will insert line breaks in a text editor simply to 
</I>&gt;<i> break lines while authoring.
</I>
In English, at least, it seems pretty common. Almost all cues seem to get 
manually line-broken so as to maintain line length balance, for instance.


&gt;<i> If you do this while testing on a large monitor, it's likely to look 
</I>&gt;<i> reasonable when rendered; the brokenness won't show up until it's played 
</I>&gt;<i> in a smaller window.  Anyone using a non-programmer's text editor that 
</I>&gt;<i> doesn't handle long lines cleanly is likely to do this.
</I>
Actually the size isn't such a big deal since the font size is just based 
on the video size.


&gt;<i> Wrapping lines manually in SRTs also appears to be common (even 
</I>&gt;<i> standard) practice, perhaps due to inadequate line wrapping in SRT 
</I>&gt;<i> renderers.  Making line breaks explicit should help keep people from 
</I>&gt;<i> translating this habit to WebVTT.
</I>
I don't really see this habit as a problem, personally.


&gt;<i> &gt;&gt; Related to line breaking, should there be an &nbsp; escape? 
</I>&gt;<i> &gt;&gt; &#160;Inserting nbsp literally into files is somewhat annoying for 
</I>&gt;<i> &gt;&gt; authoring, since they're indistinguishable from regular spaces.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; How common would &nbsp; be?
</I>&gt;<i> 
</I>&gt;<i> I guess the main cases I've used nbsp for don't apply so much to 
</I>&gt;<i> captions, eg. &#194;&#169;&nbsp;2011 (likely to come at the start of a caption, so 
</I>&gt;<i> not likely to be wrapped anyway).
</I>
Yeah.


&gt;<i> &gt;&gt; We might also consider leaning on users a bit to tell us what they 
</I>&gt;<i> &gt;&gt; want. For example, I think people are pretty used to hitting play and 
</I>&gt;<i> &gt;&gt; then pause to buffer until the end of the video. What if we just used 
</I>&gt;<i> &gt;&gt; our bandwidth heuristics while in the play state, and buffered 
</I>&gt;<i> &gt;&gt; blindly when a pause occurs less than X seconds into a video? I won't 
</I>&gt;<i> &gt;&gt; argue that this is a wonderful solution (or a habit we should 
</I>&gt;<i> &gt;&gt; encourage), but I figured I'd throw a random idea out there&#233;&#136;&#165;&#239;&#191;&#189;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; That seems like pretty ugly UI. :-)
</I>&gt;<i> 
</I>&gt;<i> Changing buffering modes based on *when* the user pauses is an ugly UI.  
</I>&gt;<i> Pausing to let a video buffer when it's underrunning (regardless of when 
</I>&gt;<i> it's paused) is something easy to understand and that people are used 
</I>&gt;<i> to, though.  I don't know if this is relevant to the spec or just an 
</I>&gt;<i> implementation issue.
</I>
The spec allows pretty much any buffering strategy. I don't see what else 
we could do, here, really. Browsers will do what they think is best 
regardless of what the spec says.


&gt;<i> &gt;&gt; I think that pausing shouldn't affect read-ahead buffering behavior. 
</I>&gt;<i> &gt;&gt; I'd suggest another preload value, preload=buffer, sitting between 
</I>&gt;<i> &gt;&gt; &quot;metadata&quot; and &quot;auto&quot;. &#194;&#160;In addition to everything loaded by 
</I>&gt;<i> &gt;&gt; &quot;metadata&quot;, it also fills the read-ahead buffer (whether the video is 
</I>&gt;<i> &gt;&gt; playing or not).
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; - If a page wants prebuffering only (not full preloading), it sets 
</I>&gt;<i> &gt;&gt; preload=buffer. &#194;&#160;This can be done even when the video is paused, so 
</I>&gt;<i> &gt;&gt; when the user presses play, the video starts instantly without 
</I>&gt;<i> &gt;&gt; pausing for a server round-trip like preload=metadata.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So this would be to buffer enough to play through assuming the network 
</I>&gt;<i> &gt; remains at the current bandwidth, but no more?
</I>&gt;<i> 
</I>&gt;<i> I suppose that wouldn't work too well: if the video is small then you 
</I>&gt;<i> may as well preload the whole thing, and if it's large then long-term 
</I>&gt;<i> bandwidth estimates aren't going to be very accurate.  (I'm dubious of 
</I>&gt;<i> any behavior based on bandwidth estimations.)
</I>
Yeah. I'll just leave this up to the UA (&quot;auto&quot;).


On Fri, 3 Jun 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> &gt; &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt; &gt; There was also some discussion about metadata. Language is 
</I>&gt;<i> &gt; &gt; &gt; &gt; sometimes necessary for the font engine to pick the right glyph.
</I>&gt;<i> &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt; Could you elaborate on this? My assumption was that we'd just use 
</I>&gt;<i> &gt; &gt; &gt; CSS, which doesn't rely on language for this.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; It's not in any spec that I'm aware of, but some browsers (including 
</I>&gt;<i> &gt; &gt; Opera) pick different glyphs depending on the language of the text, 
</I>&gt;<i> &gt; &gt; which really helps when rendering CJK when you have several CJK 
</I>&gt;<i> &gt; &gt; fonts on the system. Browsers will already know the language from 
</I>&gt;<i> &gt; &gt; &lt;track srclang&gt;, so this would be for external players.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; How is this problem solved in SRT players today?
</I>&gt;<i> 
</I>&gt;<i> Not at all, it seems. Both VLC and Totem allow setting the character 
</I>&gt;<i> encoding and font used for subtitles in the (global) preferences menu, 
</I>&gt;<i> so presumably you would change that if the default doesn't work. Font 
</I>&gt;<i> switching seems to mainly be an issue when your system has other default 
</I>&gt;<i> fonts than the text you're reading, and it appears that is rare enough 
</I>&gt;<i> that very little software does anything about it, browsers perhaps being 
</I>&gt;<i> an exception.
</I>
Interesting.

If we are to add language information to the language, there's four ways 
to do it: inline, cue-level, block-level (a section of the file, e.g. 
setting a default at different points in the file), and file-level.

Inline would look like this:

   WEBVTT

   cue id
   00:00:00.000 --&gt; 00:00:01.000
   &lt;lang en&gt;cue text says &lt;lang fr&gt;bonjour&lt;/lang&gt;&lt;/lang&gt;

File-level would look like this:

   WEBVTT
   language: fr

   cue id
   00:00:00.000 --&gt; 00:00:01.000
   bonjour

I suppose we'd need both. I wouldn't propose cue-level or block-level.

How important is this for v1?


&gt;<i> &gt; If we just ignore content until we hit a line that happens to look 
</I>&gt;<i> &gt; like a timing line, then we are much more constrained in what we can 
</I>&gt;<i> &gt; do in the future. For example, we couldn't introduce a &quot;comment block&quot; 
</I>&gt;<i> &gt; syntax, since any comment containing a timing line wouldn't be 
</I>&gt;<i> &gt; ignored. On the other hand if we keep the syntax as it is now, we can 
</I>&gt;<i> &gt; introduce a comment block just by having its first line include a 
</I>&gt;<i> &gt; &quot;--&gt;&quot; but not have it match the timestamp syntax, e.g. by having it be 
</I>&gt;<i> &gt; &quot;--&gt; COMMENT&quot; or some such.
</I>&gt;<i> 
</I>&gt;<i> One of us must be confused, do you mean something like this?
</I>&gt;<i> 
</I>&gt;<i> 1
</I>&gt;<i> --&gt; COMMENT
</I>&gt;<i> 00:00.000 --&gt; 00:01.000
</I>&gt;<i> Cue text
</I>&gt;<i> 
</I>&gt;<i> Adding this syntax would break the *current* parser, as it would fail in 
</I>&gt;<i> step 39 (Collect WebVTT cue timings and settings) and then skip the rest 
</I>&gt;<i> of the cue. If we want any room for extensions along these lines, then 
</I>&gt;<i> multiple lines preceding the timing line must be handled gracefully.
</I>
The spec has unfortunately changed since this e-mail, so we no longer have 
hte forwards-compatibility I was referring to. At this point, any time you 
get a --&gt; you skip to thinking you have a cue. This does unfortunately 
mean we can no longer introduce comment blocks in a backwards-compatible 
way.


&gt;<i> [line wrapping]
</I>&gt;<i> 
</I>&gt;<i> To expand a bit more on the problem and suggested solution, consider the 
</I>&gt;<i> example cue &quot;This sentence is spoken by a single speaker and is 
</I>&gt;<i> presented as a single cue.&quot;
</I>&gt;<i> 
</I>&gt;<i> If simple line-wrapping (how browsers currently render text) is used it 
</I>&gt;<i> might be:
</I>&gt;<i> 
</I>&gt;<i> &quot;This sentence is spoken by a single speaker and is presented as a 
</I>&gt;<i> single cue.&quot;
</I>&gt;<i> 
</I>&gt;<i> Subtitles tend to be line-wrapped to have more balanced line width, and 
</I>&gt;<i> at least I would certainly much prefer this line wrapping:
</I>&gt;<i> 
</I>&gt;<i> &quot;This sentence is spoken by a single speaker
</I>&gt;<i> and is presented as a single cue.&quot;
</I>&gt;<i> 
</I>&gt;<i> Apart from being easier to read, this is also much more suitable for 
</I>&gt;<i> left/right-alignment in cases where that is used to associate the cue 
</I>&gt;<i> with a speaker on screen. With WebVTT, one would have to manually 
</I>&gt;<i> line-break the text to get this result. Apart from wasting the time of 
</I>&gt;<i> the captioner, it will also break if a slightly larger font is used -- 
</I>&gt;<i> you might get this rendering instead:
</I>&gt;<i> 
</I>&gt;<i> &quot;This sentence is spoken by a single
</I>&gt;<i> speaker
</I>&gt;<i> and is presented as a single cue.&quot;
</I>&gt;<i> 
</I>&gt;<i> In other cases you might get 4 lines where 3 would have been enough. 
</I>&gt;<i> This is not a theoretical issue, I see it fairly with SRT subtitles 
</I>&gt;<i> rendered at another size than was tested with.
</I>&gt;<i> 
</I>&gt;<i> My suggested solution is to first layout the text using all of the 
</I>&gt;<i> available width. Then, decrease the width as much as possible without 
</I>&gt;<i> increasing the number of line breaks. The algorithm should also prefer 
</I>&gt;<i> to make the first line the longest, as this is IMO more aesthetically 
</I>&gt;<i> pleasing.
</I>&gt;<i> 
</I>&gt;<i> I would like to see this specified and would gladly implement it in 
</I>&gt;<i> Opera, but in which spec does it belong? It seems fairly 
</I>&gt;<i> subtitling-specific to me, so if it could be in the WebVTT rendering 
</I>&gt;<i> rules to begin with (as opposed to CSS with vendor prefixes) that would 
</I>&gt;<i> be at least short-term awesome. It's only if this is the default 
</I>&gt;<i> line-wrapping for &lt;track&gt;+WebVTT that people are going to discover this 
</I>&gt;<i> and stop manually line-breaking their captions.
</I>
I think the basic algorithm should be in CSS, as it is useful in other 
contexts too (e.g. headings). We can then use that white-space value.

Currently we do have line wrapping (white-space:normal is assumed, with 
the additional hard-wrap-at-edge constraint).


&gt;<i> &gt; On Wed, 19 Jan 2011, Philip J&#195;&#164;genstedt wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; The 3 preload states imply 3 simple buffering strategies:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; none: don't touch the network at all
</I>&gt;<i> &gt; &gt; preload: buffer as little as possible while still reaching readyState
</I>&gt;<i> &gt; &gt; HAVE_METADATA
</I>&gt;<i> &gt; &gt; auto: buffer as fast and much as possible
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &quot;auto&quot; isn't &quot;as fast and much as possible&quot;, it's &quot;as fast and much as
</I>&gt;<i> &gt; will make the user happy&quot;. In some configurations, it might be the same as
</I>&gt;<i> &gt; &quot;none&quot; (e.g. if the user is paying by the byte and hates video).
</I>&gt;<i> 
</I>&gt;<i> The way I see it, that's just a matter of a user preference to limit the
</I>&gt;<i> internal preload state to &quot;none&quot; regardless of what the content attribute.
</I>
My point is that the preload=&quot;&quot; attribute is a hint, it does not have hard 
conformance requirements. It can't have hard conformance requirements 
since browsers have to be able to ignore it based on user preferences.


&gt;<i> &gt; &gt; However, the state we're discussing is when the user has begun 
</I>&gt;<i> &gt; &gt; playing the video. The spec doesn't talk about it, but I call it:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; invoked: buffer as little as possible without readyState dropping 
</I>&gt;<i> &gt; &gt; below HAVE_FUTURE_DATA (in other words: being able to play from 
</I>&gt;<i> &gt; &gt; currentTime to duration at playbackRate without waiting for the 
</I>&gt;<i> &gt; &gt; network)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; There's also a fifth state, let's call it &quot;aggressive&quot;, where even 
</I>&gt;<i> &gt; while playing the video the UA is trying to download the whole thing 
</I>&gt;<i> &gt; in case the connection drops.
</I>&gt;<i> 
</I>&gt;<i> This is the same as &quot;auto&quot; for now, but sure, that could be improved.
</I>
Again, my point is just that the number of possible behaviours is far in 
excess to the number of possible hints. I list some other possible 
behaviours here:

   <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=11602#c8">http://www.w3.org/Bugs/Public/show_bug.cgi?id=11602#c8</A>


&gt;<i> &gt; If you like I can make the spec explicitly describe what the 
</I>&gt;<i> &gt; preload=&quot;&quot; hints mean while video is playing, too.
</I>&gt;<i> 
</I>&gt;<i> That would be a good start. In Opera, playing the video causes the 
</I>&gt;<i> internal preload state to go to &quot;invoked&quot;.
</I>
Ok. I'll make that change. Proposed diff:

Index: source
===================================================================
--- source	(revision 6837)
+++ source	(working copy)
@@ -31227,74 +31227,88 @@ interface &lt;dfn&gt;HTMLAudioElement&lt;/dfn&gt; : 
     will end up firing a &lt;code
     title=&quot;event-media-suspend&quot;&gt;suspend&lt;/code&gt; event, as described
     earlier.&lt;/p&gt;
 
    &lt;/li&gt;
 
    &lt;!-- this step is mentioned above, search for &quot;FINAL STEP&quot; --&gt;
    &lt;li&gt;&lt;p&gt;If the user agent ever reaches this step (which can only
    happen if the entire resource gets loaded and kept available):
    abort the overall &lt;span
    title=&quot;concept-media-load-algorithm&quot;&gt;resource selection
    algorithm&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
 
   &lt;/ol&gt;
 
   &lt;/div&gt;
 
   &lt;hr&gt;
 
   &lt;p&gt;The &lt;dfn title=&quot;attr-media-preload&quot;&gt;&lt;code&gt;preload&lt;/code&gt;&lt;/dfn&gt;
-  attribute is an &lt;span&gt;enumerated attribute&lt;/span&gt;. The following table
-  lists the keywords and states for the attribute &mdash; the keywords
-  in the left column map to the states in the cell in the second
-  column on the same row as the keyword.&lt;/p&gt;
+  attribute is an &lt;span&gt;enumerated attribute&lt;/span&gt;. The following
+  table lists the keywords and states for the attribute &mdash; the
+  keywords in the left column map to the states in the cell in the
+  second column on the same row as the keyword. The attribute can be
+  changed even once the &lt;span&gt;media resource&lt;/span&gt; is being buffered
+  or played; the descriptions in the table below are to be interpreted
+  with that in mind.&lt;/p&gt;
 
   &lt;table&gt;
    &lt;thead&gt;
     &lt;tr&gt;
      &lt;th&gt; Keyword
      &lt;th&gt; State
      &lt;th&gt; Brief description
    &lt;tbody&gt;
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;attr-media-preload-none&quot;&gt;&lt;code&gt;none&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;dfn title=&quot;attr-media-preload-none-state&quot;&gt;None&lt;/dfn&gt;
      &lt;td&gt;Hints to the user agent that either the author does not expect the user to need the media resource, or that the server wants to minimise unnecessary traffic.
+         This state does not provide a hint regarding how aggressively to actually download the media resource if buffering starts anyway (e.g. once the user hits &quot;play&quot;).
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;attr-media-preload-metadata&quot;&gt;&lt;code&gt;metadata&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;dfn title=&quot;attr-media-preload-metadata-state&quot;&gt;Metadata&lt;/dfn&gt;
      &lt;td&gt;Hints to the user agent that the author does not expect the user to need the media resource, but that fetching the resource metadata (dimensions, first frame, track list, duration, etc) is reasonable. If the user agent precisely fetches no more than the metadata, then the &lt;span&gt;media element&lt;/span&gt; will end up with its &lt;code title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; attribute set to &lt;code title=&quot;dom-media-HAVE_METADATA&quot;&gt;HAVE_METADATA&lt;/code&gt;; typically though, some frames will be obtained as well and it will probably be &lt;code title=&quot;dom-media-HAVE_CURRENT_DATA&quot;&gt;HAVE_CURRENT_DATA&lt;/code&gt; or &lt;code title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt;.
+         When the media resource is playing, hints to the user agent that bandwidth is to be considered scarce, e.g. suggesting throttling the download so that the media data is obtained at the slowest possible rate that still maintains consistent playback.
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;attr-media-preload-auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;dfn title=&quot;attr-media-preload-auto-state&quot;&gt;Automatic&lt;/dfn&gt;
      &lt;td&gt;Hints to the user agent that the user agent can put the user's needs first without risk to the server, up to and including optimistically downloading the entire resource.
   &lt;/table&gt;
 
   &lt;p&gt;The empty string is also a valid keyword, and maps to the &lt;span
   title=&quot;attr-media-preload-auto-state&quot;&gt;Automatic&lt;/span&gt; state. The
   attribute's &lt;i&gt;missing value default&lt;/i&gt; is user-agent defined,
   though the &lt;span
   title=&quot;attr-media-preload-metadata-state&quot;&gt;Metadata&lt;/span&gt; state is
   suggested as a compromise between reducing server load and providing
   an optimal user experience.&lt;/p&gt;
 
+  &lt;p class=&quot;note&quot;&gt;Authors might switch the attribute from &quot;&lt;code
+  title=&quot;attr-media-preload-none&quot;&gt;none&lt;/code&gt;&quot; or &quot;&lt;code
+  title=&quot;attr-media-preload-metadata&quot;&gt;metadata&lt;/code&gt;&quot; to &quot;&lt;code
+  title=&quot;attr-media-preload-auto&quot;&gt;auto&lt;/code&gt;&quot; dynamically once the
+  user begins playback. For example, on a page with many videos this
+  might be used to indicate that the many videos are not to be
+  downloaded unless requested, but they once one &lt;em&gt;is&lt;/em&gt; requested
+  it is to be downloaded aggressively.&lt;/p&gt;
+
   &lt;div class=&quot;impl&quot;&gt;
 
   &lt;p&gt;The &lt;code title=&quot;attr-media-preload&quot;&gt;preload&lt;/code&gt; attribute is
   intended to provide a hint to the user agent about what the author
   thinks will lead to the best user experience. The attribute may be
   ignored altogether, for example based on explicit user preferences
   or based on the available connectivity.&lt;/p&gt;
 
   &lt;p&gt;The &lt;dfn
   title=&quot;dom-media-preload&quot;&gt;&lt;code&gt;preload&lt;/code&gt;&lt;/dfn&gt; IDL
   attribute must &lt;span&gt;reflect&lt;/span&gt; the content attribute of the
   same name, &lt;span&gt;limited to only known values&lt;/span&gt;.&lt;/p&gt;
 
   &lt;/div&gt;
 
   &lt;p class=&quot;note&quot;&gt;The &lt;code
   title=&quot;attr-media-autoplay&quot;&gt;autoplay&lt;/code&gt; attribute can override
   the &lt;code title=&quot;attr-media-preload&quot;&gt;preload&lt;/code&gt; attribute (since
   if the media plays, it naturally has to buffer first, regardless of
   the hint given by the &lt;code


&gt;<i> &gt; On Thu, 20 Jan 2011, Philip J&#195;&#164;genstedt wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; There have been two non-trivial changes to the seeking algorithm in the
</I>&gt;<i> &gt; &gt; last year:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Discussed at
</I>&gt;<i> &gt; &gt; <A HREF="http://lists.w3.org/Archives/Public/public-html/2010Feb/0003.html">http://lists.w3.org/Archives/Public/public-html/2010Feb/0003.html</A>
</I>&gt;<i> &gt; &gt; lead to <A HREF="http://html5.org/r/4868">http://html5.org/r/4868</A>
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Discussed at
</I>&gt;<i> &gt; &gt; <A HREF="http://lists.w3.org/Archives/Public/public-html/2010Jul/0217.html">http://lists.w3.org/Archives/Public/public-html/2010Jul/0217.html</A>
</I>&gt;<i> &gt; &gt; lead to <A HREF="http://html5.org/r/5219">http://html5.org/r/5219</A>
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Yeah. In particular, sometimes there's no way for the UA to know 
</I>&gt;<i> &gt; asynchronously if the seek can be done, which is why the attribute is 
</I>&gt;<i> &gt; set after the method returns. It's not ideal, but the alternative is 
</I>&gt;<i> &gt; not always implementable.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; With that said, it seems like there's nothing that guarantees that 
</I>&gt;<i> &gt; &gt; the asynchronous section doesn't start running while the script is 
</I>&gt;<i> &gt; &gt; still running.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Yeah. It's not ideal, but I don't really see what we can do about it.
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=12267">http://www.w3.org/Bugs/Public/show_bug.cgi?id=12267</A>
</I>&gt;<i> 
</I>&gt;<i> By only updating the media state between tasks (or as tasks), the script 
</I>&gt;<i> that issued the seek could not see the state changed as a result of it.
</I>
I'm willing to consider concrete focused suggestions for making specific 
changes to this API to make it more predictable, but at a high level I 
think I've done pretty much as much as can be done on this issue. A slow 
script can still observe asynchronous changes after seeking, e.g. if you 
try to seek a media resource that can't be seeked, then you'll see seeking 
briefly return true before going back to false.


&gt;<i> Changing currentTime synchronously doesn't mean that seeking to that 
</I>&gt;<i> position will actually succeed, so I don't see why that would be a 
</I>&gt;<i> problem. currentTime would just be updated again once it's been clamped 
</I>&gt;<i> in the asynchronous section of the seek algorithm.
</I>
This is more or less what the spec now says.


On Sat, 4 Jun 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> Icecast streams have chained files, so streaming Ogg to an audio element 
</I>&gt;<i> would hit this problem. There is a bug in FF for this: 
</I>&gt;<i> <A HREF="https://bugzilla.mozilla.org/show_bug.cgi?id=455165">https://bugzilla.mozilla.org/show_bug.cgi?id=455165</A> [...]. There's also 
</I>&gt;<i> a webkit bug for icecast streaming, which is probably related 
</I>&gt;<i> <A HREF="https://bugs.webkit.org/show_bug.cgi?id=42750">https://bugs.webkit.org/show_bug.cgi?id=42750</A> . I'm not sure how Opera 
</I>&gt;<i> is able to deal with icecast streams, but it seems to deal with it.
</I>&gt;<i> 
</I>&gt;<i> The thing is: you can implement playback and seeking without any further 
</I>&gt;<i> changes to the spec. But then the browser-internal metadata states will 
</I>&gt;<i> change depending on the chunk you're on. Should that also update the 
</I>&gt;<i> exposed metadata in the API then? Probably yes, because otherwise the JS 
</I>&gt;<i> developer may deal with contradictory information. Maybe we need a 
</I>&gt;<i> &quot;metadatachange&quot; event for this?
</I>
What metadata will change? Just videoWidth and videoHeight? (duration can 
change too, but that's already handled in the spec) Do the height and 
width values change again when you seek back to the previous link in the 
chain? Presumably they do. Do we need to expose the videoWidth and 
videoHeight at any particular time, or can we just say it's the current 
values and fire an event when they change? (What's the use case for 
knowing when they change?) Notice that the spec already handles the 
timeline aspect of chained resources; basically the first file sets the 
timeline and the others share it, ignoring their internal times.


&gt;<i> &gt; On Tue, 24 May 2011, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Ian and I had a brief conversation recently where I mentioned a 
</I>&gt;<i> &gt;&gt; problem with extended text descriptions with screen readers (and 
</I>&gt;<i> &gt;&gt; worse still with braille devices) and the suggestion was that the 
</I>&gt;<i> &gt;&gt; &quot;paused for user interaction&quot; state of a media element may be the 
</I>&gt;<i> &gt;&gt; solution. I would like to pick this up and discuss in detail how that 
</I>&gt;<i> &gt;&gt; would work to confirm my sketchy understanding.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; *The use case:*
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; In the specification for media elements we have a &lt;track&gt; kind of
</I>&gt;<i> &gt;&gt; &quot;descriptions&quot;, which are:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; &quot;Textual descriptions of the video component of the media resource, 
</I>&gt;<i> &gt;&gt; intended for audio synthesis when the visual component is unavailable 
</I>&gt;<i> &gt;&gt; (e.g. because the user is interacting with the application without a 
</I>&gt;<i> &gt;&gt; screen while driving, or because the user is blind). Synthesized as a 
</I>&gt;<i> &gt;&gt; separate audio track.&quot;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I'm for now assuming that the synthesis will be done through a screen 
</I>&gt;<i> &gt;&gt; reader and not through the browser itself, thus making the 
</I>&gt;<i> &gt;&gt; descriptions available to users as synthesized audio or as braille if 
</I>&gt;<i> &gt;&gt; the screen reader is set up for a braille device.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; The textual descriptions are provided as chunks of text with a start 
</I>&gt;<i> &gt;&gt; and an end time (so-called &quot;cues&quot;). The cues are processed during 
</I>&gt;<i> &gt;&gt; video playback as the video's playback time starts to fall within the 
</I>&gt;<i> &gt;&gt; time frame of the cue. Thus, it is expected the that cues are 
</I>&gt;<i> &gt;&gt; consumed during the cue's time frame and are not present any more 
</I>&gt;<i> &gt;&gt; when the end time of the cue is reached, so they don't conflict with 
</I>&gt;<i> &gt;&gt; the video's normal audio.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; However, on many occasions, it is not possible to consume the cue 
</I>&gt;<i> &gt;&gt; text in the given time frame. In particular not in the following 
</I>&gt;<i> &gt;&gt; situations:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; 1. The screen reader takes longer to read out the cue text than the 
</I>&gt;<i> &gt;&gt; cue's time frame provides for. This is particularly the case with 
</I>&gt;<i> &gt;&gt; long cue text, but also when the screen reader's reading rate is 
</I>&gt;<i> &gt;&gt; slower than what the author of the cue text expected.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; 2. The braille device is used for reading. Since reading braille is 
</I>&gt;<i> &gt;&gt; much slower than listening to read-out text, the cue time frame will 
</I>&gt;<i> &gt;&gt; invariably be too short.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; 3. The user seeked right into the middle of a cue and thus the time 
</I>&gt;<i> &gt;&gt; frame that is available for reading out the cue text is shorter than 
</I>&gt;<i> &gt;&gt; the cue author calculated with.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Correct me if I'm wrong, but it seems that what we need is a way for 
</I>&gt;<i> &gt;&gt; the screen reader to pause the video element from continuing to play 
</I>&gt;<i> &gt;&gt; while the screen reader is still busy delivering the cue text. (In 
</I>&gt;<i> &gt;&gt; a11y talk: what is required is a means to deal with &quot;extended 
</I>&gt;<i> &gt;&gt; descriptions&quot;, which extend the timeline of the video.) Once it's 
</I>&gt;<i> &gt;&gt; finished presenting, it can resume the video element's playback.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Is it a requirement that the user be able to use the regular video 
</I>&gt;<i> &gt; pause, play, rewind, etc, controls to seek inside the extended 
</I>&gt;<i> &gt; descriptions
</I>&gt;<i> 
</I>&gt;<i> No, the audio descriptions (which are only text to the browser and turn 
</I>&gt;<i> into audio only through the screen reader) are controlled by the 
</I>&gt;<i> screenreader, not by the video controls. When the user navigates using 
</I>&gt;<i> the video controls, the cues of the audio description change and will be 
</I>&gt;<i> handed to the screenreader, too, so can be read out in sync. But the 
</I>&gt;<i> video controls have no direct control over the read-out audio.
</I>&gt;<i> 
</I>&gt;<i> &gt; or should they literally pause the video while playing, with the audio 
</I>&gt;<i> &gt; descriptions being controlled by the same UI as the screen reader?
</I>&gt;<i> 
</I>&gt;<i> The audio descriptions cannot control the video, since they are just 
</I>&gt;<i> text cues with a start and end time that is supposed to be in sync with 
</I>&gt;<i> the video. The only component that actually knows whether the user has 
</I>&gt;<i> heard the full text of a text cue is the screen reader, since it is 
</I>&gt;<i> turning the text into sound. So, the control over pausing the video must 
</I>&gt;<i> come from there. Indeed, the user should be able to control this through 
</I>&gt;<i> the screen reader UI - e.g. hit a button to skip reading a cue and let 
</I>&gt;<i> the video continue playing uninterrupted.
</I>
It sounds to me like what you're saying is that for the case of an audio 
description cue whose text is longer than the cue itself, the UA should 
act as if it had &quot;paused for user interaction&quot;. Here's a proposed patch to 
make this more explicit:

Index: source
===================================================================
--- source	(revision 6837)
+++ source	(working copy)
@@ -31816,46 +31816,47 @@ interface &lt;dfn&gt;HTMLAudioElement&lt;/dfn&gt; : 
       &lt;code title=&quot;dom-media-HAVE_ENOUGH_DATA&quot;&gt;HAVE_ENOUGH_DATA&lt;/code&gt;,
       then the relevant steps below must then be run also.&lt;/p&gt;
 
      &lt;/dd&gt;
 
      &lt;!-- going down --&gt;
      &lt;dt&gt;If the previous ready state was &lt;code
      title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt; or more,
      and the new ready state is &lt;code
      title=&quot;dom-media-HAVE_CURRENT_DATA&quot;&gt;HAVE_CURRENT_DATA&lt;/code&gt; or
      less&lt;/dt&gt;
 
      &lt;dd&gt;
 
       &lt;p id=&quot;fire-waiting-when-waiting&quot;&gt;If the &lt;span&gt;media
       element&lt;/span&gt; was &lt;span&gt;potentially playing&lt;/span&gt; before its
       &lt;code title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; attribute
       changed to a value lower than &lt;code
       title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt;, and
       the element has not &lt;span&gt;ended playback&lt;/span&gt;, and playback
-      has not &lt;span&gt;stopped due to errors&lt;/span&gt;, and playback has not
-      &lt;span&gt;paused for user interaction&lt;/span&gt;, the user agent must
-      &lt;span&gt;queue a task&lt;/span&gt; to &lt;span&gt;fire a simple event&lt;/span&gt;
-      named &lt;code title=&quot;event-media-timeupdate&quot;&gt;timeupdate&lt;/code&gt; at
-      the element, and &lt;span&gt;queue a task&lt;/span&gt; to &lt;span&gt;fire a
-      simple event&lt;/span&gt; named &lt;code
+      has not &lt;span&gt;stopped due to errors&lt;/span&gt;, &lt;span&gt;paused for
+      user interaction&lt;/span&gt;, or &lt;span&gt;paused for in-band
+      content&lt;/span&gt;, the user agent must &lt;span&gt;queue a task&lt;/span&gt; to
+      &lt;span&gt;fire a simple event&lt;/span&gt; named &lt;code
+      title=&quot;event-media-timeupdate&quot;&gt;timeupdate&lt;/code&gt; at the element,
+      and &lt;span&gt;queue a task&lt;/span&gt; to &lt;span&gt;fire a simple
+      event&lt;/span&gt; named &lt;code
       title=&quot;event-media-waiting&quot;&gt;waiting&lt;/code&gt; at the element.&lt;/p&gt;
 
      &lt;/dd&gt;
 
      &lt;!-- going up to future --&gt;
      &lt;dt&gt;If the previous ready state was &lt;code
      title=&quot;dom-media-HAVE_CURRENT_DATA&quot;&gt;HAVE_CURRENT_DATA&lt;/code&gt; or
      less, and the new ready state is &lt;code
      title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt;&lt;/dt&gt;
 
      &lt;dd&gt;
 
       &lt;p&gt;The user agent must &lt;span&gt;queue a task&lt;/span&gt; to &lt;span&gt;fire a
       simple event&lt;/span&gt; named &lt;code
       title=&quot;event-media-canplay&quot;&gt;canplay&lt;/code&gt;.&lt;/p&gt;
 
       &lt;p&gt;If the element's &lt;code title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt;
       attribute is false, the user agent must &lt;span&gt;queue a task&lt;/span&gt;
       to &lt;span&gt;fire a simple event&lt;/span&gt; named &lt;code
       title=&quot;event-media-playing&quot;&gt;playing&lt;/code&gt;.&lt;/p&gt;
@@ -32052,51 +32053,60 @@ interface &lt;dfn&gt;HTMLAudioElement&lt;/dfn&gt; : 
     &lt;p&gt;Sets the &lt;code title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt; attribute
     to true, loading the &lt;span&gt;media resource&lt;/span&gt; if necessary.&lt;/p&gt;
 
    &lt;/dd&gt;
 
   &lt;/dl&gt;
 
   &lt;div class=&quot;impl&quot;&gt;
 
   &lt;p&gt;The &lt;dfn title=&quot;dom-media-paused&quot;&gt;&lt;code&gt;paused&lt;/code&gt;&lt;/dfn&gt;
   attribute represents whether the &lt;span&gt;media element&lt;/span&gt; is
   paused or not. The attribute must initially be true.&lt;/p&gt;
 
   &lt;p&gt;A &lt;span&gt;media element&lt;/span&gt; is a &lt;dfn&gt;blocked media
   element&lt;/dfn&gt; if its &lt;code
   title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; attribute is in the
   &lt;code title=&quot;dom-media-HAVE_NOTHING&quot;&gt;HAVE_NOTHING&lt;/code&gt; state, the
   &lt;code title=&quot;dom-media-HAVE_METADATA&quot;&gt;HAVE_METADATA&lt;/code&gt; state, or
   the &lt;code
   title=&quot;dom-media-HAVE_CURRENT_DATA&quot;&gt;HAVE_CURRENT_DATA&lt;/code&gt; state,
-  or if the element has &lt;span&gt;paused for user interaction&lt;/span&gt;.&lt;/p&gt;
+  or if the element has &lt;span&gt;paused for user interaction&lt;/span&gt; or
+  &lt;span&gt;paused for in-band content&lt;/span&gt;.&lt;/p&gt;
 
   &lt;p&gt;A &lt;span&gt;media element&lt;/span&gt; is said to be &lt;dfn&gt;potentially
   playing&lt;/dfn&gt; when its &lt;code title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt;
   attribute is false, the element has not &lt;span&gt;ended playback&lt;/span&gt;,
   playback has not &lt;span&gt;stopped due to errors&lt;/span&gt;, 
   the element either has no &lt;span&gt;current media controller&lt;/span&gt; or
   has a &lt;span&gt;current media controller&lt;/span&gt; but is not &lt;span&gt;blocked
   on its media controller&lt;/span&gt;,
   and the element is not a &lt;span&gt;blocked media element&lt;/span&gt;.&lt;/p&gt;
 
+  &lt;p class=&quot;note&quot;&gt;A &lt;code title=&quot;event-media-waiting&quot;&gt;waiting&lt;/code&gt;
+  DOM event &lt;a href=&quot;#fire-waiting-when-waiting&quot;&gt;can be fired&lt;/a&gt; as a
+  result of an element that is &lt;span&gt;potentially playing&lt;/span&gt;
+  stopping playback due to its &lt;code
+  title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; attribute changing to
+  a value lower than &lt;code
+  title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt;.&lt;/p&gt;
+
   &lt;p&gt;A &lt;span&gt;media element&lt;/span&gt; is said to have &lt;dfn&gt;ended
   playback&lt;/dfn&gt; when:&lt;/p&gt;
 
   &lt;ul&gt;
 
    &lt;li&gt;The element's &lt;code
    title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; attribute is &lt;code
    title=&quot;dom-media-HAVE_METADATA&quot;&gt;HAVE_METADATA&lt;/code&gt; or greater,
    and
 
    &lt;li&gt;
 
     &lt;p&gt;Either:
 
     &lt;ul&gt;
 
      &lt;li&gt;The &lt;span&gt;current playback position&lt;/span&gt; is the end of the
      &lt;span&gt;media resource&lt;/span&gt;, and
 
      &lt;li&gt;The &lt;span&gt;direction of playback&lt;/span&gt; is forwards, and
@@ -32140,60 +32150,82 @@ interface &lt;dfn&gt;HTMLAudioElement&lt;/dfn&gt; : 
   data&lt;/span&gt;, and due to that error, is not able to play the content
   at the &lt;span&gt;current playback position&lt;/span&gt;.&lt;/p&gt;
 
   &lt;p&gt;A &lt;span&gt;media element&lt;/span&gt; is said to have &lt;dfn&gt;paused for user
   interaction&lt;/dfn&gt; when its &lt;code
   title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt; attribute is false, the &lt;code
   title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; attribute is either
   &lt;code title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt; or
   &lt;code title=&quot;dom-media-HAVE_ENOUGH_DATA&quot;&gt;HAVE_ENOUGH_DATA&lt;/code&gt; and
   the user agent has reached a point in the &lt;span&gt;media
   resource&lt;/span&gt; where the user has to make a selection for the
   resource to continue.
   If the &lt;span&gt;media element&lt;/span&gt; has a &lt;span&gt;current media
   controller&lt;/span&gt; when this happens, then the user agent must
   &lt;span&gt;report the controller state&lt;/span&gt; for the &lt;span&gt;media
   element&lt;/span&gt;'s &lt;span&gt;current media controller&lt;/span&gt;. If the
   &lt;span&gt;media element&lt;/span&gt; has a &lt;span&gt;current media
   controller&lt;/span&gt; when the user makes a selection, allowing playback
   to resume, the user agent must similarly &lt;span&gt;report the controller
   state&lt;/span&gt; for the &lt;span&gt;media element&lt;/span&gt;'s &lt;span&gt;current
-  media controller&lt;/span&gt;.
-  &lt;/p&gt;
+  media controller&lt;/span&gt;.&lt;/p&gt;
 
   &lt;p&gt;It is possible for a &lt;span&gt;media element&lt;/span&gt; to have both
   &lt;span&gt;ended playback&lt;/span&gt; and &lt;span&gt;paused for user
   interaction&lt;/span&gt; at the same time.&lt;/p&gt;
 
   &lt;p&gt;When a &lt;span&gt;media element&lt;/span&gt; that is &lt;span&gt;potentially
   playing&lt;/span&gt; stops playing because it has &lt;span&gt;paused for user
   interaction&lt;/span&gt;, the user agent must &lt;span&gt;queue a task&lt;/span&gt; to
   &lt;span&gt;fire a simple event&lt;/span&gt; named &lt;code
   title=&quot;event-media-timeupdate&quot;&gt;timeupdate&lt;/code&gt; at the element.&lt;/p&gt;
 
-  &lt;p class=&quot;note&quot;&gt;A &lt;code title=&quot;event-media-waiting&quot;&gt;waiting&lt;/code&gt;
-  DOM event &lt;a href=&quot;#fire-waiting-when-waiting&quot;&gt;can be fired&lt;/a&gt; as a
-  result of an element that is &lt;span&gt;potentially playing&lt;/span&gt;
-  stopping playback due to its &lt;code
-  title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; attribute changing to
-  a value lower than &lt;code
-  title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt;.&lt;/p&gt;
+  &lt;p&gt;A &lt;span&gt;media element&lt;/span&gt; is said to have &lt;dfn&gt;paused for
+  in-band content&lt;/dfn&gt; when its &lt;code
+  title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt; attribute is false, the &lt;code
+  title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; attribute is either
+  &lt;code title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt; or
+  &lt;code title=&quot;dom-media-HAVE_ENOUGH_DATA&quot;&gt;HAVE_ENOUGH_DATA&lt;/code&gt; and
+  the user agent has suspended playback of the &lt;span&gt;media
+  resource&lt;/span&gt; in order to play content that is temporally anchored
+  to the &lt;span&gt;media resource&lt;/span&gt; and has a non-zero length, or to
+  play content that is temporally anchored to a segment of the
+  &lt;span&gt;media resource&lt;/span&gt; but has a length longer than that
+  segment. If the &lt;span&gt;media element&lt;/span&gt; has a &lt;span&gt;current media
+  controller&lt;/span&gt; when this happens, then the user agent must
+  &lt;span&gt;report the controller state&lt;/span&gt; for the &lt;span&gt;media
+  element&lt;/span&gt;'s &lt;span&gt;current media controller&lt;/span&gt;. If the
+  &lt;span&gt;media element&lt;/span&gt; has a &lt;span&gt;current media
+  controller&lt;/span&gt; when the user agent unsuspends playback, the user
+  agent must similarly &lt;span&gt;report the controller state&lt;/span&gt; for
+  the &lt;span&gt;media element&lt;/span&gt;'s &lt;span&gt;current media
+  controller&lt;/span&gt;.&lt;/p&gt;
+
+  &lt;p class=&quot;example&quot;&gt;One example of when a &lt;span&gt;media element&lt;/span&gt;
+  would be &lt;span&gt;paused for in-band content&lt;/span&gt; is when the user
+  agent is playing &lt;span title=&quot;attr-track-kind-descriptions&quot;&gt;audio
+  descriptions&lt;/span&gt; from an external WebVTT file, and the
+  synthesized speech generated for a cue is longer than the time
+  between the &lt;span&gt;text track cue start time&lt;/span&gt; and the
+  &lt;span&gt;text track cue end time&lt;/span&gt;.&lt;/p&gt;
+
+  &lt;hr&gt;
 
   &lt;p&gt;When the &lt;span&gt;current playback position&lt;/span&gt; reaches the end
   of the &lt;span&gt;media resource&lt;/span&gt; when the &lt;span&gt;direction of
   playback&lt;/span&gt; is forwards, then the user agent must follow these
   steps:&lt;/p&gt;
 
   &lt;ol&gt;
 
    &lt;li&gt;&lt;p&gt;If the &lt;span&gt;media element&lt;/span&gt; has a &lt;code
    title=&quot;attr-media-loop&quot;&gt;loop&lt;/code&gt; attribute specified
    and does not have a &lt;span&gt;current media controller&lt;/span&gt;,
    then &lt;span title=&quot;dom-media-seek&quot;&gt;seek&lt;/span&gt; to the &lt;span&gt;earliest
    possible position&lt;/span&gt; of the &lt;span&gt;media resource&lt;/span&gt; and
    abort these steps.&lt;/p&gt;&lt;/li&gt; &lt;!-- v2/v3: We should fire a 'looping'
    event here to explain why this immediately fires a 'playing' event,
    otherwise the 'playing' event that fires from the readyState going
    from HAVE_CURRENT_DATA back to HAVE_FUTURE_DATA will seem
    inexplicable (since the normally matching 'ended' given below event
    doesn't fire in the loop case). --&gt;
 
@@ -39203,48 +39235,48 @@ dictionary &lt;dfn&gt;TrackEventInit&lt;/dfn&gt; : &lt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-loadeddata&quot;&gt;&lt;code&gt;loadeddata&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;code&gt;Event&lt;/code&gt;
      &lt;td&gt;The user agent can render the &lt;span&gt;media data&lt;/span&gt; at the &lt;span&gt;current playback position&lt;/span&gt; for the first time.
      &lt;td&gt;&lt;code title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; newly increased to &lt;code title=&quot;dom-media-HAVE_CURRENT_DATA&quot;&gt;HAVE_CURRENT_DATA&lt;/code&gt; or greater for the first time.
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-canplay&quot;&gt;&lt;code&gt;canplay&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;code&gt;Event&lt;/code&gt;
      &lt;td&gt;The user agent can resume playback of the &lt;span&gt;media data&lt;/span&gt;, but estimates that if playback were to be started now, the &lt;span&gt;media resource&lt;/span&gt; could not be rendered at the current playback rate up to its end without having to stop for further buffering of content.
      &lt;td&gt;&lt;code title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; newly increased to &lt;code title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt; or greater.
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-canplaythrough&quot;&gt;&lt;code&gt;canplaythrough&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;code&gt;Event&lt;/code&gt;
      &lt;td&gt;The user agent estimates that if playback were to be started now, the &lt;span&gt;media resource&lt;/span&gt; could be rendered at the current playback rate all the way to its end without having to stop for further buffering.
      &lt;td&gt;&lt;code title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; is newly equal to &lt;code title=&quot;dom-media-HAVE_ENOUGH_DATA&quot;&gt;HAVE_ENOUGH_DATA&lt;/code&gt;.
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-playing&quot;&gt;&lt;code&gt;playing&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;code&gt;Event&lt;/code&gt;
      &lt;td&gt;Playback is ready to start after having been paused or delayed due to lack of &lt;span&gt;media data&lt;/span&gt;.
      &lt;td&gt;&lt;code title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; is newly equal to or greater than &lt;code title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt; and &lt;code title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt; is false, or &lt;code title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt; is newly false and &lt;code title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; is equal to or greater than &lt;code title=&quot;dom-media-HAVE_FUTURE_DATA&quot;&gt;HAVE_FUTURE_DATA&lt;/code&gt;. Even if this event fires, the element might still not be &lt;span&gt;potentially playing&lt;/span&gt;, e.g. if
      the element is &lt;span&gt;blocked on its media controller&lt;/span&gt; (e.g. because the &lt;span&gt;current media controller&lt;/span&gt; is paused, or another &lt;span title=&quot;slaved media elements&quot;&gt;slaved media element&lt;/span&gt; is stalled somehow, or because the &lt;span&gt;media resource&lt;/span&gt; has no data corresponding to the &lt;span&gt;media controller position&lt;/span&gt;), or
-     the element is &lt;span&gt;paused for user interaction&lt;/span&gt;.
+     the element is &lt;span&gt;paused for user interaction&lt;/span&gt; or &lt;span&gt;paused for in-band content&lt;/span&gt;.
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-waiting&quot;&gt;&lt;code&gt;waiting&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;code&gt;Event&lt;/code&gt;
      &lt;td&gt;Playback has stopped because the next frame is not available, but the user agent expects that frame to become available in due course.
      &lt;td&gt;&lt;code title=&quot;dom-media-readyState&quot;&gt;readyState&lt;/code&gt; is equal to or less than &lt;code title=&quot;dom-media-HAVE_CURRENT_DATA&quot;&gt;HAVE_CURRENT_DATA&lt;/code&gt;, and &lt;code title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt; is false. Either &lt;code title=&quot;dom-media-seeking&quot;&gt;seeking&lt;/code&gt; is true, or the &lt;span&gt;current playback position&lt;/span&gt; is not contained in any of the ranges in &lt;code title=&quot;dom-media-buffered&quot;&gt;buffered&lt;/code&gt;. It is possible for playback to stop for other reasons without &lt;code title=&quot;dom-media-paused&quot;&gt;paused&lt;/code&gt; being false, but those reasons do not fire this event (and when those situations resolve, a separate &lt;code title=&quot;event-media-playing&quot;&gt;playing&lt;/code&gt; event is not fired either): e.g.
      the element is newly &lt;span&gt;blocked on its media controller&lt;/span&gt;, or
-     &lt;span title=&quot;ended playback&quot;&gt;playback ended&lt;/span&gt;, or playback &lt;span&gt;stopped due to errors&lt;/span&gt;, or the element has &lt;span&gt;paused for user interaction&lt;/span&gt;.
+     &lt;span title=&quot;ended playback&quot;&gt;playback ended&lt;/span&gt;, or playback &lt;span&gt;stopped due to errors&lt;/span&gt;, or the element has &lt;span&gt;paused for user interaction&lt;/span&gt; or &lt;span&gt;paused for in-band content&lt;/span&gt;.
    &lt;tbody&gt;
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-seeking&quot;&gt;&lt;code&gt;seeking&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;code&gt;Event&lt;/code&gt;
      &lt;td&gt;The &lt;code title=&quot;dom-media-seeking&quot;&gt;seeking&lt;/code&gt; IDL attribute changed to true.
      &lt;td&gt;
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-seeked&quot;&gt;&lt;code&gt;seeked&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;code&gt;Event&lt;/code&gt;
      &lt;td&gt;The &lt;code title=&quot;dom-media-seeking&quot;&gt;seeking&lt;/code&gt; IDL attribute changed to false.
      &lt;td&gt;
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-ended&quot;&gt;&lt;code&gt;ended&lt;/code&gt;&lt;/dfn&gt;
      &lt;td&gt;&lt;code&gt;Event&lt;/code&gt;
      &lt;td&gt;Playback has stopped because the end of the &lt;span&gt;media resource&lt;/span&gt; was reached.
      &lt;td&gt;&lt;code title=&quot;dom-media-currentTime&quot;&gt;currentTime&lt;/code&gt; equals the end of the &lt;span&gt;media resource&lt;/span&gt;; &lt;code title=&quot;dom-media-ended&quot;&gt;ended&lt;/code&gt; is true.
 
    &lt;tbody&gt;
     &lt;tr&gt;
      &lt;td&gt;&lt;dfn title=&quot;event-media-durationchange&quot;&gt;&lt;code&gt;durationchange&lt;/code&gt;&lt;/dfn&gt;


&gt;<i> Do you have an example, then, for when a video actually goes into the 
</I>&gt;<i> state &quot;paused for user interaction&quot;?
</I>
e.g. when you're playing a flash video and it reaches a frame where the 
user has to click one of two buttons to decide where the story goes.

It would never happen for Ogg, H.264, or WebM streams.


On Tue, 7 Jun 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> An Icecast stream is conceptually just one infinite audio stream, even 
</I>&gt;<i> though at the container level it is several chained Ogg streams. 
</I>&gt;<i> duration will be Infinity and currentTime will be constantly increasing. 
</I>&gt;<i> This doesn't seem to be a case where any spec change is needed. Am I 
</I>&gt;<i> missing something?
</I>
Agreed. It's only for chained video that there seems to be anything that 
might change.


On Wed, 8 Jun 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> That is all correct. However, because it is a sequence of Ogg streams, 
</I>&gt;<i> there are new Ogg headers in the middle. These new Ogg headers will lead 
</I>&gt;<i> to new metadata loaded in the media framework - e.g. because the new Ogg 
</I>&gt;<i> stream is encoded with a different audio sampling rate and a different 
</I>&gt;<i> video width/height etc. So, therefore, the metadata in the media 
</I>&gt;<i> framework changes. However, what the browser reports to the JS developer 
</I>&gt;<i> doesn't change. Or if it does change, the JS developer is not informed 
</I>&gt;<i> of it because it is a single infinite audio (or video) stream. Thus the 
</I>&gt;<i> question whether we need a new &quot;metadatachange&quot; event to expose this to 
</I>&gt;<i> the JS developer. It would then also signify that potentially the number 
</I>&gt;<i> of tracks that are available may have changed and other such 
</I>&gt;<i> information.
</I>
None of that information is exposed in the first place.


On Wed, 8 Jun 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> As for Ogg and WebM, I'm inclined to say that we just shouldn't support 
</I>&gt;<i> that, unless there's some compelling use case for it. There's also the 
</I>&gt;<i> option of tweaking the muxers so that all the streams are known 
</I>&gt;<i> up-front, even if there won't be any data arriving for them until 
</I>&gt;<i> half-way through the file.
</I>
Not supporting changes in videoWidth or videoHeight is fine by me...


On Wed, 8 Jun 2011, Eric Carlson wrote:
&gt;<i>
</I>&gt;<i> The characteristics of an Apple HTTP live stream can change on the 
</I>&gt;<i> fly. For example if the user's bandwidth to the streaming server 
</I>&gt;<i> changes, the video width and height can change as the stream resolution 
</I>&gt;<i> is switched up or down, or the number of tracks can change when a stream 
</I>&gt;<i> switches from video+audio to audio only. In addition, a server can 
</I>&gt;<i> insert segments with different characteristics into a stream on the fly, 
</I>&gt;<i> eg. inserting an ad or emergency announcement.
</I>&gt;<i> 
</I>&gt;<i> It is not possible to predict these changes before they occur.
</I>
All except the change in video width and height are already supported in 
the current API, as far as I can tell.

For the videoWidth and videoHeight cases, it would help to know what the 
use cases are for those attributes in the case of dynamic changes, so that 
we can determine if we need to expose the state at any point in time, or 
only the state at the current time, or only the state at the last buffered 
point in time, or the dimensions in the case of the highest product of 
width and height, or some other value.


On Thu, 9 Jun 2011, Eric Carlson wrote:
&gt;<i>
</I>&gt;<i>   In addition, it is possible for a stream to lose or gain an audio 
</I>&gt;<i> track. In this case the dimensions won't change but a script may want to 
</I>&gt;<i> react to the change in audioTracks.
</I>
This is already handled. (Actually, you can't lose a track currently, 
since you can always seek back to the point where the track was present. 
But I will probably be adding an event to report that the &quot;earliest 
possible position&quot; has increased past the end point of a track, so that 
the track can be GCed. It's not yet specced.)


On Mon, 20 Jun 2011, Mark Watson wrote:
&gt;<i> 
</I>&gt;<i> Also, as Eric (C) pointed out, one of the things which can change is 
</I>&gt;<i> which of several available versions of the content is being rendered 
</I>&gt;<i> (for adaptive bitrate cases). This doesn't necessarily change any of the 
</I>&gt;<i> metadata currently exposed on the video element, but nevertheless it's 
</I>&gt;<i> information that the application may need. It would be nice to expose 
</I>&gt;<i> some kind of identifier for the currently rendered stream and have an 
</I>&gt;<i> event when this changes. I think that a stream-format-supplied 
</I>&gt;<i> identifier would be sufficient.
</I>
Is the track identifier insufficient for this purpose?


On Mon, 20 Jun 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> Well, if videoWidth and videoHeight change and no dimensions on the 
</I>&gt;<i> video are provided through CSS, then surely the video will change size 
</I>&gt;<i> and the display will shrink. That would be a terrible user experience. 
</I>&gt;<i> For that reason I would suggest that such a change not be made in 
</I>&gt;<i> alternative adaptive streams.
</I>
Realistically, people will almost always set explicit dimensions on their 
&lt;video&gt; elements, especially if they will do adaptive streaming, so I 
don't think we should optimise for the case where the dimensions are not 
explicit.


On Mon, 20 Jun 2011, Mark Watson wrote:
&gt;<i> 
</I>&gt;<i> I think it would be a bad idea to try and re-invent adaptive streaming 
</I>&gt;<i> in HTML itself.
</I>
Agreed. IMHO this should be done over the network protocol.


On Sun, 5 Jun 2011, Silvia Pfeiffer wrote [channeling a coworker]:
&gt;<i>
</I>&gt;<i> * A:[start|middle|end]
</I>&gt;<i>  -- If the [subtitle box] and also the [subtitle text] are aligned by
</I>&gt;<i> the designer within a CSS (file), which setting dominates: CSS or cue
</I>&gt;<i> setting, for both [subtitle box] and [subtitle text]?
</I>
I don't understand the question.


&gt;<i>  -- As it is text alignment, for me it is alignment of text within the 
</I>&gt;<i> [subtitle text] element only, but not also alignment/positioning of 
</I>&gt;<i> [subtitle text] element in relation to the [subtitle box]! However, 
</I>&gt;<i> Silvia reckons the anchoring of the box changes with the alignment, so 
</I>&gt;<i> that it is possible to actually middle align the [subtitle box] with 
</I>&gt;<i> A:middle. We wonder which understanding is correct.
</I>
I don't really understand this question either. Do you have examples that 
would demonstrate what you mean?


&gt;<i> * T:[number]%
</I>&gt;<i>  -- If the [subtitle box] and also the [subtitle text] are aligned by
</I>&gt;<i> the designer within a CSS (file), which setting dominates: CSS or cue
</I>&gt;<i> setting, for both [subtitle box] and [subtitle text]?
</I>&gt;<i> 
</I>&gt;<i> -- What about it if &quot;T&quot; is used together with A:[start|middle|end]?
</I>
Isn't this answered exhaustively by the rendering rules? I don't really 
understand why this would be undefined.


&gt;<i> * S:[number]
</I>&gt;<i>  -- If using S:[number] without &quot;%&quot; (percentage) it is not clear
</I>&gt;<i> whether &quot;px&quot; or &quot;em&quot; is the unit for the text size.
</I>
Neither, the unit is based on &quot;vw&quot;s. Again, the rendering part of the spec 
seems to make this clear.


&gt;<i> * cue voice tag
</I>&gt;<i>  -- why are we not using voice name declaration like in the cue class
</I>&gt;<i> tags with a dot separation like &lt;v.VoiceName&gt;voice text&lt;/v&gt; and
</I>&gt;<i> without spaces (eg. &lt;v VoiceName&gt;). This could avoid errors by .vtt
</I>&gt;<i> file writer and would also be much more clear to implement.
</I>
How would you include both a class and a voice name if you did that?
Or include a name with spaces?



&gt;<i> &gt;&gt; Using this syntax, I would expect some confusion when you omit the closing
</I>&gt;<i> &gt;&gt; &lt;/v&gt;, when it's *not* a cue spoken by two voices at the same time, such as:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; &lt;v Jim&gt;- Boo!
</I>&gt;<i> &gt;&gt; &lt;v Bob&gt;- Gah!
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Gah! is spoken by both Jim and Bob, but that was likely not intended. If
</I>&gt;<i> &gt;&gt; this causes confusion, we should make validators warn about multiple
</I>&gt;<i> &gt;&gt; voices with with no closing &lt;/v&gt;.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; No need to just warn, the spec says the above is outright invalid, so
</I>&gt;<i> &gt; they would raise an error.
</I>&gt;<i> 
</I>&gt;<i> It would still need parsing. Do we expect it to result in
</I>&gt;<i> &lt;v Jim&gt;- Boo!&lt;/v&gt;
</I>&gt;<i> &lt;v Bob&gt;- Gah!
</I>&gt;<i> or
</I>&gt;<i> &lt;v Jim&gt;- Boo!
</I>&gt;<i> &lt;v Jim, Bob&gt;- Gah!
</I>&gt;<i> ?
</I>
They would end up nested, not siblings, per the current parser.


&gt;<i> Also, that raises a question: if the &quot;annotation&quot; in the &lt;v&gt; element 
</I>&gt;<i> concerns multiple people, how do we specify that? Are we leaving this 
</I>&gt;<i> completely to author preference or do we want it to be machine parsable?
</I>
The use case was for showing the text to the user, so it wouldn't be 
machine readable. You'd just write it the same way you want it to appear 
to the user. You can use class names if you need a machine-referencable 
hook, e.g. for styling:

   &lt;v.male Bob&gt;Hello&lt;/v&gt;

   &lt;v.female Nadine&gt;Hi!&lt;/v&gt;

   &lt;v.female.male Both&gt;Are you--&lt;/v&gt;


&gt;<i> &gt; On Tue, 4 Jan 2011, Alex Bishop wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Firefox too. If you visit 
</I>&gt;<i> &gt;&gt; <A HREF="http://people.mozilla.org/~jdaggett/webfonts/serbianglyphs.html">http://people.mozilla.org/~jdaggett/webfonts/serbianglyphs.html</A> in 
</I>&gt;<i> &gt;&gt; Firefox 4, the text explicitly marked-up as being Serbian Cyrillic 
</I>&gt;<i> &gt;&gt; (using the lang=&quot;sr-Cyrl&quot; attribute) uses some different glyphs to 
</I>&gt;<i> &gt;&gt; the text with no language metadata.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This seems to be in violation of CSS; we should probably fix it there 
</I>&gt;<i> &gt; before fixing it in WebVTT since WebVTT relis on CSS.
</I>&gt;<i> 
</I>&gt;<i> Only when used within browsers...
</I>
There's no reason standalone players couldn't also support CSS for WebVTT.


&gt;<i> &gt; I'm not sure what you mean by &quot;made part of the WebVTT specification&quot;, 
</I>&gt;<i> &gt; but if you mean that WebVTT should support inline CSS, that does seem 
</I>&gt;<i> &gt; line something we can add, e.g. using syntax like this:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; WEBVTT
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; STYLE--&gt;
</I>&gt;<i> &gt; &#194;&#160; ::cue(v[voice=Bob]) { color: green; }
</I>&gt;<i> &gt; &#194;&#160; ::cue(c.narration) { font-style: italic; }
</I>&gt;<i> &gt; &#194;&#160; ::cue(c.narration i) { font-style: normal; }
</I>&gt;<i> 
</I>&gt;<i> Yup, that's exactly what we need.
</I>
I haven't added this yet, but I've filed this bug to not forget about it:

   <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=15023">http://www.w3.org/Bugs/Public/show_bug.cgi?id=15023</A>


&gt;<i> &gt;&gt; WebVTT requires a structure to add header-style metadata. We are here 
</I>&gt;<i> &gt;&gt; talking about lists of name-value pairs as typically in use for 
</I>&gt;<i> &gt;&gt; header information. The metadata can be optional, but we need a 
</I>&gt;<i> &gt;&gt; defined means of adding them.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Required attributes in WebVTT files should be the main language in 
</I>&gt;<i> &gt;&gt; use and the kind of data found in the WebVTT file - information that 
</I>&gt;<i> &gt;&gt; is currently provided in the &lt;track&gt; element by the @srclang and 
</I>&gt;<i> &gt;&gt; @kind attributes. These are necessary to allow the files to be 
</I>&gt;<i> &gt;&gt; interpreted correctly by non-browser applications, for transcoding or 
</I>&gt;<i> &gt;&gt; to determine if a file was created as a caption file or something 
</I>&gt;<i> &gt;&gt; else, in particular the @kind=metadata. @srclang also sets the base 
</I>&gt;<i> &gt;&gt; directionality for BiDi calculations.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Further metadata fields that are typically used by authors to keep 
</I>&gt;<i> &gt;&gt; specific authoring information or usage hints are necessary, too. As 
</I>&gt;<i> &gt;&gt; examples of current use see the format of MPlayer mpsub&#226;&#128;&#153;s header 
</I>&gt;<i> &gt;&gt; metadata [2], EBU STL&#226;&#128;&#153;s General Subtitle Information block [3], and 
</I>&gt;<i> &gt;&gt; even CEA-608&#226;&#128;&#153;s Extended Data Service with its StartDate, Station, 
</I>&gt;<i> &gt;&gt; Program, Category and TVRating information [4]. Rather than 
</I>&gt;<i> &gt;&gt; specifying a specific subset of potential fields we recommend to just 
</I>&gt;<i> &gt;&gt; have the means to provide name-value pairs and leave it to the 
</I>&gt;<i> &gt;&gt; negotiation between the author and the publisher which fields they 
</I>&gt;<i> &gt;&gt; expect of each other.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; [2] <A HREF="http://www.mplayerhq.hu/DOCS/tech/mpsub.sub">http://www.mplayerhq.hu/DOCS/tech/mpsub.sub</A>
</I>&gt;<i> &gt;&gt; [3] <A HREF="https://docs.google.com/viewer?a=v&amp;q=cache:UKnzJubrIh8J:tech.ebu.ch/docs/tech/tech3264.pdf">https://docs.google.com/viewer?a=v&amp;q=cache:UKnzJubrIh8J:tech.ebu.ch/docs/tech/tech3264.pdf</A>
</I>&gt;<i> &gt;&gt; [4] <A HREF="http://edocket.access.gpo.gov/cfr_2007/octqtr/pdf/47cfr15.119.pdf">http://edocket.access.gpo.gov/cfr_2007/octqtr/pdf/47cfr15.119.pdf</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I don't understand the use cases here.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; CSS and JS don't have anything like this, why should WebVTT? What 
</I>&gt;<i> &gt; problem is this solving? How did SRT solve this problem?
</I>&gt;<i> 
</I>&gt;<i> SRT doesn't solve it. That's why it's not being used by professionals 
</I>&gt;<i> for subtitling. Most other subtitling formats, however, have means for 
</I>&gt;<i> including metadata, including formats like LRC for music lyrics. CSS and 
</I>&gt;<i> JS don't have metadata, but HTML has through the meta tag.
</I>
If HTML's metadata stuff is enough for CSS and JS, why is it not enough 
for WebVTT? I really don't understand the use case here.


&gt;<i> &gt; Adding defaults seems like a reasonable feature. We could add this just by
</I>&gt;<i> &gt; adding the ability to have a block in a VTT file like this:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; WEBVTT
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; DEFAULTS --&gt; A:vertical A:end
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; 00:00.000 --&gt; 00:02.000
</I>&gt;<i> &gt; &#194;&#160; This is vertical and end-aligned.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; 00:02.500 --&gt; 00:05.000
</I>&gt;<i> &gt; &#194;&#160; As is this.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; DEFAULTS --&gt; A:start
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; 00:05.500 --&gt; 00:07.000
</I>&gt;<i> &gt; &#194;&#160; This is horizontal and start-aligned.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; However, again I suggest that we wait until WebVTT has been deployed 
</I>&gt;<i> &gt; in at least one browser before adding more features like this.
</I>&gt;<i> 
</I>&gt;<i> This is a good idea. Happy to wait, though there are now implementations 
</I>&gt;<i> that are starting to emerge and in particular these DEFAULTS will be 
</I>&gt;<i> very useful to reduce repetition in authoring from the start.
</I>
Filed this bug to keep track of this issue:
   <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=15024">http://www.w3.org/Bugs/Public/show_bug.cgi?id=15024</A>


&gt;<i> There are particularly questions about what L:100% and T:100% mean - do 
</I>&gt;<i> they position the boxes outside the video viewport?
</I>
T:100% just puts the bottom of the box at the bottom of the viewport. 
L:100% puts the end of the box at the end of the viewport. I don't see why 
this would go outside the viewport.


&gt;<i> Incidentally: would it make sense to have a pixel-based (or em-based) 
</I>&gt;<i> font size specification for &quot;S&quot; as well as the percentage based one?
</I>
Not as far as I can tell.


&gt;<i> &gt;&gt; * naming: The usage of single letter abbreviations for cue settings 
</I>&gt;<i> &gt;&gt; has created quite a discussion here at Google. We all agree that 
</I>&gt;<i> &gt;&gt; file-wide cue settings are required and that this will reduce the 
</I>&gt;<i> &gt;&gt; need for cue-specific cue settings. We can thus afford a bit more 
</I>&gt;<i> &gt;&gt; readability in the cue settings. We therefore believe that it would 
</I>&gt;<i> &gt;&gt; be better if the cue settings were short names rather than single 
</I>&gt;<i> &gt;&gt; letter codes. This would be more like CSS, too, and easier to learn 
</I>&gt;<i> &gt;&gt; and get right. In the interface description, the 5 dimensions have 
</I>&gt;<i> &gt;&gt; proper names which could be re-used (&#226;&#128;&#156;direction&#226;&#128;&#157;, 
</I>&gt;<i> &gt;&gt; &#226;&#128;&#156;linePosition&#226;&#128;&#157;, &#226;&#128;&#156;textPosition&#226;&#128;&#157;, &#226;&#128;&#156;size&#226;&#128;&#157; and &#226;&#128;&#156;align&quot;). We 
</I>&gt;<i> &gt;&gt; therefore recommend replacing the single-letter cue commands with 
</I>&gt;<i> &gt;&gt; these longer names.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; That would massively bloat these files and make editing them a huge 
</I>&gt;<i> &gt; pain, as far as I can tell. I agree that defaults would make it 
</I>&gt;<i> &gt; better, but many cues would still need their own positioning and 
</I>&gt;<i> &gt; sizing information, and anything beyond a very few letters would IMHO 
</I>&gt;<i> &gt; quickly become far too verbose for most people. &quot;L&quot;, &quot;A&quot;, and &quot;S&quot; are 
</I>&gt;<i> &gt; pretty mnemonic, &quot;T&quot; would quickly become familiar to people writing 
</I>&gt;<i> &gt; cues, and &quot;D&quot; is only going to be relevant to some authors but for 
</I>&gt;<i> &gt; those authors it's pretty self-explanatory as well, since the value is 
</I>&gt;<i> &gt; verbose.
</I>&gt;<i> 
</I>&gt;<i> It took me 6 months before I got used to them for authoring subtitle 
</I>&gt;<i> files, but indeed I have grown accustomed and can deal with them now.
</I>
These will most likely change after all, for this bug:

   <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=14646">http://www.w3.org/Bugs/Public/show_bug.cgi?id=14646</A>


&gt;<i> &gt;&gt; We are happy to see the introduction of the magic file identifier for 
</I>&gt;<i> &gt;&gt; WebVTT which will make it easier to identify the file format. We do 
</I>&gt;<i> &gt;&gt; not believe the &#226;&#128;&#156;FILE&#226;&#128;&#157; part of the string is necessary.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have removed it.
</I>&gt;<i> 
</I>&gt;<i> Thanks. You should also remove the text &quot;, or the seventh character is 
</I>&gt;<i> neither a U+0020 SPACE character nor a U+0009 CHARACTER TABULATION (tab) 
</I>&gt;<i> character,&quot; from step 7 of the parsing, since such a seventh character 
</I>&gt;<i> does not need to exist at all.
</I>
That would make it impossible to e.g. have Emacs modelines on the first 
line.


&gt;<i> &gt;&gt; However, we recommend to also introduce a format version number that 
</I>&gt;<i> &gt;&gt; the file adheres to, e.g. &#226;&#128;&#156;WEBVTT 0.7&#226;&#128;&#157;.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Version numbers are an antipattern on the Web, so I have not added 
</I>&gt;<i> &gt; one.
</I>&gt;<i> 
</I>&gt;<i> We can have it underneath the file magic in another line of the header 
</I>&gt;<i> now where the metadata will be (or will be when we make V2 of the format 
</I>&gt;<i> ;-), so that's fine.
</I>
We should never have a version number, anywhere.


&gt;<i> &gt;&gt; * Voice synthesis of e.g. mixed English/French captions. Given that 
</I>&gt;<i> &gt;&gt; this would only be useful to be people who know both languages, it 
</I>&gt;<i> &gt;&gt; seem not worth complicating the format for.
</I>&gt;<i> 
</I>&gt;<i> I disagree with the third case. Many people speak more than one language 
</I>&gt;<i> and even if they don't speak the language that is in use in a cue, it is 
</I>&gt;<i> still bad to render it in using the wrong language model, in particular 
</I>&gt;<i> if it is rendered by a screen reader. We really need a mechanism to 
</I>&gt;<i> attach a language marker to a cue segment.
</I>
You think we should add a feature to WebVTT specifically for the use case 
of audio synthesis of subtitles that contain text in two languages for 
users who understand both languages?

That seems like a rather esoteric case to be something to handle in v1, 
if ever.


&gt;<i> &gt; On Wed, 9 Feb 2011, Silvia Pfeiffer wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; We're trying to avoid the need for multiple transcodings and are 
</I>&gt;<i> &gt;&gt; trying to achieve something like the following pipeline: broadcast 
</I>&gt;<i> &gt;&gt; captions -&gt; transcode to WebVTT -&gt; show in browser -&gt; transcode to 
</I>&gt;<i> &gt;&gt; broadcast devices -&gt; show
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Why not just do:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; broadcast captions -&gt; transcode to WebVTT -&gt; show in browser
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ...for browsers and:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#194;&#160; broadcast captions -&gt; show
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ...for legacy broadcast devices?
</I>&gt;<i> 
</I>&gt;<i> Eventually, we will want to get rid of the legacy format and just 
</I>&gt;<i> deliver WebVTT, but they still need to display as though they came from 
</I>&gt;<i> the original broadcast caption format for contractual reasons.
</I>
Change the contracts. We shouldn't be designing a format for the next 
hundred plus years around today's contracts for legacy content. That's 
completely backwards.


On Wed, 8 Jun 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; When would one want these descriptions to be multi-language?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; When they are describing something that is inherently multi-cultural. 
</I>&gt;<i> &gt; For example, the name of a restaurant which is in French, while the 
</I>&gt;<i> &gt; describer language is English.
</I>&gt;<i> 
</I>&gt;<i> Does this kind of thing currently work with screen readers? Non-French 
</I>&gt;<i> people speaking English don't switch to proper French pronunciation when 
</I>&gt;<i> saying something like &quot;I'm really into film noir&quot; or &quot;The general 
</I>&gt;<i> assumed political power through a coup d'etat&quot;, so screen reader users 
</I>&gt;<i> actually want what? If one doesn't know French, it seems like it would 
</I>&gt;<i> be harder to understand.
</I>&gt;<i> 
</I>&gt;<i> For languages further removed from English I'm fairly certain no English 
</I>&gt;<i> speaker would want to hear the original pronunciation. Imagine 
</I>&gt;<i> pronouncing &quot;Mexico&quot; in Spanish or &quot;Beijing&quot; in Mandarin Chinese in the 
</I>&gt;<i> middle of an English text... I'm certain it would confuse people more 
</I>&gt;<i> than help them understand.
</I>
Indeed.


On Fri, 10 Jun 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> In the parsing section for cues, step 27, the default for cue is set to 
</I>&gt;<i> 100. This means that every cue that has no explicit size setting (&quot;S:&quot;) 
</I>&gt;<i> will occupy the full width of the video viewport (height if vertical 
</I>&gt;<i> renering), even if the displayed text is only short, such as &quot;[music]&quot;. 
</I>&gt;<i> I believe that is not the best default means of rendering subtitles and 
</I>&gt;<i> captions, because more of the video's pixel are obstructed than is 
</I>&gt;<i> necessary by the cue background box with its dark grey background 
</I>&gt;<i> rgba(0,0,0,0.8).
</I>
The gray background only applies to the inline wrapper, not the box.


&gt;<i> In the parsing section for cues, step 25, the default line position for 
</I>&gt;<i> cues is 'auto' and the default snap-to-lines flag is true. For cues that 
</I>&gt;<i> have no explicit line position setting (&quot;L:&quot;), this means that the 
</I>&gt;<i> height of the cue ends up getting y-position of 0 (see Section 2 with 
</I>&gt;<i> the WebVTT cue text rendering rules, step 10, substep 9, first case ). 
</I>
I'm not sure what you mean by &quot;the height of the cue ends up getting a 
y-position&quot;. The cue in that step gets a y-position of zero, but that is 
not its final position if the snap-to-lines flag is set; that's just the 
position used to get the line box height before the actual y-position is 
determined.


&gt;<i> 3. Calculation of Text Track cue line position
</I>&gt;<i> 
</I>&gt;<i> Assuming we've set a &quot;L:100%&quot; on a cue, then according to Section 2,
</I>&gt;<i> step 10, substep 9, second case we arrive at a y-position of 100,
</I>&gt;<i> leading to the setting of &quot;top&quot; to 100% of the video's height. This
</I>&gt;<i> means that the cue will disappear beyond the bottom of the video
</I>&gt;<i> viewport. Is that intended?
</I>
Again, that position is not the final position, it's just the position in 
order to calculate the box dimensions. The actual position is then 
recalculated a few steps lower, such that in the case you describe, the 
box is aligned with its bottom at the bottom of the viewport.


&gt;<i> Also, shouldn't the caption text box have been centered in the middle of 
</I>&gt;<i> the caption text box's height at the L position rather than at the top 
</I>&gt;<i> of that box?
</I>
I don't understand the question. Can you elaborate with an example?


&gt;<i> Similarly as for the vertical line positioning, I wonder whether there 
</I>&gt;<i> is a problem with the horizontal &quot;T:&quot; text positioning. When we specify 
</I>&gt;<i> T:25% on an A:middle cue box, the box is moved half its size to the left 
</I>&gt;<i> of the T position, i.e. it ends up at -12.5% of the video viewport's 
</I>&gt;<i> width. Is that intended? Should there be a way to limit how far a box 
</I>&gt;<i> can be moved off the video viewport? Should it continue to be visible 
</I>&gt;<i> when moved off the video viewport?
</I>
I think you are misreading the spec. The x-position in the case you 
describe is entirely unaffected by the alignment and T: values (modulo 
line wrapping). Do you mean the y-position? The size in the case you give 
is twice the T: position (so 50%), which leads to a y-position of zero 
(T:25% minus half the 50% size is 25 minus 25 is zero).


On Mon, 27 Jun 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> What Ronny says there is that in his implementation the default display 
</I>&gt;<i> size of the cue (i.e. the dark box that the cue is displayed in) is only 
</I>&gt;<i> as wide as the longest line in the cue (or high where we're dealing with 
</I>&gt;<i> vertical direction). Currently, the spec puts as a default S:100%.
</I>
How can you know the width of the widest line before you know the size?

The size we're talking about here isn't the size of the background box, 
it's the size of the block into which the captions are rendered.


&gt;<i> 2. Cue voice tag:
</I>&gt;<i> &quot;this differs from specs in the way that opened &lt;v&gt; voice tags should
</I>&gt;<i> be closed with &lt;/v&gt;&quot;
</I>&gt;<i> 
</I>&gt;<i> Ronny's point is that the &lt;v&gt; element is expected to be closed,
</I>&gt;<i> because it makes it easier to parse. So, instead of:
</I>&gt;<i> 
</I>&gt;<i> 00:01:07.395 --&gt; 00:01:10.246
</I>&gt;<i> &lt;v John Do&gt;Hey!
</I>&gt;<i> &lt;v Jane Doe&gt;Hello!
</I>&gt;<i> 
</I>&gt;<i> he expects:
</I>&gt;<i> 
</I>&gt;<i> 00:01:07.395 --&gt; 00:01:10.246
</I>&gt;<i> &lt;v John Do&gt;Hey!&lt;/v&gt;
</I>&gt;<i> &lt;v Jane Doe&gt;Hello!&lt;/v&gt;
</I>&gt;<i> 
</I>&gt;<i> I think the same is true for his implementation of the &lt;c&gt; class tags.
</I>
As far as I can tell, this is based on a misreading of the specification. 
Either I misunderstand your comment, or the spec already says what this 
suggests it should say.


On Sun, 7 Aug 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> I am right now trying to figure out how vertical growing left cues (i.e. 
</I>&gt;<i> cues with a cue rendering setting of &quot;D:vertical&quot;) are rendered.
</I>&gt;<i> 
</I>&gt;<i> If nothing else is set on the cue, my expectation would be that the cue 
</I>&gt;<i> would be rendered on the right side of the video viewport, since it's 
</I>&gt;<i> growing to the left.
</I>&gt;<i> 
</I>&gt;<i> As I follow through the algorithm at
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/webvtt.html#webvtt-cue-text-rendering-rules">http://www.whatwg.org/specs/web-apps/current-work/webvtt.html#webvtt-cue-text-rendering-rules</A>
</I>&gt;<i> , I find that the default settings are:
</I>&gt;<i> * the text track cue line position default is &quot;auto&quot;,
</I>&gt;<i> * the snap-to-lines flag is &quot;true&quot; by default,
</I>&gt;<i> * block flow is left to right
</I>&gt;<i> and in step 9 we get:
</I>&gt;<i> &quot;If the text track cue writing direction is vertical growing left, and
</I>&gt;<i> the text track cue snap-to-lines flag is set, let x-position be zero&quot;.
</I>&gt;<i> 
</I>&gt;<i> I think this is incorrect and should be &quot;..., let x-position be 100&quot;
</I>&gt;<i> so as to allow the text boxes to flow onto the video viewport from the
</I>&gt;<i> right boundary, rather than off its left border.
</I>
Again, this number is not the number used for positioning. It's just a 
temporary number used for sizing.


On Tue, 9 Aug 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> It seems that where we have specified how to parse the cue settings, we 
</I>&gt;<i> only allow a single white space as separator between subsequent cue 
</I>&gt;<i> settings: 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/webvtt.html#parse-the-webvtt-settings">http://www.whatwg.org/specs/web-apps/current-work/webvtt.html#parse-the-webvtt-settings</A>
</I>&gt;<i> 
</I>&gt;<i> Thus, something like this is allowed: &quot;D:vertical A:middle&quot;
</I>&gt;<i> but not something like this: &quot;D:vertical         A:middle&quot;.
</I>&gt;<i> 
</I>&gt;<i> I think we need to add a skip white space in step three.
</I>
I think this is fixed now.


&gt;<i> While the syntax spec says &quot;The time represented by this WebVTT 
</I>&gt;<i> timestamp must be greater than or equal to the start time offsets of all 
</I>&gt;<i> previous cues in the file.&quot; , there is no step in the parse that will 
</I>&gt;<i> ascertain that cues that come our of time are dropped on the floor. Do 
</I>&gt;<i> we need to include such a requirement before step 40 of the parser?
</I>
Why would we drop them on the floor?


On Wed, 20 Jul 2011, Marc 'Tafouk' wrote:
&gt;<i> 
</I>&gt;<i> I have another question about self-closing tags in cue text. It seems 
</I>&gt;<i> they're not supported at all. The U+002F SOLIDUS character (/) is only 
</I>&gt;<i> handled in the WebVTT tag state.
</I>&gt;<i> 
</I>&gt;<i> Test case 1-a):
</I>&gt;<i>    WEBVTT
</I>&gt;<i> 
</I>&gt;<i>    00:00.000 --&gt; 00:02.000
</I>&gt;<i>    Initial &lt;b/&gt; test
</I>&gt;<i> 
</I>&gt;<i> U+0062 (b) triggers &quot;WebVTT start tag state&quot;; U+002F is then handled as 
</I>&gt;<i> &quot;Anything else&quot; and is appended to result (tagname = &quot;b/&quot;).
</I>
Right.


&gt;<i> Test case 1-b):
</I>&gt;<i>    WEBVTT
</I>&gt;<i> 
</I>&gt;<i>    00:00.000 --&gt; 00:02.000
</I>&gt;<i>    Initial &lt;b /&gt; test
</I>&gt;<i> 
</I>&gt;<i> U+0062 (b) triggers &quot;WebVTT start tag state&quot;; U+0020 (space) triggers 
</I>&gt;<i> &quot;WebVTT start tag annotation state&quot;; U+002F is handled as &quot;Anything 
</I>&gt;<i> else&quot; and is appended to buffer (annotation = &quot;/&quot;).
</I>
Right.


&gt;<i> I am aware those may be moot atm because there is no void element AFAIK, 
</I>&gt;<i> and the current tags make no sense when immediately closed.
</I>
Well, also, the /&gt; syntax thing is an XMLism and this isn't XML.


&gt;<i> I also found a slight issue when following the parser specs : there is no 
</I>&gt;<i> validation of the class attribute.
</I>&gt;<i> 
</I>&gt;<i> Test case 2):
</I>&gt;<i>    WEBVTT
</I>&gt;<i> 
</I>&gt;<i>    00:00.000 --&gt; 00:02.000
</I>&gt;<i>    Second &lt;c.......... [my annotation]&gt; test
</I>&gt;<i> 
</I>&gt;<i> classes is a list of 10 empty strings.
</I>
When you create the WebVTT Internal Node Object, empty classes are 
dropped.


On Wed, 20 Jul 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#attach-a-webvtt-internal-node-object">http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#attach-a-webvtt-internal-node-object</A> 
</I>&gt;<i> says to attach the list of classes to the element. Right now, all 
</I>&gt;<i> characters are allowed for class names bar space, tab, &quot;.&quot; and &quot;&gt;&quot;. It 
</I>&gt;<i> might indeed be an idea to restrict these character to those allowed for 
</I>&gt;<i> class names in HTML.
</I>
HTML allows even more characters (everything except whitespace).


On Sun, 19 Jun 2011, Rodger Combs wrote:
&gt;<i>
</I>&gt;<i> There are a few possible cases when JavaScript may need to add, remove, 
</I>&gt;<i> read, or modify a cue from a &lt;track&gt;:
</I>&gt;<i>
</I>&gt;<i> 1. A web-based caption editor
</I>&gt;<i>
</I>&gt;<i> 2. Parsing captions from an external non-WebVTT file (retrieved with 
</I>&gt;<i> XHR, EventSource [for live videos], WebSocket, etc.)
</I>&gt;<i>
</I>&gt;<i> 3. Live translating of captions using an external translation API
</I>&gt;<i>
</I>&gt;<i> Adding a set of methods to the TextTrackCueList for cue modification 
</I>&gt;<i> could be useful. Here's an example interface:
</I>&gt;<i> 
</I>&gt;<i> TextTrackCue addCue(in double startTime, in double endTime, in DOMString text, in optional DOMString[] flags);
</I>
Already exists as:

track.addCue(new TextTrackCue(id, startTime, endTime, text, settings, 
pauseOnExit));


&gt;<i> void removeCue(in TextTrackCue);
</I>
Already exists as:

track.removeCue(cue);


&gt;<i> void removeCueById(in DOMString id);
</I>
Already exists as:

track.removeCue(track.cues.getCueById(id));

(Should we make getCueById() a getter?)


&gt;<i> Also, I recommend that in TextTrackCue, startTime, endTime, and 
</I>&gt;<i> pauseOnExit are made non-readonly, and that &quot;attribute DOMString text;&quot; 
</I>&gt;<i> is added to the interface.
</I>
Done.


On Wed, 21 Sep 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> If you look at the source of the spec, you'll find comments as a v2 
</I>&gt;<i> feature request:
</I>&gt;<i> 
</I>&gt;<i> COMMENT --&gt;
</I>&gt;<i> this is a comment, bla bla
</I>&gt;<i> 
</I>&gt;<i> I do not think this would be very useful. As a one-line comment at the 
</I>&gt;<i> top of the file (for authorship, etc) it is rather verbose and ugly, 
</I>&gt;<i> while for commenting out cues you would have to comment out each cue 
</I>&gt;<i> individually. It also doesn't work inside cues, where something like &lt;! 
</I>&gt;<i> comment &gt; is what would be backwards compatible with the current parser. 
</I>&gt;<i> If comments are left for v2, the above is what it'll be, because of 
</I>&gt;<i> compatibility constraints. If anyone is less than impressed with that, 
</I>&gt;<i> now would be the time to suggest an alternative and have it spec'd.
</I>
I've removed the comment in the spec. It wouldn't work well with the 
recent parser changes anyway.


&gt;<i> The WebVTT layout algorithm tries to not move cues around once they've 
</I>&gt;<i> been displayed and to never obscure other cues. This means that for cues 
</I>&gt;<i> that overlap in time, the rendering will often be out of order, with the 
</I>&gt;<i> earliest cue at the bottom. This is quite contrary to the (mainly US?) 
</I>&gt;<i> style of (live) scrolling captions, where cues are always in order and 
</I>&gt;<i> scroll to bring new captions into view. (I am not suggesting any 
</I>&gt;<i> specific change.)
</I>
Live captions are different, IMHO. They're one cue that happens to have 
lots of data over a long period of time, not multiple cues.


&gt;<i> Scaling the font size with the video will not be optimal for either 
</I>&gt;<i> small screens (text will be too small) or very large screens (text will 
</I>&gt;<i> be too big). Do we change the default rendering in some way, or do we 
</I>&gt;<i> let users override the font size? If users can override it, do we care 
</I>&gt;<i> that this may break the intended layout of the author?
</I>
How small are we talking about here? DVD content seems to work fine with 
subtitles being a fixed size relative to the video size. If you can see 
the video content, you can see the subtitles, surely.

Naturally, people will always be able to override the author.


&gt;<i> The parser is fairly strict in some regards:
</I>&gt;<i> 
</I>&gt;<i> * double id line discards entire cue
</I>&gt;<i> (<A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=13943">http://www.w3.org/Bugs/Public/show_bug.cgi?id=13943</A>)
</I>&gt;<i> * must use exactly 2 digits for minutes and seconds
</I>&gt;<i> * minutes and seconds must be &lt;60
</I>&gt;<i> * must use &quot;.&quot; as the decimal separator
</I>&gt;<i> * must use exactly 3 decimal digits
</I>&gt;<i> * stray &quot;&lt;&quot; consumes the rest of the cue text
</I>
For an overview of the design philosophy here, please see this comment on 
the above bug:

   <A HREF="https://www.w3.org/Bugs/Public/show_bug.cgi?id=13943#c17">https://www.w3.org/Bugs/Public/show_bug.cgi?id=13943#c17</A>


&gt;<i> In most systems chapters are really chapter markers, a point in time. A 
</I>&gt;<i> chapter implicitly ends when the next begins. For nested chapters this 
</I>&gt;<i> isn't so, as the end time is used to determine nesting. Do we expect 
</I>&gt;<i> that UIs for chapter navigation make the end time visible in some 
</I>&gt;<i> fashion (e.g. highlighting the chapter on the timeline)
</I>
Realistically, I don't expect to see timelines... but if the start and end 
times are different, that is certainly a sensible thing to use them for.


&gt;<i> or that when a chapter it is chosen, it will pause at the end time?
</I>
I certainly don't expect any pausing behaviour, though UAs are of course 
welcome to do that if that's what their users want.


&gt;<i> A suggestion that was brought up when discussing chapters. When one 
</I>&gt;<i> simply wants the chapter to end when the next starts, it's a bit of a 
</I>&gt;<i> hassle to always include the end time. Some additional complexity in the 
</I>&gt;<i> parser could allow for this:
</I>&gt;<i> 
</I>&gt;<i> 00:00.000 --&gt; next
</I>&gt;<i> Chapter 1
</I>&gt;<i> 
</I>&gt;<i> 01:00.000 --&gt; next
</I>&gt;<i> Intermezzo
</I>&gt;<i> 
</I>&gt;<i> 02:00.000 --&gt; next
</I>&gt;<i> Last Chapter
</I>&gt;<i> 
</I>&gt;<i> Cues would be created with endTime = Infinity, and be modified to the 
</I>&gt;<i> startTime of the following cue (in source order) if there is a following 
</I>&gt;<i> cue. This would IMO be quite neat, but is the use case strong enough?
</I>
The same feature would be useful for captions sometimes, actually. I don't 
know how strong the use case is. It's purely syntactic sugar. It probably 
depends on how common it is for VTT files to be hand-authored vs written 
with tools.


On Wed, 21 Sep 2011, Ralph Giles wrote:
&gt;<i> 
</I>&gt;<i> I don't like the format either. I do think it's very important we have 
</I>&gt;<i> some mechanism for multi-line file level metadata, embedded css, etc. so 
</I>&gt;<i> the files can live on their own.
</I>
What is the use case?


&gt;<i> The syntax section also suggests all metadata has to be on the signature 
</I>&gt;<i> line, while the parser will actually skip everything between the 
</I>&gt;<i> signature and the first double line terminator.
</I>
The stuff on the signature line is not metadata, what suggests that it is? 
I just allow stuff there to allow things like Emacs mode lines to be 
ignored.


&gt;<i> For in-caption, &lt;! comment&gt; is a good idea. Semantically it's a bit 
</I>&gt;<i> weird to not mention it in the spec, since everything else has an end 
</I>&gt;<i> tag, but the parser will ignore it as we want.
</I>
What's the use case for inline comments?


&gt;<i> I'm not normally one for restrictions, but parser also says the 
</I>&gt;<i> (optional) hours field must have &quot;two or more&quot; digits, with no maximum 
</I>&gt;<i> value specified.
</I>&gt;<i> 
</I>&gt;<i> If we all agree on an implementation limit, it could be helpful to 
</I>&gt;<i> specify one. Storing milliseconds in a 32 bit type gives a little over 
</I>&gt;<i> 1000 hours of timestamps. Single-precision float runs out of useful 
</I>&gt;<i> precision after about 50 hours. I'd suggest a two or three digit limit 
</I>&gt;<i> on hours to avoid requiring a 64 bit type. If we don't care about that, 
</I>&gt;<i> then 10 digits is a reasonable limit to avoid running out of precision 
</I>&gt;<i> with doubles.
</I>
As a general rule, I think we shold avoid defining limits for things that 
will naturally get less limited over time.


On Wed, 21 Sep 2011, Glenn Maynard wrote:
&gt;<i> 
</I>&gt;<i> My take on in-caption comments was to put them in a class and hide the 
</I>&gt;<i> class, with the advantage of the comments being available 
</I>&gt;<i> programmatically (you can toggle them on for editing purposes by 
</I>&gt;<i> un-hiding the class) and requiring no additional specification, though 
</I>&gt;<i> the disadvantage that you need a stylesheet to properly view the 
</I>&gt;<i> resulting file.  To avoid that, maybe a separate span type would be 
</I>&gt;<i> better, analogous to the &quot;hidden&quot; HTML attribute.
</I>
What's the use case, though? If it's notes to a translator, or notes about 
uncertain captioning, presumably you would want to strip those out before 
publishing the captions.


&gt;<i> (I don't want to restart the whole comment discussion, but it'd be 
</I>&gt;<i> unfortunate if the desired syntax for inline comments never happens due 
</I>&gt;<i> to being punted to v2 and then being impossible to make 
</I>&gt;<i> backwards-compatible with v1.)
</I>
I don't think that's a concern, since unknown tags get dropped. We can 
always add it later if it is something we need.



On Thu, 29 Sep 2011, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> Also note that YouTube is experimenting with richer captions, see 
</I>&gt;<i> <A HREF="http://www.youtube.com/watch?v=0xTURXWoJ6A">http://www.youtube.com/watch?v=0xTURXWoJ6A</A> (check the different caption 
</I>&gt;<i> tracks) . These are representing some of the features that the US TV 
</I>&gt;<i> standard CEA608/708 captions support, so we need to make sure they are 
</I>&gt;<i> also supported by browsers, otherwise we get a lower quality result with 
</I>&gt;<i> captions on the Web that we get with captions on TV.
</I>
I think we are already at a higher quality level with WebVTT as it is 
today. We don't need to be a superset to be better.


&gt;<i> What happens with the new lines that are created by wrapping should, 
</I>&gt;<i> however, be defined better than what we have right now. In other 
</I>&gt;<i> existing caption formats, there is the concept of an &quot;anchor&quot;. The box 
</I>&gt;<i> into which the caption text is rendered is &quot;anchored&quot; to the video by 
</I>&gt;<i> choosing a point inside the one-line caption cue box and a point on the 
</I>&gt;<i> video viewport and anchoring that point. The box then grows around that 
</I>&gt;<i> point in equal parts. For example, if the box is anchored at its top 
</I>&gt;<i> middle point and assuming horizontally rendered text, the box will grow 
</I>&gt;<i> down from that point. If it's anchored at the bottom middle point, the 
</I>&gt;<i> box will grow up (even if the text is wrapped down and grows down - i.e. 
</I>&gt;<i> the first line will be moved up before the second line is rendered).
</I>
For block-progression-direction positioning, we already essentially have 
this. For inline-progression-direction positioning, if we need to support 
the same model as for block-position we can add support for it as a new 
unit on the inline-position setting (&quot;T:&quot; currently). But I don't think we 
need to; we already provide a way to anchor to a specific position.


On Wed, 5 Oct 2011, Simon Pieters wrote:
&gt;<i>
</I>&gt;<i> I did some research on authoring errors in SRT timestamps to inform 
</I>&gt;<i> whether WebVTT parsing of timestamps should be changed.
</I>
Thanks!


&gt;<i> [...] 65,000 files [...]
</I>&gt;<i> Grepping for lines that contain &quot;--&gt;&quot; resulted in 52,000,000 lines [...]
</I>&gt;<i>
</I>&gt;<i> Of those, there were 31,900 lines that are invalid, i.e. don't match the 
</I>&gt;<i> python regexp 
</I>&gt;<i> '\s*\d\d:[0-5]\d:[0-5]\d\,\d\d\d\s*--&gt;\s*\d\d:[0-5]\d:[0-5]\d\,\d\d\d($|\s)'.
</I>
Wow, 31,900 is 0.06%, which is a really low error rate, at least comapred 
to HTML (which is in the single digit percentages at best, probably double 
digits).

Looking at the errors you listed, ignoring those that occured in at most 
1% of files (i.e. fewer than 650 occurrences), we get:

&gt;<i> 00834: hours too many '(^|\s|&gt;)\d{3,}[:\.,]\d+[:\.,]\d+'
</I>
...but in another e-mail you said that 671 of these came from one file 
whose hours were all &quot;255&quot;, so I'll ignore this one.


&gt;<i> 00889: seconds too few '(^|\s|&gt;)\d+[:\.,]\d+[:\.,]\d([:.,-]|\s|$)'
</I>
We could zero pad by default, but that seems a bit dodgy -- what if the 
missing digit is not zero? Given how rare this is, I wonder what causes 
it. Is it hand-authoring mistake? Were the seconds always &quot;0&quot; in these 
cases, or were they non-zero seconds?

How many files did this affect?


&gt;<i> 00922: spaces in timestamp '(\d[\d\s]*[:\.,]\s*){2,3}\d[\d\s]*' and not '(\d+[:\.,]){2,3}\d+'
</I>
Odd. Anecdotally, any idea what was going on with these?

How many files did this affect?


&gt;<i> 02085: decimals too few '(^|\s|&gt;)\d+[:\.,]\d+[:\.,]\d+[:\.,]\d{1,2}(\s|$|-)'
</I>
I wonder if people saying 0.1s mean 0.001s or 0.100s. If the latter, we 
can probably support this without too much trouble. Do you have any 
insight into this? e.g. what were the other times around such shortened 
times? Were they also short? e.g. did it ever go ...:0.9 --&gt; ...:0.800 
(meaning the time was intended to be milliseconds), or was 0.9 always 
followed by a time greater than a second later (meaning the time was 
intended to be a fraction)?

How many files did this affect?


&gt;<i> 25372: dot instead of comma '\d+[:\.,]\d+[:\.,]\d+\.\d+'
</I>
The spec actually only allows a dot, so really that's 51,974,628 lines 
that used a comma instead of a dot... This was an intentional choice; part 
of converting an SRT file to VTT is to mechanically change this. (It seems 
more likely that people would use a period mistakenly instead of a comma 
than vice versa, so hopefully this isn't an authoring problem for us.)



On Wed, 5 Oct 2011, David Singer wrote:
&gt;<i> 
</I>&gt;<i> I rather expect that there may be people tempted to write an 
</I>&gt;<i> implementation that will ingest SRT and VTT, and unify their parsing to 
</I>&gt;<i> cope with either. &quot;Be strict with what you produce, and liberal with 
</I>&gt;<i> what you accept&quot; is a maxim for at least some people, also.  And being 
</I>&gt;<i> strict with HTML (I seem to recall that one of the features of XHTML was 
</I>&gt;<i> that nothing was supposed to show when documents had errors) didn't get 
</I>&gt;<i> a lot of traction, either.
</I>
Yeah, but HTML didn't have a defined parser. VTT does. (HTML does too now, 
and browsers are converging on it.)


On Wed, 5 Oct 2011, Ralph Giles wrote:
&gt;<i> 
</I>&gt;<i> A point Philip J&#195;&#164;genstedt has made is that it's sufficiently tedious to 
</I>&gt;<i> verify correct subtitle playback that authors are unlikely to do so with 
</I>&gt;<i> any vigilance. Therefore the better trade-off is to make the parser 
</I>&gt;<i> forgiving, rather than inflict the occasional missing cue on viewers.
</I>
Being forgiving but misinterpreting the times will still inflict missing 
cues, it'll just additionally inflict broken cues elsewhere.


On Thu, 6 Oct 2011, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> To clarify, I have certainly never suggested that implementation do 
</I>&gt;<i> anything other than follow the spec to the letter. I *have* suggested 
</I>&gt;<i> that the parsing spec be more tolerant of certain errors, but looking at 
</I>&gt;<i> the extremely low error rates in our sample I have to conclude that 
</I>&gt;<i> either (1) the data is biased or (2) most of these errors are not common 
</I>&gt;<i> enough that they need to be handled.
</I>
Agreed (on both counts).


On Mon, 24 Oct 2011, Simon Pieters wrote:
&gt;<i>
</I>&gt;<i> I wanted to research how common it is to fail to separate cues in SRT, 
</I>&gt;<i> and for what reason.
</I>&gt;<i> 
</I>&gt;<i> SRT parsers usually interpret a timings line as a new cue, while WebVTT 
</I>&gt;<i> wants two blank lines for a new cue.
</I>&gt;<i>
</I>&gt;<i> I took the 65k SRT files we've got, replaced comma with dot and 
</I>&gt;<i> prepended &quot;WEBVTT\n\n&quot;, then ran them in Opera's &lt;track&gt; impl, looking 
</I>&gt;<i> for '--&gt;' in cue data.
</I>&gt;<i> 
</I>&gt;<i> There were 840 files with --&gt; in cue data. This is 1.3% of the files.
</I>&gt;<i> 
</I>&gt;<i> Looking at the cue data, there were 11,118 lines that contained --&gt;. 
</I>&gt;<i> There were 8830 lines of only whitespace.
</I>&gt;<i>
</I>&gt;<i> In the cue data, if I look at valid-looking timing lines 
</I>&gt;<i> (/^\d\d:\d\d:\d\d\.\d\d\d\s*--&gt;\s*\d\d:\d\d:\d\d\.\d\d\d(\s|$)/) and 
</I>&gt;<i> check the line before that, or the line before *that* if it looks like 
</I>&gt;<i> an SRT id (/^\d+\s*$/), then I see 7030 lines of only whitespace and 
</I>&gt;<i> 3761 lines of something else.
</I>&gt;<i> 
</I>&gt;<i> Failing to separate cues results in an unpleasant experience for the 
</I>&gt;<i> user, since basically the screen is filled with several &quot;cues&quot; including 
</I>&gt;<i> their IDs and timing lines.
</I>&gt;<i> 
</I>&gt;<i> Some files had most or all of their cues parsed as a single cue with the 
</I>&gt;<i> WebVTT parser, e.g. because all lines ended with one or more spaces. 
</I>&gt;<i> Looking at such a file in a text editor, it's not immediately obvious 
</I>&gt;<i> that there's an error, because the spaces are not visible. Moreover, the 
</I>&gt;<i> file is not non-conforming, so a validator wouldn't help either.
</I>&gt;<i> 
</I>&gt;<i> So what about the cases that aren't whitespace? It seems to be mostly 
</I>&gt;<i> just missing the newline completely. Some omitted the ID also. One file 
</I>&gt;<i> had a &quot;|&quot; between all cues.
</I>&gt;<i> 
</I>&gt;<i> My recommendation is <A HREF="http://www.w3.org/Bugs/Public/show_bug.cgi?id=14550">http://www.w3.org/Bugs/Public/show_bug.cgi?id=14550</A>
</I>
Thanks for this data. The spec has since been updated to scan for the 
timing line rather than just a blank line. A blank line still ends a cue, 
though. Is that a problem?

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>












































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="076285.html">[whatwg] API design restrictions due to barewords in onxxx=&quot;&quot; attributes
</A></li>
	<LI>Next message: <A HREF="076286.html">[whatwg] WebVTT feedback (and some other &lt;video&gt; feedback that	snuck in)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34026">[ date ]</a>
              <a href="thread.html#34026">[ thread ]</a>
              <a href="subject.html#34026">[ subject ]</a>
              <a href="author.html#34026">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
