<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] &lt;video&gt; element feedback
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%3Cvideo%3E%20element%20feedback&In-Reply-To=%3CPine.LNX.4.62.0710082259110.2018%40hixie.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012652.html">
   <LINK REL="Next"  HREF="012687.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] &lt;video&gt; element feedback</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%3Cvideo%3E%20element%20feedback&In-Reply-To=%3CPine.LNX.4.62.0710082259110.2018%40hixie.dreamhostps.com%3E"
       TITLE="[whatwg] &lt;video&gt; element feedback">ian at hixie.ch
       </A><BR>
    <I>Mon Oct  8 21:04:23 PDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="012652.html">[whatwg] &lt;video&gt; element feedback
</A></li>
        <LI>Next message: <A HREF="012687.html">[whatwg] &lt;video&gt; element feedback - integration, fragments,	and queries
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12653">[ date ]</a>
              <a href="thread.html#12653">[ thread ]</a>
              <a href="subject.html#12653">[ subject ]</a>
              <a href="author.html#12653">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
This e-mail replies to e-mails sent to both <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">whatwg at whatwg.org</A> and 
<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">public-html at w3.org</A>, as the thread in question ended up spilling over both 
mailing lists.

WHEN REPLYING TO THIS E-MAIL PLEASE PICK ONE MAILING LIST AND REPLY TO 
JUST THAT ONE. PLEASE DO NOT CROSS-POST THIS THREAD TO BOTH LISTS.

Also, please adjust the subject line appropriately to talk about just the 
issue you are responding to.

Thanks!

On Tue, 20 Mar 2007, Benjamin Hawkes-Lewis wrote:
&gt;<i> 
</I>&gt;<i> Obviously a preferable solution would be for everyone to create 
</I>&gt;<i> accessible content using open technologies in the first place, and we 
</I>&gt;<i> must do everything we can to encourage and enable that. But falling 
</I>&gt;<i> short of such revolutions, can anyone suggest an alternative way of 
</I>&gt;<i> limiting the disillusion caused by inaccessible downloads?
</I>
In the case of multimedia content, the best place for content whose 
purpose is ensuring universal use is within the multimedia content itself, 
so that when the data is moved (e.g. when the user saves a video file to 
disk) the content remains universally useful (&quot;accessible&quot;).

This also allows us to leverage industry expertise without reinventing 
any wheels ourselves.


&gt;<i> What would happen if the &lt;video&gt; element actually contained &lt;audio&gt; 
</I>&gt;<i> elements for the audio, &lt;audiodescription&gt; elements for the audio 
</I>&gt;<i> descriptions, &lt;caption&gt; elements for the captions, and &lt;subtitle&gt; 
</I>&gt;<i> elements for the subtitles? Would it be technologically possible for 
</I>&gt;<i> HTML elements to act as containers in that way?
</I>
The result would be that using video in an HTML context required far more 
work for accessibility purposes than using the same video in non-HTML 
contexts (e.g. on an iPod). This would be bad for the end-user.


&gt;<i> Alternatively (thinking of XSPF playlists), what if &lt;video&gt;'s src 
</I>&gt;<i> attribute pointed to an XML (or text/html-esque) file which contained 
</I>&gt;<i> these separate elements? It would be a powerful way of building a level 
</I>&gt;<i> of transparent accessibility into the system, without requiring users to 
</I>&gt;<i> download and play high-bandwidth content to find out if it has the 
</I>&gt;<i> features they need.
</I>
Most video formats already have support for timed text and other features 
for accessible content. So effectively what the spec says today is pretty 
much what you describe here, except that we side-step the problem of 
having to invent a new format.


On Tue, 20 Mar 2007, Benjamin Hawkes-Lewis wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; I have seriously considered doing this. Unfortunately I don't think we 
</I>&gt;<i> &gt; can actually do it given the large amount of legacy content, e.g. 
</I>&gt;<i> &gt; tutorials for how to embed flash which encourage use of &lt;object&gt;.
</I>&gt;<i> 
</I>&gt;<i> In the unlikely event that &lt;object&gt; be in any way discouraged, can we 
</I>&gt;<i> ensure we allow element level fallback content for &lt;img&gt; (or some 
</I>&gt;<i> replacement element) as opposed to the alt attributes we're currently 
</I>&gt;<i> lumbered with and the longdesc attribute that WHATWG has done away with?
</I>
I'll discuss &lt;img&gt; fallback as part of &lt;img&gt; feedback.


On Wed, 21 Mar 2007, Gareth Hay wrote:
&gt;<i>
</I>&gt;<i> This is a bit of a sideways step here, but why not make tags reflect 
</I>&gt;<i> MIME type,
</I>&gt;<i> 
</I>&gt;<i> e.g.
</I>&gt;<i> &lt;image&gt;		image/*
</I>&gt;<i> &lt;video&gt;		video/*
</I>&gt;<i> &lt;application&gt; 	application/*
</I>&gt;<i> &lt;audio&gt;		audio/*
</I>&gt;<i> 
</I>&gt;<i> That way we have a clear identification of what is going to be in the 
</I>&gt;<i> tag, API's can be tailored sufficiently for each one. Each tag can have 
</I>&gt;<i> appropriate fallback also. Just a thought, and it gets us out of the 
</I>&gt;<i> &lt;object&gt; hole.
</I>
That's pretty much where we are today with HTML5, except for the vague 
category &quot;application/*&quot;.


On Wed, 21 Mar 2007, Martin Atkins wrote:
&gt;<i> 
</I>&gt;<i> What do you imagine &quot;application&quot; being used for?
</I>&gt;<i> 
</I>&gt;<i> The &quot;application&quot; type category is pretty-much just &quot;miscellaneous&quot;.
</I>
Indeed.


On Tue, 20 Mar 2007, Robert Brodrecht wrote:
&gt;<i> Simon Pieters said:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Oh. I thought &lt;video&gt; fallback would work pretty much like &lt;object&gt; 
</I>&gt;<i> &gt; fallback, but I see that's not the case. When I think about it it 
</I>&gt;<i> &gt; makes sense; &lt;video&gt; is pretty much like &lt;iframe&gt;, it never falls back 
</I>&gt;<i> &gt; in UAs that support it.
</I>&gt;<i> 
</I>&gt;<i> Oh, damn it.  I thought it'd work like &lt;object&gt;, too.  I'm not sure I 
</I>&gt;<i> like the only-fallback-if-no-support idea.  I'm getting the feeling that 
</I>&gt;<i> there won't be one common video format among the browsers.  I think not 
</I>&gt;<i> having fallback to nested video elements to get at other formats would 
</I>&gt;<i> ultimately be a bad thing.
</I>
We already have fallback for multiple formats through the use of multiple 
&lt;source&gt; elements.


&gt;<i> When PNG support sucked in IE6, I just didn't use alpha PNGs and opted 
</I>&gt;<i> for some other format.  If there is no shared format, the only ways to 
</I>&gt;<i> support multiple video formats for multiple browsers would be:
</I>&gt;<i> 
</I>&gt;<i> 1. Just have two video elements on screen (bad).
</I>&gt;<i> 2. Swap the src with JavaScript (won't work if JS is off).
</I>&gt;<i> 3. Delegate content on the server based on http-accept [?] (best of the 
</I>&gt;<i> three, but not very fun).
</I>&gt;<i> 4. Maybe conditional comments if IE is the oddball (we'll see, but I 
</I>&gt;<i> don't like this option much either).
</I>
5. The &lt;source&gt; element. :-)


&gt;<i> Any thoughts on this or did I miss something?
</I>
Yup, the &lt;source&gt; element. :-)


On Wed, 21 Mar 2007, Laurens Holst wrote:
&gt;<i> &gt; 
</I>&gt;<i> &gt; &lt;object&gt; right now is overloaded to do at least four things:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;    * inline images
</I>&gt;<i> &gt;    * plugins
</I>&gt;<i> &gt;    * nested browsing contexts (iframes)
</I>&gt;<i> &gt;    * fallback container
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ...each of which has very distinct behaviour
</I>&gt;<i> 
</I>&gt;<i> I really don&#8217;t see how those are different, except for fallback 
</I>&gt;<i> content.
</I>
They are very different from an implementation perspective.


&gt;<i> &gt; (e.g. whether it has a scripting context, whether it shrinkwraps, 
</I>&gt;<i> &gt; whether it is replaced or not;
</I>&gt;<i> 
</I>&gt;<i> That is implemented today, so it is possible. Also, I think these 
</I>&gt;<i> differences only apply to fallback content vs. other content&#8230;? The 
</I>&gt;<i> problem here is: I don&#8217;t know. Nobody seems to know, except for you. 
</I>
I'm far from the only experienced person here, I assure you! However, this 
lack of clarity is one of the reasons we started the HTML5 project in the 
first place. Hopefully many of the differences are now documented in the 
spec, which should make this easier to approach.


&gt;<i> &gt; Adding a fifth (inline video with an API) would increase the 
</I>&gt;<i> &gt; complexity yet again.
</I>&gt;<i> 
</I>&gt;<i> There is no &#8216;adding&#8217;. Video is already embedded via &lt;object&gt;, today. 
</I>&gt;<i> Also, having video via &lt;object&gt; is no different from having images, so I 
</I>&gt;<i> don&#8217;t see why you consider it a separate thing.
</I>
I understand that you do not consider &lt;object&gt; implementation complexity 
to be high; however, browser vendors have uniformally expressed their 
despair at the difficulty of implementing &lt;object&gt; fully and correctly, 
which is a clear sign, to me at least, that adding further features to 
&lt;object&gt; is poor language design.


&gt;<i> &gt; &lt;object&gt; is *very badly* implemented. It has been a decade since 
</I>&gt;<i> &gt; &lt;object&gt; was first created and browsers STILL don't do it right in all 
</I>&gt;<i> &gt; cases (or even in most cases, frankly). Adding more complexity to such 
</I>&gt;<i> &gt; a disaster zone is bad design.
</I>&gt;<i> 
</I>&gt;<i> If the existing problems with &lt;object&gt; are so severe that it can&#8217;t be 
</I>&gt;<i> reused (which I somehow doubt), create a new element where you do it 
</I>&gt;<i> right. However, don&#8217;t start separating it out into separate tags.
</I>
The problem, as far as I can tell, is that it is just one element. &quot;Doing 
it right&quot; means splitting the problem into different elements.


&gt;<i> You are using one argument, current implementation of object is broken 
</I>&gt;<i> in several ways, to promote another idea, splitting up what is perceived 
</I>&gt;<i> as different types of media into separate tags.
</I>
The argument I'm using is that the element's current overloaded design led 
to uniformally poor implementations. I am basing this on what browser 
vendors have told me. If the problem is that the element is overloaded, 
splitting it seems like the best way forward.


&gt;<i> &gt; It wouldn't be &quot;simply&quot;, though. You'd need to define how to determine 
</I>&gt;<i> &gt; what the media group is, you'd need to define how to change from one 
</I>&gt;<i> &gt; type to another, you'd need to have browsers implement all this on top 
</I>&gt;<i> &gt; of all their existing bugs -- sometimes, it's just better to keep 
</I>&gt;<i> &gt; things separate, even if they seem like they could be abstracted out 
</I>&gt;<i> &gt; into one concept. We can't ignore our past experiences in designing 
</I>&gt;<i> &gt; HTML5.
</I>&gt;<i> 
</I>&gt;<i> That&#8217;s just nonsense. It is generic. Create drawing object, retrieve 
</I>&gt;<i> source, check MIME type, invoke renderer depending on MIME type with 
</I>&gt;<i> drawing object as parameter. Really, what is so difficult here.
</I>
I encourage you to try to implement &lt;object&gt; in a Web browser in a fully 
interoperable way; that will likely answer your question. :-)


&gt;<i> I find this argument really awkward. Especially since you&#8217;re saying 
</I>&gt;<i> that anything that doesn&#8217;t fall in the &lt;video&gt; category *or* is 
</I>&gt;<i> not-natively implemented could still use &lt;object&gt;. So apparantly it does 
</I>&gt;<i> work &#8216;good enough&#8217; after all.
</I>
We have &lt;embed&gt; for this case.


&gt;<i> You keep saying that &lt;object&gt; is a huge bag of problems. It would help 
</I>&gt;<i> if someone who knows exactly what aspects of &lt;object&gt; are implemented 
</I>&gt;<i> badly (you) would instead of proactively making changes to a 
</I>&gt;<i> specification on his own judgement with input from others, create a 
</I>&gt;<i> document that clearly describes the issues with &lt;object&gt; and what is 
</I>&gt;<i> implemented consistently and where browser implementations differ. That 
</I>&gt;<i> way everyone can consider what is wrong exactly, and how it can be 
</I>&gt;<i> fixed.
</I>
We've somewhat tried that with &lt;object&gt; in HTML5. However, I have 
received strong feedback from implementors that they do not wish to add 
further features to &lt;object&gt;.


&gt;<i> Because without that, it is really just a guessing game. For a change 
</I>&gt;<i> like this, there needs to be a clear overview of what is wrong first. 
</I>&gt;<i> Otherwise, it is just people saying you should do this or that, and you 
</I>&gt;<i> responding overloaded this browser authors that, and there is no real 
</I>&gt;<i> way to verify that what you say is correct, to make a general estimate 
</I>&gt;<i> of how big the problem is that is tried to be fixed, to provide 
</I>&gt;<i> alternative suggestions, and to judge whether what you say is wrong 
</I>&gt;<i> really warrants these changes (personally, I think not). I would like to 
</I>&gt;<i> see a more structured approach, and frankly, a more open approach.
</I>
It's not clear to me how I could really be more open.

One way to verify what I've been saying is this: if implementing &lt;video&gt; 
in &lt;object&gt; was so easy, why wouldn't browser vendors have done it by now? 
Meanwhile, at least three browser vendors have indicated strong interest 
in implementing &lt;video&gt;.


On Wed, 21 Mar 2007, Sander Tekelenburg wrote:
&gt;<i> 
</I>&gt;<i> I thought the idea of the Web was that the user is always in control 
</I>&gt;<i> (because the author cannot know the user's browsing environment). Why 
</I>&gt;<i> would authors ever have to be in control?
</I>
We've added controls=&quot;&quot; now, and the spec suggests that some controls 
always be available. So this should be a non-issue now.


&gt;<i> If &lt;video&gt; is to be a first-class Netizen, it'd better not be
</I>&gt;<i> javascript-dependant.
</I>
The spec now requires controls to be visible when scripting is disabled.


&gt;<i> Something else concerning first-class Netizenry: I'd like to see the 
</I>&gt;<i> spec to require UAs support implicit anchors, so that one can link to a 
</I>&gt;<i> specific startpoint: &lt;URL:<A HREF="http://domain.example/movie.ogg#21:08">http://domain.example/movie.ogg#21:08</A>&gt;, to 
</I>&gt;<i> mean &quot;fetch the movie and start playing it at 21 minutes 8 seconds into 
</I>&gt;<i> the movie&quot;. (Or better yet, if this can be achieved reliably, don't 
</I>&gt;<i> fetch the entire movie, but only from 21:08 on.)
</I>
We have a start=&quot;&quot; attribute for this now for inline videos. It does, 
however, prevent the user from seeking to before that point. The only 
current way to start somewhere other than the start of the video clip and 
be able to seek back is to use the API.

When you link straight to a video (with no &lt;video&gt; element in use) the 
fragment identifer syntax is left up to the MIME type RFC for that video, 
and is out of scope of HTML5.


&gt;<i> &gt; I agree that &lt;video&gt; needs a standard UI (in v2, at least).
</I>&gt;<i> 
</I>&gt;<i> It needs it right from the start, in v1.0. Without it, it would be like 
</I>&gt;<i> a browser without its own back button, relying on authors to provide 
</I>&gt;<i> such functionality.
</I>
The spec now has this.


On Wed, 21 Mar 2007, Spartanicus wrote:
&gt;<i> 
</I>&gt;<i> Recently I have begun to fear that the principle of not relying on CSS 
</I>&gt;<i> [1] and/or Javascript for anything essential has also been abandoned by 
</I>&gt;<i> various specifications.
</I>
I assure you that this is still a concern for me, at least; HTML5 for 
instance introduces irrelevant=&quot;&quot; to help with this.


On Wed, 21 Mar 2007, MegaZone wrote:
&gt;<i> 
</I>&gt;<i> Strongly agreed.  I know more than a few people who are (still) rabidly 
</I>&gt;<i> anti-JavaScript as end-users, because of the repeated security issues in 
</I>&gt;<i> various implementations - and how it keeps popping up in things like 
</I>&gt;<i> Quicktime where you wouldn't necessarily expect it.
</I>
(There are security issues when you have scripting disabled just like when 
you have it enabled; I think disabling scripting is more of a good luck 
charm than a real security measure. But anyway.)

With JS disabled, &lt;video&gt; will now have controls, per spec.


On Fri, 23 Mar 2007, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> About 8 years ago, we had the idea of using fragment offsets to start 
</I>&gt;<i> playing from offsets of media files. However, in discussions with the 
</I>&gt;<i> URI standardisation team at W3C it turned out that fragment offsets are 
</I>&gt;<i> only being seen by the UA that sends them, so they will never reach the 
</I>&gt;<i> web server. This makes it impossible to use them for &quot;play from this 
</I>&gt;<i> offset&quot; since obviously the offsetting should be done by the server and 
</I>&gt;<i> avoid downloading the bunch of data that comes before the offset point.
</I>&gt;<i> 
</I>&gt;<i> The only solution was to use the query &quot;?&quot; identifier for defining 
</I>&gt;<i> offsets.
</I>&gt;<i> 
</I>&gt;<i> This has been done and specified in 
</I>&gt;<i> <A HREF="http://annodex.net/TR/draft-pfeiffer-temporal-fragments-03.txt,">http://annodex.net/TR/draft-pfeiffer-temporal-fragments-03.txt,</A> though 
</I>&gt;<i> we never took it through full standardisation.
</I>&gt;<i> 
</I>&gt;<i> An implementation of that feature can be seen at 
</I>&gt;<i> <A HREF="http://media.annodex.net/cmmlwiki/">http://media.annodex.net/cmmlwiki/</A> where the videos are marked-up with 
</I>&gt;<i> sections and the sections are referred to through URIs such as 
</I>&gt;<i> <A HREF="http://media.annodex.net/cmmlwiki/SFD2005-Trailer?t=0:00:01.962.">http://media.annodex.net/cmmlwiki/SFD2005-Trailer?t=0:00:01.962.</A>
</I>&gt;<i> 
</I>&gt;<i> Another example is used by the metavid guys: e.g. 
</I>&gt;<i> <A HREF="http://metavid.ucsc.edu/overlay/video_player/webview?stream_name=house_proceeding_12-07-06&amp;t=0:14:02/0:14:37">http://metavid.ucsc.edu/overlay/video_player/webview?stream_name=house_proceeding_12-07-06&amp;t=0:14:02/0:14:37</A> 
</I>&gt;<i> which provides a section out of the video.
</I>&gt;<i> 
</I>&gt;<i> Both of the above given examples use Ogg Theora as the video, though the 
</I>&gt;<i> files are being served through a server plugin (in both cases it is 
</I>&gt;<i> mod_annodex) that provides for the offset functionality without breaking 
</I>&gt;<i> the file format.
</I>
The problem with such an approach is that while it lets the user start 
from that point, it doesn't let the user seek to before that point if he 
downloads the whole video and uses it offline.


On Thu, 22 Mar 2007, Nicholas Shanks wrote:
&gt;<i> &gt;
</I>&gt;<i> &gt; This makes it impossible to use them for &quot;play from this offset&quot; since 
</I>&gt;<i> &gt; obviously the offsetting should be done by the server and avoid 
</I>&gt;<i> &gt; downloading the bunch of data that comes before the offset point.
</I>&gt;<i> 
</I>&gt;<i> But it doesn't stop the UA from taking cues from the markup (such as my 
</I>&gt;<i> gegenschein example from yesterday) and generating a query such as 
</I>&gt;<i> ?start=17:33. They don't have to request the exact value of the src 
</I>&gt;<i> attribute.
</I>
Don't they? Why not?


On Thu, 22 Mar 2007, Kornel Lesinski wrote:
&gt;<i> 
</I>&gt;<i> I think we had in mind (at least I did) URL of the page that contains 
</I>&gt;<i> the video, not the URL of the video file itself. Because of this 
</I>&gt;<i> indirection it's completly up to UA to read fragment identifier and 
</I>&gt;<i> translate it into appropriate HTTP request for the video file (which 
</I>&gt;<i> could use Range header that's more proxy-friendly than query string).
</I>
That wouldn't work very well on pages with multiple videos (which is 
common already today).


&gt;<i> Let's say there's <A HREF="http://example.com/example.html">http://example.com/example.html</A> page which contains 
</I>&gt;<i> embedded video: ...&lt;video src=&quot;video.ogg&quot;&gt;...
</I>&gt;<i> 
</I>&gt;<i> I'd like to be able to construct URL like: 
</I>&gt;<i> <A HREF="http://example.com/example.html#@12:35">http://example.com/example.html#@12:35</A> that would cause UA to start 
</I>&gt;<i> playing the embedded video.ogg from 12:35.
</I>
One could certainly see script in the page supporting this.


On Fri, 23 Mar 2007, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> The Range header is providing for byteranges to be downloaded. There is 
</I>&gt;<i> however no simple way to map a timerange to a byterange without finding 
</I>&gt;<i> out about the filetype. So, in effect, if you are trying to get a 
</I>&gt;<i> byterange, you will have to request the server to inspect the file and 
</I>&gt;<i> to return to you a mapping of a timerange to a byterange before you can 
</I>&gt;<i> undertake a byterange query, which can then be proxied.
</I>&gt;<i> 
</I>&gt;<i> This process is exactly what we suggested in 
</I>&gt;<i> <A HREF="http://annodex.net/TR/draft-pfeiffer-temporal-fragments-03.txt.">http://annodex.net/TR/draft-pfeiffer-temporal-fragments-03.txt.</A>
</I>
Interesting stuff. Unfortunately this URI doesn't seem to work any more.


On Fri, 23 Mar 2007, Kornel Lesinski wrote:
&gt;<i> 
</I>&gt;<i> If such altered behavior of play() is not unacceptable, then that might 
</I>&gt;<i> work:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://example.com/example.html#myvideo@12:35">http://example.com/example.html#myvideo@12:35</A>
</I>&gt;<i> 
</I>&gt;<i> Where &quot;myvideo&quot; part is interpreted as ID of element in the document 
</I>&gt;<i> (and if there's no such element - assume document.body). If the element 
</I>&gt;<i> is a &lt;video&gt;, then seek() that video. If it isn't, then seek first 
</I>&gt;<i> &lt;video&gt; descendant of that element (something like: 
</I>&gt;<i> (document.getElementById(&quot;myvideo&quot;) || 
</I>&gt;<i> document.body).getElementsByTagName('video')[0].seek(12*60000+35000))).
</I>
This certainly can be implemented by script on the page.


&gt;<i> My rationale:
</I>&gt;<i>
</I>&gt;<i> * it doesn't require any changes to the document, so user can control 
</I>&gt;<i> starting position in any document, even if author didn't think of such 
</I>&gt;<i> possibility
</I>
Well, you can do that just by creating a new page with a &lt;video&gt; element 
pointing to the part you want. Embedding videos is quite common, there's 
no reason it couldn't also be common to embed with a start=&quot;&quot; point.


&gt;<i> * It's part of document's URL, not URL of the video file, so user 
</I>&gt;<i> doesn't have to extract video file URL from the document and can still 
</I>&gt;<i> use the page (which provides controls for the video).
</I>
True.


&gt;<i> * it can be implemented in JavaScript with current &lt;video&gt; API (also in 
</I>&gt;<i> User JavaScript, but I think for interoperability it's important to be 
</I>&gt;<i> part of the spec).
</I>
I think this is something we can safely wait until v2 to add, though.


&gt;<i> * it's orthogonal to server-side support for seeking
</I>
Indeed.


&gt;<i> &gt; Also, it could be interpreted by the UA only, since everything after 
</I>&gt;<i> &gt; &quot;#&quot; will not be transferred to the server.
</I>&gt;<i> 
</I>&gt;<i> Yes, that's intentional. It allows user to modify *any* URL without risk 
</I>&gt;<i> of breaking it (some servers/applications may not like extra query 
</I>&gt;<i> string). I think use of hash for this is appropriate - just like UA 
</I>&gt;<i> scrolls HTML to given element, UA would &quot;scroll&quot; the video - it's just a 
</I>&gt;<i> change of axis from Y to time :)
</I>
You can't do this today with, e.g., iframes, or images, though. Why are 
videos special?


On Sat, 24 Mar 2007, Silvia Pfeiffer wrote:
&gt;<i>
</I>&gt;<i> How about the following idea:
</I>&gt;<i> 
</I>&gt;<i> Example.html contains:
</I>&gt;<i> 
</I>&gt;<i> &lt;video id=&quot;myvideo_1&quot; src=&quot;video.ogg&quot;&gt;
</I>&gt;<i>   to provide the full video
</I>&gt;<i> 
</I>&gt;<i> &lt;video id=&quot;myvideo_2&quot; src=&quot;video.ogg?t=0:12:35&quot;&gt;
</I>&gt;<i>   to provide the video from offset 12:35
</I>&gt;<i> 
</I>&gt;<i> &lt;video id=&quot;myvideo_3&quot; src=&quot;video.ogg?t=0:12:35/0:20:40&quot;&gt;
</I>&gt;<i>   to provide the video segment between offset 12:35 and 20:40
</I>&gt;<i> 
</I>&gt;<i> &lt;video id=&quot;myvideo_4&quot; src=&quot;video.ogg?id=section4&quot;&gt;
</I>&gt;<i>   to provide the video from named offset &quot;section4&quot;
</I>&gt;<i> 
</I>&gt;<i> These provide the Web page author with the power to do offsets.
</I>
The spec does this today with attributes. We don't want to require the URI 
to use a specific syntax, since that would severely limit the options on 
the server side (and would somewhat step outside the bounds on what 
HTML5's scope should be -- we're supposed to be URI agnostic).


&gt;<i> And example URLs relating to the webpage:
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://example.com/example.html#myvideo_1&amp;t=0:12:35">http://example.com/example.html#myvideo_1&amp;t=0:12:35</A>
</I>&gt;<i>   to provide the Web page with the first video playing from offset 12:35,
</I>&gt;<i>   offset action provided by  the UA (i.e. video gets fully downloaded)
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://example.com/example.html#myvideo_1?t=0:12:35/0:20:40">http://example.com/example.html#myvideo_1?t=0:12:35/0:20:40</A>
</I>&gt;<i>   to provide the Web page with the first video playing section 12:35-20:40,
</I>&gt;<i>   UA resolves this to create a query for video.ogg?t=0:12:35/0:20:40,
</I>&gt;<i>   offset action provided by the server
</I>&gt;<i>
</I>&gt;<i> These provide the user with control over the start points of the videos 
</I>&gt;<i> on the Webpage.
</I>
I'm not sure they really do so in a particularly user-friendly way, 
though. (It also isn't immediately clear to me that there is a big demand 
for this kind of feature, given what we see generally on the Web with 
video today.) In any case, it seems like a feature we can safely introduce 
later in version 2 -- the current API is already probably too heavy for us 
to get decent interoperability in version 1.


On Fri, 23 Mar 2007, Sander Tekelenburg wrote:
&gt;<i> 
</I>&gt;<i> While that might be useful, it's not at all obvious to me that it is a 
</I>&gt;<i> *requirement*. What is so wrong with fetching the entire file, and start 
</I>&gt;<i> playing it at the point referenced by the fragment identifier? That's 
</I>&gt;<i> how fragment identifiers work for textual resources (and they fetch the 
</I>&gt;<i> usual truckload of images along with the HTML file).
</I>
Well, video files are orders of magnitude bigger, as you point out.


On Fri, 23 Mar 2007, Gareth Hay wrote:
&gt;<i>
</I>&gt;<i> In this case, there is a big difference between streamed data, which can 
</I>&gt;<i> be played from various positions, and non-streamed data which requires a 
</I>&gt;<i> complete download, or at least the start of the file.
</I>&gt;<i> 
</I>&gt;<i> Perhaps there should be some reflection of this in the tag?
</I>
It's not clear to me what we should do.


On Sat, 24 Mar 2007, Silvia Pfeiffer wrote:
&gt;<i>
</I>&gt;<i> The difference between streaming and non-streaming is artificial and not 
</I>&gt;<i> technically necessary - except for life content, where you cannot jump 
</I>&gt;<i> &quot;into the future&quot;.
</I>
The spec currently doesn't distinguish these cases.


On Sat, 24 Mar 2007, Geoffrey Sneddon wrote:
&gt;<i> On 23 Mar 2007, at 03:15, liorean wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Well, it would be nice to not have to download an hour long lecture to 
</I>&gt;<i> &gt; see the 30 second interval of interest starting at at 47:26... 
</I>&gt;<i> &gt; However, as I understand the Ogg Theora format, it contains essential 
</I>&gt;<i> &gt; data for decoding in the start of the file, so unless the server has 
</I>&gt;<i> &gt; some format specific knowledge and handling the client must either 
</I>&gt;<i> &gt; have already gotten that information somehow, or must request the 
</I>&gt;<i> &gt; entire file. I have no idea whether the other codecs I've heard 
</I>&gt;<i> &gt; discussed (Dirac and H.264) have a similar issue or not.
</I>&gt;<i> 
</I>&gt;<i> That sort of info is held within the container, so everything within Ogg 
</I>&gt;<i> (so both Theora and Dirac) will suffer from it.
</I>
Or benefit from it -- you can fetch the start, then jump to where the data 
you want is, without geting the whole file.


On Sat, 24 Mar 2007, Maik Merten wrote:
&gt;<i> 
</I>&gt;<i> Well, with Ogg you can just fetch a bit of the start (seems that's 
</I>&gt;<i> needed for MPEG, too - I just killed a few bytes from the beginning of a 
</I>&gt;<i> .mp4 files and it won't play) and get an educated guess about bitrate 
</I>&gt;<i> etc. to directly jump to a position in the file (you there get a precise 
</I>&gt;<i> timestamp). If you ended up jumping too far away from the destination 
</I>&gt;<i> you can repeat once or twice and you're &quot;close&quot; enough.
</I>&gt;<i> 
</I>&gt;<i> That has been done before, works like a charm. 
</I>&gt;<i> <A HREF="http://stream.fluendo.com/demos.php?stream=ondemand">http://stream.fluendo.com/demos.php?stream=ondemand</A> (that's a Java Ogg 
</I>&gt;<i> Theora streaming applet)
</I>
Good to know. Hopefully implementations will use this.


On Sat, 24 Mar 2007, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> 1) The UA doesn't know what byterange a timecode or timerange maps to. 
</I>&gt;<i> So, it has to request this information from the server, who has access 
</I>&gt;<i> to the file. For QuickTime movies, the UA would need to request the 
</I>&gt;<i> offset table from the server and for AVI it would need to request the 
</I>&gt;<i> chunking information.
</I>&gt;<i> 
</I>&gt;<i> 2) Just streaming from an offset of a video file often breaks the file 
</I>&gt;<i> format. For nearly all video formats, there are headers at the beginning 
</I>&gt;<i> of a video file which determine how to decode the video file. Lacking 
</I>&gt;<i> this information, the video files cannot be decoded. Therefore, a simple 
</I>&gt;<i> byterange request of a subpart of the video only results in undecodable 
</I>&gt;<i> content. The server actually has to be more intelligent and provide a 
</I>&gt;<i> re-assembled correct video file if it is to stream from an offset.
</I>
Why can't the client just get the start of the file and the middle of the 
file and do the work of seeking itself?


On Sat, 24 Mar 2007, Michael Dale wrote:
&gt;<i>
</I>&gt;<i> There is no reason why both methods can't be supported. If people wanted 
</I>&gt;<i> to use annodex for seeking they could just write a js function that will 
</I>&gt;<i> remap the src of the video element on seek overriding the UA http offset 
</I>&gt;<i> seek method.
</I>
Indeed.


&gt;<i> The UA http offset method evoked by stream_id#time as the src would be 
</I>&gt;<i> more or less equivalent to the calling stream_id.seek(time); All that is 
</I>&gt;<i> required of video element is that it be open to annodex content and not 
</I>&gt;<i> freak out when the src element has a request string and the timestamps 
</I>&gt;<i> for the video stream don't start with zero.
</I>
The spec doesn't currently say that the times in the API are in any way 
related to the times in the media file, other than requiring one unit of 
media time to be treated as one unit of wall clock time.

Should it say somewhere that times in the media file must be examined and 
processed such that if the file starts at a non-zero media time, an offset 
must be applied equal to that media time to obtain API time?


On Fri, 23 Mar 2007, Sander Tekelenburg wrote:
&gt;<i> 
</I>&gt;<i> If the spec requires UAs to be able to return the movie's &quot;duration&quot; and 
</I>&gt;<i> &quot;current position&quot;, etc. (which I got the impression is the intention of 
</I>&gt;<i> both Opera and Apple's proposals), to for instance allow, through 
</I>&gt;<i> javascript, playing from a certain point, then I don't see why it would 
</I>&gt;<i> not be possible to trigger the same event through a fragment identifier. 
</I>&gt;<i> I don't see how this would require anything from the author.
</I>
It's not clear to me exactly how this could work, but I'm open to 
suggestions.

We could also make the seeking happen through the autostart=&quot;&quot; attribute, 
or through a new attribute, or punt it to v2 for now.


&gt;<i> (That aside, a lot of what is being defined on this list is javascript, 
</I>&gt;<i> not HTML. The popular term &quot;HTML5&quot; is misguiding. The offical name &quot;Web 
</I>&gt;<i> Apps 1.0&quot; is more descriptive.)
</I>
Indeed, the &quot;HTML5&quot; spec also covers DOM5 HTML, the API to the HTML5 
language.

Cheers,
-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012652.html">[whatwg] &lt;video&gt; element feedback
</A></li>
	<LI>Next message: <A HREF="012687.html">[whatwg] &lt;video&gt; element feedback - integration, fragments,	and queries
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12653">[ date ]</a>
              <a href="thread.html#12653">[ thread ]</a>
              <a href="subject.html#12653">[ subject ]</a>
              <a href="author.html#12653">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
