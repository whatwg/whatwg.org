<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] New URL Standard
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20New%20URL%20Standard&In-Reply-To=%3CCABirCh9AJ7NN--Qwy-SAHd9LV9SA7qVMXuAdOvAu6yMBR6c79w%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="079709.html">
   <LINK REL="Next"  HREF="079715.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] New URL Standard</H1>
<!--htdig_noindex-->
    <B>Glenn Maynard</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20New%20URL%20Standard&In-Reply-To=%3CCABirCh9AJ7NN--Qwy-SAHd9LV9SA7qVMXuAdOvAu6yMBR6c79w%40mail.gmail.com%3E"
       TITLE="[whatwg] New URL Standard">glenn at zewt.org
       </A><BR>
    <I>Tue Sep 25 15:53:29 PDT 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="079709.html">[whatwg] New URL Standard
</A></li>
        <LI>Next message: <A HREF="079715.html">[whatwg] New URL Standard
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#79710">[ date ]</a>
              <a href="thread.html#79710">[ thread ]</a>
              <a href="subject.html#79710">[ subject ]</a>
              <a href="author.html#79710">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Tue, Sep 25, 2012 at 5:14 PM, David Sheets &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">kosmo.zb at gmail.com</A>&gt; wrote:

&gt;<i> Looking up keys is easy in an association list. Filtering the list
</I>&gt;<i> retains ordering. Appending to the list is well-defined. Folding into
</I>&gt;<i> a dictionary is trivial and key merging can be defined according to
</I>&gt;<i> the author's URL convention.
</I>&gt;<i>
</I>
I'd suggest writing out what you mean in JavaScript or JS-like pseudocode,
demonstrating what it would actually look like to scripts and how it would
be used.  It's the quickest way to get API ideas across.

 &gt; The right approach is probably to expose the results in an object-like
&gt;<i> form,
</I>&gt;<i> &gt; as Tab suggests, but to store the state internally in a list-like format,
</I>&gt;<i> &gt; with modifications defined in terms of mutations to the list.
</I>&gt;<i>
</I>&gt;<i> This sounds more complicated to implement while maintaining
</I>&gt;<i> invariants. A dictionary with an associated total order is an
</I>&gt;<i> association list.
</I>&gt;<i>
</I>
I think it's pretty straightforward both to specify and to implement.  Of
course, implementations can use any internal data structure they like as
long as the end result is the same.

 Why hide the order?
&gt;<i>
</I>
Because the natural JS interface, object-like access, doesn't allow it.  If
you think there's an API with similar convenience to an object and natural
usage in the language, then feel free to suggest it as I described above.

(Of course, a separate method could exist to get access to the underlying
order, if and when real use cases turn up that actually need it, and it's
not unlikely that there are use cases--but so far they haven't been
raised.  There's nothing wrong with exposing multiple API &quot;views&quot; into the
same data set, when they have clearly distinct goals and attempts to meet
both sets of goals with the same API fail.)

 &gt;&gt; Like: query = new URL(&quot;?a=b&amp;c=d&quot;); query.query[&quot;a&quot;] = &quot;x&quot;;
&gt;<i> &gt;&gt; query.toString() == &quot;?a=x&amp;c=d&quot;;
</I>&gt;<i>
</I>&gt;<i> &gt; That won't work, since &quot;?a=b&amp;c=d&quot; isn't a valid URL.
</I>&gt;<i>
</I>&gt;<i> &quot;?a=b&amp;c=d&quot; is a valid URI reference. @href=&quot;?a=b&amp;c=d&quot; is valid.
</I>&gt;<i>
</I>
It's not a valid *absolute* URL, which is what you used above.  You can
sidestep this either by prefixing it to make it into a valid URL (as I
suggested) or by specifying a base URL; they're both pretty much equivalent
here.

 This is a use case for parsing without composed relative resolution.
&gt;<i>
</I>
Maybe, but that's a pretty complicated approach for this use case.

(To summarize the mechanism he's referring to, as I understand it: the
ability to use this API to parse, modify and output relative URLs without
resolving them to a base URL at all.)

-- 
Glenn Maynard

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="079709.html">[whatwg] New URL Standard
</A></li>
	<LI>Next message: <A HREF="079715.html">[whatwg] New URL Standard
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#79710">[ date ]</a>
              <a href="thread.html#79710">[ thread ]</a>
              <a href="subject.html#79710">[ subject ]</a>
              <a href="author.html#79710">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
