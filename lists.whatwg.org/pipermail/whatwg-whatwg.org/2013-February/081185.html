<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Enabling LCD Text and antialiasing in canvas
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Enabling%20LCD%20Text%20and%20antialiasing%20in%20canvas&In-Reply-To=%3CCAGN7qDBok6prgE3iKGU53%2BnXzm9C-Yg75uUtuG009793MS7pXA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="081178.html">
   <LINK REL="Next"  HREF="081186.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Enabling LCD Text and antialiasing in canvas</H1>
<!--htdig_noindex-->
    <B>Rik Cabanier</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Enabling%20LCD%20Text%20and%20antialiasing%20in%20canvas&In-Reply-To=%3CCAGN7qDBok6prgE3iKGU53%2BnXzm9C-Yg75uUtuG009793MS7pXA%40mail.gmail.com%3E"
       TITLE="[whatwg] Enabling LCD Text and antialiasing in canvas">cabanier at gmail.com
       </A><BR>
    <I>Wed Feb 13 09:22:29 PST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="081178.html">[whatwg] Enabling LCD Text and antialiasing in canvas
</A></li>
        <LI>Next message: <A HREF="081186.html">[whatwg] Enabling LCD Text and antialiasing in canvas
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#81185">[ date ]</a>
              <a href="thread.html#81185">[ thread ]</a>
              <a href="subject.html#81185">[ subject ]</a>
              <a href="author.html#81185">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>For blending optimizations, it might be better to introduce a function
instead of a boolean attribute like 'opaque'.
What you really want, is to matte [1] the canvas with a solid color so you
can optimize compositing.

How about this API:

void applyMatte(DOMString color); // color is a CSS rgb color value (alpha
is ignored)


When you call this function, the canvas is matted with that color. If it's
the first drawing call, you can just fill the canvas with that color (no
compositing needed)
After matting, you no longer have to read or update the alpha channel since
it's always 1 which should speed up drawing.

1: <A HREF="http://en.wikipedia.org/wiki/Matte_(filmmaking">http://en.wikipedia.org/wiki/Matte_(filmmaking</A>)

On Wed, Feb 13, 2013 at 7:45 AM, Stephen White &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">senorblanco at chromium.org</A>&gt;wrote:

&gt;<i> On Tue, Feb 12, 2013 at 6:14 PM, Rik Cabanier &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">cabanier at gmail.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Tue, Feb 12, 2013 at 2:56 PM, Stephen White &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">senorblanco at chromium.org</A>&gt;wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On Fri, Nov 23, 2012 at 6:04 PM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; On Thu, 29 Mar 2012, Jeremy Apthorp wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt; On Thu, Mar 29, 2012 at 10:25 AM, Jeremy Apthorp &lt;
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jeremya at chromium.org</A>
</I>&gt;&gt;&gt;<i> &gt; &gt;wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; On Thu, Mar 29, 2012 at 8:41 AM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt; On Fri, 13 Jan 2012, Jeremy Apthorp wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt; &gt; I'd like to draw non-antialiased lines in a &lt;canvas&gt;. Currently
</I>&gt;&gt;&gt;<i> it
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt; &gt; seems that the only way to do this is to directly access the
</I>&gt;&gt;&gt;<i> pixel
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt; &gt; data.
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt; &gt; Is there a reason there's no way to turn off antialiasing?
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;&gt; What's the use case?
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; Pixel-art style games.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Specifically: even with the new image smoothing stuff in place for
</I>&gt;&gt;&gt;<i> &gt; &gt; drawImage, a 1:2 diagonal line will still be anti-aliased (only the
</I>&gt;&gt;&gt;<i> &gt; &gt; antialiasing will look silly scaled up to 2x).
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Do you have an example of a game where lines are drawn using a line API
</I>&gt;&gt;&gt;<i> &gt; without antialiasing, then scaled up? Most &quot;pixel art&quot; games I've seen
</I>&gt;&gt;&gt;<i> &gt; tend to use bitmaps for that kind of thing.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; On Mon, 12 Nov 2012, Justin Novosad wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; For many types of apps, DOM-based rendering is uncompetitively slow
</I>&gt;&gt;&gt;<i> &gt; &gt; [so we should make text rendering in canvas more controllable]
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; This seems like something we should fix, not something we should work
</I>&gt;&gt;&gt;<i> &gt; around by having people use canvas instead. Using canvas has all kinds
</I>&gt;&gt;&gt;<i> of
</I>&gt;&gt;&gt;<i> &gt; terrible side-effects, like reducing the likely accessibility of the
</I>&gt;&gt;&gt;<i> page,
</I>&gt;&gt;&gt;<i> &gt; making searcheability much worse, etc.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Also, do you have any metrics showing the magnitude of this problem on
</I>&gt;&gt;&gt;<i> &gt; real-world sites that might consider using canvas instead?
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; If LCD text were enable-able, authors would have to be mindful of a
</I>&gt;&gt;&gt;<i> &gt; &gt; number of caveats in order to avoid rendering artifacts.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Do we have any reason to believe the majority of authors would make the
</I>&gt;&gt;&gt;<i> &gt; right decisions here?
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; (The main reason we haven't provided control over things like
</I>&gt;&gt;&gt;<i> antialiasing
</I>&gt;&gt;&gt;<i> &gt; is that many authors tend to make terribly bad decisions.) (Before
</I>&gt;&gt;&gt;<i> anyone
</I>&gt;&gt;&gt;<i> &gt; gets offended, by the way: that you are reading this almost guarantees
</I>&gt;&gt;&gt;<i> &gt; that you are above average in terms of authoring ability.)
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; On Tue, Nov 13, 2012 at 9:37 PM, Robert O'Callahan wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; We'd have to define what happens when you use subpixel antialiasing
</I>&gt;&gt;&gt;<i> &gt; &gt; &quot;incorrectly&quot;, because we can be pretty sure authors will use it
</I>&gt;&gt;&gt;<i> &gt; &gt; incorrectly and expect to get interoperable behavior.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; That's certainly true.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Mozilla supports a &quot;mozOpaque&quot; attribute which makes the canvas
</I>&gt;&gt;&gt;<i> buffer
</I>&gt;&gt;&gt;<i> &gt; &gt; RGBX (initialized to solid black) and enables subpixel antialiasing
</I>&gt;&gt;&gt;<i> for
</I>&gt;&gt;&gt;<i> &gt; &gt; most text drawing. That might be enough to address your use-cases.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; I haven't specified this; if other vendors intend to implement this
</I>&gt;&gt;&gt;<i> let me
</I>&gt;&gt;&gt;<i> &gt; know and I can spec it. I'm not sure it's worth it though.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> [blowing the dust off this thread]
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Folks on the Chrome team are looking into implementing this attribute,
</I>&gt;&gt;&gt;<i> and
</I>&gt;&gt;&gt;<i> would be interested in seeing it spec'ed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What are you implementing? Initializing the canvas to black or subpixel
</I>&gt;&gt;<i> antialiasing?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> We're interested in both aspects:  the opportunity for culling and
</I>&gt;<i> blending optimizations at composite time, as well as enabling subpixel AA.
</I>&gt;<i>
</I>&gt;<i> Stephen
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; On Wed, 14 Nov 2012, Robert O'Callahan wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt; On Wed, Nov 14, 2012 at 8:09 AM, Justin Novosad &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">junov at chromium.org</A>&gt;
</I>&gt;&gt;&gt;<i> &gt; wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; Are there precedents for exposing features with documented caveats?
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; (excluding caveats that were discovered after the fact)
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Yes, and many of them have been extremely problematic, because Web
</I>&gt;&gt;&gt;<i> &gt; &gt; authors will ignore the caveats.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Right. I'd really like to avoid adding more if we can help it.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; On Wed, 14 Nov 2012, Justin Novosad wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; There is a recent improvement in Chrome called &quot;deferred 2D canvas
</I>&gt;&gt;&gt;<i> &gt; &gt; rendering&quot; (enabled by default as of Chrome 23).  It is a mechanism
</I>&gt;&gt;&gt;<i> that
</I>&gt;&gt;&gt;<i> &gt; &gt; records 2d canvas commands during JS execution, and only executes
</I>&gt;&gt;&gt;<i> them
</I>&gt;&gt;&gt;<i> &gt; &gt; for real when the render buffer needs to be resolved (draw to screen,
</I>&gt;&gt;&gt;<i> &gt; &gt; getImageData, toDataURL, etc.).  If you want to check it out, the
</I>&gt;&gt;&gt;<i> guts
</I>&gt;&gt;&gt;<i> &gt; &gt; are in Skia: SkGPipe is a sort of FIFO for graphics commands,
</I>&gt;&gt;&gt;<i> &gt; &gt; SkDeferredCanvas is a wrapper that manages the GPipe and
</I>&gt;&gt;&gt;<i> automatically
</I>&gt;&gt;&gt;<i> &gt; &gt; flushes it and applies some command culling optimizations.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; So to come back to the problem of with and without subpixel AA
</I>&gt;&gt;&gt;<i> buffers:
</I>&gt;&gt;&gt;<i> &gt; &gt; if rendering is deferred, the non-AA buffer would never get
</I>&gt;&gt;&gt;<i> rasterized
</I>&gt;&gt;&gt;<i> &gt; &gt; (and possibly never even allocated), unless it needs to be.
</I>&gt;&gt;&gt;<i>  Obviously
</I>&gt;&gt;&gt;<i> &gt; &gt; there are practical limitations, for example we cannot store an
</I>&gt;&gt;&gt;<i> &gt; &gt; unlimited stream of recorded commands, so if the canvas draws
</I>&gt;&gt;&gt;<i> &gt; &gt; indefinitely without ever being cleared, at some point we have to
</I>&gt;&gt;&gt;<i> &gt; &gt; rasterize the non-AA buffer just so that we can safely discard the
</I>&gt;&gt;&gt;<i> &gt; &gt; recording data. Also, if at record time the necessary conditions for
</I>&gt;&gt;&gt;<i> &gt; &gt; subpixel AA are not met, perhaps we just forget about it.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; I admit this is a complex solution for implementors, but it makes the
</I>&gt;&gt;&gt;<i> &gt; &gt; management of subpixel-AA safety transparent to web authors.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; I think it'd be reasonable (for some definition of reasonable that
</I>&gt;&gt;&gt;<i> &gt; relates to whether it's compatible with the spec, anyway) for
</I>&gt;&gt;&gt;<i> implementors
</I>&gt;&gt;&gt;<i> &gt; to do this today, without having to expose any control to the author.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; On Thu, 15 Nov 2012, Fred Andrews wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; The canvas that scripts draw into could be over-sized with the UA
</I>&gt;&gt;&gt;<i> down
</I>&gt;&gt;&gt;<i> &gt; &gt; sampling this to fit the target size and taking into account the
</I>&gt;&gt;&gt;<i> &gt; &gt; sub-pixel screen layout when doing so.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; On Thu, 15 Nov 2012, Justin Novosad wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Obviously, that would be costly (x3 pixels), but I think it is a very
</I>&gt;&gt;&gt;<i> &gt; &gt; realistic solution and relatively low hanging fruit. The over-sizing
</I>&gt;&gt;&gt;<i> of
</I>&gt;&gt;&gt;<i> &gt; &gt; the canvas would have to be handled under the hood by the UA though,
</I>&gt;&gt;&gt;<i> &gt; &gt; because it depends on LCD component ordering and orientation, which
</I>&gt;&gt;&gt;<i> &gt; &gt; means querying the OS/display driver. A lot of the kinks with the
</I>&gt;&gt;&gt;<i> &gt; &gt; over-sized canvas approach have already been ironed out for solving
</I>&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;<i> &gt; &gt; problem of High-DPI support ( put/getImageDataHD ), and I like the
</I>&gt;&gt;&gt;<i> idea
</I>&gt;&gt;&gt;<i> &gt; &gt; of unifying the two. Implementing this would mostly be a matter of
</I>&gt;&gt;&gt;<i> &gt; &gt; adding per color component compositing of canvases. Also, the pixel
</I>&gt;&gt;&gt;<i> &gt; &gt; aspect ratio would have to be taken into account for line drawing.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; getImageDataHD() requires that the pixels be square, but so long as
</I>&gt;&gt;&gt;<i> that
</I>&gt;&gt;&gt;<i> &gt; is taken into consideration (e.g. by dropping down to square pixels if
</I>&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;<i> &gt; author calls putImageDataHD()) I think this could probably be made to
</I>&gt;&gt;&gt;<i> work
</I>&gt;&gt;&gt;<i> &gt; within the spec's current requirements.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Regarding the concerns about accessibility, I think the problem can
</I>&gt;&gt;&gt;<i> be
</I>&gt;&gt;&gt;<i> &gt; &gt; solved by using HitRegions with labels.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; Oh it _can_ be solved. That's not the problem. Accessibility is not
</I>&gt;&gt;&gt;<i> about
</I>&gt;&gt;&gt;<i> &gt; what is _possible_, it's about what actually _is_. Most authors,
</I>&gt;&gt;&gt;<i> &gt; realistically speaking, aren't goin to be using hit regions
</I>&gt;&gt;&gt;<i> sufficiently
</I>&gt;&gt;&gt;<i> &gt; for us to declare victory here.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Come to think of it, there should be an option to make the UA do this
</I>&gt;&gt;&gt;<i> &gt; &gt; automatically: create a HitRegion with a label every time text is
</I>&gt;&gt;&gt;<i> drawn
</I>&gt;&gt;&gt;<i> &gt; &gt; to a canvas.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; I considered doing that, but it gets really fiddly when you're doing
</I>&gt;&gt;&gt;<i> &gt; things like text that fades over multiple frames. In the end I decided
</I>&gt;&gt;&gt;<i> &gt; that the magic wasn't worth it, as it would likely screw up more often
</I>&gt;&gt;&gt;<i> &gt; than it would actually help.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; --
</I>&gt;&gt;&gt;<i> &gt; Ian Hickson               U+1047E                )\._.,--....,'``.
</I>&gt;&gt;&gt;<i>  fL
</I>&gt;&gt;&gt;<i> &gt; <A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._
</I>&gt;&gt;&gt;<i> ,.
</I>&gt;&gt;&gt;<i> &gt; Things that are impossible just take longer.
</I>&gt;&gt;&gt;<i> `._.-(,_..'--(,_..'`-.;.'
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="081178.html">[whatwg] Enabling LCD Text and antialiasing in canvas
</A></li>
	<LI>Next message: <A HREF="081186.html">[whatwg] Enabling LCD Text and antialiasing in canvas
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#81185">[ date ]</a>
              <a href="thread.html#81185">[ thread ]</a>
              <a href="subject.html#81185">[ subject ]</a>
              <a href="author.html#81185">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
