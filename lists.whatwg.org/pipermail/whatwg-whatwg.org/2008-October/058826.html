<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] HTML5 Offline Web Applications
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20HTML5%20Offline%20Web%20Applications&In-Reply-To=%3Cfa2eab050810071403q29cb47cbuf68ad54da9c9ab06%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="058777.html">
   <LINK REL="Next"  HREF="058828.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] HTML5 Offline Web Applications</H1>
<!--htdig_noindex-->
    <B>Michael Nordman</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20HTML5%20Offline%20Web%20Applications&In-Reply-To=%3Cfa2eab050810071403q29cb47cbuf68ad54da9c9ab06%40mail.gmail.com%3E"
       TITLE="[whatwg] HTML5 Offline Web Applications">michaeln at google.com
       </A><BR>
    <I>Tue Oct  7 14:03:10 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="058777.html">[whatwg] HTML5 Offline Web Applications
</A></li>
        <LI>Next message: <A HREF="058828.html">[whatwg] HTML5 Offline Web Applications
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#58826">[ date ]</a>
              <a href="thread.html#58826">[ thread ]</a>
              <a href="subject.html#58826">[ subject ]</a>
              <a href="author.html#58826">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Some more comments for the whatwg bit bucket...

1) Foreign entry detection

The spec points out an optimization when a foreign entry is discovered at
cache-selection time, involving marking the entry as foreign at that time
so  it will get filtered out of future searches during top-level navigation.
Another optimization that could be pointed out is to detect foreign'ness
upon insertion into the cache.

Really, it may be more clear if the spec were simply spec'd that way rather.
The behavior exhibitted by the algorithms described corresponds with 'detect
on insert', but accomplishes that in a less direct fashion.


2) Silent manifest parsing errors

The spec goes out of its way to indicate that most errors while parsing the
manifest file should be silently eaten. That can't be an accident. What
badness is being averted by that behavior? What is trying to be accomplished
by that behavior?


3) Update algorithm

The intent is to grab a coherent set of resources that make up a 'version'
of the app. No provisions are made to ensure that is what you actually end
up with. Say the system starts an update, grabs the manifest file and starts
fetching/validating resources. Half way thru, a new manifest file and set of
resources lands on the server (or a new server is deployed). You end up with
a mixed set of resources on the client.


4) Why require text/cache-manifest mimetype?

Presents a small hurdle to get over. What is being accomplished with this
requirement?


5) More thoughts on rephrasing the caching semantics of non-explicit entries

To job memories...
&gt;<i> One idea is to rephrase this feature in terms closer to std http caching
</I>for
&gt;<i> all entries that do not explicily appear in the manifest file. In
</I>&gt;<i> effect, closer to telling the http cache to not purge the resource.
</I>
I was trading mail with somebody using Gears and this came up. The developer
was interested in purging based on LRU when a threshold was exceeded. The
app works with a unbounded (for all practical purposes) set of resources
that could be cached.

If the 'contract' for these non-explicit entries required them be purged as
quotas are bumped into, that would be ideal for this particular use case.
These type of semantics could make a lot of sense for a class of apps like
Flickr or PicassaWeg or YouTube.

So they don't expire according to normal http caching rules, and they are
used as a fallback in the event of errors, but they are not guaranteed to be
there forever unless you stay within a quota.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20081007/790ebdee/attachment-0001.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20081007/790ebdee/attachment-0001.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="058777.html">[whatwg] HTML5 Offline Web Applications
</A></li>
	<LI>Next message: <A HREF="058828.html">[whatwg] HTML5 Offline Web Applications
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#58826">[ date ]</a>
              <a href="thread.html#58826">[ thread ]</a>
              <a href="subject.html#58826">[ subject ]</a>
              <a href="author.html#58826">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
