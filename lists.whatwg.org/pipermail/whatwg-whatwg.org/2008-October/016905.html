<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] WebSocket support in HTML5
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20WebSocket%20support%20in%20HTML5&In-Reply-To=%3CBAY131-DAV13FC9CF11DC35F7883D37BFB260%40phx.gbl%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016899.html">
   <LINK REL="Next"  HREF="016906.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] WebSocket support in HTML5</H1>
<!--htdig_noindex-->
    <B>Richard's Hotmail</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20WebSocket%20support%20in%20HTML5&In-Reply-To=%3CBAY131-DAV13FC9CF11DC35F7883D37BFB260%40phx.gbl%3E"
       TITLE="[whatwg] WebSocket support in HTML5">maher_rj at hotmail.com
       </A><BR>
    <I>Wed Oct 29 02:47:45 PDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="016899.html">[whatwg] WebSocket support in HTML5
</A></li>
        <LI>Next message: <A HREF="016906.html">[whatwg] Dealing with UI redress vulnerabilities inherent to	the current web
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16905">[ date ]</a>
              <a href="thread.html#16905">[ thread ]</a>
              <a href="subject.html#16905">[ subject ]</a>
              <a href="author.html#16905">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Hi Philipp,

&gt;<i> After all, more or less the only situation you'd want to use UDP
</I>
Wrong. But then personally, I'd use UDP for server-generated events, and
something other than a context-devoid, connection-less, session-hijackable,
bollocks protocol as my middleware backbone; I am clearly 180 degrees in the
minority :-)

&gt;<i> That out of the way, I think the &quot;structure in content&quot; approach is
</I>&gt;<i> preferable because in the end it makes the whole feature easier to use
</I>&gt;<i> and accessible to a much broader range of web authors. Because a WS
</I>&gt;<i> stream has standardized metadata and delimiters, you can easily build
</I>&gt;<i> a generic framework that processes those parts for you.
</I>
Fine, you want &quot;structure in content&quot; then you stick it on *afterwards*.
Please don't impose your particular views on what everyone else's data
stream should look like! Some might like chunking, record-type indicators,
or data-length sentinels, or something completely different; it's up to
them!

Anyway, I believe Shannon has come up with a very workable ws.read(bytes)
and ws.write(bytes) alternative.Spookily, just like a Socket - amazing. Well
done.

&gt;<i> Note that it was a conscious design decision to make WS incompatible
</I>&gt;<i> with existing protocols, because the risk for misuse is too great.
</I>
Excellent, so WebSockets have been deliberately ham-strung by design? Now
that explains a lot :-(

Even if I was less paranoid I'd still smell a vested interest rat here &quot;Yes,
you can have all the sockets you want as long as you are forced through our
HTTP servers to do it&quot;.

Cheers Richard Maher

----- Original Message ----- 
From: &quot;Philipp Serafin&quot; &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">phil127 at gmail.com</A>&gt;
To: &quot;Kristof Zelechovski&quot; &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">giecrilj at stegny.2a.pl</A>&gt;; &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">whatwg at whatwg.org</A>&gt;
Sent: Monday, September 29, 2008 7:18 PM
Subject: Re: [whatwg] WebSocket support in HTML5


&gt;<i> On Sat, Sep 27, 2008 at 12:58 PM, Kristof Zelechovski
</I>&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">giecrilj at stegny.2a.pl</A>&gt; wrote:
</I>&gt;<i> &gt; If you are in control of the server, you can simulate datagram sockets
</I>with
&gt;<i> &gt; one-shot controlled sockets
</I>&gt;<i>
</I>&gt;<i> I do not agree with Richard at all, but I have to play devil's
</I>&gt;<i> advocate here because I think such a simulation would be pretty
</I>&gt;<i> useless.
</I>&gt;<i> After all, more or less the only situation you'd want to use UDP
</I>&gt;<i> outside a LAN is when TCP doesn't fit your needs, e.g. because the
</I>&gt;<i> flow control does more harm than good to your use-case or because your
</I>&gt;<i> peers have not enough processing power for a full TCP implementation.
</I>&gt;<i> Simulating UDP via TCP would pretty much combine the disadvantages of
</I>&gt;<i> both protocols.
</I>&gt;<i> Also, you already need a full roudtrip to initiate a TCP connection, a
</I>&gt;<i> second one to perform the WS handshake and a third one to close the
</I>&gt;<i> connection. Data not taken into account. You can hardly repeat that
</I>&gt;<i> for every datagram you want to send.
</I>&gt;<i>
</I>&gt;<i> That out of the way, I think the &quot;structure in content&quot; approach is
</I>&gt;<i> preferable because in the end it makes the whole feature easier to use
</I>&gt;<i> and accessible to a much broader range of web authors. Because a WS
</I>&gt;<i> stream has standardized metadata and delimiters, you can easily build
</I>&gt;<i> a generic framework that processes those parts for you.
</I>&gt;<i> This is especially important if you DON'T have full control over the
</I>&gt;<i> server, which I believe is the case for the majority of smaller sites
</I>&gt;<i> that use a shared hosting solution. Those hosters usually don't give
</I>&gt;<i> their clients access to the underlying processes at all. All the
</I>&gt;<i> clients can do is upload static files and script files that get
</I>&gt;<i> executed in a restricted environment. It's really hard to integrate
</I>&gt;<i> pure, persistent connections into such a setup. With WS, a hoster
</I>&gt;<i> could for example have a demon listen to all incoming WS connections
</I>&gt;<i> and call the client's scripts whenever a data frame has been received.
</I>&gt;<i> In short, it's much easier for them to manage persistent connections
</I>&gt;<i> if there is a standardized structure. And if it's easier for them,
</I>&gt;<i> hopefully the support for this feature will grow.
</I>&gt;<i>
</I>&gt;<i> As for the restriction of unicode data, of course we could just use an
</I>&gt;<i> octet counting mechanism like HTTP does instead of a fixed delimiter.
</I>&gt;<i> This would allow arbitrary data inside the WS frames. On the other
</I>&gt;<i> hand, this might make it easier to spoof existing protocols. Would the
</I>&gt;<i> benefits of this outweigh the risks?
</I>&gt;<i>
</I>&gt;<i> Note that it was a conscious design decision to make WS incompatible
</I>&gt;<i> with existing protocols, because the risk for misuse is too great.
</I>&gt;<i>
</I>&gt;<i> If you need your web app to inerac with a specific service, it should
</I>&gt;<i> be easy to write a generic proxy that does the handshake, strips out
</I>&gt;<i> the frame marks and transforms the data.
</I>&gt;<i>
</I>&gt;<i> Also, it's not like the other technologies would vanish all of a
</I>&gt;<i> sudden. If you have sufficient control over your server, you can STILL
</I>&gt;<i> use Java or Flash sockets.
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Philipp Serafin
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016899.html">[whatwg] WebSocket support in HTML5
</A></li>
	<LI>Next message: <A HREF="016906.html">[whatwg] Dealing with UI redress vulnerabilities inherent to	the current web
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16905">[ date ]</a>
              <a href="thread.html#16905">[ thread ]</a>
              <a href="subject.html#16905">[ subject ]</a>
              <a href="author.html#16905">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
