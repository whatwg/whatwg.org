<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] The &lt;link&gt; element and &quot;display: meta&quot;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20The%20%3Clink%3E%20element%20and%20%22display%3A%20meta%22&In-Reply-To=%3C43CCFB6B.9030509%40earthlink.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="047657.html">
   <LINK REL="Next"  HREF="047785.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] The &lt;link&gt; element and &quot;display: meta&quot;</H1>
<!--htdig_noindex-->
    <B>Matthew Raymond</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20The%20%3Clink%3E%20element%20and%20%22display%3A%20meta%22&In-Reply-To=%3C43CCFB6B.9030509%40earthlink.net%3E"
       TITLE="[whatwg] The &lt;link&gt; element and &quot;display: meta&quot;">mattraymond at earthlink.net
       </A><BR>
    <I>Tue Jan 17 06:12:59 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="047657.html">[whatwg] The &lt;link&gt; element and &quot;display: meta&quot;
</A></li>
        <LI>Next message: <A HREF="047785.html">[whatwg] The &lt;link&gt; element and &quot;display: meta&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47733">[ date ]</a>
              <a href="thread.html#47733">[ thread ]</a>
              <a href="subject.html#47733">[ subject ]</a>
              <a href="author.html#47733">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Sander Tekelenburg wrote:
&gt;<i> At 15:26 -0500 UTC, on 2006-01-10, Matthew Raymond wrote:
</I>[Snip!]
&gt;&gt;&gt;&gt;&gt;&gt;<i> No, user agents could construct a link bar using the |rel| values of
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>hyperlinks.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>Exactly. That would in fact be an implementation of display:meta. Rendering
</I>&gt;&gt;&gt;&gt;&gt;<i>the contents of TITLE attributes in a Status Bar is too.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>  No they're not. They're implementations of the |rel| and |title|
</I>&gt;&gt;&gt;&gt;<i>attributes.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>How? I don't see the HTML spec stating how rel or title attributes must be
</I>&gt;&gt;&gt;<i>presented.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   The spec fails to REQUIRE what the implementations do, but it does
</I>&gt;&gt;<i>not PROHIBIT what the implementations in question do.
</I>&gt;<i> 
</I>&gt;<i> Agreed. That's because HTML defines structure and meaning/semantics, not
</I>&gt;<i> presentation.
</I>
   ...Or behavior.

&gt;<i> In that sense you're right that presenting a title attribute's
</I>&gt;<i> contents in a &quot;Status Bar&quot; would be an implemantation of HTML - but merely in
</I>&gt;<i> the sense that it makes that content accessible. But that seems a bit like
</I>&gt;<i> saying it is an implementation of TCP/IP. It's true of course, but rather
</I>&gt;<i> broad.
</I>
   This is misleading. A browser in not an implementation of TCP/IP.
Rather, the APIs it uses are. The actual implementation is written
against some very strict specifications and has to be to insure
interoperation with other implementations.

   HTML is deliberately flexible in how it can be interpreted to allow
a variety of implementations. However, it is strict when it has to be,
like how form data is submitted back to the server.

&gt;<i> More minutely would be saying that such a presentation is an
</I>&gt;<i> implementation of display:meta because only *then* do you refer to the
</I>&gt;<i> detailed aspect of the presentation method.
</I>
   If something is an implementation of a CSS property value, then it
has to work when you use that CSS property value. That's just common
sense. You can't call the XUL element &lt;textbox&gt; an implementation of
&lt;input type=&quot;text&quot;&gt;, because it isn't. It could be USED to implement
&lt;input type=&quot;text&quot;&gt;, but that doesn't mean it actually is one.

&gt;&gt;&gt;&gt;<i>  Until I can turn items into metadata using &quot;display: meta&quot;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Nit-pick: you will never be able to do that. Just like P {display:list-item}
</I>&gt;&gt;&gt;<i>doesn't change a paragraph into a list item. It is only *presented* as a
</I>&gt;&gt;&gt;<i>list-item - it still is a paragraph.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   Then you will be requiring user agents to have a specific and well
</I>&gt;&gt;<i>defined presentation of elements styled with &quot;display: meta&quot;?
</I>&gt;<i> 
</I>&gt;<i> No, absolutely not. The entire point would be that user-agents would have the
</I>&gt;<i> freedom to decide for themselves what sort of presentation of display:meta
</I>&gt;<i> would be appropriate. Exactly because different presentations will be best
</I>&gt;<i> for different browsing environments. (It would be good if the spec would
</I>&gt;<i> mention some examples of possible implementations, but only to convey to
</I>&gt;<i> browser developers that they are to take the freedom to implement this in a
</I>&gt;<i> way that makes sense to their specific browsing environment.)
</I>
   So what you're saying is that &quot;display: meta&quot; will basically mean
&quot;not presented in the body&quot;. This is not a presentation. It's the
exclusion of a presentation. It would be like me saying &quot;everything
outside of that telephone both&quot; is a location. It's not. The &quot;telephone
both&quot; is a location. &quot;Everything outside&quot; is the entire universe minus
the telephone both.

&gt;&gt;<i>I'm not
</I>&gt;&gt;<i>sure how pleased browser vendors would be to have portions of their
</I>&gt;&gt;<i>browser GUI defined in a spec...
</I>&gt;<i> 
</I>&gt;<i> Indeed. In no way do I mean to go in that direction. Quite the contrary. In
</I>&gt;<i> the *current* situation a Web page's navigation menu can look entirely
</I>&gt;<i> different from a given UI's convention. The &quot;display:meta&quot; I envision would
</I>&gt;<i> allow user-agents to present such a navigation menu in a manner that is
</I>&gt;<i> consistent with the browsing environment's UI - whatever that is. (The goal
</I>&gt;<i> being that the navigation menu would become easier to find and use for end
</I>&gt;<i> users than is currently possible.)
</I>
   User style sheets already let users decide what these pages look
like. What you're talking about is a CSS property value that lets the
user agent vendor determine the presentation and functionality.

&gt;&gt;&gt;<i>The point of display:meta is that instead the data can be
</I>&gt;&gt;&gt;<i>presented in a manner that is consistent (for that user-agent) at every
</I>&gt;&gt;&gt;<i>site.
</I>&gt;&gt;&gt;<i>(And that therefore it would need to waste less space.)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   This can be done with new HTML markup.
</I>&gt;<i> 
</I>&gt;<i> I don't see how. Surely you're not proposing that HTML should start dealing
</I>&gt;<i> with presentation again?
</I>
   No. I'm suggesting markup that tells the user agent that certain
content is intended as list for commands and/or navigation. The user
agents may do as they see fit with this information.

&gt;<i> (I haven't said anything about it yet, but some of
</I>&gt;<i> the proposed HTML for &quot;menu&quot; that I've seen floating by in this discussion
</I>&gt;<i> gave me the impression that that indeed is the direction it is heading in,
</I>&gt;<i> which quite surprised me - not to say scared me. I'm hoping I just
</I>&gt;<i> misunderstood.)
</I>
   Why the obvious intent would be that &lt;menu&gt; could be rendered with
platform menu widgets, I do not believe that the intent is to make this
a requirement. User agents may do as they see fit.

&gt;&gt;<i>   &quot;Chrome&quot; is the GUI of a user agent that is not part of the page
</I>&gt;&gt;<i>body. The status bar, menus, toolbars, et cetera are all &quot;chrome&quot;.
</I>&gt;<i> 
</I>&gt;<i> Hm... OK. I think I would prefer to refer to that as &quot;the browsing
</I>&gt;<i> environment's UI&quot;. If only because that doesn't limit itself to graphical UIs.
</I>
   &quot;Browsing environment's UI&quot; is misleading. Do scrollbars count as
part of this? &quot;Chrome&quot;, while sounding mildly visual, is nearly always
used to refer to elements of the user interface that are not part of the
document body.

&gt;<i> Does &quot;chrome&quot; also indicate non-graphical UI aspects? (Think of a cli
</I>&gt;<i> browser, a braille browser, a talking browser, none of which would (have to)
</I>&gt;<i> have such graphical UI elements as &quot;toolbars&quot; or &quot;menubars&quot;.)
</I>
   I don't see why not.

&gt;&gt;&gt;&gt;<i>  This problem is better solved by markup, though.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Exactly how can markup solve this? I think we're talking about presentation,
</I>&gt;&gt;&gt;<i>which is not the realm of HTML (which is why I agree this is somethin for
</I>&gt;&gt;&gt;<i>www-style).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   No, you're talking about presentation.
</I>&gt;<i> 
</I>&gt;<i> Yes, but only up to the point of display:meta defining that something is to
</I>&gt;<i> be presented outside of the body. Beyond that, it's up to the user-agent.
</I>
   If the user agent determines the appropriate presentation and
functionality, it's interpreting the meaning of &quot;display: meta&quot;, and
that makes it semantic.

&gt;&gt;<i>I'm talking about a general
</I>&gt;&gt;<i>&quot;menu&quot; solution that user agent vendors may or may not choose to make
</I>&gt;&gt;<i>part of the UA chrome. Let the vendors decide how it works or what it
</I>&gt;&gt;<i>looks like. A compliant implementation could possibly even be in-body.
</I>&gt;<i> 
</I>&gt;<i> Well, not for display:meta of course. But I do agree that the point of
</I>&gt;<i> display:meta would be to allow a user-agent to present something in a manner
</I>&gt;<i> consistent among different websites. In that sense, yes, if that can be
</I>&gt;<i> achieved through in-body presentation, that would be fine. (I just don't
</I>&gt;<i> think it *can* be achieved that way.)
</I>
   We shouldn't create arbitrary restrictions for user agents simply
because we lack the creativity to come up with a design outside those
restrictions.

&gt;<i> &quot;display in a consistent, user-agent specific manner, not a site-specific
</I>&gt;<i> manner&quot;.
</I>
   So we're using &quot;display: meta&quot; to create a page style that says
&quot;ignore the page style&quot;?

&gt;<i> But I'd expect an in-body implementation of this would be a much
</I>&gt;<i> harder approach to achieve, if only because then the user-agent would have to
</I>&gt;<i> style some part of the body in a way that will conflict with the rest of the
</I>&gt;<i> body. Removing it from the body, which display:meta would 'do', seems more
</I>&gt;<i> realistic to me.
</I>
   I agree that in-body implementations are unlikely, but if that's the
case, writing that into a specification would simply be redundant, since
the realities of the market would do far more to prevent it that any
spec would.

&gt;&gt;<i>   If we reuse &lt;menu&gt; for navigational lists in HTML5, we can just style
</I>&gt;&gt;<i>&lt;menu&gt; for user agents like IE6. That way, if a legacy browser supports
</I>&gt;&gt;<i>CSS, we have fallback styling that can reduce the size of the
</I>&gt;&gt;<i>navigational markup on the page and position elements to use up less
</I>&gt;&gt;<i>space. By contrast, for &quot;display: meta&quot;, you have to double-declare the
</I>&gt;&gt;<i>property for legacy browsers:
</I>&gt;&gt;<i>
</I>&gt;&gt;|<i> display: block;
</I>&gt;&gt;|<i> display: meta;
</I>&gt;<i> 
</I>&gt;<i> If a NAV element would be allowed only to contain a UL element, that would
</I>&gt;<i> solve a legacy browser support issue, wouldn't it? Antiques would ignore the
</I>&gt;<i> NAV element and just render the UL and its contents.
</I>
   This doesn't solve anything outside of the &lt;nav&gt; element. What
happens when you style a non-&lt;nav&gt; element as &quot;display: meta&quot;? Allowing
a CSS property to determine the children of an arbitrary element in the
DOM just doesn't make sense.

&gt;<i> Better yet might be to not introduce a new nav element at all, but to go no
</I>&gt;<i> further than introducing a nav property for UL? (Or maybe no &quot;navigation
</I>&gt;<i> elements/attributes&quot; at all, given that the entire idea appears to be quite
</I>&gt;<i> presentational.)
</I>
   Better yet, just replace &quot;ul&quot; with &quot;menu&quot; and forget the CSS. ;)

&gt;&gt;<i>   This, of course, will do nothing for HTML5-compliant browsers that
</I>&gt;&gt;<i>don't support &quot;display: meta&quot; at all.
</I>&gt;<i> 
</I>&gt;<i> True. But given that authors cannot rely on CSS support anyway that seems
</I>&gt;<i> irrelevant to me.
</I>
   Huh? In that situation, HTML markup would provide a solution, whereas
CSS would not.

&gt;&gt;<i>   In the end, this means that &quot;display: meta&quot; can't have a specific
</I>&gt;&gt;<i>presentation, and that user agents have flexibility in determining the
</I>&gt;&gt;<i>behavior and presentation (which is at the very least required to
</I>&gt;&gt;<i>conform with the native UI guidelines).
</I>&gt;<i> 
</I>&gt;<i> Exactly.
</I>&gt;<i> 
</I>&gt;&gt;<i> As a result, you essentially
</I>&gt;&gt;<i>have a CSS property that gives &lt;link&gt; semantics to other HTML elements.
</I>&gt;<i> 
</I>&gt;<i> No :) CSS doesn't affect semantics, just presentation.
</I>
   So you're pretty much making my case for me...

&gt;&gt;&gt;&gt;<i>In fact, the other day I saw a page
</I>&gt;&gt;&gt;&gt;<i>that emulated the Windows XP desktop.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Which would be a confusing UI for a user who is used to another UI.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   That makes no sense. The whole point is to emulate another UI so that
</I>&gt;&gt;<i>the user can experience what it's like to use the Windows XP desktop.
</I>&gt;<i> 
</I>&gt;<i> That might be a useful application for 1 or 2 websites that are about
</I>&gt;<i> demonstrating the WinXP desktop. But we all know that there are web developers
</I>&gt;<i> out there who love to try to force their site's presentation to be just like
</I>&gt;<i> the one environment *they* happen to be comfortable with, ignoring that it
</I>&gt;<i> would confuse the hell out of many other people. HTML/CSS should not cater
</I>&gt;<i> for such authoring. Authors who want that sort of control should use other
</I>&gt;<i> techniques, like Flash.
</I>
   Actually, I hear Flash is even less accessible than HTML, and forcing
people to something like Flash would just encourage Flash-only web
design, which is a real pain already.

   That said, there's really no reason why you couldn't build stuff like
simulated desktops already with HTML+JS+CSS. You just don't want to give
them the ability to make a text box look like a button and what not.
Navigational lists actually probably shouldn't be too heavily stylable,
except for maybe context and pull-down menus, and even that's debatable.

&gt;&gt;&gt;&gt;<i>  Doubt it. All I see are a bunch of complex rules on how to process
</I>&gt;&gt;&gt;&gt;<i>the children of a &quot;meta&quot; element.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>That depends on what type of elements a spec would allow display:meta to
</I>&gt;&gt;&gt;<i>apply to.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   In other words, HTML and every XML language in existence would have
</I>&gt;&gt;<i>to define what elements &quot;display: meta&quot; applies to. Not a good solution.
</I>&gt;<i> 
</I>&gt;<i> I can't follow. Today's CSS specs already define such limitations, don't
</I>&gt;<i> they?
</I>
   I believe this is done in current CSS specs by providing specific
presentation details, then allowing user agents to ignore properties
when they have cause to do so. CSS provides presentational hints which
user agents can ignore if they have proper cause to do so (such as
operating system UI conventions).

&gt;<i> Some apply to block level elements only, some to positioned elements,
</I>&gt;<i> etc. A CSS spec would only have to define to what sort of elements
</I>&gt;<i> display:meta applies. Markup languages don't need to be aware of that.
</I>
   But CSS allows you do define which elements are presented as block or
inline, so I don't see your point. The properties in that particular
case are being defined as specific to certain CSS &quot;display&quot; property
values, not specific elements.

&gt;&gt;&gt;<i>For the moment I am only thinking about the NAV element Ian
</I>&gt;&gt;&gt;<i>proposes, which it seems would only contain what are essentially list items,
</I>&gt;&gt;&gt;<i>possibly organised in sub lists.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   What would be the error handling for this, then? The elements don't
</I>&gt;&gt;<i>display at all? Does &lt;nav&gt; even have a limitation on what the children
</I>&gt;&gt;<i>can be?
</I>&gt;<i> 
</I>&gt;<i> Given that it appears to be meant as a list, I'd expect it to only allow list
</I>&gt;<i> items. You're right though that a problem might exist with what list items
</I>&gt;<i> are allowed to contain.
</I>
   <A HREF="http://whatwg.org/specs/web-apps/current-work/#the-nav">http://whatwg.org/specs/web-apps/current-work/#the-nav</A>

   From the spec:

|<i> The nav element represents a section of a page that links to other
</I>|<i> pages or to parts within the page: a section with navigation links.
</I>|<i>
</I>|<i> When used as an inline-level content container, the element represents
</I>|<i> a paragraph.
</I>|<i>
</I>|<i> Each nav element potentially has a heading. See the section on
</I>|<i> headings and sections for further details.
</I>
   Doesn't sound like it's intended for lists only to me.

&gt;<i> Still, I'm not sure how real that problem might be in practice. In theory a
</I>&gt;<i> nav element's list items might contain &lt;P&gt;s with a lot of text. That could be
</I>&gt;<i> a problem for a user-agent (depending on its display:meta implementation).
</I>&gt;<i> But how likely is it that an author would do such a thing in a navigation
</I>&gt;<i> menu?
</I>
   It's a heck of a lot more likely with a CSS property, because all you
have to do to style something that's not a navigational menu is to get
the selector wrong. By contrast, if you're using markup to define what
constitutes a navigational list, the problem doesn't exist.

&gt;<i> Isn't this comparable with the fact that the HTML spec doesn't define a
</I>&gt;<i> limit for the length of a title attribute, but that in most browsing
</I>&gt;<i> environments there *is* a limit on the amount of text that can be rendered
</I>&gt;<i> through a Tooltip? In other words, does this really *need* to be defined, or
</I>&gt;<i> would it be reasonable to leave some level of responsibility to the author
</I>&gt;<i> here?
</I>
   The difference is that the author knows that when he/she uses
&lt;title&gt;, it's going to be displayed in a manner consistent with the
platform UI. By contrast, you do not know that the author of a specific
web page knows that the first &lt;h1&gt; element in the &lt;body&gt; will be styled
with &quot;display: title&quot; or some similar display type. This is because
multiple individuals may be working on content for a single site and
they may be using a single style sheet for all pages. This style sheet
may be changed without notice. As a result, you can't rely on the author
to be able to coordinate the style sheet with the content.

&gt;&gt;|<i> &lt;nav&gt;
</I>&gt;&gt;|<i>   &lt;p&gt;&lt;img src=&quot;image.png&quot; alt=&quot;[navigational header]&quot;&gt;&lt;/p&gt;
</I>&gt;&gt;|<i>   &lt;ul/&gt;
</I>&gt;&gt;|<i> &lt;/nav&gt;
</I>&gt;<i> 
</I>&gt;<i> I'm not sure this would be a problem. One browsing environment might choose
</I>&gt;<i> to present the image, another might choose to only present the ALT text.
</I>
  The problem is that the markup has meaning, and this meaning is
potentially stripped from a user perspective when &quot;display: meta&quot; is
used, depending on the implementation. Granted, that's not such a huge
problem with this specific markup. Here's another example:

|<i> &lt;nav&gt;
</I>|<i>   &lt;h1&gt;
</I>|<i>     &lt;iframe src=&quot;header.html&quot; width=&quot;200&quot; height=&quot;10&quot;&gt;&lt;/iframe&gt;
</I>|<i>   &lt;/h1&gt;
</I>|<i>   &lt;ul&gt;&lt;!-- List of links here. --&gt;&lt;/ul&gt;
</I>|<i>   &lt;ol&gt;&lt;!-- List of links here. --&gt;&lt;/ol&gt;
</I>|<i> &lt;/nav&gt;
</I>
   What do you even do with the &lt;iframe&gt;? Use the non-existent contents
instead, thus yielding a blank header? And how would the header be
displayed? What effect does using an ordered list have? With something
like &lt;menu&gt;, you can define what elements can be children and have the
user agents ignore all inappropriate children. In that regard, you don't
have to define a behavior for every possible element of every language,
because many of those elements wouldn't be valid children anyways.

&gt;<i> (But
</I>&gt;<i> I might be [misunderstanding] your example, given the closing ul lacking an
</I>&gt;<i> opening ul. Typo?)
</I>
   In XML, &lt;tag/&gt; is the same thing as &lt;tag&gt;&lt;/tag&gt; with no inner
contents. I was using that to indicate that there was an unordered list
there without specifying the full markup for the list.

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="047657.html">[whatwg] The &lt;link&gt; element and &quot;display: meta&quot;
</A></li>
	<LI>Next message: <A HREF="047785.html">[whatwg] The &lt;link&gt; element and &quot;display: meta&quot;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#47733">[ date ]</a>
              <a href="thread.html#47733">[ thread ]</a>
              <a href="subject.html#47733">[ subject ]</a>
              <a href="author.html#47733">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
