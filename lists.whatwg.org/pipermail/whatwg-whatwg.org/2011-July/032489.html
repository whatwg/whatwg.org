<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] a rel=attachment
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20a%20rel%3Dattachment&In-Reply-To=%3CCAP0-Qpt%3D1c_LbCbCm22qryWSfZO5BwfUp2Kr1DUP%2Bq6ws%3Dvqwg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="032481.html">
   <LINK REL="Next"  HREF="032490.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] a rel=attachment</H1>
<!--htdig_noindex-->
    <B>Darin Fisher</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20a%20rel%3Dattachment&In-Reply-To=%3CCAP0-Qpt%3D1c_LbCbCm22qryWSfZO5BwfUp2Kr1DUP%2Bq6ws%3Dvqwg%40mail.gmail.com%3E"
       TITLE="[whatwg] a rel=attachment">darin at chromium.org
       </A><BR>
    <I>Fri Jul 15 14:34:29 PDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="032481.html">[whatwg] a rel=attachment
</A></li>
        <LI>Next message: <A HREF="032490.html">[whatwg] a rel=attachment
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32489">[ date ]</a>
              <a href="thread.html#32489">[ thread ]</a>
              <a href="subject.html#32489">[ subject ]</a>
              <a href="author.html#32489">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Fri, Jul 15, 2011 at 1:09 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt; wrote:

&gt;<i> 2011/7/15 Ian Fette (&#12452;&#12450;&#12531;&#12501;&#12455;&#12483;&#12486;&#12451;) &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ifette at google.com</A>&gt;:
</I>&gt;<i> &gt; 2011/7/15 Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; 2011/7/14 Ian Fette (&#12452;&#12450;&#12531;&#12501;&#12455;&#12483;&#12486;&#12451;) &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ifette at google.com</A>&gt;:
</I>&gt;<i> &gt;&gt; &gt; Many websites wish to offer a file for download, even though it could
</I>&gt;<i> &gt;&gt; &gt; potentially be viewed inline (take images, PDFs, or word documents as
</I>&gt;<i> an
</I>&gt;<i> &gt;&gt; &gt; example). Traditionally the only way to achieve this is to set a
</I>&gt;<i> &gt;&gt; &gt; content-disposition header. *However, sometimes it is not possible for
</I>&gt;<i> &gt;&gt; the
</I>&gt;<i> &gt;&gt; &gt; page author to have control over the response headers sent by the
</I>&gt;<i> &gt;&gt; &gt; server.*(A related example is offline apps, which may wish to provide
</I>&gt;<i> &gt;&gt; &gt; the user with
</I>&gt;<i> &gt;&gt; &gt; a way to &quot;download&quot; a file stored locally using the filesystem API but
</I>&gt;<i> &gt;&gt; again
</I>&gt;<i> &gt;&gt; &gt; can't set any headers.) It would be nice to provide the page author
</I>&gt;<i> with
</I>&gt;<i> &gt;&gt; a
</I>&gt;<i> &gt;&gt; &gt; client side mechanism to trigger a download.
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; After mulling this over with some application developers who are
</I>&gt;<i> trying
</I>&gt;<i> &gt;&gt; to
</I>&gt;<i> &gt;&gt; &gt; use this functionality, it seems like adding a &quot;rel&quot; attribute to the
</I>&gt;<i> &lt;a&gt;
</I>&gt;<i> &gt;&gt; &gt; tag would be a straightforward, minimally invasive way to address this
</I>&gt;<i> &gt;&gt; use
</I>&gt;<i> &gt;&gt; &gt; case. &lt;a rel=attachment href=blah.pdf&gt; would indicate that the browser
</I>&gt;<i> &gt;&gt; &gt; should treat this link as if the response came with a
</I>&gt;<i> &gt;&gt; content-disposition:
</I>&gt;<i> &gt;&gt; &gt; attachment header, and offer to download/save the file for the user.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; We've discussed a different solution to the same problem at mozilla.
</I>&gt;<i> &gt;&gt; The solution we discussed was allowing FileSaver to in addition to
</I>&gt;<i> &gt;&gt; taking a blob argument, allow it to take a url argument.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; One concern which was brought up was the ability to cause the user to
</I>&gt;<i> &gt;&gt; download a file from a third party site. I.e. this would allow
</I>&gt;<i> &gt;&gt; evil.com to trick the user into downloading an email from the users
</I>&gt;<i> &gt;&gt; webmail, or download a page from their bank which contains all their
</I>&gt;<i> &gt;&gt; banking information. It might be easier to then trick the user into
</I>&gt;<i> &gt;&gt; re-uploading the saved file to evil.com since from a user's
</I>&gt;<i> &gt;&gt; perspective, it looked like the file came from evil.com
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Another possible attack goes something like:
</I>&gt;<i> &gt;&gt; 1. evil.com tricks the user into downloading sensitive data from
</I>&gt;<i> bank.com
</I>&gt;<i> &gt;&gt; 2. evil.com then asks the user to download a html from evil.com and
</I>&gt;<i> &gt;&gt; open the newly downloaded file
</I>&gt;<i> &gt;&gt; 3. the html file contains script which reads the contents from the
</I>&gt;<i> &gt;&gt; file downloaded from bank.com and sends it back to evil.com
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Step 1 and 2 require the user to answer &quot;yes&quot; to a dialog displayed by
</I>&gt;<i> &gt;&gt; the browser. However it's well known that users very often hit
</I>&gt;<i> &gt;&gt; whichever button they suspect will make the dialog go away, rather
</I>&gt;<i> &gt;&gt; than actually read the contents of the dialog.
</I>&gt;<i> &gt;&gt; Step 3 again requires the user to answer &quot;yes&quot; to a dialog displayed
</I>&gt;<i> &gt;&gt; by the browser in at least some browsers. Same caveat applies though.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; One very simple remedy to this would be to require CORS opt-in for
</I>&gt;<i> &gt;&gt; cross-site downloads. For same-site downloads no special opt-in would
</I>&gt;<i> &gt;&gt; be required of course.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; It's also possible that it would be ok to do this without any opt-ins
</I>&gt;<i> &gt;&gt; since there are a good number of actions that the user has to take in
</I>&gt;<i> &gt;&gt; all these scenarios. Definitely something that I'd be ok with
</I>&gt;<i> &gt;&gt; discussing with our security team.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Tentatively I would feel safer with the CORS option though. And again,
</I>&gt;<i> &gt;&gt; for same-site downloads this isn't a problem at all, but I suspect
</I>&gt;<i> &gt;&gt; that in many cases the file to be downloaded is hosted on a separate
</I>&gt;<i> &gt;&gt; server.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Oh, and I don't have strong opinions at this time on if rel=attachment
</I>&gt;<i> &gt;&gt; or FileSaver or both should be the way to trigger this functionality.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; / Jonas
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I agree FileSaver is useful and has its place, but I don't think it
</I>&gt;<i> negates
</I>&gt;<i> &gt; the need for something like rel=attachment or download=filename. For one,
</I>&gt;<i> &gt; FileSaver currently operates on blobs and as you mention would have to be
</I>&gt;<i> &gt; modified to handle URLs or streams more generally. Second, it would force
</I>&gt;<i> &gt; developers to use javascript links and/or set up click listeners and so
</I>&gt;<i> &gt; forth, which could be annoying for users (losing the ability to copy the
</I>&gt;<i> URL
</I>&gt;<i> &gt; etc).
</I>&gt;<i>
</I>&gt;<i> As stated, I don't have a strong preference here. I suspect ultimately
</I>&gt;<i> we'll end up wanting both a markup based and an API based solution
</I>&gt;<i> here.
</I>&gt;<i>
</I>&gt;<i> &gt; I guess the interesting question is &quot;If the response would not have
</I>&gt;<i> &gt; otherwise triggered a download, and the request is cross-origin, should
</I>&gt;<i> that
</I>&gt;<i> &gt; require CORS&quot; and personally I would say no, this is still a remote
</I>&gt;<i> enough
</I>&gt;<i> &gt; concern that I would not worry about it.
</I>&gt;<i>
</I>&gt;<i> Indeed, that is the interesting question.
</I>&gt;<i>
</I>&gt;<i> I know that I would personally feel a lot more comfortable if the site
</I>&gt;<i> opted in to allowing downloads of the resource in question. But it's
</I>&gt;<i> quite possible that I'm overly paranoid.
</I>&gt;<i>
</I>&gt;<i> Though one thing to keep in mind is sites that explicitly state that a
</I>&gt;<i> resource should *not* reach the users disk. This is today often done
</I>&gt;<i> using &quot;Cache-Control: no-store&quot;. Seems scary to allow such content to
</I>&gt;<i> be saved based on a cross-site request.
</I>&gt;<i>
</I>&gt;<i> / Jonas
</I>&gt;<i>
</I>

This security concern is very interesting.  I had not considered it before.

Putting that aside for a moment, I'm glad to hear that you also support
there being some declarative method of triggering a download.  Which of
the proposals are you leaning toward?

Personally, I'm most fond of the @download=filename method.  Reason:

1)  Unlike rel=something, @download is feature detectable at runtime via
(&quot;download&quot; in document.createElement(&quot;a&quot;)).

2)  Unlike rel=something, @download provides a way to specify the name
of the file to save.  This makes the feature useful with data: URLs and
blob:
URLs (that are not backed by a single file).  This is valuable to me because
I can imagine wanting to save the contents of a &lt;canvas&gt;, and that probably
involves saving the data URL that you get from toDataURL().

3)  The target=_download idea is interesting, but I'm not sure we can safely
introduce new target values, and this also suffers from not providing a way
to
specify the downloaded filename.

4)  The idea of using both a rel=something and an attribute to specify the
file
name could work too, but it seems a bit overly verbose.  I'm not sure I see
enough benefit from this.  The idea of providing a name for &lt;img&gt; tags that
might be downloaded manually by the user is interesting, but it feels like a
far less interesting problem to solve.  If our solution solves this too,
then great,
but I wouldn't necessarily make it a requirement to solve this problem too.

Anyways, what do you think?  I'd really like to reach some consensus on what
the declarative method should look like.

Whatever security restrictions we come up with will need to apply to
FileSaver
too assuming FileSaver ends up taking an URL (and a filename!).

Thanks!
-Darin
</PRE>

















<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="032481.html">[whatwg] a rel=attachment
</A></li>
	<LI>Next message: <A HREF="032490.html">[whatwg] a rel=attachment
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32489">[ date ]</a>
              <a href="thread.html#32489">[ thread ]</a>
              <a href="subject.html#32489">[ subject ]</a>
              <a href="author.html#32489">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
