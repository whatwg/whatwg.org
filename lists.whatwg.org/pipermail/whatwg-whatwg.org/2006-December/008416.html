<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] PaceEntryMediatype
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20PaceEntryMediatype&In-Reply-To=%3CPine.LNX.4.62.0612041839230.16843%40dhalsim.dreamhost.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008389.html">
   <LINK REL="Next"  HREF="008554.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] PaceEntryMediatype</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20PaceEntryMediatype&In-Reply-To=%3CPine.LNX.4.62.0612041839230.16843%40dhalsim.dreamhost.com%3E"
       TITLE="[whatwg] PaceEntryMediatype">ian at hixie.ch
       </A><BR>
    <I>Mon Dec  4 10:54:04 PST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="008389.html">[whatwg] PaceEntryMediatype
</A></li>
        <LI>Next message: <A HREF="008554.html">[whatwg] PaceEntryMediatype
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8416">[ date ]</a>
              <a href="thread.html#8416">[ thread ]</a>
              <a href="subject.html#8416">[ subject ]</a>
              <a href="author.html#8416">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Mon, 4 Dec 2006, Thomas Broyer wrote:
&gt;<i> 
</I>&gt;<i> There's no need to fetch every link if you base your assumptions on the 
</I>&gt;<i> type=&quot;&quot; attribute (and *only* the type=&quot;&quot; attribute, not the combination 
</I>&gt;<i> with any special rel=&quot;&quot; attribute value). If you don't use the type=&quot;&quot; 
</I>&gt;<i> attribute on &lt;link&gt;s, you'll have many more requests than if you did, 
</I>&gt;<i> because of the &quot;fetch to discover the content-type&quot; algorithm described 
</I>&gt;<i> for &lt;link&gt; elements, but that's the author problem, and it's not limited 
</I>&gt;<i> to feed autodiscovery, so&#8230;
</I>
So your proposal is to ignore the rel=&quot;&quot; attribute altogether for feed 
autodiscovery? This seems contrary to what you were saying before, namely 
that there should be a way to give links to Atom documents that aren't 
feeds and have them not be autodetected. This isn't what you were 
proposing before as far as I can tell.


&gt;<i> &gt; &gt; No more than they already are. rel=&quot;alternate&quot; is for linking to 
</I>&gt;<i> &gt; &gt; alternate representations, and hundreds of millions of syndication 
</I>&gt;<i> &gt; &gt; feed links are not using it that way; they already are 
</I>&gt;<i> &gt; &gt; non-conforming.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Fair enough. They still exist, though. Browser vendors aren't going to 
</I>&gt;<i> &gt; stop supporting this. We would be just sticking our heads in the sand 
</I>&gt;<i> &gt; if we ignored this.
</I>&gt;<i> 
</I>&gt;<i> Many things are marked as &quot;deprecated&quot; in earlier HTML versions, and
</I>&gt;<i> are still supported by browsers.
</I>&gt;<i> Also, as the misuse of rel=&quot;alternate&quot; is not machine testable, and
</I>&gt;<i> given that I don't propose &quot;banning&quot; the use of rel=&quot;alternate&quot; for
</I>&gt;<i> feed autodiscovery, I can't see how a browser vendor could &quot;stop
</I>&gt;<i> supporting this&quot;.
</I>
If you don't want browsers to implement the spec, why do you care what the 
spec says? I'm confused. If the specification is ignored by browser 
vendors, as you seem to be advocating, then the specification is useless.


&gt;<i> &gt; When people link to an Atom document, they are giving a syndication 
</I>&gt;<i> &gt; feed. I'm sure theoretically there could be other uses of Atom, but 
</I>&gt;<i> &gt; from my studies of Web content, I haven't seen any evidence that this 
</I>&gt;<i> &gt; is widespread enough to deserve special treatment.
</I>&gt;<i> 
</I>&gt;<i> Seems like you really didn't understand my point&#8230;
</I>&gt;<i> &#171; rel=&quot;alternate&quot; + type=&quot;RSS or Atom&quot; means rel=&quot;feed alternate&quot; &#187;
</I>&gt;<i> *is* special treatment.
</I>
Which is justified, since feeds _are_ widespread. I was saying that 
non-feed Atom documents are not widespread and that _they_ don't deserve 
special treatment, not the other way around.


&gt;<i> &#171; type=&quot;RSS or Atom&quot; means it's a syndication feed, whichever the
</I>&gt;<i> rel=&quot;&quot; value &#187; is *not* special treatment.
</I>
It would be the only way to create a hyperlink link with a &lt;link&gt; element 
without also specifying a rel=&quot;&quot; attribute; that seems like special 
treatment to me. It also seems like a *superset* of what the spec 
currently says. If you don't like what it says now, why would you like it 
to be even more general?


&gt;<i> &#171; rel=&quot;feed&quot; means it's a feed &#8211;with *my* definition of the &quot;feed&quot; 
</I>&gt;<i> relationship&#8211;, whichever the type=&quot;&quot; value &#187; is *not* special 
</I>&gt;<i> treatment.
</I>
The type=&quot;&quot; attribute is not relevant when rel=feed is set, according to 
the current spec. Your definition was a subset of the current definition, 
and didn't cover some of the existing use cases. I don't see how it 
changes the processing of the type=&quot;&quot; attribute at all.


&gt;<i> &gt; &gt; In 4.4.3.1 (Link type &quot;alternate&quot;), remove this paragraph:
</I>&gt;<i> &gt; &gt; &quot;&quot;&quot;If the alternate keyword is used with the type attribute set to the
</I>&gt;<i> &gt; &gt; value application/rss+xml or the value application/atom+xml, then the
</I>&gt;<i> &gt; &gt; user agent must treat the link as it would if it had the feed keyword
</I>&gt;<i> &gt; &gt; specified as well.&quot;&quot;&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Removing this paragraph breaks existing practices.
</I>&gt;<i> 
</I>&gt;<i> No, it doesn't.
</I>&gt;<i> &lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; href=&quot;A&quot;&gt; links to a
</I>&gt;<i> syndication feed, not because of the rel=&quot;alternate&quot; or its
</I>&gt;<i> combination with the type=&quot;application/rss+xml&quot;, but just because of
</I>&gt;<i> the type=&quot;application/rss+xml&quot;.
</I>
No, browsers need both to consider it a link to a feed.


&gt;<i> We have a problem with application/atom+xml because it can represent
</I>&gt;<i> either a feed or a standalone entry, but the Atom WG is working on
</I>&gt;<i> this issue (either we'll have a new 'type' parameter:
</I>&gt;<i> application/atom+xml;type=entry, or a new media type:
</I>&gt;<i> application/atom.entry+xml), so Atom won't be any different from RSS.
</I>&gt;<i> And given that I redefine rel=&quot;feed&quot; and feed autodiscovery (see
</I>&gt;<i> below), the above quoted paragraph is no longer appropriate.
</I>
I don't see how.


&gt;<i> &gt; &gt; Remove rel=&quot;feed&quot; or, if you really think it's different from
</I>&gt;<i> &gt; &gt; rel=&quot;index&quot;, define it that way:
</I>&gt;<i> &gt; &gt; &quot;&quot;&quot;The feed keyword indicates that the referenced document is a
</I>&gt;<i> &gt; &gt; syndication feed which is or has been linking to the current page as a
</I>&gt;<i> &gt; &gt; feed item.
</I>&gt;<i> &gt; &gt; For example, in a Web log, a page representing a single entry can link
</I>&gt;<i> &gt; &gt; to the Web log homepage and/or the Web log's Atom or RSS feed using
</I>&gt;<i> &gt; &gt; using the link type feed.&quot;&quot;&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; There are syndication feeds that don't fit this definition.
</I>&gt;<i> 
</I>&gt;<i> Of course yes, and they will be discovered based on the content-type,
</I>&gt;<i> and rel=&quot;&quot; will deserve its real role: describing the relationship
</I>&gt;<i> between the two resources (and not describing the other end of the
</I>&gt;<i> link).
</I>
We don't want to rely on the content type, because that isn't scalable or 
extensible.


&gt;<i> Definition of feed: a bag of items; the representation of a feed
</I>&gt;<i> generally exposes only the 10, or so, latest created or updated items.
</I>&gt;<i> You'll note that this has nothing to do with the feed &quot;format&quot; (Atom,
</I>&gt;<i> RSS, a Web log's homepage in HTML, etc.)
</I>
Exactly.


&gt;<i> If a document was once linked from a feed's representation as an item,
</I>&gt;<i> it is an item of this feed, even if the feed's current representation
</I>&gt;<i> doesn't link to it anymore. The relationship still exists. This
</I>&gt;<i> relationship is &quot;I am an item of this feed&quot; or &quot;this is a feed within
</I>&gt;<i> which I once appeared&quot;. I propose representing it as rel=&quot;feed&quot;.
</I>
But the page might never have been in the feed, as previously discussed.


&gt;<i> &gt; For example, a home page could link to various feeds for things like 
</I>&gt;<i> &gt; planned outages, news, press releases, etc, not all of which might be 
</I>&gt;<i> &gt; on the page itself.
</I>&gt;<i> 
</I>&gt;<i> What do you mean by &quot;might be on the page itself&quot;?
</I>
I mean that the feed might contain items that were never part of the page 
linking to the feed. For example, this page:

   &lt;!DOCTYPE HTML&gt;
   &lt;title&gt;Feeds for this site&lt;/title&gt;
   &lt;link rel=feed href=status.xml&gt;
   &lt;link rel=feed href=news.xml&gt;
   &lt;link rel=feed href=links.xml&gt;
   &lt;p&gt;This page links to the three feeds for this site.

There are no items on that page, but it links to three feeds that the site 
provides.


&gt;<i> Anyway, if you link to something, there's a reason. This reason is that 
</I>&gt;<i> there is a relationship between the current document and the thing the 
</I>&gt;<i> link points to. This relationship is described in the rel=&quot;&quot; attribute.
</I>
Not really. There are many link types these days that don't really 
describe a relationship between documents. nofollow, for example. The 
&quot;real world&quot; has made it clear that sometimes, the &quot;link types&quot; aren't 
actually relationships.


&gt;<i> Is what you want an algorithm for feed autodiscovery?
</I>&gt;<i>
</I>&gt;<i> for each &lt;link&gt; in the document:
</I>&gt;<i>     if @rel=&quot;feed&quot;:
</I>&gt;<i>         if canSubscribeTo(@type)*:
</I>&gt;<i>             add to list of &quot;links to feeds&quot;
</I>&gt;<i>     if isSubscribable(@type)*:
</I>&gt;<i>         add to list of &quot;links to feeds&quot;
</I>&gt;<i> 
</I>&gt;<i> * canSubscribeTo: &lt;link rel=&quot;feed&quot;&gt; could point to an HTML page.
</I>&gt;<i> There's no reason some aggregators couldn't subscribe to it if it uses
</I>&gt;<i> HTML5's &lt;article&gt; or the hAtom microformat, for example. If this is
</I>&gt;<i> the case, canSubscribeTo would return true for &quot;text/html&quot;. @type is
</I>&gt;<i> the type=&quot;&quot; attribute if present, or the Content-Type returned by a
</I>&gt;<i> fetch.
</I>&gt;<i>  * isSubscribable: returns true if the type is any recognized
</I>&gt;<i> &quot;subscribable content type&quot;: RSS  or Atom, but also
</I>&gt;<i> text/vnd.IPTC.NewsML for example. @type is the type=&quot;&quot; attribute if
</I>&gt;<i> present, or the Content-Type returned by a fetch.
</I>
The above is pretty much what the spec says, except that if it _doesn't_ 
have rel=feed, then it isn't added to the list of feeds, because the 
author didn't want it added to the list of feeds for some reason. For 
example, in a browser that thinks text/html is subscribable as you 
suggest, any &lt;link&gt; to an HTML page would count as subscribable, even 
things like copyright licenses. This is clearly not what the author wants, 
and would be bad for usability.


It really isn't clear to me what problem you see with the current spec 
that you are trying to solve. I thought I knew, but your proposals suffer 
from the same problems, so I'm guessing I was wrong.


On Mon, 4 Dec 2006, Michel Fortin wrote:
&gt;<i> 
</I>&gt;<i> I'd like to suggest a possible solution that would address these two issues at
</I>&gt;<i> the same time. The type attributes allows for parameters after the mime type.
</I>&gt;<i> So what about this:
</I>&gt;<i> 
</I>&gt;<i>     &lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml;role=feed&quot; src=&quot;...&quot;&gt;
</I>&gt;<i>     &lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml;role=entry&quot; src=&quot;...&quot;&gt;
</I>&gt;<i>     &lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml;role=edit&quot; src=&quot;...&quot;&gt;
</I>&gt;<i> 
</I>&gt;<i> If the type parameter &quot;role&quot; is not present, &quot;role=feed&quot; would be implied.
</I>
Thomas mentions that this is indeed being considered. It would indeed 
solve the problem.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008389.html">[whatwg] PaceEntryMediatype
</A></li>
	<LI>Next message: <A HREF="008554.html">[whatwg] PaceEntryMediatype
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8416">[ date ]</a>
              <a href="thread.html#8416">[ thread ]</a>
              <a href="subject.html#8416">[ subject ]</a>
              <a href="author.html#8416">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
