<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Video%20source%20selection%20based%20on%20quality%20%28was%3A%20%3Cvideo%3E%0A%09feedback%29&In-Reply-To=%3C2a1386f81002151507t4560a77ctb181b7020cb2ff8f%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="067310.html">
   <LINK REL="Next"  HREF="067420.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)</H1>
<!--htdig_noindex-->
    <B>Hugh Guiney</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Video%20source%20selection%20based%20on%20quality%20%28was%3A%20%3Cvideo%3E%0A%09feedback%29&In-Reply-To=%3C2a1386f81002151507t4560a77ctb181b7020cb2ff8f%40mail.gmail.com%3E"
       TITLE="[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)">hugh.guiney at gmail.com
       </A><BR>
    <I>Mon Feb 15 15:07:16 PST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="067310.html">[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)
</A></li>
        <LI>Next message: <A HREF="067420.html">[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#67419">[ date ]</a>
              <a href="thread.html#67419">[ thread ]</a>
              <a href="subject.html#67419">[ subject ]</a>
              <a href="author.html#67419">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Thanks for your insight Silvia.

On Wed, Feb 10, 2010 at 2:47 AM, Silvia Pfeiffer
&lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">silviapfeiffer1 at gmail.com</A>&gt; wrote:
&gt;<i> Firstly, I think that explicit user choice isn't a problem.
</I>&gt;<i>
</I>&gt;<i> As a content provider, you have several means of doing this user choice:
</I>&gt;<i>
</I>&gt;<i> 1) You can provide in a single (admittedly javascript-based) video
</I>&gt;<i> player interface an option to the user to switch between source files
</I>&gt;<i> of different quality (bitrate, width x height, audio samplerate, and
</I>&gt;<i> whatever other choices you make for differently encoded content).
</I>&gt;<i> This is what YouTube does in their latest players, e.g. 360p / 480p / 720p
</I>&gt;<i> choice (though this is not really a quality measure, but only a
</I>&gt;<i> measure of width x height, but since the display size is not changed
</I>&gt;<i> in YouTube, it actually is a quality setting).
</I>
I can *maybe* see this feature being a video player UI component (more
on why in a bit), though not a JS-based one. I imagine people with
slower computers/connections and/or in more restrictive environments,
who probably stand to benefit the most from this, would be more likely
to have JS off. Additionally, it would require document authors to
take on the responsibility of scripting their own content selection
algorithms (unless there's a standard library that everyone just
copies and pastes), which seems unnecessary given the fact that
resource selection is already capable of being done by the browser
and/or server.

Also, the choices don't *only* measure width x height, but also
indicate of how frames are scanned: &quot;p&quot; for progressive and &quot;i&quot; for
interlaced, which have a direct impact on both file size and perceived
image quality. Although, the label &quot;p&quot; is redundant in YouTube, since
AFAIK, it automatically de-interlaces whatever you upload.

The problems with making this a video UI component are that:

It'd be heavily abbreviated. YouTube is using an industry convention
that has only entered consumer parlance due to HDTV marketing (just
Google &quot;720p vs. 1080i&quot; or &quot;1080p TrueHD&quot;), which ONLY specifies
height and scan type, since the rest of the information is implied due
to engineering and broadcast standards, e.g. 1080p implies 1920x1080
29.97 or 23.976 fps progressive scan; 720p implies the same but at
1280x720. But &quot;360p&quot; doesn't imply anything, because there's no
standard that defines it, and once you hit the SD level (480p and
below), there are two different display sizes depending on the pixel
aspect ratio.

But even if we had a standard, YouTube further dilutes the meaning of
these abbreviations since they now also have a toggle button (depicted
as two arrows at a right angle) that expands or contracts the player
but leaves the quality setting the same. So if you select &quot;360p&quot;, and
decide you want it to fill more of your screen, it will, but then it's
no longer 360 pixels tall because it's been scaled.

The alternative would be to specify the video information in full, or
in a partially-abbreviated form. But then you'd have to cram stuff
like &quot;1920x1080p24 (Scaled to 1280x720)&quot; into the UI, which crowds the
other controls and hinders the viewing experience.

The other thing is that so much goes into video. Yes,

&gt;<i> (bitrate, width x height, audio samplerate
</I>
go into it, but

&gt;<i> whatever other choices you make for differently encoded content).
</I>
covers a huge spectrum, as I previously outlined in the original
thread: &lt;<A HREF="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-December/024520.html">http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-December/024520.html</A>&gt;.

All of this criteria is potentially useful, so maybe the goal for now
should be to prioritize them in the order of importance they'd be to
the average user and implement a high-ranking subset.

&gt;<i> 2) If users log in to use your content, you can ask them to provide a
</I>&gt;<i> default setting, just like YouTube does it in their Account Settings
</I>&gt;<i> (as Hugh describes below).
</I>
This may be fine for video portal sites, but not every page utilizes
logins. Most people just want to share a video they made or like with
their audience, the same way they would an image. And they may be
using a free blogging service that doesn't allow them to implement
additional features. I also find it impractical to require a login
system to be in place just to ask users to select a content quality
preference.

&gt;<i> 3) Even if users don't log in, you can have a button on the side of
</I>&gt;<i> the video (and a once-off splashscreen if you so like), which allows
</I>&gt;<i> users to set and change their preference and leave a cookie to
</I>&gt;<i> remember their choice.
</I>
I'd be OK with cookies as an interim solution but they're not ideal,
since they'd require setting new preferences for every site visited
while the clients' connection and computational speeds would stay more
or less the same.

&gt;<i> All of this is based on the premise that the user either knows what
</I>&gt;<i> their pipe and their computer can take, or experiments with it until
</I>&gt;<i> he/she is happy.
</I>
Well, they don't always have to know off the top of their head. P2P
programs often allow one to run automated tests to estimate the speed
of his/her current connection. If similar functionality were
incorporated into browsers, it could be a &quot;set it and forget it&quot;
experience for those users who do not know. If the resulting video
quality isn't to their liking, and the content author offers
alternatives, the user could adjust the settings as you said and see
if the quality/playback speed tradeoff is worth it to them.

&gt;<i> Secondly, choosing the best video encoding format for a given
</I>&gt;<i> user-server connection (and user device capabilities) is actually a
</I>&gt;<i> really difficult decision to make automatically.
</I>&gt;<i>
</I>&gt;<i> Let's say we declare the quality in the &lt;source&gt; elements in some form
</I>&gt;<i> or other (either an additional attribute or by addition to the media
</I>&gt;<i> queries). Now we have to take this information into account in the
</I>&gt;<i> source selection algorithm, since we are asking the UA to make a
</I>&gt;<i> choice of which media source to use based on the quality information.
</I>&gt;<i> The source selection algorithm goes through the list of &lt;source&gt;
</I>&gt;<i> elements from top to bottom and stops at the first one that it is able
</I>&gt;<i> to play. It does not check whether in that list there would be a
</I>&gt;<i> better choice. Thus, we have to require from authors to build the list
</I>&gt;<i> in a way that the highest quality content is put at the top of the
</I>&gt;<i> list, while lower qualities are put further down.
</I>
Which is why I think it'd ultimately be best to update the source
selection algorithm to function non-linearly. I realize that may be
asking a lot at this stage in the game, but then again, it'd have to
be changed to incorporate quality values anyway.

&gt;<i> For example:
</I>&gt;<i> &lt;video&gt;
</I>&gt;<i> &#160;&lt;source src='video-hd.ogv' media='quality:1.0' type='video/ogg;
</I>&gt;<i> codecs=&quot;theora, vorbis&quot;'&gt;
</I>&gt;<i> &#160;&lt;source src='video-hq.ogv' media='quality:0.5' type='video/ogg;
</I>&gt;<i> codecs=&quot;theora, vorbis&quot;'&gt;
</I>&gt;<i> &#160;&lt;source src='video-sd.ogv' type='video/ogg; codecs=&quot;theora, vorbis&quot;'&gt;
</I>&gt;<i> &lt;/video&gt;
</I>&gt;<i>
</I>&gt;<i> Now, we need to devise an algorithm for UAs to determine which quality
</I>&gt;<i> to choose based on the given computer/device and connection. This is
</I>&gt;<i> not trivial, but let's assume we are able to do so and set
</I>&gt;<i> * quality:1.0 to any connection &gt;5Mbit, CPU &gt; &#160;2GHz, and
</I>&gt;<i> * quality:0.5 to any connection &gt; 1Mbit, CPU &gt; 1.5GHz.
</I>&gt;<i>
</I>&gt;<i> This would be measured once during source selection and thus the
</I>&gt;<i> choice made. But it's actually not a guarantee that it will work. If
</I>&gt;<i> your connection degrades or your CPU gets busy with other
</I>&gt;<i> applications, the choice may need to be revised. YouTube doesn't
</I>&gt;<i> currently allow for this, so this kind of solution would replicate
</I>&gt;<i> what YouTube does at this point - which doesn't seem to be such a bad
</I>&gt;<i> thing, since YouTube is acceptable for most people.
</I>
Let's let the user worry about CPU, RAM, network traffic, etc. If they
have video playback problems after a best available choice has been
made, they can either change their settings, close other applications,
leave the site, or upgrade their computer. None of that can be done
automatically&#8212;well, unless the settings adjusted dynamically,
selecting lesser qualities if the playback speed fell below a certain
point. But I wouldn't ever want to make something like that a required
feature for conformance.

&gt;<i> An improvement over this would be the introduction of an adaptive
</I>&gt;<i> stream scaling scheme over HTTP, similar to e.g. Microsoft's Smooth
</I>&gt;<i> Streaming and Apple's HTTP Live Streaming (also note: Adobe is in the
</I>&gt;<i> process of developing HTTP streaming support). There is no such thing
</I>&gt;<i> available for Ogg yet, but the Ogg community is interested in
</I>&gt;<i> developing/using something that is open and fulfills the needs for
</I>&gt;<i> HTML5. It may well be that an activity should be taken up by the
</I>&gt;<i> WHATWG (or W3C? or IETF?) to develop a media-format independent
</I>&gt;<i> adaptive streaming standard over HTTP. The point about adaptive
</I>&gt;<i> streaming is that it does not require any new HTTP headers to deliver
</I>&gt;<i> the data or any new software on the HTTP server - the choice is made
</I>&gt;<i> client-side by switching between different encodings of the same
</I>&gt;<i> resource on the server. This requires declaration of the available
</I>&gt;<i> alternative files to the client - which could either be done inside
</I>&gt;<i> HTML5 or through some extra resource. Apple's scheme, for example,
</I>&gt;<i> uses m3u-based files (m3u8), while MS's scheme uses SMIL-like files
</I>&gt;<i> (ismv).
</I>&gt;<i>
</I>&gt;<i> Apple's scheme is already going through the IETF for standardisation
</I>&gt;<i> as an informal RFC, but not through a working group. Apple's scheme is
</I>&gt;<i> based on massive creation of small chunks (e.g. 10s duration) on the
</I>&gt;<i> server - an overhead that could possibly be avoided by using W3C Media
</I>&gt;<i> Fragment URIs. There are lots of things to discuss for such an
</I>&gt;<i> activity and the WHATWG may not be the best forum for discussing this
</I>&gt;<i> - though in the end it's up to the browser vendors to implement it, so
</I>&gt;<i> maybe it would.
</I>&gt;<i>
</I>&gt;<i> Note that adaptive HTTP streaming deliberately avoids introducing new
</I>&gt;<i> HTTP parameters and server requirements, because these are really
</I>&gt;<i> difficult to roll out, in particular since they also create new
</I>&gt;<i> requirements on HTTP proxy infrastructure.
</I>
So, it's basically RTSP, only not. That actually sounds perfect for
this, seeing as it wouldn't require much extra work on the part of the
content authors. But, then there's the issue of which scheme to
support; I imagine they're competing? :P

&gt;<i> If we develop such an adaptive streaming approach, the source
</I>&gt;<i> selection algorithm would then select the default resource to stream
</I>&gt;<i> from, while being given the option for adaptive streaming through the
</I>&gt;<i> extra information (e.g. delivered through an extra attribute on the
</I>&gt;<i> &lt;source&gt; elements, e.g. @adaptive=&quot;alternatives.xml&quot;). There could
</I>&gt;<i> then be dynamic switching between the files listed as alternatives in
</I>&gt;<i> the @adaptive file.
</I>
I'd move to specify any extra information in-context or server-side
rather than by reference, simply because if we introduce an XML
settings file, it's one more syntax to learn, and file to host. Maybe
the resource pointed to by &lt;source&gt; is itself the settings file, akin
to an Apache type map. Or @src is a comma-delimited list of fallbacks
like CSS @font* properties.
Or &lt;source&gt; becomes non-empty and we introduce &lt;alternative&gt; allowed
as children elements.

&gt;<i> Incidentally, it may make more sense to expose the actual components
</I>&gt;<i> of &quot;quality&quot; explicitly in media queries, just like they are
</I>&gt;<i> explicitly exposed both in m3u8 and ismv, in particular bandwidth and
</I>&gt;<i> resolution.
</I>&gt;<i>
</I>&gt;<i> Further, it needs to be considered that current media queries (see
</I>&gt;<i> <A HREF="http://dev.w3.org/csswg/css3-mediaqueries/">http://dev.w3.org/csswg/css3-mediaqueries/</A>) are actually NOT about
</I>&gt;<i> defining the features of a given resource, but about defining the
</I>&gt;<i> features of a device. Some of the most relevant queries for a/v are :
</I>&gt;<i> * min/max-device-width/height (rendering surface of output device)
</I>&gt;<i> * min/max-width/height (targeted display area of output device)
</I>&gt;<i> * aspect ratio / device-aspect-ratio
</I>&gt;<i> * min/max-resolution (pixel density of output device)
</I>&gt;<i> * tv / handheld / screen / aural / braille (devices)
</I>&gt;<i>
</I>&gt;<i> Thus, the width/height are already defined through media queries.
</I>&gt;<i> Thus, mainly adding &quot;bitrate&quot; and &quot;CPU&quot; may be sufficient to define
</I>&gt;<i> device qualities to distinguish default loaded media files.
</I>
I'd agree that those two are high-priority, but altogether I think it
would need to cover a bit more than those, namely:
&quot;display-aspect-ratio&quot; (or have &quot;aspect-ratio&quot; defined more explicitly
so that it accounts for pixel aspect ratio), &quot;codec&quot; (and possibly
&quot;container&quot;), and something to account for audio properties&#8212;at the
bare minimum.

&gt;<i> Note that YouTube uses width/height encoding parameters for
</I>&gt;<i> distinguishing between different &quot;quality&quot; video encodings, so the
</I>&gt;<i> media queries parameters width/height could potentially be used here
</I>&gt;<i> in the same way.
</I>
I would stay away from that, for the reasons stated above.
Width/height are insufficient to describe the quality of a video. You
could encode a 1080p video with a really low bitrate and have it come
out smaller than a 480p video with a really high bitrate.

-Hugh

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="067310.html">[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)
</A></li>
	<LI>Next message: <A HREF="067420.html">[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#67419">[ date ]</a>
              <a href="thread.html#67419">[ thread ]</a>
              <a href="subject.html#67419">[ subject ]</a>
              <a href="author.html#67419">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
