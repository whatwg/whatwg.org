<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Video%20source%20selection%20based%20on%20quality%20%28was%3A%20%3Cvideo%3E%0A%09feedback%29&In-Reply-To=%3C2c0e02831002092347g56aac808r2e1633926b9e0e02%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025139.html">
   <LINK REL="Next"  HREF="025146.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)</H1>
<!--htdig_noindex-->
    <B>Silvia Pfeiffer</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Video%20source%20selection%20based%20on%20quality%20%28was%3A%20%3Cvideo%3E%0A%09feedback%29&In-Reply-To=%3C2c0e02831002092347g56aac808r2e1633926b9e0e02%40mail.gmail.com%3E"
       TITLE="[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)">silviapfeiffer1 at gmail.com
       </A><BR>
    <I>Tue Feb  9 23:47:30 PST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="025139.html">[whatwg] &lt;% text %&gt; and &lt;? text ?&gt; in corporate intranet html	content
</A></li>
        <LI>Next message: <A HREF="025146.html">[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25037">[ date ]</a>
              <a href="thread.html#25037">[ thread ]</a>
              <a href="subject.html#25037">[ subject ]</a>
              <a href="author.html#25037">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Wed, Feb 10, 2010 at 1:03 PM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
[..]
&gt;<i> On Sat, 12 Dec 2009, Hugh Guiney wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So, in my first foray into preparing Theora/Vorbis content, for use with
</I>&gt;&gt;<i> &lt;video&gt;, I realized that I wasn't sure with what settings to encode my
</I>&gt;&gt;<i> materials. Should I:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A.) Supply my visitors with the best possible quality at the expense of
</I>&gt;&gt;<i> loading/playback speed for people on slower connections
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> B.) Just account for the lowest common denominator and give everyone a
</I>&gt;&gt;<i> low quality encode
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> or
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> C.) Go halfway and present a medium quality encode acceptable for &quot;most
</I>&gt;&gt;<i> people&quot;?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A. is not legacy-proof, B. is not future-proof, and the C. is neither.
</I>&gt;&gt;<i> C. may sound like the most sensible solution, but even if I were to put
</I>&gt;&gt;<i> up something that worked for &quot;most people&quot; *right now*, as computers
</I>&gt;&gt;<i> become more capable and connections become faster, more visitors are
</I>&gt;&gt;<i> going to want higher-quality videos, meaning I'd have to stay on top of
</I>&gt;&gt;<i> the relevant trends and update my pages accordingly.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ideally, I would like to be able to simply encode a few different
</I>&gt;&gt;<i> quality variations of the same file and serve each version to its
</I>&gt;&gt;<i> corresponding audience.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There are a few ways I could do this. One of the most obvious ways would
</I>&gt;&gt;<i> be to present different versions of the site, e.g. one for &quot;slow
</I>&gt;&gt;<i> connections&quot; and one for &quot;fast connections&quot; and have the user pick via a
</I>&gt;&gt;<i> splash page before entering, as was popular in '90s. But this is almost
</I>&gt;&gt;<i> certainly a faux pas today: it puts a wall between the user and my
</I>&gt;&gt;<i> content, and requires me to maintain two different versions of the site.
</I>&gt;&gt;<i> Hardly efficient.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Another way would be to itemize each version of the file in a list, with
</I>&gt;&gt;<i> details next to them such as frame and file size, so the user could pick
</I>&gt;&gt;<i> accordingly. While this would probably be fine for downloads, it
</I>&gt;&gt;<i> completely defeats the point of embedded media.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Alternatively, I could devise a script that prompts users for their
</I>&gt;&gt;<i> connection speed and/or quality preference, which (assuming they know
</I>&gt;&gt;<i> it) would then go through the available resources on the server and
</I>&gt;&gt;<i> return the version of the file I'd have allocated to that particular
</I>&gt;&gt;<i> response. But that would require either branching for every file
</I>&gt;&gt;<i> alternative of every video on my site in the script&#8212;or specifying the
</I>&gt;&gt;<i> quality in some other way that can be programmatically exploited;
</I>&gt;&gt;<i> perhaps using microdata, but then I'd be stuffing the fallback content
</I>&gt;&gt;<i> with name-value pairs, which isn't particularly accessible.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Or, I could invent my own HTTP header and try to get everyone to use it.
</I>&gt;&gt;<i> Which is a lot to do for something like this, and isn't guaranteed to
</I>&gt;&gt;<i> work.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> None of these options seem particularly viable to me. Right now, the
</I>&gt;&gt;<i> HTML5 spec allows UAs to choose between multiple versions of a media
</I>&gt;&gt;<i> resource based on type. In the interest of making media more accessible
</I>&gt;&gt;<i> to users of varying bandwidth and processing power, and easier to
</I>&gt;&gt;<i> maintain for authors, I propose allowing the relative quality of each
</I>&gt;&gt;<i> resource to be specified for multiple-source media.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You will notice that in Flash animations, there is a context menu option
</I>&gt;&gt;<i> to change the rendered quality between &quot;High&quot;, &quot;Medium&quot;, and &quot;Low&quot;. Each
</I>&gt;&gt;<i> setting degrades or upgrades the picture, and requires less or more
</I>&gt;&gt;<i> computing power to process respectively. Additionally, some Flash video
</I>&gt;&gt;<i> authors elect to construct their own quality selection UI/scripting
</I>&gt;&gt;<i> within the video itself, allowing them to have a finer degree of control
</I>&gt;&gt;<i> over the presentation of the image.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Similarly, YouTube has the ability to switch between standard quality,
</I>&gt;&gt;<i> high quality, and high definition videos based on users' preferences. In
</I>&gt;&gt;<i> the &quot;Playback Setup&quot; section of &quot;Account Settings&quot;, you will find the
</I>&gt;&gt;<i> following options:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &quot;Video Playback Quality
</I>&gt;&gt;<i> Choose the default setting for viewing videos
</I>&gt;&gt;<i> * Choose my video quality dynamically based on the current connection speed.
</I>&gt;&gt;<i> * I have a slow connection. Never play higher-quality video.
</I>&gt;&gt;<i> * I have a fast connection. Always play higher-quality video when it's
</I>&gt;&gt;<i> available.&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If HTML video is to compete with Flash, or become implemented on as
</I>&gt;&gt;<i> wide a scale as YouTube &lt;<A HREF="http://www.youtube.com/html5">http://www.youtube.com/html5</A>&gt;, it makes sense
</I>&gt;&gt;<i> to allow for some sort of quality choice mechanism, as users will have
</I>&gt;&gt;<i> come to expect that functionality.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This could be done by allowing an attribute on &lt;source&gt; elements that
</I>&gt;&gt;<i> takes a relative value, such as (or similar to) those specified in
</I>&gt;&gt;<i> HTTP &lt;<A HREF="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9">http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9</A>&gt;.
</I>&gt;&gt;<i> This attribute could be called &quot;quality&quot; or &quot;qvalue&quot; or just &quot;q&quot; (my
</I>&gt;&gt;<i> personal preference would be it that order decreasing), and be used as
</I>&gt;&gt;<i> such:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &lt;video controls&gt;
</I>&gt;&gt;<i> &#160; &lt;source src='video-hd.ogv' quality='1.0' type='video/ogg;
</I>&gt;&gt;<i> codecs=&quot;theora, vorbis&quot;'&gt;
</I>&gt;&gt;<i> &#160; &lt;source src='video-hq.ogv' quality='0.5' type='video/ogg;
</I>&gt;&gt;<i> codecs=&quot;theora, vorbis&quot;'&gt;
</I>&gt;&gt;<i> &#160; &lt;source src='video-sd.ogv' type='video/ogg; codecs=&quot;theora, vorbis&quot;'&gt;
</I>&gt;&gt;<i> &lt;/video&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In this case, video-hd.ogv (a high definition encode) would be the
</I>&gt;&gt;<i> author's preferred version, video-hq.ogv (a high quality standard
</I>&gt;&gt;<i> definition encode) would be less preferred than video-hd.ogv, but more
</I>&gt;&gt;<i> preferred than video-sd, and video-sd (a standard definition encode)
</I>&gt;&gt;<i> would be less preferred than both, since it lacks a quality attribute
</I>&gt;&gt;<i> and would thus be the equivalent of specifying &quot;quality='0.001'&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The UA could then have a playback setup that would allow the user to
</I>&gt;&gt;<i> specify how it should handle content negotiation for multiple-source
</I>&gt;&gt;<i> media. This could be based solely on the quality attribute if provided,
</I>&gt;&gt;<i> or if @type is also provided, also based on what content-type the user
</I>&gt;&gt;<i> prefers.
</I>&gt;<i>
</I>&gt;<i> Thank you for this detailed problem description and discussion of a
</I>&gt;<i> suggested solution.
</I>&gt;<i>
</I>&gt;<i> I think my recommendation would be something similar to what you suggest
</I>&gt;<i> above regarding an HTTP header, but more specific to the Content-Type
</I>&gt;<i> header: a new MIME parameter similar to &quot;codecs&quot; that describes the power
</I>&gt;<i> needed for playback, in terms of network bandwidth, CPU, etc. This could
</I>&gt;<i> just be boiled down to a number, e.g. &quot;1&quot; for today's &quot;low&quot; and &quot;2&quot; for
</I>&gt;<i> today's &quot;high&quot;, with the number being increased over the years as we get
</I>&gt;<i> better and better.
</I>&gt;<i>
</I>&gt;<i> Alternatively, we could extend Media Queries to specify the kind of CPU
</I>&gt;<i> and bandwidth expected to be needed for a media resource. This would fit
</I>&gt;<i> right into the Media Queries model.
</I>&gt;<i>
</I>&gt;<i> Or, of course, we could add an attribute to &lt;source&gt;, as you suggest.
</I>&gt;<i>
</I>&gt;<i> The best thing to do is to approach browser vendors directly (e.g. on
</I>&gt;<i> their relevant mailing lists, like webkit-dev for WebKit, or the Mozilla
</I>&gt;<i> newsgroups for Firefox), and see if they would be interested in doing
</I>&gt;<i> something like this. The WHATWG FAQ gives some detail on this:
</I>&gt;<i>
</I>&gt;<i> &#160; <A HREF="http://wiki.whatwg.org/wiki/FAQ#Is_there_a_process_for_adding_new_features_to_a_specification.3F">http://wiki.whatwg.org/wiki/FAQ#Is_there_a_process_for_adding_new_features_to_a_specification.3F</A>
</I>

I've taken one particular issue out of the large feedback thread of
Ian (which, incidentally, I found a most interesting read).

I'd like to address the issue video source selection where a content
provider wants to stream the best quality video to the user based
either on maximising use of the pipe between him and the user, or
based on explicit user choice.


Firstly, I think that explicit user choice isn't a problem.

As a content provider, you have several means of doing this user choice:

1) You can provide in a single (admittedly javascript-based) video
player interface an option to the user to switch between source files
of different quality (bitrate, width x height, audio samplerate, and
whatever other choices you make for differently encoded content). This
is what YouTube does in their latest players, e.g. 360p / 480p / 720p
choice (though this is not really a quality measure, but only a
measure of width x height, but since the display size is not changed
in YouTube, it actually is a quality setting).

2) If users log in to use your content, you can ask them to provide a
default setting, just like YouTube does it in their Account Settings
(as Hugh describes below).

3) Even if users don't log in, you can have a button on the side of
the video (and a once-off splashscreen if you so like), which allows
users to set and change their preference and leave a cookie to
remember their choice.

All of this is based on the premise that the user either knows what
their pipe and their computer can take, or experiments with it until
he/she is happy.


Secondly, choosing the best video encoding format for a given
user-server connection (and user device capabilities) is actually a
really difficult decision to make automatically.

Let's say we declare the quality in the &lt;source&gt; elements in some form
or other (either an additional attribute or by addition to the media
queries). Now we have to take this information into account in the
source selection algorithm, since we are asking the UA to make a
choice of which media source to use based on the quality information.
The source selection algorithm goes through the list of &lt;source&gt;
elements from top to bottom and stops at the first one that it is able
to play. It does not check whether in that list there would be a
better choice. Thus, we have to require from authors to build the list
in a way that the highest quality content is put at the top of the
list, while lower qualities are put further down.

For example:
&lt;video&gt;
  &lt;source src='video-hd.ogv' media='quality:1.0' type='video/ogg;
codecs=&quot;theora, vorbis&quot;'&gt;
  &lt;source src='video-hq.ogv' media='quality:0.5' type='video/ogg;
codecs=&quot;theora, vorbis&quot;'&gt;
  &lt;source src='video-sd.ogv' type='video/ogg; codecs=&quot;theora, vorbis&quot;'&gt;
&lt;/video&gt;

Now, we need to devise an algorithm for UAs to determine which quality
to choose based on the given computer/device and connection. This is
not trivial, but let's assume we are able to do so and set
* quality:1.0 to any connection &gt;5Mbit, CPU &gt;  2GHz, and
* quality:0.5 to any connection &gt; 1Mbit, CPU &gt; 1.5GHz.

This would be measured once during source selection and thus the
choice made. But it's actually not a guarantee that it will work. If
your connection degrades or your CPU gets busy with other
applications, the choice may need to be revised. YouTube doesn't
currently allow for this, so this kind of solution would replicate
what YouTube does at this point - which doesn't seem to be such a bad
thing, since YouTube is acceptable for most people.

An improvement over this would be the introduction of an adaptive
stream scaling scheme over HTTP, similar to e.g. Microsoft's Smooth
Streaming and Apple's HTTP Live Streaming (also note: Adobe is in the
process of developing HTTP streaming support). There is no such thing
available for Ogg yet, but the Ogg community is interested in
developing/using something that is open and fulfills the needs for
HTML5. It may well be that an activity should be taken up by the
WHATWG (or W3C? or IETF?) to develop a media-format independent
adaptive streaming standard over HTTP. The point about adaptive
streaming is that it does not require any new HTTP headers to deliver
the data or any new software on the HTTP server - the choice is made
client-side by switching between different encodings of the same
resource on the server. This requires declaration of the available
alternative files to the client - which could either be done inside
HTML5 or through some extra resource. Apple's scheme, for example,
uses m3u-based files (m3u8), while MS's scheme uses SMIL-like files
(ismv).

Apple's scheme is already going through the IETF for standardisation
as an informal RFC, but not through a working group. Apple's scheme is
based on massive creation of small chunks (e.g. 10s duration) on the
server - an overhead that could possibly be avoided by using W3C Media
Fragment URIs. There are lots of things to discuss for such an
activity and the WHATWG may not be the best forum for discussing this
- though in the end it's up to the browser vendors to implement it, so
maybe it would.

Note that adaptive HTTP streaming deliberately avoids introducing new
HTTP parameters and server requirements, because these are really
difficult to roll out, in particular since they also create new
requirements on HTTP proxy infrastructure.

If we develop such an adaptive streaming approach, the source
selection algorithm would then select the default resource to stream
from, while being given the option for adaptive streaming through the
extra information (e.g. delivered through an extra attribute on the
&lt;source&gt; elements, e.g. @adaptive=&quot;alternatives.xml&quot;). There could
then be dynamic switching between the files listed as alternatives in
the @adaptive file.

Incidentally, it may make more sense to expose the actual components
of &quot;quality&quot; explicitly in media queries, just like they are
explicitly exposed both in m3u8 and ismv, in particular bandwidth and
resolution.

Further, it needs to be considered that current media queries (see
<A HREF="http://dev.w3.org/csswg/css3-mediaqueries/">http://dev.w3.org/csswg/css3-mediaqueries/</A>) are actually NOT about
defining the features of a given resource, but about defining the
features of a device. Some of the most relevant queries for a/v are :
* min/max-device-width/height (rendering surface of output device)
* min/max-width/height (targeted display area of output device)
* aspect ratio / device-aspect-ratio
* min/max-resolution (pixel density of output device)
* tv / handheld / screen / aural / braille (devices)

Thus, the width/height are already defined through media queries.
Thus, mainly adding &quot;bitrate&quot; and &quot;CPU&quot; may be sufficient to define
device qualities to distinguish default loaded media files.

Note that YouTube uses width/height encoding parameters for
distinguishing between different &quot;quality&quot; video encodings, so the
media queries parameters width/height could potentially be used here
in the same way.

Regards,
Silvia.
</PRE>











































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025139.html">[whatwg] &lt;% text %&gt; and &lt;? text ?&gt; in corporate intranet html	content
</A></li>
	<LI>Next message: <A HREF="025146.html">[whatwg] Video source selection based on quality (was: &lt;video&gt;	feedback)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25037">[ date ]</a>
              <a href="thread.html#25037">[ thread ]</a>
              <a href="subject.html#25037">[ subject ]</a>
              <a href="author.html#25037">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
