<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Storage mutex
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Storage%20mutex&In-Reply-To=%3Cbd8f24d20908260049q49242fabyd009f7608de0c608%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="064598.html">
   <LINK REL="Next"  HREF="064610.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Storage mutex</H1>
<!--htdig_noindex-->
    <B>Darin Fisher</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Storage%20mutex&In-Reply-To=%3Cbd8f24d20908260049q49242fabyd009f7608de0c608%40mail.gmail.com%3E"
       TITLE="[whatwg] Storage mutex">darin at google.com
       </A><BR>
    <I>Wed Aug 26 00:49:31 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="064598.html">[whatwg] Storage mutex
</A></li>
        <LI>Next message: <A HREF="064610.html">[whatwg] Storage mutex
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#64591">[ date ]</a>
              <a href="thread.html#64591">[ thread ]</a>
              <a href="subject.html#64591">[ subject ]</a>
              <a href="author.html#64591">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Sun, Aug 23, 2009 at 11:33 PM, Robert O'Callahan &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">robert at ocallahan.org</A>&gt;wrote:

&gt;<i> On Sat, Aug 22, 2009 at 10:22 PM, Jeremy Orlow &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jorlow at chromium.org</A>&gt;wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> On Sat, Aug 22, 2009 at 5:54 AM, Robert O'Callahan &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">robert at ocallahan.org</A>&gt;wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On Wed, Aug 19, 2009 at 11:26 AM, Jeremy Orlow &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jorlow at chromium.org</A>&gt;wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> First of all, I was wondering why all user prompts are specified as
</I>&gt;&gt;&gt;&gt;<i> &quot;must release the storage mutex&quot; (
</I>&gt;&gt;&gt;&gt;<i> <A HREF="http://dev.w3.org/html5/spec/Overview.html#user-prompts">http://dev.w3.org/html5/spec/Overview.html#user-prompts</A>).  Should this
</I>&gt;&gt;&gt;&gt;<i> really say &quot;must&quot; instead of &quot;may&quot;?  IIRC (I couldn't find the original
</I>&gt;&gt;&gt;&gt;<i> thread, unfortunately) this was added because of deadlock concerns.  It
</I>&gt;&gt;&gt;&gt;<i> seems like there might be some UA implementation specific ways this could
</I>&gt;&gt;&gt;&gt;<i> deadlock and there is the question of whether we'd want an alert() while
</I>&gt;&gt;&gt;&gt;<i> holding the lock to block other execution requiring the lock, but I don't
</I>&gt;&gt;&gt;&gt;<i> see why the language should be &quot;must&quot;.  For Chromium, I don't think we'll
</I>&gt;&gt;&gt;&gt;<i> need to release the lock for any of these, unless there's some
</I>&gt;&gt;&gt;&gt;<i> deadlock scenario I'm missing here.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So if one page grabs the lock and then does an alert(), and another page
</I>&gt;&gt;&gt;<i> in the same domain tries to get the lock, you're going to let the latter
</I>&gt;&gt;&gt;<i> page hang until the user dismisses the alert in the first page?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes.  And I agree this is sub-optimal, but shouldn't it be left up to the
</I>&gt;&gt;<i> UAs what to do?  I feel like this is somewhat of an odd case to begin with
</I>&gt;&gt;<i> since alerts lock up most (all?) browsers to a varying degrees even without
</I>&gt;&gt;<i> using localStorage.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That behaviour sounds worse than what Firefox currently does, where an
</I>&gt;<i> alert disables input to all tabs in the window (which is already pretty
</I>&gt;<i> bad), because it willl make applications in visually unrelated tabs and
</I>&gt;<i> windows hang.
</I>&gt;<i>
</I>
You can have script connections that span multiple tabs in multiple windows,
so in order to preserve the run-to-completion semantics of JavaScript, it is
important that window.{alert,confirm,prompt,showModalDialog} be modal across
all windows in the browser.  This is why those APIs suck rocks, and we
should never create APIs like them again.



&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>  Given that different UAs are probably going to have
</I>&gt;&gt;&gt;&gt;<i> other scenarios where they have to drop the lock (some of them may even be
</I>&gt;&gt;&gt;&gt;<i> purely implementational issues), should we add some way for us to notify
</I>&gt;&gt;&gt;&gt;<i> scripts the lock was dropped?  A normal event isn't going to be of much use,
</I>&gt;&gt;&gt;&gt;<i> since it'll fire after the scripts execution ends (so the lock would have
</I>&gt;&gt;&gt;&gt;<i> been dropped by then anyway).  A boolean doesn't seem super useful, but it's
</I>&gt;&gt;&gt;&gt;<i> better than nothing and could help debugging.  Maybe fire an exception?  Are
</I>&gt;&gt;&gt;&gt;<i> there other options?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> A generation counter might be useful.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Ooo, I like that idea.  When would the counter increment?  It'd be nice if
</I>&gt;&gt;<i> it didn't increment if the page did something synchronous but no one else
</I>&gt;&gt;<i> took the lock in the mean time.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Defining &quot;no-one else&quot; may be difficult. I haven't thought this through, to
</I>&gt;<i> be honest, but I think you could update the counter every time the storage
</I>&gt;<i> mutex is released and the shared state was modified since the storage mutex
</I>&gt;<i> was acquired. Reading the counter would acquire the storage mutex. You'd
</I>&gt;<i> basically write
</I>&gt;<i>
</I>&gt;<i> var counter = window.storageMutexGenerationCounter;
</I>&gt;<i> ... do lots of stuff ...
</I>&gt;<i> if (window.storageMutexGenerationCounter != counter) {
</I>&gt;<i>   // abort, or refresh local state, or something
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> I'm not sure what you'd do if you discovered an undesired lock-drop,
</I>&gt;<i> though. If you can't write something sensible instead of &quot;abort, or
</I>&gt;<i> something&quot;, it's not worth doing.
</I>&gt;<i>
</I>
Implementation-wise, the easiest thing to support is a boolean that becomes
true when the lock is release and false when the lock is acquired.  Trying
to update a counter based on modifications to the local storage backend
which may be happening on another thread seems like more effort than it is
worth.

But, what would you call this boolean?  storageMayHaveBeenUpdated? :-P

I'm struggling to find a good use case for this.



&gt;<i>
</I>&gt;<i>  But getStorageUpdates is still not the right name for it.  The only way
</I>&gt;&gt;<i> that there'd be any updates to get is if, when you call the function,
</I>&gt;&gt;<i> someone else takes the lock and makes some updates.  Maybe it should be
</I>&gt;&gt;<i> yieldStorage (or yieldStorageMutex)?  In other words, maybe the name should
</I>&gt;&gt;<i> imply that you're allowing concurrent updates to happen?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I thought that's what getStorageUpdates implied :-).
</I>&gt;<i>
</I>&gt;<i>
</I>The getStorageUpdates name seems pretty decent to me when considering it
from the perspective of the caller.  The caller is saying that they are OK
with being able to see changes made to the localStorage by &quot;other threads.&quot;
 This cleverly avoids the need to talk about locks, which seems like a good
thing.  It is okay for there to be no updates to storage.

-Darin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20090826/098cc189/attachment-0002.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20090826/098cc189/attachment-0002.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="064598.html">[whatwg] Storage mutex
</A></li>
	<LI>Next message: <A HREF="064610.html">[whatwg] Storage mutex
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#64591">[ date ]</a>
              <a href="thread.html#64591">[ thread ]</a>
              <a href="subject.html#64591">[ subject ]</a>
              <a href="author.html#64591">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
