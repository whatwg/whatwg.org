<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Web Storage: apparent contradiction in spec
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Web%20Storage%3A%20apparent%20contradiction%20in%20spec&In-Reply-To=%3Cd62cf1d10908261621x35e8f68bn99da1f84d4e1c59b%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="064620.html">
   <LINK REL="Next"  HREF="064622.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Web Storage: apparent contradiction in spec</H1>
<!--htdig_noindex-->
    <B>Peter Kasting</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Web%20Storage%3A%20apparent%20contradiction%20in%20spec&In-Reply-To=%3Cd62cf1d10908261621x35e8f68bn99da1f84d4e1c59b%40mail.gmail.com%3E"
       TITLE="[whatwg] Web Storage: apparent contradiction in spec">pkasting at google.com
       </A><BR>
    <I>Wed Aug 26 16:21:45 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="064620.html">[whatwg] Web Storage: apparent contradiction in spec
</A></li>
        <LI>Next message: <A HREF="064622.html">[whatwg] Web Storage: apparent contradiction in spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#64621">[ date ]</a>
              <a href="thread.html#64621">[ thread ]</a>
              <a href="subject.html#64621">[ subject ]</a>
              <a href="author.html#64621">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Wed, Aug 26, 2009 at 4:01 PM, Linus Upson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">linus at google.com</A>&gt; wrote:

&gt;<i> The analogy was made comparing a user agent that purges local storage to an
</I>&gt;<i> OS throwing out files without explicit user action. This is misleading since
</I>&gt;<i> most files arrive on your computer's disk via explicit user action. You copy
</I>&gt;<i> files to your disk by downloading them from the internet, copying from a
</I>&gt;<i> network drive, from a floppy, your camera, etc. You put them on your disk
</I>&gt;<i> and you are responsible for removing them to reclaim space.
</I>&gt;<i>
</I>&gt;<i> There are apps that create files in hidden places such as:
</I>&gt;<i>
</I>&gt;<i> C:\Documents and Settings\linus\Local Settings\Application
</I>&gt;<i> Data\Google\Chrome\User Data
</I>&gt;<i>
</I>&gt;<i> If those apps do not manage their space carefully, users get annoyed. If
</I>&gt;<i> such an app filled the user's disk they would have no idea what consumed the
</I>&gt;<i> space or how to reclaim it. They didn't put the files there. How are they
</I>&gt;<i> supposed to know to remove them? Most users have no idea that Local Settings
</I>&gt;<i> exists (it is hidden), much less how to correctly manage any files they
</I>&gt;<i> find.
</I>&gt;<i>
</I>
This seems like an argument for ensuring web apps have as much ability to
take reasonable steps to control their space usage as local apps do, not an
argument that the UA should be able to discard those files.  After all, you
are not arguing that Windows should be able to throw away those
non-user-visible files in Local Storage.

Without automatic space management the local storage consumed will grow
&gt;<i> without bound. I'm concerned that even without an intentional DOS attack
</I>&gt;<i> users are going to be unhappy about their shrinking disks and not know what
</I>&gt;<i> to do about it. The problem is worse on phones.
</I>&gt;<i>
</I>
I don't think anyone is suggesting UAs should not have the ability to
control the total space usage, e.g. by presetting per-app and global quotas.
 That's not the same as saying that the UA can throw away data after the
fact.

Things get worse still if a griefer wants to make a point about the
&gt;<i> importance of keeping web browsers logically stateless. Here's how such an
</I>&gt;<i> attack could be carried out:
</I>&gt;<i>
</I>&gt;<i> 2a. Acquire a bunch of unrelated domains from a bunch of registrars using
</I>&gt;<i> stolen credit cards. Skip this step if UAs don't group subdomains under the
</I>&gt;<i> same storage quota. For extra credit pick names that are similar to
</I>&gt;<i> legitimate sites that use local storage.
</I>&gt;<i>
</I>&gt;<i> 2b. Start up some web hosting accounts. Host your attack code here. If they
</I>&gt;<i> aren't free, use stolen credit cards.
</I>&gt;<i>
</I>&gt;<i> 2c. Buy ads from a network that subsyndicates from a network that
</I>&gt;<i> subsyndicates from a major ad network that allows 3rd party ad serving.
</I>&gt;<i> There are lots to choose from. No money? Stolen credit cards. Serve the ads
</I>&gt;<i> from your previously acquired hosting accounts.
</I>&gt;<i>
</I>&gt;<i> 2d. Giggle. The user will be faced with the choice of writing off the
</I>&gt;<i> space, deleting everything including their precious data, or carefully
</I>&gt;<i> picking though tens of thousands of entries to find the few domains that
</I>&gt;<i> hold precious content. User gets really unhappy if the attack managed to
</I>&gt;<i> fill the disk.
</I>&gt;<i>
</I>
I'm not sure why this is more compelling for a griefer than the existing
attack (along similar lines) they can already make against the cookie store
to blow away 100% of the user's cookies, and keep doing it, such that the
user can never log in anywhere.  In fact, to some degree that's a testimony
that treating things &quot;like cookies&quot; doesn't mean users will be free from
griefing.

In practice I don't foresee either of these happening unless doing so allows
attackers monetary gain.

Chrome's Incognito mode creates a temporary, in-memory profile. Local
&gt;<i> storage operations will work, but nothing will be saved after the Incognito
</I>&gt;<i> window is closed. Safari takes a different approach and causes local storage
</I>&gt;<i> operations to fail when in Private Browsing mode. Some sites won't work in
</I>&gt;<i> Private Browsing. I don't recall what Firefox or IE do. Pick your poison.
</I>&gt;<i>
</I>
This is a problem that has to be solved regardless, and it doesn't seem like
a bad one.  If the purpose of section 6.1 is to state that UAs must give
users the ability to see and clean up their Local Storage data (which seems
to me like a good idea but outside the scope of what HTML5 should be
specifying), then users have the ability to manually delete this data
anyway, and live with the consequences.  Chrome's behavior is akin to a user
manually clearing his Local Storage data, and Safari's is akin to an app
hitting its quota.  Apps have to be able to deal with both anyway, perhaps
with a (possibly large) reduction in functionality.

While that may sound like an argument for your position (since I am saying
that apps need to deal with disappearing Local Storage data), the critical
difference is that the user is in control of this, either by cleaning up the
data manually or by electing to use a private browsing mode.  Thus I don't
think it justifies some UA behavior when the user is _not_ in explicit
control.

If the spec requires UAs to maintain local storage as 'precious' it will be
&gt;<i> the first such feature in HTML 5. Everything else in the spec is treated as
</I>&gt;<i> volatile.
</I>&gt;<i>
</I>
To use a very poor analogy, if one thinks of Local Storage like a &quot;hard
drive&quot; where the JS execution context is &quot;RAM&quot;, authors expect that their
scripts won't fail because variables suddenly lose state.  VMs are allowed
to garbage-collect, but not to collect live data.  In this (admittedly
awkward) sense, RAM is not &quot;volatile&quot;, why should the hard drive be?

It seems like your main concerns are around the potential damage to users by
poorly-written or malicious applications that store a lot of data.  I don't
see why quota policies don't address this sufficiently.  That is, the spec
can allow the UA to set whatever quotas it likes, and provide users with
whatever UI it wants to expand them, but failure to write due to hitting
quota should behave in a well-defined way, apps should be able to determine
that they are using a lot of storage space and clean up somewhat, and data
successfully stored won't be thrown away without explicit user action.

PK
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20090826/2a98223d/attachment-0002.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20090826/2a98223d/attachment-0002.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="064620.html">[whatwg] Web Storage: apparent contradiction in spec
</A></li>
	<LI>Next message: <A HREF="064622.html">[whatwg] Web Storage: apparent contradiction in spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#64621">[ date ]</a>
              <a href="thread.html#64621">[ thread ]</a>
              <a href="subject.html#64621">[ subject ]</a>
              <a href="author.html#64621">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
