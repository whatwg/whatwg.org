<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Processing the zoom level - MS extensions to	window.screen
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Processing%20the%20zoom%20level%20-%20MS%20extensions%20to%0A%09window.screen&In-Reply-To=%3C4CEA3C55.3030103%40jumis.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="071367.html">
   <LINK REL="Next"  HREF="071369.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Processing the zoom level - MS extensions to	window.screen</H1>
<!--htdig_noindex-->
    <B>Charles Pritchard</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Processing%20the%20zoom%20level%20-%20MS%20extensions%20to%0A%09window.screen&In-Reply-To=%3C4CEA3C55.3030103%40jumis.com%3E"
       TITLE="[whatwg] Processing the zoom level - MS extensions to	window.screen">chuck at jumis.com
       </A><BR>
    <I>Mon Nov 22 01:48:05 PST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="071367.html">[whatwg] Processing the zoom level - MS extensions to	window.screen
</A></li>
        <LI>Next message: <A HREF="071369.html">[whatwg] Processing the zoom level - MS extensions	to	window.screen
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#71368">[ date ]</a>
              <a href="thread.html#71368">[ thread ]</a>
              <a href="subject.html#71368">[ subject ]</a>
              <a href="author.html#71368">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On 11/22/10 12:30 AM, Robert O'Callahan wrote:
&gt;<i> On Mon, Nov 22, 2010 at 8:49 PM, Charles Pritchard &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">chuck at jumis.com</A> 
</I>&gt;<i> &lt;mailto:<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">chuck at jumis.com</A>&gt;&gt; wrote:
</I>&gt;<i>
</I>&gt;<i>     On 11/21/10 10:51 PM, Robert O'Callahan wrote:
</I>&gt;&gt;<i>     On Mon, Nov 22, 2010 at 6:22 PM, Charles Pritchard
</I>&gt;&gt;<i>     &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">chuck at jumis.com</A> &lt;mailto:<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">chuck at jumis.com</A>&gt;&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         I've a deep and detailed understanding of the SVG, HTML, DOM
</I>&gt;&gt;<i>         and CSS specs.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     Just out of interest, why aren't you using SVG?
</I>&gt;<i>     Many thanks for the SVG Filter Effect CSS extension.
</I>&gt;<i>     I'd like to see that catch on with other vendors.
</I>&gt;<i>
</I>&gt;<i>     Implementations of SVG are uneven and/or slow:
</I>&gt;<i>
</I>&gt;<i>     Example: SVG Filter Effect + with an animated rotate in FF 3
</I>&gt;<i>     (excuse me if this is dated)
</I>&gt;<i>     was quite slow, though the SVG FE implementation is faster than
</I>&gt;<i>     CanvasPixelArray.
</I>&gt;<i>     It's also tricky, getting SVG FE turned on (for me anyway), with
</I>&gt;<i>     the xhtml mime requirements.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That doesn't really explain why you're using canvas, if SVG is faster 
</I>&gt;<i> than canvas for your effect.
</I>I wasn't able to &quot;freeze&quot; the composition of the SVG layer. Upon 
rotation, the SVG layer re-filters the image,
it re-runs the filter effect on each rotation. With canvas, I simply 
re-draw the filtered image
into the rotation.

I don't mean to get caught up in particular platform quirks. It's been a 
few months since I've
addressed SVG ones. SVG FE afaik, was only in FF 3.6 w/ strict reqs.

We target several browsers; so regardless of the merits of SVG in FF 
3.6, we still try to support
FF 3.0 and other legacy browsers and non-gecko browsers.

Simply, Canvas is less expensive to implement, and I'm sure far fewer 
LOC than SVG,
so it's uptake was reasonably quick, and adding it to a new platform is 
reasonably quick.

&gt;<i>
</I>&gt;<i>     For both performance and compatibility reasons, we've had to write
</I>&gt;<i>     low level code anyway.
</I>&gt;<i>     Actual display calls (be they SVG-able or not) are a relatively
</I>&gt;<i>     small part of our app.
</I>&gt;<i>
</I>&gt;<i>     I'm currently focused on interchangeability of our HTML and Canvas
</I>&gt;<i>     profiles.
</I>&gt;<i>     Many SVG features are available via CSS now: paint servers and
</I>&gt;<i>     gradients,
</I>&gt;<i>     rounded rectangles, some text effects.
</I>&gt;<i>
</I>&gt;<i>     Because of that, we're focused on HTML.
</I>&gt;<i>     SVG FE is definitely in our code base as a rendering option.
</I>&gt;<i>     We store our iconography in SVG, and some basic glyphs.
</I>&gt;<i>     We use canvas to render the glyphs, and we pre-render our
</I>&gt;<i>     iconography into png.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It's important to separate the issues that are fixable implementation 
</I>&gt;<i> limitations from those issues that are fundamental to the design of 
</I>&gt;<i> Web standards. There is no point in adding new platform features to 
</I>&gt;<i> work around implementation limitations; we get a simpler platform if 
</I>&gt;<i> implementors just fix the existing features.
</I>&gt;<i>
</I>&gt;<i> So, for example, I wouldn't want to add canvas features to address 
</I>&gt;<i> use-cases for which SVG would work well if it was a bit better 
</I>&gt;<i> implemented.
</I>My attention is still on exposing metrics so I can repaint to the device 
resolution, fully within the existing standard. I don't want to change a 
thing about CSS/Canvas; just looking for some data to be available in 
the DOM.

It's a DOM deficiency in relation to the canvas tag.
Google Books demonstrates a use case apart from Canvas. They don't need 
to override the browser's zoom. They do provide their own icon. If the 
browser did provide
information, about zoom, they could send a higher resolution image to 
the browser for that portion.

Here's a good, short, example of an SVG/WebGL+Canvas+HTML+CSS profile:
[canvas style=&quot;filter: url(#myPixelFilter); scale(.5,.5)&quot;]
Everything is doing exactly what it should.

My only active proposal for the canvas spec is exposing a baseline 
property in TextMetrics. textBaseline is insufficient on its own.
&gt;<i>
</I>&gt;&gt;<i>     I understand the need to make canvas backing store pixels map to
</I>&gt;&gt;<i>     device pixels when possible. Suppose that, on clearing the canvas
</I>&gt;&gt;<i>     (e.g. by setting the width or height attribute), the browser
</I>&gt;&gt;<i>     automatically set the canvas backing store density so that canvas
</I>&gt;&gt;<i>     backing store pixels map to device pixels (taking into account
</I>&gt;&gt;<i>     the current zoom settings). Suppose further that browsers fired
</I>&gt;&gt;<i>     the 'resize' event when they zoom in a way that changes the
</I>&gt;&gt;<i>     window size (as they should, even if they currently don't). Then
</I>&gt;&gt;<i>     on 'resize' you could clear your canvas and redraw it, and
</I>&gt;&gt;<i>     automatically get a canvas backing store with the right
</I>&gt;&gt;<i>     resolution with no further code changes. Would that address your
</I>&gt;&gt;<i>     use case?
</I>&gt;<i>     I appreciate your understanding, and your brainstorming.
</I>&gt;<i>
</I>&gt;<i>     We currently use downsampled images within our application, and
</I>&gt;<i>     this proposal would override them We use them where filter effects
</I>&gt;<i>     are live, and are too expensive for the host to process quickly.
</I>&gt;<i>     Sampling is also useful as a memory management technique. On a
</I>&gt;<i>     resource constrained device, for whatever reason, it can make
</I>&gt;<i>     sense to draw the canvas at a smaller size, even though upscaling
</I>&gt;<i>     is noticable.
</I>&gt;<i>
</I>&gt;<i>     With a complex gui / canvas drawing, redrawing the image may take
</I>&gt;<i>     some time. During zoom events, I can use a setTimeout to wait for
</I>&gt;<i>     the browser to settle before redrawing at higher resolution. CSS
</I>&gt;<i>     automates everything for me. It works wonderfully.
</I>&gt;<i>
</I>&gt;<i>     Generally, with Canvas, things should not be automated. It's the
</I>&gt;<i>     CSS that's automated.
</I>&gt;<i>     Think of CSS as sending GPU instructions, and Canvas as simply
</I>&gt;<i>     updating a texture within the GPU.
</I>&gt;<i>
</I>...
&gt;<i>
</I>&gt;<i>     I was able to support resolution scaling on a complex application
</I>&gt;<i>     with less than an hour of work. It took me longer to test
</I>&gt;<i>     compatibility between browsers,
</I>&gt;<i>     for the hacks I used to try and get the DPI Scale values.
</I>&gt;<i>
</I>&gt;<i> It sounds to me like the approach I described would work for you.
</I>
It would be a non-standard extension to canvas that I would have to 
write additional code to support. It would create more complexity for 
the other browsers to add to their implementations. It may alter 
ImageData or otherwise require more overhead for CanvasPixelArray 
manipulation, slowing things down.

I would have to check my backing size before redrawing, to gain control 
again. It would effectively require more data lookups and a storage 
table (in script) so I know which elements have which backing 
resolution.  We do have cases where we want our backing store to be 
different than the native resolution; these are typically related to 
rendering speed/responsiveness. Some use cases are related to memory 
management.

Your proposal would 'fix' existing apps written in canvas, ones at least 
that weren't designed with pixel ratio in mind. But I don't think it's 
necessary, and it would create more work for apps that do want to use 
pixel ratio data, as well as suggesting more work to canvas implementers 
in other browsers. It does make some sense as a CSS extension, which 
would be turned off by default. Having a toggle, and having it off by 
default would address all of my concerns about the proposal.

The method you've proposed is something that should be brought up to the 
SVG working group in relation to future SVG + Canvas interoperability. 
They're looking to extend the SVG standard, to bring in lessons from 
Canvas. Within the context of an SVG scene graph and a new draft of SVG, 
I think a dynamic backing store would work wonderfully. SVG has many 
additional use cases not related to browser zoom, and I think it'd be 
the best place to try out the technique. Another area to try it out 
might be with getCSSCanvasContext, as it has different semantics than 
getContext, and it seems like a great fit: 
<A HREF="http://webkit.org/blog/176/css-canvas-drawing/">http://webkit.org/blog/176/css-canvas-drawing/</A>

I do feel like this proposal is a new idea, it's a good one. It's a bit 
more work on browser vendors, to address zoom, than the short-term work 
of making sure that they actually expose css pixel metrics to the 
scripting environment. Like many css options, I'm sure it'd be easier on 
some code bases than others.







-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20101122/92e48c77/attachment-0002.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20101122/92e48c77/attachment-0002.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="071367.html">[whatwg] Processing the zoom level - MS extensions to	window.screen
</A></li>
	<LI>Next message: <A HREF="071369.html">[whatwg] Processing the zoom level - MS extensions	to	window.screen
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#71368">[ date ]</a>
              <a href="thread.html#71368">[ thread ]</a>
              <a href="subject.html#71368">[ subject ]</a>
              <a href="author.html#71368">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
