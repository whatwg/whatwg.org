<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] &lt;a onlyreplace&gt;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%3Ca%20onlyreplace%3E&In-Reply-To=%3CBAY117-W90F5B859CD291AC4E373B83C20%40phx.gbl%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023686.html">
   <LINK REL="Next"  HREF="023728.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] &lt;a onlyreplace&gt;</H1>
<!--htdig_noindex-->
    <B>tali garsiel</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20%3Ca%20onlyreplace%3E&In-Reply-To=%3CBAY117-W90F5B859CD291AC4E373B83C20%40phx.gbl%3E"
       TITLE="[whatwg] &lt;a onlyreplace&gt;">t_garsiel at hotmail.com
       </A><BR>
    <I>Sun Oct 18 04:45:29 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="023686.html">[whatwg] &lt;a onlyreplace&gt;
</A></li>
        <LI>Next message: <A HREF="023728.html">[whatwg] &lt;a onlyreplace&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23720">[ date ]</a>
              <a href="thread.html#23720">[ thread ]</a>
              <a href="subject.html#23720">[ subject ]</a>
              <a href="author.html#23720">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
 &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">dd0fbad0910161343s277083c7v4eee5197c15bdfa4 at mail.gmail.com</A>&gt;
Content-Type: text/plain; charset=&quot;windows-1255&quot;
Content-Transfer-Encoding: 8bit
MIME-Version: 1.0


Some comments:

I think an optimization that enables the server to strip unnecessary content is a MUST.
It seems the browser will need to make a distinction between a regular request and a request invoked by a bookmark.
In case of a bookmark the server should not strip content so the browser must let him know that.

In a single page application AJAX updates can be originated in 2 roots:
1. The user clicks something in the navigation panel
2. The user clicks an action button inside the content panel

An example of use case #2 can be clicking a &quot;save&quot; button.
In this case the &quot;&lt;a&gt;&quot; tag is usually not used but a button, this means that other tags the&#160; &quot;&lt;a&gt;&quot; should have the &quot;onlyreplace&quot; attribute.
In this example the URL should not be remembered by the history.

There are other cases of use case #2 where the URL should be remembered - like a &quot;next&quot; button on a page-able data grid.

I think this solution is good for changes of the entire content panel.
When a specific widget needs to update a data binding solution may be better.
This means the &quot;onlyreplace&quot; will probably be always the defaults.








----------------------------------------
&gt;<i> From: <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jackalmage at gmail.com</A>
</I>&gt;<i> Date: Fri, 16 Oct 2009 15:43:25 -0500
</I>&gt;<i> To: <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">Simetrical+w3c at gmail.com</A>
</I>&gt;<i> CC: <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">derernst at gmx.ch</A>; <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">whatwg at whatwg.org</A>
</I>&gt;<i> Subject: Re: [whatwg] 
</I>&gt;<i>
</I>&gt;<i> A few public responses to issues/questions brought up in IRC: (thanks,
</I>&gt;<i> Aryeh and Philip!)
</I>&gt;<i>
</I>&gt;<i> How is this better than  and &amp;lt;a target&amp;gt;?&amp;lt;br /&amp;gt;&amp;gt; =========================================================&amp;lt;br /&amp;gt;&amp;gt; It's significantly better in multiple ways, actually.&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; 1. &amp;lt;iframe&amp;gt;s, like frames before them, break bookmarking. If a user&amp;lt;br /&amp;gt;&amp;gt; bookmarks the page and returns to it later, or gets deeplinked via a&amp;lt;br /&amp;gt;&amp;gt; search engine or a link from a friend, the &amp;lt;iframe&amp;gt; won't show the&amp;lt;br /&amp;gt;&amp;gt; correct content. The only way around this is some fairly non-trivial&amp;lt;br /&amp;gt;&amp;gt; url-hacking with javascript, altering the displayed url as the user&amp;lt;br /&amp;gt;&amp;gt; navigates the iframe, and parsing a deeplink url into an appropriate&amp;lt;br /&amp;gt;&amp;gt; url for the iframe on initial pageload. @onlyreplace, on the other&amp;lt;br /&amp;gt;&amp;gt; hand, automatically works perfectly with bookmarking. The UA still&amp;lt;br /&amp;gt;&amp;gt; changes urls and inserts history appropriately as you navigate, and on&amp;lt;br /&amp;gt;&amp;gt; a fresh pageload it just requests the ordinary static page showing the&amp;lt;br /&amp;gt;&amp;gt; appropriate content.&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; 2. &amp;lt;a target&amp;gt; can only navigate one iframe at a time. Many/most&amp;lt;br /&amp;gt;&amp;gt; sites, though, have multiple dynamic sections scattered throughout the&amp;lt;br /&amp;gt;&amp;gt; page. The main site for my company, frex, has 3 (content,&amp;lt;br /&amp;gt;&amp;gt; breadcrumbs, and section nav) which *cannot* be combined to display as&amp;lt;br /&amp;gt;&amp;gt; a single &amp;lt;iframe&amp;gt;, at least not without including a whole bunch of&amp;lt;br /&amp;gt;&amp;gt; static content as well. You'd have use javascript to hook the links&amp;lt;br /&amp;gt;&amp;gt; and manually navigate the additional iframes. @onlyreplace, on the&amp;lt;br /&amp;gt;&amp;gt; other hand, handles this seamlessly - just include multiple ids in the&amp;lt;br /&amp;gt;&amp;gt; attribute value.&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; 3. &amp;lt;iframe&amp;gt;s require you to architect your site around them. Rather&amp;lt;br /&amp;gt;&amp;gt; than a series of independent pages, you must create a single master&amp;lt;br /&amp;gt;&amp;gt; page and then a number of content-chunk mini-pages. This breaks&amp;lt;br /&amp;gt;&amp;gt; normal authoring practices (though in some ways it's easier), and&amp;lt;br /&amp;gt;&amp;gt; requires you to work hard to maintain accessibility and such in the&amp;lt;br /&amp;gt;&amp;gt; face of these atrophied mini-pages. @onlyreplace works on full,&amp;lt;br /&amp;gt;&amp;gt; ordinary pages. It's *possible* to link to a content-chunk mini-page&amp;lt;br /&amp;gt;&amp;gt; instead, but this will spectacularly break if you ever deeplink&amp;lt;br /&amp;gt;&amp;gt; straight to one of the pages, so it should become automatic for&amp;lt;br /&amp;gt;&amp;gt; authors to do this correctly.&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; 4. &amp;lt;iframe&amp;gt;s have dubious accessibility and search effects. I don't&amp;lt;br /&amp;gt;&amp;gt; know if bots can navigate &amp;lt;a target&amp;gt; links appropriately. I also&amp;lt;br /&amp;gt;&amp;gt; believe that this causes problems with screen-readers. While either&amp;lt;br /&amp;gt;&amp;gt; of these sets of UAs can be rewritten to handle &amp;lt;iframe&amp;gt;s better (and&amp;lt;br /&amp;gt;&amp;gt; handle @onlyreplace replacement as well), with @onlyreplace they&amp;lt;br /&amp;gt;&amp;gt; *also* have the option of just completely ignoring the attribute and&amp;lt;br /&amp;gt;&amp;gt; navigating the site as an ordinary multi-page app. Legacy UAs will&amp;lt;br /&amp;gt;&amp;gt; automatically do so, providing perfect backwards compatibility.&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; Isn't if inefficient to request the whole page and then throw most of&amp;lt;br /&amp;gt;&amp;gt; it out? With proper AJAX you can just request the bits you want.&amp;lt;br /&amp;gt;&amp;gt; ======================================================&amp;lt;br /&amp;gt;&amp;gt; This is a valid complaint, but one which I don't think is much of a&amp;lt;br /&amp;gt;&amp;gt; problem for several reasons.&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; 1. One of the big beneficiaries of @onlyreplace will be fairly&amp;lt;br /&amp;gt;&amp;gt; ordinary sites that are currently using an ordinary multi-page&amp;lt;br /&amp;gt;&amp;gt; architecture. All they have to do is add a single tag to the &amp;lt;head&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; of their pages, and they automatically get the no-flicker refresh of a&amp;lt;br /&amp;gt;&amp;gt; single-page app. These sites are *already* grabbing the whole page on&amp;lt;br /&amp;gt;&amp;gt; each request, so @onlyreplace won't make them take any *additional*&amp;lt;br /&amp;gt;&amp;gt; bandwidth. It will merely make the user experience smoother by&amp;lt;br /&amp;gt;&amp;gt; reducing flicker and keeping js-heavy elements of the page template&amp;lt;br /&amp;gt;&amp;gt; alive.&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; 2. Even though site templates are usually weighter than the dynamic&amp;lt;br /&amp;gt;&amp;gt; portions of a site, it's still not a very significant wasteage. For&amp;lt;br /&amp;gt;&amp;gt; comparison, my company's main site is roughly 16kb of template, and&amp;lt;br /&amp;gt;&amp;gt; somewhere around 2-3k of dynamic page content. (Aryeh - I gave you&amp;lt;br /&amp;gt;&amp;gt; slightly different numbers in chat because I was counting wrong.) So&amp;lt;br /&amp;gt;&amp;gt; that's a good 85% of each request being thrown away as irrelevant.&amp;lt;br /&amp;gt;&amp;gt; However, it's also *only 16kb*, and that's UNCOMPRESSED - after&amp;lt;br /&amp;gt;&amp;gt; standard gzip compression the template is worth maybe 5kb. So I waste&amp;lt;br /&amp;gt;&amp;gt; 5kb of bandwidth per request. Big deal. (According to Philip`, my&amp;lt;br /&amp;gt;&amp;gt; company's site's weight is just on the low side of average.)&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; 3. Because this is a declarative mechanism (specifying WHAT you want,&amp;lt;br /&amp;gt;&amp;gt; not HOW to get it), it has great potential for transparent&amp;lt;br /&amp;gt;&amp;gt; optimizations behind the scenes. For example, the browser could tell&amp;lt;br /&amp;gt;&amp;gt; the server which bits it's interested in replacing, and the server&amp;lt;br /&amp;gt;&amp;gt; could automatically strip full pages down to only those chunks. This&amp;lt;br /&amp;gt;&amp;gt; would eliminate virtually all bandwidth waste, while still being&amp;lt;br /&amp;gt;&amp;gt; completely transparent to the author - they just create ordinary full&amp;lt;br /&amp;gt;&amp;gt; static pages. Heck, you could even handle this yourself with JS and a&amp;lt;br /&amp;gt;&amp;gt; bit of server-side coding, intercepting clicks and rewriting the urls&amp;lt;br /&amp;gt;&amp;gt; to pass the @onlyreplace data in a query parameter, and have a&amp;lt;br /&amp;gt;&amp;gt; server-side script determine what to return based on that. Less&amp;lt;br /&amp;gt;&amp;gt; automatic, but fairly simple, and still easier than using JS to do&amp;lt;br /&amp;gt;&amp;gt; this in the normal AJAX manner. (And UAs that don't run javascript&amp;lt;br /&amp;gt;&amp;gt; but do support @onlyreplace will still work properly, just with a bit&amp;lt;br /&amp;gt;&amp;gt; more bandwidth waste.)&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; What about scripts in the page?&amp;lt;br /&amp;gt;&amp;gt; ===============================&amp;lt;br /&amp;gt;&amp;gt; Semantically the replace operation should be identical to grabbing the&amp;lt;br /&amp;gt;&amp;gt; appropriate chunk of text from the new page and setting is as the&amp;lt;br /&amp;gt;&amp;gt; outerHTML of the appropriate element. Any &amp;lt;script&amp;gt;s that are located&amp;lt;br /&amp;gt;&amp;gt; within this chunk would run in the exact same manner. Scripts&amp;lt;br /&amp;gt;&amp;gt; elsewhere in the new page would not be run.&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt;&amp;lt;br /&amp;gt;&amp;gt; What about document.write()? What if the important fragment of the&amp;lt;br /&amp;gt;&amp;gt; page is produced by document.write()?&amp;lt;br /&amp;gt;&amp;gt; ====================================================&amp;lt;br /&amp;gt;&amp;gt; Then you're screwed. document.write()s contained in &amp;lt;script&amp;gt; blocks&amp;lt;br /&amp;gt;&amp;gt; inside the target fragment will run when they get inserted into the&amp;lt;br /&amp;gt;&amp;gt; page, but document.write()s outside of that won't. Producing the&amp;lt;br /&amp;gt;&amp;gt; target fragment with document.write() is a no-go from the start.&amp;lt;br /&amp;gt;&amp;gt; Don't do that anyway; it's a bad idea.&amp;lt;br /&amp;gt; 		 	   		  
</I>_________________________________________________________________
Keep your friends updated&#151;even when you&#146;re not signed in.
<A HREF="http://www.microsoft.com/middleeast/windows/windowslive/see-it-in-action/social-network-basics.aspx?ocid=PID23461::T:WLMTAGL:ON:WL:en-xm:SI_SB_5:092010">http://www.microsoft.com/middleeast/windows/windowslive/see-it-in-action/social-network-basics.aspx?ocid=PID23461::T:WLMTAGL:ON:WL:en-xm:SI_SB_5:092010</A>
</PRE>































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023686.html">[whatwg] &lt;a onlyreplace&gt;
</A></li>
	<LI>Next message: <A HREF="023728.html">[whatwg] &lt;a onlyreplace&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23720">[ date ]</a>
              <a href="thread.html#23720">[ thread ]</a>
              <a href="subject.html#23720">[ subject ]</a>
              <a href="author.html#23720">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
