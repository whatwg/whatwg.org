<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Structured clone algorithm on LocalStorage
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Structured%20clone%20algorithm%20on%20LocalStorage&In-Reply-To=%3Cbd8f24d20910022111i5b2ee03ag2ecb038ad9779159%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="065546.html">
   <LINK REL="Next"  HREF="065556.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Structured clone algorithm on LocalStorage</H1>
<!--htdig_noindex-->
    <B>Darin Fisher</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Structured%20clone%20algorithm%20on%20LocalStorage&In-Reply-To=%3Cbd8f24d20910022111i5b2ee03ag2ecb038ad9779159%40mail.gmail.com%3E"
       TITLE="[whatwg] Structured clone algorithm on LocalStorage">darin at chromium.org
       </A><BR>
    <I>Fri Oct  2 21:11:02 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="065546.html">[whatwg]  Structured clone algorithm on LocalStorage
</A></li>
        <LI>Next message: <A HREF="065556.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65555">[ date ]</a>
              <a href="thread.html#65555">[ thread ]</a>
              <a href="subject.html#65555">[ subject ]</a>
              <a href="author.html#65555">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Fri, Oct 2, 2009 at 8:08 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt; wrote:

&gt;<i> On Wed, Sep 30, 2009 at 10:11 PM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> On Tue, Sep 29, 2009 at 11:48 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On Tue, Sep 29, 2009 at 12:19 AM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt;
</I>&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;<i> &gt; On Thu, Sep 24, 2009 at 11:57 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; On Thu, Sep 24, 2009 at 9:04 PM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt;
</I>&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; On Thu, Sep 24, 2009 at 4:43 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; On Thu, Sep 24, 2009 at 10:52 AM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; wrote:
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; On Thu, Sep 24, 2009 at 10:40 AM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; wrote:
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; On Thu, Sep 24, 2009 at 1:17 AM, Darin Fisher &lt;
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; wrote:
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; On Thu, Sep 24, 2009 at 12:20 AM, Jonas Sicking
</I>&gt;&gt;&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; wrote:
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; On Wed, Sep 23, 2009 at 10:19 PM, Darin Fisher
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; wrote:
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; ... snip ...
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; multi-core is the future.  what's the opposite of
</I>&gt;&gt;&gt;<i> fine-grained
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; locking?
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;  it's not good ;-)
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; the implicit locking mechanism as spec'd is super lame.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;  implicitly
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; unlocking under
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; mysterious-to-the-developer circumstances!  how can that be
</I>&gt;&gt;&gt;<i> a
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; good
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; thing?
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; storage.setItem(&quot;y&quot;,
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> function_involving_implicit_unlocking(storage.getItem(&quot;x&quot;)));
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; I totally agree on all points. The current API has big
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; imperfections.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; However I haven't seen any workable counter proposals so far,
</I>&gt;&gt;&gt;<i> and
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; I
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; honestly don't believe there are any as long as our goals
</I>&gt;&gt;&gt;<i> are:
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; * Don't break existing users of the current implementations.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; * Don't expose race conditions to the web.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; * Don't rely on authors getting explicit locking mechanisms
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; right.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; The current API exposes race conditions to the web.  The
</I>&gt;&gt;&gt;<i> implicit
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; dropping of the storage lock is that.  In Chrome, we'll have
</I>&gt;&gt;&gt;<i> to
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; drop
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; an existing lock whenever a new lock is acquired.  That can
</I>&gt;&gt;&gt;<i> happen
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; due to a variety of really odd cases (usually related to
</I>&gt;&gt;&gt;<i> nested
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; loops
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; or nested JS execution), which will be difficult for
</I>&gt;&gt;&gt;<i> developers to
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; predict, especially if they are relying on third-party JS
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; libraries.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; This issue seems to be discounted for reasons I do not
</I>&gt;&gt;&gt;<i> understand.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; I don't believe we've heard about this before, so that would be
</I>&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; reason it hasn't been taken into account.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; So you're saying that chrome would be unable implement the
</I>&gt;&gt;&gt;<i> current
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; storage mutex as specified in spec? I.e. one that is only
</I>&gt;&gt;&gt;<i> released
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; at
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; the explicit points that the spec defines? That seems like a
</I>&gt;&gt;&gt;<i> huge
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; problem.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; No, no... my point is that to the application developer, those
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; &quot;explicit&quot;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; points will appear quite implicit and mysterious.  This is why I
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; called
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; out third-party JS libraries.  One day, a function that you are
</I>&gt;&gt;&gt;<i> using
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; might transition to scripting a plugin, which might cause a
</I>&gt;&gt;&gt;<i> nested
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; loop, which could then force the lock to be released.  As a
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; programmer,
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; the unlocking is not explicit or predictable.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; Ah, indeed, this is a problem. However the unfortunate fact remains
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; that so far no other workable solution has been proposed.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; OK, so we agree that the current solution doesn't meet the goals you
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; stated above :-(
</I>&gt;&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; Well, it addresses them as long as users are aware of the risk, and
</I>&gt;&gt;&gt;<i> &gt;&gt; properly document weather their various library functions will release
</I>&gt;&gt;&gt;<i> &gt;&gt; the lock or not. However I agree that it's unlikely that they will do
</I>&gt;&gt;&gt;<i> &gt;&gt; so correctly.
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; I thought the point of not having lock APIs was that users shouldn't
</I>&gt;&gt;&gt;<i> have
</I>&gt;&gt;&gt;<i> &gt; to understand locks ;-)  The issue I've raised here is super subtle.
</I>&gt;&gt;&gt;<i>  We
</I>&gt;&gt;&gt;<i> &gt; have not succeeded in avoiding subtlety!
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I think we're mostly in agreement. What I'm not sure about is what you
</I>&gt;&gt;&gt;<i> are proposing we do with localStorage? Remove it from the spec? Change
</I>&gt;&gt;&gt;<i> the API? Something else?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> I'm glad we agree.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not sure what we should do.  It seems like there is a &quot;legacy API&quot;
</I>&gt;&gt;<i>  argument for sticking with the current proposal even though it is flawed
</I>&gt;&gt;<i> and
</I>&gt;&gt;<i> HTML5 is not yet final.  (It has also not been implemented by browsers for
</I>&gt;&gt;<i> very long.)  Stated that way, it sounds like a weak argument for
</I>&gt;&gt;<i> preserving
</I>&gt;&gt;<i> the API as is, and we should just fix it to be better.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My understanding is that removal is not a popular position.  However,
</I>&gt;&gt;<i> given
</I>&gt;&gt;<i> that more browsers are moving to be multi-process, I have to say that I'm
</I>&gt;&gt;<i> a
</I>&gt;&gt;<i> bit surprised there isn't more support for ditching the current
</I>&gt;&gt;<i> localStorage
</I>&gt;&gt;<i> API.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> You're preaching to the choir :) I'd recommend talking to apple and
</I>&gt;<i> microsoft directly. I don't know what their plans are regarding all this.
</I>&gt;<i>
</I>
Fair enough :-)



&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>  &gt;&gt; &gt;&gt; &gt; Moreover, there are other examples which have been discussed on
</I>&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; list.  There are some DOM operations that can result in a frame
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; receiving
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; a DOM event synchronously.  That can result in a nesting of
</I>&gt;&gt;&gt;<i> storage
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; locks,
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; which can force us to have to implicitly unlock the outermost
</I>&gt;&gt;&gt;<i> lock to
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; avoid
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; deadlocks.  Again, the programmer will have very poor visibility
</I>&gt;&gt;&gt;<i> into
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; when
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; these things can happen.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; So far I don't think it has been shown that these events need to be
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; synchronous. They all appear to be asynchronous in gecko, and in
</I>&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; case of different-origin frames, I'm not even sure there's a way
</I>&gt;&gt;&gt;<i> for
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; pages to detect if the event was fired asynchronously or not.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; IE and WebKit dispatch some of them synchronously.  It's hard to say
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; which
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; is correct or if it causes any web compat isues.  I'm also not sure
</I>&gt;&gt;&gt;<i> that
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; we
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; have covered all of the cases.
</I>&gt;&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; It still seems to me that it's extremely unlikely that pages depend on
</I>&gt;&gt;&gt;<i> &gt;&gt; cross origin events to fire synchronously. I can't even think of a way
</I>&gt;&gt;&gt;<i> &gt;&gt; to test if a browser dispatches these events synchronously or not. Can
</I>&gt;&gt;&gt;<i> &gt;&gt; you?
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; i agree that it seems uncommon.  maybe there could be some odd app that
</I>&gt;&gt;&gt;<i> &gt; does something after resizing an iframe that could be dependent on the
</I>&gt;&gt;&gt;<i> &gt; event handler setting some data field.  this kind of thing is probably
</I>&gt;&gt;&gt;<i> even
</I>&gt;&gt;&gt;<i> &gt; less common in the cross-origin case.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> But how would you read that data field in the cross-origin frame? I
</I>&gt;&gt;&gt;<i> think it might be possible, but extremely hard.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> Yeah.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My concern is simply that I cannot prove that I don't have to worry about
</I>&gt;&gt;<i> this
</I>&gt;&gt;<i> problem.  Future web APIs might also inadvertently make matters worse.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I agree it's not ideal, but at the same time I don't think that not
</I>&gt;<i> allowing synchronous cross-origin APIs is a huge burden. You campaigned
</I>&gt;<i> heavily against that when we were designing postMessage for wholly other
</I>&gt;<i> reasons. I would imagine those reasons will hole true no matter what.
</I>&gt;<i>
</I>
Agreed.  That's a good point.  In that case, I was concerned about stack
depth.  The same issue might apply here.  Hmm...


...snip...

&gt;<i>
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; Not quite sure I follow your proposal. How would you for example
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; increase the value of a property by one without risking race
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; conditions? Or keep two values in different properties in sync?
</I>&gt;&gt;&gt;<i> I.e.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; so that if you update one always update the other, so that they
</I>&gt;&gt;&gt;<i> never
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; have different values.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;&gt; / Jonas
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; Easy.  Just like with database, the transaction is the storage lock.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt;  Any
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; storage
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; operation performed on that transaction are done atomically.
</I>&gt;&gt;&gt;<i>  However,
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; all
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; storage
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; operations are asynchronous.  You basically string together
</I>&gt;&gt;&gt;<i> asynchronous
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; storage
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; operations by using the same transaction for each.
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; We could add methods to get/set multiple items at once to simplify
</I>&gt;&gt;&gt;<i> life
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; for
</I>&gt;&gt;&gt;<i> &gt;&gt; &gt; the coder.
</I>&gt;&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;&gt; I think I still don't understand your proposal, could you give some
</I>&gt;&gt;&gt;<i> &gt;&gt; code examples?
</I>&gt;&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; ripping off database:
</I>&gt;&gt;&gt;<i> &gt; interface ValueStorage {
</I>&gt;&gt;&gt;<i> &gt;   void transaction(in DOMString namespace, in
</I>&gt;&gt;&gt;<i> &gt; ValueStorageTransactionCallback callback);
</I>&gt;&gt;&gt;<i> &gt; };
</I>&gt;&gt;&gt;<i> &gt; interface ValueStorageTransactionCallback {
</I>&gt;&gt;&gt;<i> &gt;   void handleEvent(in ValueStorageTransaction transaction);
</I>&gt;&gt;&gt;<i> &gt; };
</I>&gt;&gt;&gt;<i> &gt; interface ValueStorageTransaction {
</I>&gt;&gt;&gt;<i> &gt;   void readValue(in DOMString name, in ValueStorageReadCallback
</I>&gt;&gt;&gt;<i> callback);
</I>&gt;&gt;&gt;<i> &gt;   void writeValue(in DOMString name, in DOMString value);
</I>&gt;&gt;&gt;<i> &gt; };
</I>&gt;&gt;&gt;<i> &gt; interface ValueStorageReadCallback {
</I>&gt;&gt;&gt;<i> &gt;   void handleEvent(in ValueStorageTransaction transaction, in DOMString
</I>&gt;&gt;&gt;<i> &gt; value);
</I>&gt;&gt;&gt;<i> &gt; };
</I>&gt;&gt;&gt;<i> &gt; then, to use these interfaces, you could implement thread-safe
</I>&gt;&gt;&gt;<i> increment:
</I>&gt;&gt;&gt;<i> &gt; window.localStorage.transaction(&quot;slice&quot;, function(transaction) {
</I>&gt;&gt;&gt;<i> &gt;   transaction.readValue(&quot;foo&quot;, function(transaction, fooValue) {
</I>&gt;&gt;&gt;<i> &gt;     transaction.writeValue(&quot;foo&quot;, ++fooValue);
</I>&gt;&gt;&gt;<i> &gt;   })
</I>&gt;&gt;&gt;<i> &gt; })
</I>&gt;&gt;&gt;<i> &gt; to fetch multiple values, you could do this:
</I>&gt;&gt;&gt;<i> &gt; var values = [];
</I>&gt;&gt;&gt;<i> &gt; var numValues = 10;
</I>&gt;&gt;&gt;<i> &gt; function readNextValue(transaction) {
</I>&gt;&gt;&gt;<i> &gt;   if (values.length == numValues)
</I>&gt;&gt;&gt;<i> &gt;    return;  // done!
</I>&gt;&gt;&gt;<i> &gt;   var index = values.length;
</I>&gt;&gt;&gt;<i> &gt;   transaction.readValue(&quot;value&quot; + index, function(transaction, value) {
</I>&gt;&gt;&gt;<i> &gt;     values.push(value);
</I>&gt;&gt;&gt;<i> &gt;     readNextValue(transaction);
</I>&gt;&gt;&gt;<i> &gt;   })
</I>&gt;&gt;&gt;<i> &gt; }
</I>&gt;&gt;&gt;<i> &gt; window.localStorage.transaction(&quot;slice&quot;, readNextValue);
</I>&gt;&gt;&gt;<i> &gt; This has the property that all IO is non-blocking and the &quot;lock&quot; is
</I>&gt;&gt;&gt;<i> held
</I>&gt;&gt;&gt;<i> &gt; only
</I>&gt;&gt;&gt;<i> &gt; for a very limited scope.  The programmer is however free to extend the
</I>&gt;&gt;&gt;<i> &gt; life of the lock as needed.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> What do you mean by that the &quot;lock&quot; is held for only a very limited
</I>&gt;&gt;&gt;<i> scope? You still want to prevent modifications for as long as the
</I>&gt;&gt;&gt;<i> transaction is being used right? I.e. no modifications can happen
</I>&gt;&gt;&gt;<i> between the read and the write in the first example, and between the
</I>&gt;&gt;&gt;<i> different reads in the second.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes.  I only meant that the programmer doesn't have to call a special
</I>&gt;&gt;<i> function to close the transaction.  It closes by virtue of the last
</I>&gt;&gt;<i> handleEvent
</I>&gt;&gt;<i> call referring to the transaction returning.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> So wouldn't you implement this transaction using a lock? To prevent other
</I>&gt;<i> pages from accessing the localStorage?
</I>&gt;<i>
</I>&gt;<i>
</I>Yes, but it wouldn't need to be a normal mutex if that's what you mean.  You
could just defer callbacks until the transaction completes.  It is purely
asynchronous locking.

-Darin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20091002/704e585f/attachment-0002.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20091002/704e585f/attachment-0002.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="065546.html">[whatwg]  Structured clone algorithm on LocalStorage
</A></li>
	<LI>Next message: <A HREF="065556.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65555">[ date ]</a>
              <a href="thread.html#65555">[ thread ]</a>
              <a href="subject.html#65555">[ subject ]</a>
              <a href="author.html#65555">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
