<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Parsing, syntax, and content model feedback
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Parsing%2C%20syntax%2C%20and%20content%20model%20feedback&In-Reply-To=%3CPine.LNX.4.62.0812242151260.24109%40hixie.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017927.html">
   <LINK REL="Next"  HREF="017951.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Parsing, syntax, and content model feedback</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Parsing%2C%20syntax%2C%20and%20content%20model%20feedback&In-Reply-To=%3CPine.LNX.4.62.0812242151260.24109%40hixie.dreamhostps.com%3E"
       TITLE="[whatwg] Parsing, syntax, and content model feedback">ian at hixie.ch
       </A><BR>
    <I>Thu Dec 25 02:41:47 PST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="017927.html">[whatwg] Error in 8.2.4.26 After DOCTYPE name state
</A></li>
        <LI>Next message: <A HREF="017951.html">[whatwg] Parsing, syntax, and content model feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17947">[ date ]</a>
              <a href="thread.html#17947">[ thread ]</a>
              <a href="subject.html#17947">[ subject ]</a>
              <a href="author.html#17947">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
This is a bulk reply to a variety of e-mails on the topic of the 
HTML5 syntax, its parsing rules, and  sent to the WHATWG list.

On Sun, 27 Jul 2008, Henri Sivonen wrote:
&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; 2.3.1.
</I>&gt;<i> &gt; &gt; Since blockquote is so abused that it is useless for AI, allowing 
</I>&gt;<i> &gt; &gt; attribution within the blockquote would be practical.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Attribution isn't part of a quote. How would you distinguish quoting 
</I>&gt;<i> &gt; an attribution from quoting text with an attribution from quoting text 
</I>&gt;<i> &gt; that happens to have its attribution?
</I>&gt;<i> 
</I>&gt;<i> Quotation marks:
</I>&gt;<i> &lt;BLOCKQUOTE&gt;&lt;p&gt;&#147;There&#146;s just no nice way to say this: Anyone
</I>&gt;<i> who can&#146;t make a syndication feed that&#146;s well-formed XML
</I>&gt;<i> is an incompetent fool.&#151;&#151;Maybe this is unkind and elitist
</I>&gt;<i> of me, but I think that anyone who either can&#146;t or won&#146;t
</I>&gt;<i> implement these measures is, as noted above, a bozo.&#148; &#150;
</I>&gt;<i> &lt;A HREF=&quot;<A HREF="http://www.tbray.org/ongoing/When/200x/2004/01/11/PostelPilgrim&quot;">http://www.tbray.org/ongoing/When/200x/2004/01/11/PostelPilgrim&quot;</A>&gt;Tim
</I>&gt;<i> Bray&lt;/A&gt;, co-editor of the XML 1.0 specification&lt;/p&gt;&lt;/BLOCKQUOTE&gt;
</I>
I think if we were to allow this we would have to introduce an explicit 
&lt;credit&gt; element. Or maybe &lt;legend&gt;, but then why not just use &lt;figure&gt; to 
link the &lt;blockquote&gt; and its legend together?


&gt;<i> On the topic of foreignObject: Shouldn't HTML5 actually *disallow* 
</I>&gt;<i> &lt;html&gt; as a child of &lt;foreignObject&gt; and make the content model of 
</I>&gt;<i> foreignObject equivalent to the content model of &lt;body&gt;? The commented 
</I>&gt;<i> out SVG-in-text/html functionality doesn't support &lt;html&gt; as a child of 
</I>&gt;<i> &lt;foreignObject&gt;.
</I>
Ok, done. (I'm surprised that SVG itself doesn't give any guidance as to 
the contents of &lt;foreignObject&gt;. I had no hooks to use to define this.)


&gt;<i> &gt; &gt; 2.3.4.
</I>&gt;<i> &gt; &gt; &quot;When an element has an ID set through multiple methods (for 
</I>&gt;<i> &gt; &gt; example, if it has both id and xml:id attributes simultaneously 
</I>&gt;<i> &gt; &gt; [XMLID]), then the element has multiple identifiers. User agents 
</I>&gt;<i> &gt; &gt; must use all of an HTML element's identifiers (including those that 
</I>&gt;<i> &gt; &gt; are in error according to their relevant specification) for the 
</I>&gt;<i> &gt; &gt; purposes of ID matching.&quot;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; What does this mean in terms of document conformance?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; n/a (is the current text ok?)
</I>&gt;<i> 
</I>&gt;<i> It's OK for the multiple ID issue. However, this sentence is known to be 
</I>&gt;<i> confusing: &quot;The value must be unique in the subtree within which the 
</I>&gt;<i> element finds itself and must contain at least one character.&quot; It should 
</I>&gt;<i> say that the ID must be unique within all nodes that are inserted into a 
</I>&gt;<i> document, a document fragment or an interconnected set of nodes that 
</I>&gt;<i> live outside a document or document fragment.
</I>
I've tried to make it mean that.


&gt;<i> &gt; &gt; 2.9.10.
</I>&gt;<i> &gt; &gt; I suggest the definition of i be changed to &quot;The i element 
</I>&gt;<i> &gt; &gt; represents anything that is italicized in conventional typography.&quot; 
</I>&gt;<i> &gt; &gt; That's pretty much the only real world-compatible definition.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Also, I suggest b be included in the spec and defined as &quot;The b 
</I>&gt;<i> &gt; &gt; element represents anything (except headings) that is set in bold 
</I>&gt;<i> &gt; &gt; face in conventional typography.&quot;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Is the current text ok?
</I>&gt;<i> 
</I>&gt;<i> Yes, except the advice &quot;The i element should be used as a last resort 
</I>&gt;<i> when no other element is more appropriate. In particular, citations 
</I>&gt;<i> should use the cite element, defining instances of terms should use the 
</I>&gt;<i> dfn element, stress emphasis should use the em element&quot; may not be 
</I>&gt;<i> respectful of the authors' time in the absence of concrete benefits for 
</I>&gt;<i> justifying the advice (other than future potential for unconventional 
</I>&gt;<i> styling).
</I>
Changed.


On Thu, 4 Dec 2008, Tommy Thorsen wrote:
&gt;<i>
</I>&gt;<i> Consider the following simple markup:
</I>&gt;<i> 
</I>&gt;<i> &lt;!doctype html&gt;&lt;/br&gt;
</I>&gt;<i> 
</I>&gt;<i> If I run it through my parser, which is implemented after the html5 algorithm,
</I>&gt;<i> the resulting dom is as follows:
</I>&gt;<i> 
</I>&gt;<i> &lt;html&gt;
</I>&gt;<i>    &lt;head&gt;
</I>&gt;<i>    &lt;body&gt;
</I>&gt;<i> 
</I>&gt;<i> The br end tag is a bit special, and should be handled as if it was a br start
</I>&gt;<i> tag. What happens here is as follows: The &quot;before head&quot; insertion mode will,
</I>&gt;<i> upon receiving a br end tag, create a head node and switch to the &quot;in head&quot;
</I>&gt;<i> insertion mode. &quot;in head&quot; will close the head node and move on to the &quot;after
</I>&gt;<i> head&quot; insertion mode. I was expecting &quot;after head&quot; to see the &lt;/br&gt; and do
</I>&gt;<i> like it does on a start tag, which is to create a body node and move to the
</I>&gt;<i> &quot;in body&quot; state, but the &lt;/br&gt; is just ignored.
</I>&gt;<i> 
</I>&gt;<i> I've changed my implementation of &quot;after head&quot; to handle &lt;/br&gt; just like the
</I>&gt;<i> &quot;in head&quot; insertion mode, which is:
</I>&gt;<i> 
</I>&gt;<i>    An end tag whose tag name is &quot;br&quot;
</I>&gt;<i>        Act as described in the &quot;anything else&quot; entry below.
</I>&gt;<i> 
</I>&gt;<i> This results in the following dom, for the example above:
</I>&gt;<i> 
</I>&gt;<i> &lt;html&gt;
</I>&gt;<i>    &lt;head&gt;
</I>&gt;<i>    &lt;body&gt;
</I>&gt;<i>       &lt;br&gt;
</I>&gt;<i> 
</I>&gt;<i> This matches Internet Explorer and Opera, but not Firefox and Safari. Then
</I>&gt;<i> again, it looks like Firefox and Safari ignore all &lt;/br&gt; tags.
</I>
Oops, this was an oversight. Fixed.


On Thu, 4 Dec 2008, timeless wrote:
&gt;<i>
</I>&gt;<i> if we're both able to get away with ignoring all &lt;/br&gt; tags, wouldn't 
</I>&gt;<i> the ideal forward path be to make always ignored?
</I>
We can't remove this from quirks, and as others have pointed out, the 
fewer differences the better.


On Thu, 4 Dec 2008, Henri Sivonen wrote:
&gt;<i>
</I>&gt;<i> One option would be making the tokenizer check if an end tag has the 
</I>&gt;<i> name 'br' and turn it into a start tag in the tokenizer. This assumes 
</I>&gt;<i> that SVG and MathML won't be able to introduce an element whose local 
</I>&gt;<i> name is 'br' anyway.
</I>
I'd rather not make the tokeniser be aware of specific tag names.


On Thu, 4 Dec 2008, Calogero Alex Baldacchino wrote:
&gt;<i> 
</I>&gt;<i> Section 4.5.3 says,
</I>&gt;<i> 
</I>&gt;<i> &quot;|br| elements must be empty. Any content inside |br| elements must not 
</I>&gt;<i> be considered part of the surrounding text.&quot;
</I>&gt;<i> 
</I>&gt;<i> The first part is clearly an authoring rule. But the second part cannot 
</I>&gt;<i> be such as well clearly, because an author might feel that as a 
</I>&gt;<i> reference to a parsing rule discarding anything like &lt;br&gt;Something&lt;/br&gt; 
</I>&gt;<i> (but it isn't). Yet, that can't be a parsing rule, since in contrast 
</I>&gt;<i> with the &quot;in body&quot; insertion mode (but not only that), which would turn 
</I>&gt;<i> it into &lt;br&gt;Something&lt;br&gt;, thus presenting the content to the end user 
</I>&gt;<i> (and obviously that's unlikely anyone visiting a web page would check 
</I>&gt;<i> the html code looking for content to ignore :-P). For the purpose of 
</I>&gt;<i> validation, the first part should be enough (that is, when a &lt;/br&gt; end 
</I>&gt;<i> tag is found, an error may be prompted to the author). Perhaps, should 
</I>&gt;<i> the second sentence be modified with references to scripts (e.g. to tell 
</I>&gt;<i> it is wrong to use a br .innerHTML or .appendChild() to modify the 
</I>&gt;<i> document) and to styles (e.g. to tell it's wrong to expect any font 
</I>&gt;<i> property will affect the sorrounding text), to make it more clearly an 
</I>&gt;<i> authoring rule? Or perhaps changed into an exemple of bad markup? Or 
</I>&gt;<i> removed, if source of confusion with parsing rules?
</I>
The second sentence can't be a requirement on authors, since that would 
contradict the first requirement. Thus it's a UA requirement.


&gt;<i> Otherwise, I don't follow its meaning (perhaps I'm the only confused 
</I>&gt;<i> one). I mean, as far as I know, xml derived languages require a closing 
</I>&gt;<i> tag for every elements, while html has never had such requirements per 
</I>&gt;<i> se, but that's a matter of syntax, not semantics. And, semantically 
</I>&gt;<i> speaking, whatever (but a closing tag) follows an element which can't 
</I>&gt;<i> have children, in the markup, obviously consists of one or more siblings 
</I>&gt;<i> of such element, while its closing tag (again, that's syntax), if 
</I>&gt;<i> misplaced, or not provided for by syntax rules at all, causes a parse 
</I>&gt;<i> error (which may, or may not, be handled gracefully by the u.a., that's 
</I>&gt;<i> a matter of parsing rules). That is, declaring an element as &quot;empty&quot; 
</I>&gt;<i> should imply per se that the element cannot have any descendant, so its 
</I>&gt;<i> content is not... its content, but a syntax error. Perhaps, defining the 
</I>&gt;<i> empty content model such way might avoid misunderstandings. Or am I 
</I>&gt;<i> making some mistakes?
</I>
The requirements have nothing to do with the syntax here; &lt;br&gt; elements 
can end up with contents in a variety of ways, e.g. through the DOM or 
using XML.


On Thu, 18 Dec 2008, Giovanni Campagna wrote:
&gt;<i> 2008/12/17 Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This doesn't cost any time in HTML either, since the tokeniser doesn't 
</I>&gt;<i> &gt; need to worry about what tags have end tags, the tree construction 
</I>&gt;<i> &gt; side just drops unexpected end tags on the floor.
</I>&gt;<i>
</I>&gt;<i> I don't think authors expect tags to disappear.
</I>
That's possible, but my point was just related to the performance aspect.

We're very constrained by the legacy for text/html's syntax; sadly, 
usability concerns aren't really able to make us change the language.


&gt;<i> &gt; &gt; don't check for insertion modes
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Having an insertion mode isn't particularly a performance cost. (It 
</I>&gt;<i> &gt; affects code footprint, but that's about it.)
</I>&gt;<i>
</I>&gt;<i> 1) it needs more code (one x insertion mode): more code is always less 
</I>&gt;<i> performance, even if it is just to load a bigger executable
</I>
Sure, but in this case the code footprints are the same, in practice, 
according to reports from browser vendors.


&gt;<i> 2) it needs code to select the insertion mode for the next element (when 
</I>&gt;<i> the spec says to reset the insertion mode): in the worst case it has to 
</I>&gt;<i> compare nodeName 18 times
</I>
There are implementation strategies that avoid these problems, e.g. using 
jump tables on interned names, and using function pointers instead of 
insertion mode flags.

&gt;<i> &gt; &gt; just parses the input completely any semantic or particular 
</I>&gt;<i> &gt; &gt; behaviour associated with any tag. Then, when the DOMElement or 
</I>&gt;<i> &gt; &gt; DOMAttr or DOM-whatever are built, they get the appropriate 
</I>&gt;<i> &gt; &gt; interface (eg. HTMLElement) depending on the namespace.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; That's the same as HTML.
</I>&gt;<i>
</I>&gt;<i> No it is not. HTML defines special beaviour for the following elements: 
</I>&gt;<i> address, area, article, aside, base, basefont, bgsound, blockquote, 
</I>&gt;<i> body, br, center, col, colgroup, command, datagrid, dd, details, dialog, 
</I>&gt;<i> dir, div, dl, dt, embed, eventsource fieldset, figure, footer, form, 
</I>&gt;<i> frame, frameset, h1, h2, h3, h4, h5, h6, head, header, hr, iframe, img, 
</I>&gt;<i> input, isindex, li, link, listing, menu, meta, nav, noembed, noframes, 
</I>&gt;<i> noscript, ol, p, param, plaintext, pre, script, section, select, spacer, 
</I>&gt;<i> style, tbody, textarea, tfoot, thead, title, tr, ul, and wbr. I think 
</I>&gt;<i> they're quite too many to say that it is like XML
</I>
I don't wish to pretend that XML is like HTML; my point was that what you 
said above -- that elements get interfaces depending on the tag -- is the 
same in HTML and XML.


&gt;<i> &gt; There are a number of HTML5 parser implementations, and data suggests 
</I>&gt;<i> &gt; that there is no particular performance gain.
</I>&gt;<i>
</I>&gt;<i> There are no actual HTML5 parser implementation, only HTML4 compatible 
</I>&gt;<i> with new syntax. (are you sure that closed source browsers really do 
</I>&gt;<i> what is written in the specification?)
</I>
As others have noted, there are in fact a variety of actual HTML5 parser 
implementations. Even browsers are working on implementations.


&gt;<i> &gt; There's no guessing in HTML either; all input streams have very 
</I>&gt;<i> &gt; specific and required results.
</I>&gt;<i>
</I>&gt;<i> Actually, there's nothing that really says that &lt;div&gt;&lt;p&gt;some 
</I>&gt;<i> text&lt;/p&gt;&lt;p&gt;some more text&lt;/p&gt;&lt;/div&gt; is more correct than &lt;div&gt;&lt;p&gt;some 
</I>&gt;<i> text&lt;p&gt;some more text&lt;/p&gt;&lt;/p&gt;&lt;/div&gt;
</I>
Yes there is; the HTML5 syntax section defines that the latter is wrong 
(as does the HTML4 DTD, for that matter), and the HTML5 parser spec 
defines how conformance checkers are to catch that as a parse error.


&gt;<i> Just when writing the specification you guess that the first possibility 
</I>&gt;<i> is what auctor thought. You are guessing, not the browser.
</I>
The goal is not to guess what the author meant when the authors makes a 
mistake; the goal is to have interoperable, predictable, defined behavior 
for all input.


&gt;<i> &gt; Validating code is certainly an important QA point, but once you've 
</I>&gt;<i> &gt; shipped code, the presence of an error is not helpful to the end user. 
</I>&gt;<i> &gt; Often errors in XML files weren't present when the file was created, 
</I>&gt;<i> &gt; but appear later when new text is merged in automatically.
</I>&gt;<i> 
</I>&gt;<i> As Nils pointed, it is an error itself to have any content to be 
</I>&gt;<i> automatically merged inside a stream.
</I>
I'm not attempting to make any value judgements here, I'm just stating 
where XML errors are most frequently found.


&gt;<i> It is like opening a random file, executing it and expecting no errors. 
</I>&gt;<i> Every input, even from the most trustworthy source, must be parsed for 
</I>&gt;<i> errors and then checked after publishing.
</I>
Agreed, but that doesn't mean people do it, or that they catch all errors. 
For examples, blogs that use XML often fail to catch invalid UTF-8 bytes 
that, when used, cause the page to be malformed XML.


&gt;<i> And if an end user finds an error, he probably will report it to the 
</I>&gt;<i> owner of the web site, who in turn will report it (quite angrily) to web 
</I>&gt;<i> designer.
</I>
That only works if the site is actively maintained. It's also not clear 
that most users really would report the error. I rarely report errors when 
I come across a site that doesn't work right for whatever reason; I just 
find another site. It thus becomes a competitive advantage to use a 
technology that doesn't expose errors to the user.


&gt;<i> &gt; Well, they've ignored it for the past 7 years, so why would they change?
</I>&gt;<i>
</I>&gt;<i> Nobody said to user that he was browsing a deprecate web site. If something
</I>&gt;<i> like IE7 information bar (ie. a non modal bar, disactivable and not annoying
</I>&gt;<i> the user, but immediately visible) could appear in a  web site sent with
</I>&gt;<i> text/html,  I think companies won't like their site tagged as &quot;deprecate&quot;
</I>&gt;<i> and port them to application/xhtml+xml in no time (do you imagine what
</I>&gt;<i> &quot;deprecate&quot; can mean on news web site?)
</I>&gt;<i> And don't forget that the most common browser was IE6, not very standard
</I>&gt;<i> oriented...
</I>
What advantage would there be to a Web browser to tell users that the 
entire Web was deprecated?

Web browser vendors have clearly said they're not interested in doing 
this.


&gt;<i> &gt; Anyway, it isn't clear that we would _want_ to deprecate HTML, even if 
</I>&gt;<i> &gt; we had any real choice in the matter.
</I>&gt;<i> 
</I>&gt;<i> I'm not sure if I understood your sentence (sorry, English is not my 
</I>&gt;<i> mother language). Anyway, you just have to put an &quot;authoring 
</I>&gt;<i> requirement&quot; for text/html
</I>&gt;<i> 
</I>&gt;<i> 1) user agent will just ignore it and implement the HTML algorithm (we 
</I>&gt;<i> don't want to &quot;break the web&quot;, using Microsoft terms)
</I>&gt;<i>
</I>&gt;<i> 2) standard-oriented authors will convert their sites to 
</I>&gt;<i> application/xhtml+xml (if they didn't before)
</I>&gt;<i>
</I>&gt;<i> 3) other authors will keep their tag soup (and get their sites 
</I>&gt;<i> yellow-barred)
</I>&gt;<i>
</I>&gt;<i> 4) company owners will make their decision between 2 and 3
</I>
Why would we want to get rid of text/html?


&gt;<i> Gradually, n&#176; 3 will disappear, because there's no actual needing for HTML.
</I>
There's no actual need for XML. :-)


On Sun, 21 Dec 2008, Philipp Kempgen wrote:
&gt;<i> Ian Hickson schrieb:
</I>&gt;<i> 
</I>&gt;<i> &gt; Deprecating HTML thus seems like vain effort. (We already tried over 
</I>&gt;<i> &gt; the past few years with XHTML 1.x, and it didn't work.)
</I>&gt;<i> 
</I>&gt;<i> I'd say it _did_ work.  :-)
</I>
To a first order of magnitude, nobody uses XHTML. (A few people -- around 
15% last I checked -- label their HTML documents as XHTML, but even those 
documents, if processed as XHTML, likely wouldn't work, for reasons such 
as those given in [1].)

[1] <A HREF="http://hixie.ch/advocacy/xhtml">http://hixie.ch/advocacy/xhtml</A>

So I'm not really sure under what measure you would say it worked. Could 
you elaborate on what data and criteria you are basing this evaluation on?


On Sun, 21 Dec 2008, Nils Dagsson Moskopp wrote:
&gt;<i>
</I>&gt;<i> I'd say too: The worst abominations have disappeared (for new sites, 
</I>&gt;<i> that is). the &lt;font&gt; element, for example, or frames through deprecating 
</I>&gt;<i> them.
</I>
That has nothing to do with XHTML.


&gt;<i> Fact: Deprecating stuff takes it out of (X)HTML-Books, Howtos like 
</I>&gt;<i> Selfhtml warn against it, thus ensuring lesser use by novices.
</I>
Tutorials can certainly help guide authors towards best practices, and 
that is why things like &lt;font&gt; aren't in HTML5. That, though, is 
independent of things like XHTML vs HTML.


&gt;<i> Does anyone remember &lt;marquee&gt; ?
</I>
&lt;marquee&gt; is used so much (primarily in Asian markets) that all Web 
browsers have been forced to copy IE and support it even though it was 
never in a standard.


On Sun, 21 Dec 2008, Giovanni Campagna wrote:
&gt;<i> 
</I>&gt;<i> As I discovered lately, the main problem of HTML5 is its design oriented 
</I>&gt;<i> to keep features that are distributed across browsers, that work or that 
</I>&gt;<i> are simple way to solve big problem. Actually, they are a bunch of 
</I>&gt;<i> different features somehow not integrated to the others.
</I>&gt;<i>
</I>&gt;<i> Instead, programmer (please note, I use the word programmer, not author 
</I>&gt;<i> or web designer) developing *new* application may more like a more 
</I>&gt;<i> structured and logical organization, like XHTML modularization is.
</I>
Could you elaborate on how spec design like XHTML modularisation has any 
impact on developers of Web applications? I was under the impression that 
the only benefit was in the development of other specs based on the 
modules (and that only if those needs happened to mesh with the particular 
modules picked).


&gt;<i> [Some] HTML5 features, summed in big groups, [..] can be achieved 
</I>&gt;<i> without any of HTML5, for example
</I>&gt;<i>
</I>&gt;<i> 1) common syntax for the most used datatypes.
</I>
I assume you mean in forms?

&gt;<i> 1) use XMLSchema datatypes
</I>
It's unclear how XML Schema datatypes would work with HTML forms and how 
they would be better than what we have in forms in HTML5 now.


&gt;<i> 2) additional DOM interfaces, which include HTMLElement - HTMLCollection -
</I>&gt;<i> HTMLFormsControlCollection - HTMLOptionsCollection - DOMTokenList -
</I>&gt;<i> DOMStringMap
</I>&gt;<i>
</I>&gt;<i> 2) you don't need HTMLElement: markup insertion, attributes querying can 
</I>&gt;<i> be done using DOM3Core (that in latest browser are even more performant 
</I>&gt;<i> as no parser is involved), events are far better handled by DOM3Events, 
</I>&gt;<i> styling is included by CSSOM
</I>&gt;<i>
</I>&gt;<i> you don't need collection either: just use appropriate DOMNodeLists, 
</I>&gt;<i> while for DOMStringMap you may use binding specific features (all Object 
</I>&gt;<i> are hash maps in ECMAScript3): it works this way even in HTML5
</I>
Both HTMLElement and collections are in DOM2 HTML (even DOM1 HTML).

DOMStringMap is basically nothing but a binding-specific feature.


&gt;<i> 3) Elements and Content Models
</I>&gt;<i>
</I>&gt;<i> 3) use XHTML2, which is extensible because modularized
</I>
XHTML2 is not backwards compatible, and was a big part of the motivation 
behind starting the HTML5 effort.

Extensibility is an anti-feature -- we specifically don't _want_ people to 
extend HTML without working with the wider community. That way lies 
fragmentation of the language and lack of interoperability. Indeed, what 
little non-centralised extension HTML has seen -- &lt;spacer&gt;, &lt;blink&gt;, 
&lt;marquee&gt; -- has been widely decried as a disaster.


&gt;<i> 4) Element types: metadata - structure - sectioning - grouping - text -
</I>&gt;<i> editing - embedding - table - forms - interactive - scripting elements
</I>&gt;<i> 
</I>&gt;<i> 4) metadata is better handled by XHTML2 Meta Attributes module, which fully
</I>&gt;<i> integrates the RDF module in any elements;
</I>
It's not clear that that is better, but that is an open issue that I will 
deal with separately.


&gt;<i> structure, sectioning, grouping are the same;
</I>
It's unclear why you think XHTML2's features in this area are better than 
HTML5's. Can you elaborate?


&gt;<i> text is very similar: you don't have time, but you can have &lt;span
</I>&gt;<i> datatype=&quot;xsd:date&quot; content=&quot;2008-12-21&quot;&gt;Today&lt;/span&gt; as in HTML5 you have
</I>&gt;<i> &lt;time value=&quot;2008-12-21&quot;&gt;Today&lt;/time&gt;;
</I>
Why is that better? It seems far worse.


&gt;<i> for progress and meter semantic you can use role attribute (for styling 
</I>&gt;<i> you always use CSS);
</I>
That would have a terrible accessibility story as far as I can tell.


&gt;<i> editing is the same, but you have an attribute instead of an element, so 
</I>&gt;<i> you don't have the issue that ins and del can contain everything, even a 
</I>&gt;<i> whole document (not including &lt;html&gt;);
</I>
This is an area where we are mostly just constrained by legacy -- &lt;ins&gt; 
amd &lt;del&gt; are from HTML4, not new in HTML5.


&gt;<i> embedding is much more powerful as any element can be replaced by 
</I>&gt;<i> embedded content;
</I>
This isn't more powerful, it's more buggy. Just compare &lt;object&gt; with 
&lt;img&gt;. Making things general is something that language designers often 
feel is a good way to solve many problem at once, but usually it just ends 
up not solving any of the problems well. For example, XHTML2 doesn't have 
anything like &lt;video&gt;'s APIs.


&gt;<i> tables are the same (you don't have tables API; but you can still use
</I>&gt;<i> DOM3Core);
</I>
Tables in HTML5 are mostly unchanged from HTML4.


&gt;<i> XForms are actually more powerful than WebForms2, since you divide
</I>&gt;<i> presentation from data from action (that is implemented declaratively);
</I>
XForms were the original motivation behind HTML5 -- they don't solve the 
problem that HTML5 tries to solve, which is the ability to add new 
features to existing documents.


&gt;<i> interactive elements are not needed at all: details is better implemented as
</I>&gt;<i> it is now (ECMAScript3 + CSS3),
</I>
That has a terrible accessibility story.


&gt;<i> datagrid is just a way to put data in a tree model: use plain XML for 
</I>&gt;<i> that;
</I>
How would that be used by, for example, GMail? Gmail today doesn't have a 
way to show a list control of all your e-mail without loading all your 
mail; &lt;datagrid&gt; allows it.


&gt;<i> command and a in XHTML2 implemented in any element using href attribute;
</I>&gt;<i> menu is mostly an ul with some style;
</I>
I think you misunderstand &lt;command&gt; and &lt;menu&gt;. Does XHTML2 have anything 
for context menus and native toolbars?


&gt;<i> scripting uses XMLEvents and handler: it looks the same, but it is 
</I>&gt;<i> different as it is more event oriented (scripts are not executed by 
</I>&gt;<i> default, they're executed when some event fires)
</I>
Scripting in HTML5 is mostly just describing what we have today, which we 
need to keep for backwards-compatibility.


&gt;<i> [5, 6, 7 not listed in original e-mail]
</I>&gt;<i>
</I>&gt;<i> 8) HTML Syntax
</I>&gt;<i>
</I>&gt;<i> 8) as I said before, use XML for that
</I>
This doesn't seem to solve many of the problems being faced by developers 
today, and ignores many of our requirements, such as backwards- 
compatibility, and the desire for incremental improvements only.


&gt;<i> What I am asking now is so to &quot;modularize HTML&quot;. copy those features 
</I>&gt;<i> into separate, interoperable modules, removing legacy features (like 
</I>&gt;<i> window.on-whatever event listener)
</I>&gt;<i>
</I>&gt;<i> A copy of those will remain in HTML5, because browser implement them at 
</I>&gt;<i> the moment, and the HTML5 goal is that all browser implement the same 
</I>&gt;<i> things in the same ways
</I>&gt;<i> 
</I>&gt;<i> Instead, some web developers in the future will think that a modularized 
</I>&gt;<i> and less redudant API is more usable, like I personally do, and switch 
</I>&gt;<i> to that, without mixing with HTML5: actually, I guess what a Database 
</I>&gt;<i> API does inside HTML.
</I>
Some parts of HTML5 are indeed going to be split out into separate specs, 
but unless you know someone who can actually edit these other specs, it's 
not going to happen any time soon.

See also:

   <A HREF="http://lists.w3.org/Archives/Public/public-html/2008Oct/0127.html">http://lists.w3.org/Archives/Public/public-html/2008Oct/0127.html</A>


On Thu, 18 Dec 2008, Elliotte Harold wrote:
&gt;<i>
</I>&gt;<i> &quot;However, if the element is found within an XSLT transformation sheet 
</I>&gt;<i> (assuming the UA also supports XSLT), then the processor would instead 
</I>&gt;<i> treat the script element as an opaque element that forms part of the 
</I>&gt;<i> transform.&quot;
</I>&gt;<i> 
</I>&gt;<i> &quot;transformation sheet&quot; is not a term in common use, and I don't think it 
</I>&gt;<i> appears in the relevant specs. I suggest the action be taken of changing 
</I>&gt;<i> this to either &quot;stylesheet&quot; or &quot;style sheet&quot;. (stylesheet is the form in 
</I>&gt;<i> the XSLT 1.0 spec, but both forms with and without space are seen in 
</I>&gt;<i> practice.)
</I>
Fixed.

I used &quot;transformation expressed in XSLT&quot;, to avoid confusing with the 
term &quot;stylesheet&quot;. XSLT 1.0 defines the two terms as equivalent.


On Thu, 18 Dec 2008, Elliotte Harold wrote:
&gt;<i>
</I>&gt;<i> &quot;The nodes representing HTML elements in the DOM must implement, and 
</I>&gt;<i> expose to scripts, the interfaces listed for them in the relevant 
</I>&gt;<i> sections of this specification. This includes HTML elements in XML 
</I>&gt;<i> documents, even when those documents are in another context (e.g. inside 
</I>&gt;<i> an XSLT transform).&quot;
</I>&gt;<i> 
</I>&gt;<i> I find this very questionable. If an XSLT processor is parsing a 
</I>&gt;<i> stylesheet, including a browser-hosted XSLT processor, there is no 
</I>&gt;<i> reason or expectation for it to treat HTML elements specially in the 
</I>&gt;<i> context of the stylesheet.
</I>
It's a requirement because of the case where a script gets hold of a node 
in an XSLT transformation and inserts it into an HTML document, removing 
any association with the XSLT transformation. Since it's the same node the 
whole time, it can't change interface or class, yet it must once in the 
HTML document behave like an HTML element. Thus it has to have been an 
HTML element the whose time.


&gt;<i> Possibly doing so would lead to violations of the XSLT spec, especially 
</I>&gt;<i> given the error recovery littered throughout the HTML 5 spec. And of 
</I>&gt;<i> course XSLT is just one example. There are others where similar issues 
</I>&gt;<i> may apply.
</I>
I don't understand the relevance of implementing the DOM interfaces with 
the error handling you mention. (And why is the error handling any more 
relevant here than the rules even in the absence of errors? I don't 
understand why the distinction is relevant here.)

Note that the spec very clearly says that the rules in the HTML spec can 
be overriden by other specs, and even mentions XSLT as an example of this, 
as you quote:

&gt;<i> I think something along the lines of section 2.2 would be more 
</I>&gt;<i> reasonable. &quot;Web browsers that support XHTML must process elements and 
</I>&gt;<i> attributes from the HTML namespace found in XML documents as described 
</I>&gt;<i> in this specification, so that users can interact with them, *unless the 
</I>&gt;<i> semantics of those elements have been overridden by other 
</I>&gt;<i> specifications.*&quot;
</I>&gt;<i> 
</I>&gt;<i> What's missing in 3.3.2 is something along the lines of &quot;unless the 
</I>&gt;<i> semantics of those elements have been overridden by other 
</I>&gt;<i> specifications.&quot;
</I>
Could you give an example of such a spec for this case?


&gt;<i> I'm not sure exactly what language we need here. Maybe something like
</I>&gt;<i> 
</I>&gt;<i> &quot;The nodes representing HTML elements in the DOM must implement, and 
</I>&gt;<i> expose to scripts, the interfaces listed for them in the relevant 
</I>&gt;<i> sections of this specification. This includes HTML elements in XML 
</I>&gt;<i> documents unless those documents are in another context (e.g. inside an 
</I>&gt;<i> XSLT transform).&quot;
</I>&gt;<i> 
</I>&gt;<i> That is, change &quot;even when&quot; to &quot;unless&quot;. It would also be helpful here 
</I>&gt;<i> to define exactly what &quot;another context&quot; means. That is, what is the 
</I>&gt;<i> context where the HTML DOM is appropriate and what are its limits?  
</I>&gt;<i> That wasn't clear to me from ereading the preceding sections. However 
</I>&gt;<i> whatever those limits are, I think they should stop well short of 
</I>&gt;<i> applying to an XSLT stylesheet.
</I>
As noted above, if the interfaces are ever not exposed, then this leads to 
impossible situations or contradictions that would be highly confusing to 
authors.


On Sun, 21 Dec 2008, Kartikaya Gupta wrote:
&gt;<i> Section 8.2.4.1, for the '&lt;' input, says:
</I>&gt;<i> 
</I>&gt;<i> &gt; When the content model flag is set to either the RCDATA state or the 
</I>&gt;<i> &gt; CDATA state and the escape flag is false: switch to the tag open 
</I>&gt;<i> &gt; state.
</I>&gt;<i> 
</I>&gt;<i> I think the lack of commas in this sentence makes it ambiguous: it can 
</I>&gt;<i> either be interpreted as &quot;(cmf == RCDATA or cmf == CDATA) and (escape 
</I>&gt;<i> flag == false)&quot; or &quot;(cmf == RCDATA) or (cmf == CDATA and escape flag == 
</I>&gt;<i> false)&quot;. Adding a comma either after &quot;RCDATA state&quot; or after &quot;CDATA 
</I>&gt;<i> state&quot; would fix the ambiguity. Other similar sentences already have 
</I>&gt;<i> commas.
</I>
Fixed.


On Sun, 21 Dec 2008, Philip Taylor wrote:
&gt;<i>  On Sun, Dec 21, 2008 at 5:41 AM, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; On Sat, 20 Dec 2008, Edward Z. Yang wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; 1. Given an input stream that is known to be valid UTF-8, is it 
</I>&gt;<i> &gt;&gt; possible to implement the tokenization algorithm with byte-wise 
</I>&gt;<i> &gt;&gt; operations only? I think it's possible, since all of the character 
</I>&gt;<i> &gt;&gt; matching parts of the algorithm map to characters in ASCII space.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yes. (At least, that's the intent; if you find anything that 
</I>&gt;<i> &gt; contradicts that, please let me know.)
</I>&gt;<i> 
</I>&gt;<i> I think there are some cases where it still should work but you might 
</I>&gt;<i> have to be a little careful - e.g. &quot;&lt;table&gt;foo&quot; notionally results in 
</I>&gt;<i> three parse errors according to the spec (one for each character token 
</I>&gt;<i> which gets foster-parented), so &quot;&lt;table&gt;&#226;&#152;&#185;&quot; results in one if you work 
</I>&gt;<i> with Unicode characters but three if you treat each UTF-8 byte as a 
</I>&gt;<i> separate character token.
</I>&gt;<i> 
</I>&gt;<i> But in practice, tokenisers emit sequence-of-many-characters tokens 
</I>&gt;<i> instead of single-character tokens, so they only emit one parse error 
</I>&gt;<i> for &quot;&lt;table&gt;foo&quot;, and the html5lib test cases assume that behaviour, and 
</I>&gt;<i> it should work identically if you have sequence-of-many-bytes tokens 
</I>&gt;<i> instead.
</I>&gt;<i> 
</I>&gt;<i> (Apparently only the distinction between 0 and more-than-0 parse errors 
</I>&gt;<i> is important as far as the spec is concerned, since that has an effect 
</I>&gt;<i> on whether the document is conforming; but it seems useful for 
</I>&gt;<i> implementors to share test cases that are precise about exactly where 
</I>&gt;<i> all the parse errors are emitted, since that helps find bugs, and so the 
</I>&gt;<i> parse error count is relevant.)
</I>
I considered changing this in the spec, but it doesn't really seem to 
matter. UAs are already allowed to do all kinds of things with parse 
errors that would make these cases indistinguishable.


On Mon, 22 Dec 2008, Edward Z. Yang wrote:
&gt;<i>
</I>&gt;<i> 8.2.4.4 Close tag open state
</I>&gt;<i>
</I>&gt;<i> The condition here is reaaaally long. Is there any way we can make it 
</I>&gt;<i> shorter?
</I>
On Mon, 22 Dec 2008, Henri Sivonen wrote:
&gt;<i> 
</I>&gt;<i> Not really, but it's possible to flatten out the lookahead by adding 
</I>&gt;<i> states so that the condition in each state becomes simpler. (In fact, 
</I>&gt;<i> it's possible to remove lookahead from the tokenizer altogether by 
</I>&gt;<i> adding more states.) See Tokenizer.java in the Validator.nu HTML Parser.
</I>
I haven't changed anything here. I'm not sure what is really being 
proposed.


On Mon, 22 Dec 2008, Edward Z. Yang wrote:
&gt;<i> 
</I>&gt;<i> I think EOF should be handled explicitly in the states after we &quot;Consume 
</I>&gt;<i> the U+0023 NUMBER SIGN,&quot; since the spec as it stands right now implies 
</I>&gt;<i> that there will always be another character after the number sign. Or am 
</I>&gt;<i> I being a little redundant?
</I>
On Mon, 22 Dec 2008, Philip Taylor wrote:
&gt;<i>
</I>&gt;<i> EOF is always treated as if it were a character, e.g. lots of places say 
</I>&gt;<i> &quot;Consume the next input character: ... EOF -&gt; ... Reconsume the EOF 
</I>&gt;<i> character in the data state&quot;. If you have &quot;&amp;#&quot; at the end of a file, the 
</I>&gt;<i> next character is the EOF character, which is not 'x' or 'X' and so it 
</I>&gt;<i> is &quot;anything else&quot;. So it seems consistent and unambiguous to me.
</I>
On Mon, 22 Dec 2008, Edward Z. Yang wrote:
&gt;<i> 
</I>&gt;<i> That seems fair, although most implementations won't have an actual end 
</I>&gt;<i> of file character; they'll be checking their string index to see if 
</I>&gt;<i> they've gone out of bounds. But the spec is internally consistent (I'm 
</I>&gt;<i> just used to seeing an EOF special case on almost every state).
</I>
I haven't changed the spec here either, for the reason Philip gave.

(Personally I would recommend actually using an EOF character, as it makes 
the code much simpler and can in fact make it faster. There are several 
characters you can use to denote an EOF (since several have to be stripped 
early), I personally favour U+0000.


On Tue, 23 Dec 2008, Kartikaya Gupta wrote:
&gt;<i>
</I>&gt;<i> For the steps under 'A start tag whose tag name is &quot;textarea&quot;' in 
</I>&gt;<i> 8.2.5.10 (in body insertion mode), step 3 seems wrong to me, since step 
</I>&gt;<i> 1 already includes an append operation. As specified now, it will cause 
</I>&gt;<i> two textarea elements to be added (assuming &quot;new element&quot; refers to the 
</I>&gt;<i> textarea).
</I>
Fixed. Thanks. (It wouldn't cause two elements, though, it would just case 
the one element to be inserted twice.)


On Mon, 22 Dec 2008, Edward Z. Yang wrote:
&gt;<i> 
</I>&gt;<i> When I'm consuming a character reference, when does the ampersand get 
</I>&gt;<i> consumed? This doesn't seem to be obvious from the documentation, which 
</I>&gt;<i> talks of consuming character references and number hash signs, but never 
</I>&gt;<i> the ampersand.
</I>
On Tue, 23 Dec 2008, Philip Taylor wrote:
&gt;<i> 
</I>&gt;<i> They're consumed in the state that comes before the character
</I>&gt;<i> reference state, e.g.:
</I>&gt;<i> 
</I>&gt;<i>   &quot;8.2.4.1 Data state
</I>&gt;<i>   Consume the next input character:
</I>&gt;<i>    -&gt; U+0026 AMPERSAND (&amp;) ... switch to the character reference data state.&quot;
</I>
No change, based on Philip's comment.


On Mon, 22 Dec 2008, Edward Z. Yang wrote:
&gt;<i>
</I>&gt;<i> &quot;in the range 0x0000 to 0x0008, U+000B, U+000E to 0x001F, 0x007F to 
</I>&gt;<i> 0x009F, 0xD800 to 0xDFFF , 0xFDD0 to 0xFDDFin the range 0x0000 to 
</I>&gt;<i> 0x0008, U+000B, U+000E to 0x001F, 0x007F to 0x009F, 0xD800 to 0xDFFF, 
</I>&gt;<i> 0xFDD0 to 0xFDDF&quot;
</I>&gt;<i> 
</I>&gt;<i> U+000B is not a range.
</I>
While this is technically true, I don't really see a better way to phrase 
this that isn't verbose (e.g. &quot;ranges and codepoints&quot; or some such).

If it helps, consider the whole set of subranges and code points to be a 
single discontinuous range, hence the use of the singular &quot;range&quot;. :-)


On Tue, 23 Dec 2008, Edward Z. Yang wrote:
&gt;<i>
</I>&gt;<i> In section 8.2.4.26 the spec says:
</I>&gt;<i> 
</I>&gt;<i> &gt; If the next six characters are an ASCII case-insensitive match for the 
</I>&gt;<i> &gt; word &quot;PUBLIC&quot;, then consume those characters and switch to the before 
</I>&gt;<i> &gt; DOCTYPE public identifier state.
</I>&gt;<i> 
</I>&gt;<i> The P has already been consumed at the beginning of this section. Thus, 
</I>&gt;<i> I believe it should read:
</I>&gt;<i> 
</I>&gt;<i> If this character and the next five characters are an ASCII 
</I>&gt;<i> case-insensitive match for the word &quot;PUBLIC&quot;, etc.
</I>&gt;<i> 
</I>&gt;<i> Same goes for the match for SYSTEM.
</I>
You're still checking the next input character at that point, so &quot;P&quot; is 
still the &quot;next input character&quot;, so the next six are &quot;PUBLIC&quot;.

At least, that's how I'm defending what the spec says. :-)

In practice I think having the text be clear (&quot;PUBLIC&quot;) is less confusing 
than having it be pedantic (&quot;P&quot; and &quot;UBLIC&quot; or &quot;this and the next five&quot; or 
some such). It's not like people are going to assume the spec is allowing 
&quot;XPUBLIC&quot; or &quot;*PUBLIC&quot; and so forth, right?

Cheers,
-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017927.html">[whatwg] Error in 8.2.4.26 After DOCTYPE name state
</A></li>
	<LI>Next message: <A HREF="017951.html">[whatwg] Parsing, syntax, and content model feedback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17947">[ date ]</a>
              <a href="thread.html#17947">[ thread ]</a>
              <a href="subject.html#17947">[ subject ]</a>
              <a href="author.html#17947">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
