<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Examples where HTML5 is not multicore-ready
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Examples%20where%20HTML5%20is%20not%20multicore-ready&In-Reply-To=%3C20100726182026.GC2208%40erno%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027352.html">
   <LINK REL="Next"  HREF="027356.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Examples where HTML5 is not multicore-ready</H1>
<!--htdig_noindex-->
    <B>Ryan Heise</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Examples%20where%20HTML5%20is%20not%20multicore-ready&In-Reply-To=%3C20100726182026.GC2208%40erno%3E"
       TITLE="[whatwg] Examples where HTML5 is not multicore-ready">ryan at ryanheise.com
       </A><BR>
    <I>Mon Jul 26 11:20:26 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="027352.html">[whatwg] Fwd:  Timed tracks for &lt;video&gt;
</A></li>
        <LI>Next message: <A HREF="027356.html">[whatwg] Fwd: Timed tracks for &lt;video&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27353">[ date ]</a>
              <a href="thread.html#27353">[ thread ]</a>
              <a href="subject.html#27353">[ subject ]</a>
              <a href="author.html#27353">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Hi everyone,

I would like this thread to be a collection of parallel algorithms that
should run faster as the number of cores increase, but in HTML5 (using
Web Workers) will actually run slower as the number of cores increase.

If there are significant and substantial examples of parallel algorithms
that actually run slower on more expensive multi-core machines, this
would be an embarrassing result that should be addressed sooner rather
than later.

I am mostly interested in realworld examples, but some synthetic
examples could also be interesting.

Realworld example #1:

	Sorting an array of large objects by a key that is contained
	within the objects.

Realworld example #2:

	Particle systems. To understand why this is a good example,
	read:

	<A HREF="http://software.intel.com/sites/billboard/archive/ticker-tape.php">http://software.intel.com/sites/billboard/archive/ticker-tape.php</A>

	Particle systems are often used in games and other graphics
	applications. (If anyone wants to run benchmarks, here is a
	starting point: <A HREF="http://www.ryanheise.com/html5/particles.html">http://www.ryanheise.com/html5/particles.html</A>)

Realworld example #3:

	<A HREF="http://www.picnet.com.au/blogs/Guido/post/2010/02/18/Html-Web-Worker-Woes-Data-Analysis-not-an-Option.aspx">http://www.picnet.com.au/blogs/Guido/post/2010/02/18/Html-Web-Worker-Woes-Data-Analysis-not-an-Option.aspx</A>

	Guido provides an interesting example that is not game related,
	and also provides a synthetic demonstration.

Realworld example #4:

	Game artificial intelligence that needs to analyse large data
	structures.

Synthetic example #1:

	for (var i = 0; i &lt; 100000000; i++)
		array[i] = i;

Synthetic example #2

	Guido's example from above.

(Although many realworld examples also follow this pattern)


For anyone who would like to contribute to these examples, here is how
to go about finding similar examples:

The kinds of examples that are likely to slow down rather than speed up
as more cores are added are those with a high memory access to cpu usage
ratio. Of these, there are two kinds:

1. Those that require heavy write access.
2. Those that mainly rely on readonly access.

Sorting and particle systems are both examples of the first kind, and
can potentially have a high memory access to cpu usage ratio.

An example of the second kind is a game artifical intelligence which
needs to analyse the entire game state without necessarily changing it.
(Beware: although the AI will not modify this memory, this is not
readonly memory. Being game &quot;state&quot;, it will surely be updated by the
physics engine.)

This thread is a follow-up to a recent thread:
<A HREF="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2010-July/027229.html">http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2010-July/027229.html</A>

-- 
Ryan Heise
</PRE>










<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027352.html">[whatwg] Fwd:  Timed tracks for &lt;video&gt;
</A></li>
	<LI>Next message: <A HREF="027356.html">[whatwg] Fwd: Timed tracks for &lt;video&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27353">[ date ]</a>
              <a href="thread.html#27353">[ thread ]</a>
              <a href="subject.html#27353">[ subject ]</a>
              <a href="author.html#27353">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
