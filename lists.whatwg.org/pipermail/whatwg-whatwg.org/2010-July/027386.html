<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Timed tracks for &lt;video&gt;
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Timed%20tracks%20for%20%3Cvideo%3E&In-Reply-To=%3CPine.LNX.4.64.1007152316530.7242%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="069209.html">
   <LINK REL="Next"  HREF="069548.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Timed tracks for &lt;video&gt;</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Timed%20tracks%20for%20%3Cvideo%3E&In-Reply-To=%3CPine.LNX.4.64.1007152316530.7242%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] Timed tracks for &lt;video&gt;">ian at hixie.ch
       </A><BR>
    <I>Thu Jul 22 22:40:57 PDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="069209.html">[whatwg] My proposal of a subtitle format via an XML-like markup (in progress)
</A></li>
        <LI>Next message: <A HREF="069548.html">[whatwg] Timed tracks for &lt;video&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27386">[ date ]</a>
              <a href="thread.html#27386">[ thread ]</a>
              <a href="subject.html#27386">[ subject ]</a>
              <a href="author.html#27386">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>
I recently added to the HTML spec a mechanism by which external subtitles 
and captions can be added to videos in HTML.

In designing this feature I went through hundreds and hundreds of e-mails, 
blogs, proposals, etc, trying to get all the key use cases that needed 
handling. (Replies to the WHATWG e-mails on the topic are included below.)

The proposal consists of several components:

 - A &lt;track&gt; element for linking to timed tracks from the markup.
 - A DOM API for manipulating timed tracks dynamically.
 - A specification for a simple captioning format.
 - A set of rules and processing models to hold it all together.

I tried to keep the following principles in mind when designing this 
feature. These are principles in line with the attitude used for the rest 
of the HTML specification's design also.

 - Keep things simple: features that don't have clear use cases and broad 
   appeal shouldn't be considered.
 - Keep implementation costs for standalone players low.
 - Use real data to determine what use cases are relevant.
 - Use existing technologies where appropriate.
 - Don't innovate, but provide others with the ability to do so.
 - Try as much as possible to have things Just Work.

I first researched (with some help from various other contributors - 
thanks!) what kinds of timed tracks were common. The main classes of use 
cases I tried to handle were plain text subtitles (translations) and 
captions (transcriptions) with minimal inline formatting and karaoke 
support, chapter markers so that browsers could provide quick jumps to 
points in the video, text-driven audio descriptions, and application- 
specific timed data. Text-driven audio descriptions aren't common (most 
audio descriptions use audio files), so these may be a little more 
innovative than makes sense for a specification. The specification so far 
doesn't really say how they are to be interpreted; I expect this area to 
change significantly based on implementation feedback.

The most controversial feature may be the captioning format. Based on SRT, 
a widely-supported and somewhat widely-used format, it tries to apply the 
principles of separating presentation from semantics. I've defined some 
extensions to CSS to help style the subtitles in browsers, while keeping 
the format compatible with existing players so that careful authors can 
write files that work both in new browsers and existing players.

Currently this format's parser rules assume UTF-8; this may be something 
we have to change in the future. Unfortunately since existing files don't 
seem to declare their encodings we can't easily reuse existing files 
unless we provide an out-of-band encoding override such as the &quot;charset&quot; 
attribute on &lt;script&gt;. I haven't gone there yet, but we can consider this 
if supporting existing files without having them convert to UTF-8 is 
desired. The parser is designed to be very easy to implement while leaving 
us lots of room to extend the format in the future.


The rest of this e-mail consists of replies to various e-mails sent on the 
subject in the last year. I haven't included all e-mails; in particular, a 
number of e-mails that were very useful in the development of the proposed 
format and API consisted of just use cases and links, which I haven't 
reproduced below. Nonetheless, thanks to the authors of those e-mails.


On Thu, 16 Jul 2009, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> [...] the problem with creating a new format is that you start from 
</I>&gt;<i> scratch and already spreaded formats are not supported.
</I>
Indeed. Hopefully by reusing SRT we are able to leverage a significant 
amount of existing infrastructure, such as it is.


&gt;<i> I can see that your proposed format is trying to be backwards compatible 
</I>&gt;<i> with SRT, so at least it would work for the large number of existing srt 
</I>&gt;<i> file collections. I am still skeptical, in particular because there are 
</I>&gt;<i> no authoring systems for this format around.
</I>
SRT was invented for an authoring tool, so clearly there are some. The 
good thing about this format, though, is that it is really simple to 
support and therefore tool creation should be an easy matter.


&gt;<i> &gt;&gt; In fact, the easiest solution would be if that particular format was 
</I>&gt;<i> &gt;&gt; really only HTML.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; IMHO that would be absurd. HTML means scripting, embedded videos, an 
</I>&gt;<i> &gt; unbelivably complex rendering system, complex parsing, etc; plus, 
</I>&gt;<i> &gt; what's more, it doesn't even support timing yet, so we'd have to add 
</I>&gt;<i> &gt; all the timing and karaoke features on top of it. Requiring that video 
</I>&gt;<i> &gt; players embed a timed HTML renderer just to render subtitles is like 
</I>&gt;<i> &gt; saying that we should ship Microsoft Word with every DVD player, to 
</I>&gt;<i> &gt; handle the user input when the user wants to type in a new chapter 
</I>&gt;<i> &gt; number to jump to.
</I>&gt;<i> 
</I>&gt;<i> I agree, it cannot be a format that contains all the complexity of HTML. 
</I>&gt;<i> It would only support a subpart of HTML that is relevant, plus the 
</I>&gt;<i> addition of timing - and in this case is indeed a new format.
</I>
If we don't use HTML wholesale, then there's really no reason to use HTML 
at all. (And using HTML wholesale is not really an option, as you say 
above.) Profiling HTML is a huge amount of work, however, for everyone 
involved: you have to basically write a whole new spec, you have to write 
a whole new set of test cases, and you have to write a whole new set of 
implementations -- some code reuse would be possible in the latter case, 
though great care has to be taken to make sure only the right code is 
reused, as otherwise there would be a huge risk that people implement more 
than the profile, leading to huge interop problems.


&gt;<i> I have therefore changed my mind since I sent that email in Dec 08 and 
</I>&gt;<i> am hoping we can do it with existing formats.
</I>
Excellent. :-)


&gt;<i> In particular, I have taken an in-depth look at the latest specification 
</I>&gt;<i> from the Timed Text working group that have put years of experiments and 
</I>&gt;<i> decades of experience into developing DFXP. You can see my review of 
</I>&gt;<i> DFXP here: 
</I>&gt;<i> <A HREF="http://blog.gingertech.net/2009/06/28/a-review-of-the-w3c-timed-text-authoring-format/">http://blog.gingertech.net/2009/06/28/a-review-of-the-w3c-timed-text-authoring-format/</A> 
</I>&gt;<i> I think it is both too flexible in a lot of ways, but also too 
</I>&gt;<i> restrictive in others. However, it is a well formulated format that is 
</I>&gt;<i> also getting market traction. In addition, it is possible to formulate 
</I>&gt;<i> profiles to add missing functionality.
</I>
I looked at DXFP when looking at which format to use:

   <A HREF="http://wiki.whatwg.org/wiki/Timed_track_formats">http://wiki.whatwg.org/wiki/Timed_track_formats</A>

Compared to the other formats I examined, it performs poorly on pretty 
much every front:

 - It's based on XML, which means it is hard to hand-author and quite 
   verbose. It uses namespaces, which means it's very prone to authoring 
   errors.

 - It is very much formatting-centric, rather than semantic-based.

 - It uses (amongst other things) pixel-based positioning, which makes it 
   very awkward to use when you don't know the size of the video file or 
   of the display.

 - It would be quite difficult to expose sanely in a simple API; you'd 
   basically just have to expose the whole DOM and hope for the best.

 - It is quite hard to use it to do karaoke-style internally timed cues.


&gt;<i> If we want a quick and dirty hack, srt itself is probably the best 
</I>&gt;<i> solution. If we want a well thought-out solution, DFXP is probably a 
</I>&gt;<i> better idea.
</I>
I don't really agree with that characterisation.


&gt;<i> &gt;&gt; Here is my example again:
</I>&gt;<i> &gt;&gt; &lt;video src=&quot;<A HREF="http://example.com/video.ogv">http://example.com/video.ogv</A>&quot; controls&gt;
</I>&gt;<i> &gt;&gt; &#160;&lt;text category=&quot;CC&quot; lang=&quot;en&quot; type=&quot;text/x-srt&quot; src=&quot;caption.srt&quot;&gt;&lt;/text&gt;
</I>&gt;<i> &gt;&gt; &#160;&lt;text category=&quot;SUB&quot; lang=&quot;de&quot; type=&quot;application/ttaf+xml&quot; src=&quot;german.dfxp&quot;&gt;&lt;/text&gt;
</I>&gt;<i> &gt;&gt; &#160;&lt;text category=&quot;SUB&quot; lang=&quot;jp&quot; type=&quot;application/smil&quot; src=&quot;japanese.smil&quot;&gt;&lt;/text&gt;
</I>&gt;<i> &gt;&gt; &#160;&lt;text category=&quot;SUB&quot; lang=&quot;fr&quot; type=&quot;text/x-srt&quot; src=&quot;translation_webservice/fr/caption.srt&quot;&gt;&lt;/text&gt;
</I>&gt;<i> &gt;&gt; &lt;/video&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Here's a counterproposal:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &#160; &lt;video src=&quot;<A HREF="http://example.com/video.ogv">http://example.com/video.ogv</A>&quot;
</I>&gt;<i> &gt; &#160; &#160; &#160; &#160; &#160;subtitles=&quot;<A HREF="http://example.com/caption.srt">http://example.com/caption.srt</A>&quot; controls&gt;
</I>&gt;<i> &gt; &#160; &lt;/video&gt;
</I>&gt;<i> 
</I>&gt;<i> Subtitle files are created to enable users to choose the text in the 
</I>&gt;<i> language that they speak to be displayed. With a simple addition like 
</I>&gt;<i> what you are proposing, I don't think such a choice is possible. Or do 
</I>&gt;<i> you have a proposal on how to choose the adequate language file?
</I>
The proposal now looks like:

   &lt;video src=&quot;<A HREF="http://example.com/video.ogv">http://example.com/video.ogv</A>&quot; controls&gt;
     &lt;track srclang=en src=&quot;caption.srt&quot;&gt;
     &lt;track srclang=de kind=subtitles src=&quot;german.dfxp&quot;&gt;
     &lt;track srclang=jp kind=subtitles src=&quot;japanese.smil&quot;&gt;
     &lt;track srclang=fr kind=subtitles src=&quot;translation_webservice/fr/caption.srt&quot;&gt;
     (...fallback...)
   &lt;/video&gt;


&gt;<i> Also, the attributes on the proposed text element of course serve a purpose:
</I>&gt;<i> * the &quot;category&quot; attribute is meant to provide a default for styling
</I>&gt;<i> the text track,
</I>
I renamed this to &quot;kind&quot; in the spec.


&gt;<i> * the &quot;language&quot; attribute is meant to provide a means to build a menu
</I>&gt;<i> to choose the adequate subtitle file from,
</I>
&quot;srclang&quot;.


&gt;<i> * the &quot;type&quot; attribute is meant to both identify the mime type of the
</I>&gt;<i> format and the character set used in the file.
</I>
It's not clear that the former is useful. The latter may be useful; I 
haven't supported that yet.


&gt;<i> The character set question is actually a really difficult problem to get 
</I>&gt;<i> right, because srt files are created in an appropriate character set for 
</I>&gt;<i> the language, but there is no means to store in a srt file what 
</I>&gt;<i> character set was used in its creation. That's a really bad situation to 
</I>&gt;<i> be in for the Web server, who can then only take an educated guess. By 
</I>&gt;<i> giving the ability to the HTML author to specify the charset of the srt 
</I>&gt;<i> file with the link, this can be solved.
</I>
Yeah, if this is a use case people are concerned about, then I agree that 
a solution at the markup level makes sense.


On Thu, 16 Jul 2009, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> There are already more formats than you could possibly want on the scale 
</I>&gt;<i> between SRT (dumb text) and complex XML formats like DFXP or USF (used 
</I>&gt;<i> in Matroska).
</I>
Indeed. I tried to examine all of them, but many had no documentation that 
I could find. The results are in the wiki page cited above.


&gt;<i> In my layman opinion both extremes make sense, but anything in between 
</I>&gt;<i> I'm rather skeptical to.
</I>
Is the SRT variant described in the spec extreme enough to make sense?


&gt;<i> I think that eventually we will want timing/synchronization in HTML for 
</I>&gt;<i> synchronizing multiple video or audio tracks.
</I>
Agreed. We need this for various purposes, including possibly most 
importantly sign-language tracks.


&gt;<i> As far as I can tell no browser wants to implement the addCueRange API 
</I>&gt;<i> (removing this should be the topic of a separate mail), so we really 
</I>&gt;<i> need to re-think this part and I think that timed text plays an 
</I>&gt;<i> important part here.
</I>
The addCueRange() API has been removed and replaced with a feature based 
on the subtitle mechanism.


On Fri, 31 Jul 2009, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> * I can see a need for a multitude of different categories of 
</I>&gt;<i> time-aligned text that either already exist or will be developed in the 
</I>&gt;<i> future. The list that I can currently grasp is mentioned in the 
</I>&gt;<i> specification. While these text categories are rather diverse (e.g. 
</I>&gt;<i> karaoke text, ticker text, chapter markers, captions), they all share 
</I>&gt;<i> common properties and can be handled in fundamentally the same way by a 
</I>&gt;<i> browser. I therefore propose a common &quot;itext&quot; element (for &quot;included 
</I>&gt;<i> text&quot;) to deal with associating such time-aligned text resources with 
</I>&gt;<i> &lt;video&gt; resources.
</I>
That's more or less what &lt;track&gt; is now. I started with just a small set 
of kinds of tracks, but we can add more in the future if new ones are 
found to be useful.


&gt;<i> * I can also see a need for internationalisation of each text category. 
</I>&gt;<i> I.e. each text resource will come with an associated language for which 
</I>&gt;<i> it is valid and alternative language resources will be made available. 
</I>&gt;<i> This is why I am suggesting the @lang attribute.
</I>
I went with srclang=&quot;&quot;, since lang=&quot;&quot; is already used for another purpose.


&gt;<i> * It is unclear, which of the given alternative text tracks in different 
</I>&gt;<i> languages should be displayed by default when loading an &lt;itext&gt; 
</I>&gt;<i> resource. A @default attribute has been added to the &lt;itext&gt; elements to 
</I>&gt;<i> allow for the Web content author to tell the browser which &lt;itext&gt; 
</I>&gt;<i> tracks he/she expects to be displayed by default. If the Web author does 
</I>&gt;<i> not specify such tracks, the display depends on the user agent (UA - 
</I>&gt;<i> generally the Web browser): for accessibility reasons, there should be a 
</I>&gt;<i> field that allows users to always turn display of certain &lt;itext&gt; 
</I>&gt;<i> categories on. Further, the UA is set to a default language and it is 
</I>&gt;<i> this default language that should be used to select which &lt;itext&gt; track 
</I>&gt;<i> should be displayed.
</I>
It's not clear to me that we need a way to do this; by default presumably 
tracks would all be off unless the user wants them, in which case the 
user's preferences are paramount. That's what I've specced currently. 
However, it's easy to override this from script.


&gt;<i> * Another typical feature of time-aligned text files is that they may be 
</I>&gt;<i> out of sync with the actual video file. For that purpose, a @delay 
</I>&gt;<i> attribute was suggested as an addition to the &lt;itext&gt; element. This has 
</I>&gt;<i> not been implemented into the demo. In the feedback to this proposal, a 
</I>&gt;<i> further &quot;stretch&quot; or &quot;drift&quot; attribute was suggested.
</I>
I haven't added this yet, but it's an interesting idea (possibly best kept 
until a &quot;v2&quot; release though). One can implement this from script by 
creating a new track that simply copies the previous one cue-for-cue with 
an offset applied, so we'll be able to see if this is something for which 
there is real demand by seeing if anyone does that.


On Fri, 31 Jul 2009, Philip J&#195;&#164;genstedt wrote:
&gt;<i> 
</I>&gt;<i> * DOM interfaces. These should be the same regardless of source 
</I>&gt;<i> (external/internal) and format. I also believe these ranges have event 
</I>&gt;<i> listeners, so as to replace the cue ranges interface.
</I>
Done.


&gt;<i> * Security. What restrictions should apply for cross-origin loading?
</I>
Currently the files have to be same-origin. My plan is to wait for CORS to 
be well established and then use it for timed tracks, video files, images 
on &lt;canvas&gt;, text/event-stream resources, etc.


&gt;<i> * Complexity. There is no limit to the complexity one could argue for 
</I>&gt;<i> (bouncing ball multi-color karaoke with fan translations/annotations 
</I>&gt;<i> anyone?). We should accept that some use cases will require creative use 
</I>&gt;<i> of scripts/SVG/etc and not even try to solve them up-front. Draw a line 
</I>&gt;<i> and stick to it.
</I>
Agreed. Hopefully you agree with where I drew the line! :-)


On Sun, 11 Apr 2010, Silvia Pfeiffer wrote:
&gt;<i> On Sun, Apr 11, 2010 at 4:18 PM, Robert O'Callahan wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This needs to be clarified. Authors can position arbitrary content 
</I>&gt;<i> &gt; over the video, and presumably the browser is not supposed to ensure 
</I>&gt;<i> &gt; rendered text doesn't collide with such content. I presume what you 
</I>&gt;<i> &gt; meant is simply that rendered text must not collide with browser 
</I>&gt;<i> &gt; built-in UI. Although I'm not sure how that can be ensured when 
</I>&gt;<i> &gt; arbitrary styling of the rendered text is supported.
</I>&gt;<i> 
</I>&gt;<i> Yes, the idea was for browser built-in default UI controls. [...]
</I>&gt;<i>
</I>&gt;<i> The main issue is to keep the area that captions or subtitles are 
</I>&gt;<i> rendered into and the area that controls are rendered into separately, 
</I>&gt;<i> since you will always want to have access to both if both are activated.
</I>
I've made sure that WebSRT titles avoid overlapping the controls.


On Sun, 11 Apr 2010, Chris Double wrote:
&gt;<i> 
</I>&gt;<i> I am wary of being required to implement the entire TTML specification 
</I>&gt;<i> and an underspecified SRT format.
</I>
I've specified the SRT format and not required TTML support (though I have 
provided rough guidelines for how to implement it in a manner consistent 
with the rest of the captions model if you do want to implement it).


On Mon, 12 Apr 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> For the record, I am also not enthusiastic about TTML, specifically the 
</I>&gt;<i> styling mechanism which even makes creative use of XML namespaces. An 
</I>&gt;<i> example for those that haven't seen it before: 
</I>&gt;<i> <A HREF="http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-backgroundColor-example-1">http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-backgroundColor-example-1</A>
</I>&gt;<i>
</I>&gt;<i> &lt;region xml:id=&quot;r1&quot;&gt;
</I>&gt;<i>  &lt;style tts:extent=&quot;306px 114px&quot;/&gt;
</I>&gt;<i>  &lt;style tts:backgroundColor=&quot;red&quot;/&gt;
</I>&gt;<i>  &lt;style tts:color=&quot;white&quot;/&gt;
</I>&gt;<i>  &lt;style tts:displayAlign=&quot;after&quot;/&gt;
</I>&gt;<i>  &lt;style tts:padding=&quot;3px 40px&quot;/&gt;
</I>&gt;<i> &lt;/region&gt;
</I>&gt;<i> ...
</I>&gt;<i> &lt;p region=&quot;r1&quot; tts:backgroundColor=&quot;purple&quot; tts:textAlign=&quot;center&quot;&gt;
</I>&gt;<i>  Twinkle, twinkle, little bat!&lt;br/&gt;
</I>&gt;<i>  How &lt;span tts:backgroundColor=&quot;green&quot;&gt;I wonder&lt;/span&gt; where you're at!
</I>&gt;<i> &lt;/p&gt;
</I>&gt;<i> 
</I>&gt;<i> While I don't have any suggestions about what to use instead, I'd much 
</I>&gt;<i> prefer something which just uses CSS with the same syntax we're all used 
</I>&gt;<i> to.
</I>
I've defined some CSS extensions to allow us to use CSS with SRT.


On Tue, 13 Apr 2010, Jonas Sicking wrote:
&gt;<i> 
</I>&gt;<i> Will implementations want to do the rendering of the subtitles off the 
</I>&gt;<i> main thread? I believe many browsers are, or are planning to, render the 
</I>&gt;<i> actual video graphics using a separate thread. If that is correct, do we 
</I>&gt;<i> want to support rendering of the subtitles on a separate thread too?
</I>&gt;<i> 
</I>&gt;<i> Or is it enough to do the rendering on the main thread, but composit 
</I>&gt;<i> using a separate thread?
</I>&gt;<i> 
</I>&gt;<i> If rendering is expected to happen on a separate thread, then CSS is 
</I>&gt;<i> possibly not the right solution as most CSS engines are main-thread-only 
</I>&gt;<i> today.
</I>
I've tried to scope the complexity of the way CSS is used to style WebSRT 
so as to avoid making it too hard to precompute the information needed to 
style the titles and then shove the data to the other thread for final 
processing and rendering. I don't know how successful I have been (you 
might still have to send updates regularly, basically anytime the computed 
styles of the &lt;video&gt; element itself changes, or any time the DOM changes 
in a way that affects which selectors match the cues), but those changes 
can be sent asynchronously, it seems. The actual rendering is somewhat 
scoped; there's only so much you can do. For example, you can't change the 
'display' value, use 'float's, collapse margins, or anything like that.


On Wed, 14 Apr 2010, Jonas Sicking wrote:
&gt;<i> 
</I>&gt;<i> I like this approach, though I wonder how it's intended to attach a 
</I>&gt;<i> stylesheet to the SRT+HTML file?
</I>
Currently, styles are attached to the HTML file that contains the &lt;video&gt;, 
and apply to the SRT file. If this is successful, it would make sense to 
add a mechanism to SRT files to link straight to the CSS files, but I 
don't think that's a priority yet.


&gt;<i> Of course, even better would be to have a markup language for marking up 
</I>&gt;<i> the meaning of the timed text. For example, it's unfortunate that the 
</I>&gt;<i> DFXP markup contains things like
</I>&gt;<i> 
</I>&gt;<i> [Water dropping]&lt;br/&gt;
</I>&gt;<i> [&lt;span tts:fontStyle=&quot;italic&quot; tts:color=&quot;lime&quot;&gt;plop, plop, plop, &#133;&lt;/span&gt;]
</I>&gt;<i> 
</I>&gt;<i> Where the brackets clearly mean that the contained text isn't being 
</I>&gt;<i> said, but that they are sound effects. This would be much better done 
</I>&gt;<i> with markup like:
</I>&gt;<i> 
</I>&gt;<i> &lt;descriptive&gt;Water dropping&lt;/descriptive&gt;
</I>&gt;<i> &lt;soundeffect&gt;plop, plop, plop&lt;/soundeffect&gt;
</I>
In WebSRT, this is now:

   &lt;sound&gt;Water dropping
   plop, plop, plop

...or, if you want the square brackets to render:

   &lt;sound&gt;[Water dropping]
   [plop, plop, plop]

To style it as lime italics, the CSS is:

   ::cue-part(sound) { font-style: italic; color: lime; }


&gt;<i> On a separate note, I note that the DFXP file seems to be specific to a 
</I>&gt;<i> specific size of the video. If I resize the video, the captions that go 
</I>&gt;<i> on top of the video doesn't move appropriately. This could very well 
</I>&gt;<i> simply be due to this being a demo. Or due to a bug in the 
</I>&gt;<i> &quot;implementation&quot;. Or a simple mistake on on the part of the author of 
</I>&gt;<i> the specific DFXP file.
</I>
In WebSRT, the positioning is all with percentages (or relative line 
numbers), side-stepping this issue (this also neatly solves the problem 
that occurs when the ratio changes, e.g. due to someone accidentally 
forcing something into anamorphic view).


On Thu, 15 Apr 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> A spec would need to be written for this new extended SRT format.
</I>
Done. :-)


&gt;<i> Also, if we are introducing HTML markup inside SRT time cues, then it 
</I>&gt;<i> would make sense to turn the complete SRT file into markup, not just the 
</I>&gt;<i> part inside the time cue.
</I>
That doesn't seem to follow. Could you elaborate?


&gt;<i> Further, SRT has no way to specify which language it is written in
</I>
What's the use case?


&gt;<i> further such general mechanisms that already exist for HTML.
</I>
Such as?


&gt;<i> That extension doesn't give us anything anyway, since no existing SRT 
</I>&gt;<i> application would be able to do much with it.
</I>
Why not?


&gt;<i> It is not hard to replicate the SRT functionality in something new. If 
</I>&gt;<i> we really want to do &quot;SRT + HTML + CSS&quot;, then we should start completely 
</I>&gt;<i> from a blank page.
</I>
I'm not a big fan of reinventing wheels. Only when what already exists 
simply doesn't handle all the use cases and can't be extended to do so 
does it make sense to start over.


On Thu, 15 Apr 2010, Philip J&#228;genstedt wrote:
&gt;<i> 
</I>&gt;<i> While I don't favor TTML, I also don't think that extending SRT is a 
</I>&gt;<i> great way forward, mostly because I don't see how to specify the 
</I>&gt;<i> language (which sometimes helps font selection),
</I>
That's done in the &lt;track&gt; element. It can't be in the file, since you 
need to know it before downloading the file (otherwise you'd have to 
download all the files to update the UI).


&gt;<i> apply document-wide styling,
</I>
I just used the document's own styles.


&gt;<i> reference external style sheets,
</I>
I just did that from the document.


&gt;<i> use webfonts, etc...
</I>
Since the styles come from the document, the fonts come from there too.


&gt;<i> I actually quite like the general idea behind Silvia's 
</I>&gt;<i> <A HREF="http://wiki.xiph.org/Timed_Divs_HTML">http://wiki.xiph.org/Timed_Divs_HTML</A>
</I>&gt;<i> 
</I>&gt;<i> This is somewhat similar to the &lt;timerange&gt; proposal that David Singer 
</I>&gt;<i> and Eric Carlson from Apple have brought up a few times.
</I>
I am very reluctant to have such a verbose format be used for such dense 
data files as captions. It works for HTML because the use of markup is 
balanced with the text (though it can get pretty borderline, e.g. the HTML 
spec itself has a high ratio of markup to text). It's not a nice format 
for more dense data, IMHO.


&gt;<i> No matter the syntax, the idea is basically to allow marking up certain 
</I>&gt;<i> parts of HTML as being relevant for certain time ranges. A CSS 
</I>&gt;<i> pseudo-selector matches the elements which are currently active, based 
</I>&gt;<i> on the current time of the media.
</I>&gt;<i> 
</I>&gt;<i> So, the external subtitle file could simply be HTML, [...]
</I>&gt;<i>
</I>&gt;<i> Cons:
</I>&gt;<i> - Politics.
</I>&gt;<i> - New format for subtitle authors and tools.
</I>&gt;<i> - Not usable outside the web platform (i.e. outside of web browsers).
</I>
The last of these is pretty critical, IMHO.

It would also result in some pretty complicated situations, like captions 
containing &lt;video&gt;s themselves.


&gt;<i> Pros:
</I>&gt;<i> + Styling using CSS and only CSS.
</I>
We'd need extensions (for timing, to avoid different caption streams 
overlapping), so I think this would end up being no better than what we've 
ended up with with WebSRT.


&gt;<i> + Well known format to web authors and tools.
</I>
SRT is pretty well-known in the subtitling community.


&gt;<i> + High reuse of existing implementations.
</I>
I think the incremental cost of implementing WebSRT is pretty minimal; I 
tried to make it possible for a browser to reuse all the CSS 
infrastructure, for instance.


&gt;<i> + You could author CSS to make the HTML document read as a transcript 
</I>&gt;<i> when opened directly.
</I>
That isn't a use case I considered. Is it a use case we should address?


&gt;<i> + &lt;timerange&gt; reusable for page-embedded timed markup, which was the 
</I>&gt;<i> original idea.
</I>
I didn't end up addressing this use case. I think if we do this we should 
seriously consider how it interacts with SMIL/SVG. I also think it's 
something we should look at in conjunction with synchronising multiple 
&lt;video&gt; or &lt;audio&gt; elements, e.g. to do audio descriptions, dubbing, 
sign-language video overlays, split-screen video, etc.


On Wed, 14 Apr 2010, Jonas Sicking wrote:
&gt;<i> 
</I>&gt;<i> I really do hate to come up with a new format. But I think TTML is 
</I>&gt;<i> severely off the mark for what we want. Am I wrong in that marking up 
</I>&gt;<i> dialogue vs. sound effects vs. narrator vs. descriptions is important? 
</I>&gt;<i> Or at least more useful than for example the ability to set the text 
</I>&gt;<i> outline blur radius?
</I>
Incidentally, I ended up with the following predefined voices: The
string &quot;narrator&quot;, &quot;music&quot;, &quot;lyric&quot;, &quot;sound&quot;, &quot;comment&quot;, and &quot;credit&quot;. Are 
there others we should add?


On Fri, 16 Apr 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> I guess the problem is more with char sets. For HTML pages and other Web 
</I>&gt;<i> content, there is typically information inside the resource that tells 
</I>&gt;<i> you what character set the document is written in. E.g. HTML pages have 
</I>&gt;<i> &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;. 
</I>&gt;<i> Such functionality is not available for SRT, so it is impossible for a 
</I>&gt;<i> browser to tell what charset to use to render the content in.
</I>
Indeed. See the discussion at the top of this e-mail for my current 
thoughts on this.


&gt;<i> And yes, we have made an adjustment in the Media Associations spec for 
</I>&gt;<i> &lt;track&gt; to contain a hint on what mime type and charset the external 
</I>&gt;<i> document is specified in. But that is only a bad fix of SRT's problem. 
</I>&gt;<i> It should be available inside the file so that any application can use 
</I>&gt;<i> the SRT file without requiring additional information.
</I>
It's not clear to me how this information would be used. Do you have 
examples of other formats having this metadata? What do UAs do with it in 
those cases? I didn't come across anything compelling in my research of 
other formats and UAs.


&gt;<i> The extended SRT file will barely have anything in common with the 
</I>&gt;<i> original ones.
</I>
That isn't really the case.


&gt;<i> For example:
</I>&gt;<i> 
</I>&gt;<i> (1) original SRT file:
</I>&gt;<i> 
</I>&gt;<i> ---
</I>&gt;<i> 1
</I>&gt;<i> 00:00:15,000 --&gt; 00:00:17,951
</I>&gt;<i> At the left we can see...
</I>&gt;<i> 
</I>&gt;<i> 2
</I>&gt;<i> 00:00:18,166 --&gt; 00:00:20,083
</I>&gt;<i> At the right we can see the...
</I>&gt;<i> ---
</I>
That's a complete and valid WebSRT file.


&gt;<i> (2) possibly new extended SRT file:
</I>&gt;<i> 
</I>&gt;<i> ---
</I>&gt;<i> Content-Type: text/html; charset=UTF-8
</I>&gt;<i> Content-Language: en_us
</I>&gt;<i> Styles:
</I>&gt;<i> {
</I>&gt;<i>   div.left-align {
</I>&gt;<i>     font-family:Arial,Helvetica,sans-serif;
</I>&gt;<i>     text-align: left;
</I>&gt;<i>   }
</I>&gt;<i>   div.left-right {
</I>&gt;<i>     font-family:Courier New, monospace;
</I>&gt;<i>     text-align: right;
</I>&gt;<i>   }
</I>&gt;<i>   div.speaker {
</I>&gt;<i>     font-family:Courier New, monospace;
</I>&gt;<i>     text-align: left;
</I>&gt;<i>     font-weight: bold;
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i> 1
</I>&gt;<i> 00:00:15,000 --&gt; 00:00:17,951
</I>&gt;<i> &lt;div class=&quot;left-align speaker&quot;&gt;&lt;img src=&quot;proof.png&quot;
</I>&gt;<i> role=&quot;presentation&quot; alt=&quot;Proog icon&quot;/&gt;Proog:&lt;/div&gt;
</I>&gt;<i> &lt;div class=&quot;left-align&quot; style=&quot;color: green;&quot;&gt;At the &lt;span
</I>&gt;<i> style=&quot;font-style:italic;&quot;&gt;left&lt;/span&gt; we can &lt;a
</I>&gt;<i> href=&quot;looking_left.html&quot;&gt;see&lt;/a&gt;...&lt;/div&gt;
</I>&gt;<i> 
</I>&gt;<i> 2
</I>&gt;<i> 00:00:18,166 --&gt; 00:00:20,083
</I>&gt;<i> &lt;div class=&quot;right-align&quot; style=&quot;color: blue;&quot;&gt;At the right we can &lt;a
</I>&gt;<i> href=&quot;looking_right.html&quot;&gt;see&lt;/a&gt; the...&lt;/div&gt;
</I>&gt;<i> ---
</I>
That isn't. :-)


&gt;<i> (3) TTML file: (no hyperlinks, no images - just for comparison)
</I>&gt;<i> 
</I>&gt;<i> ---
</I>&gt;<i> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
</I>&gt;<i> &lt;tt xml:lang=&quot;en_us&quot; xmlns=&quot;<A HREF="http://www.w3.org/ns/ttml">http://www.w3.org/ns/ttml</A>&quot;&gt;
</I>&gt;<i>   &lt;head&gt;
</I>&gt;<i>     &lt;styling&gt;
</I>&gt;<i>       &lt;style xml:id=&quot;left-align&quot;
</I>&gt;<i>         tts:fontFamily=&quot;proportionalSansSerif&quot;
</I>&gt;<i>         tts:textAlign=&quot;left&quot;
</I>&gt;<i>       /&gt;
</I>&gt;<i>       &lt;style xml:id=&quot;right-align&quot;
</I>&gt;<i>         tts:fontFamily=&quot;monospaceSerif&quot;
</I>&gt;<i>         tts:textAlign=&quot;right&quot;
</I>&gt;<i>       /&gt;
</I>&gt;<i>       &lt;style xml:id=&quot;speaker&quot;
</I>&gt;<i>         tts:fontFamily=&quot;monospaceSerif&quot;
</I>&gt;<i>         tts:textAlign=&quot;left&quot;
</I>&gt;<i>         tts:fontWeight=&quot;bold&quot;
</I>&gt;<i>       /&gt;
</I>&gt;<i>     &lt;/styling&gt;
</I>&gt;<i>     &lt;layout&gt;
</I>&gt;<i>       &lt;region xml:id=&quot;subtitleArea&quot;
</I>&gt;<i>         tts:extent=&quot;560px 62px&quot;
</I>&gt;<i>         tts:padding=&quot;5px 3px&quot;
</I>&gt;<i>       /&gt;
</I>&gt;<i>     &lt;/layout&gt;
</I>&gt;<i>   &lt;/head&gt;
</I>&gt;<i>   &lt;body region=&quot;subtitleArea&quot;&gt;
</I>&gt;<i>     &lt;div&gt;
</I>&gt;<i>       &lt;p style=&quot;left-align&quot; begin=&quot;0.15s&quot; end=&quot;0.17s 951ms&quot;&gt;
</I>&gt;<i>         &lt;div style=&quot;speaker&quot;&gt;Proog:&lt;/div&gt;
</I>&gt;<i>         &lt;div tts:color=&quot;green&quot;&gt;At the &lt;span
</I>&gt;<i> tts:fontStyle=&quot;italic&quot;&gt;left&lt;/span&gt; we can see...&lt;/div&gt;
</I>&gt;<i>       &lt;/p&gt;
</I>&gt;<i>       &lt;p style=&quot;right-align&quot; begin=&quot;0.18s 166ms&quot; end=&quot;0.20s 83ms&quot;&gt;
</I>&gt;<i>         &lt;div tts:color=&quot;green&quot;&gt;At the right we can see the...&lt;/div&gt;
</I>&gt;<i>       &lt;/p&gt;
</I>&gt;<i>     &lt;/div&gt;
</I>&gt;<i>   &lt;/body&gt;
</I>&gt;<i> &lt;/tt&gt;
</I>&gt;<i> ---
</I>
Here's the minimalist WebSRT version:

 ---
 00:00:15,000 --&gt; 00:00:17,951 A:start L:-2
 &lt;1&gt;Proog:

 00:00:15,000 --&gt; 00:00:17,951 A:start L:-1
 At the left we can see...
 
 00:00:18,166 --&gt; 00:00:20,083 A:end L:-1
 At the right we can see the...
 ---

You can style it further:

 --
 ::cue { color: green; font: 1em sans-serif; }
 ::cue-part(1) { font: bold 1em serif; }
 --

That seems way simpler than the versions above. :-)


On Fri, 16 Apr 2010, Richard Watts wrote:
&gt;<i> 
</I>&gt;<i> [...] but the consensus in broadcast (OCAP, HbbTV, DVB) is that the 
</I>&gt;<i> Right Way to do this is to fire Javascript events from events in the 
</I>&gt;<i> input stream - one of them being timecode, so something like:
</I>&gt;<i> 
</I>&gt;<i>  video.request_events(video.EVENT_TYPE_TIMED, { from: 10.0, to: 20.0},
</I>&gt;<i>    myfunc)
</I>&gt;<i> 
</I>&gt;<i> And myfunc then gets called whenever you go into or out of that time 
</I>&gt;<i> range. Obviously there's horribleness around the edges for requesting 
</I>&gt;<i> periodic events, etc.
</I>&gt;<i> 
</I>&gt;<i> This should let you write your SRT viewer in Javascript, should you feel 
</I>&gt;<i> that way perverted^Winclined.
</I>
The API handles this case in a similar way (you create a timed track for 
yourself, then create a cue for each of the time ranges you want, and 
can register an event either on the track or on individual cues).


On Fri, 23 Apr 2010, Sam Dutton wrote:
&gt;<i>
</I>&gt;<i> [...] film archives used to have no more than a one-sentence description 
</I>&gt;<i> for an entire can of film, illegibly written in a book or on index cards 
</I>&gt;<i> or (more recently) with a few lines in a Word document. Now, digitised 
</I>&gt;<i> footage will often be provided alongside timed, digitised metadata: high 
</I>&gt;<i> quality, structured, detailed, shot-level, frame accurate data about 
</I>&gt;<i> content, location, personnel, dialogue, rights, ratings and more. 
</I>&gt;<i> Accelerating digitisation is at the heart of this 'granularisation', 
</I>&gt;<i> obviously, but a variety of technologies contribute: linked data and 
</I>&gt;<i> semantic markup, temporal URLs, image recognition (show me frames in 
</I>&gt;<i> this video with a car in them), M3U / HTTP streaming, and so on -- even 
</I>&gt;<i> the new iPhone seekToTime method.
</I>&gt;<i> 
</I>&gt;<i> So, in addition to what's on offer in the specs, I'm wondering if it 
</I>&gt;<i> might be possible to have time-aligned *data*, with custom roles.
</I>
WebSRT can be used for this, yes.


&gt;<i> For example, imagine a video with a synchronised 'chapter' carousel 
</I>&gt;<i> below it (like the R&amp;DTV demo at 
</I>&gt;<i> <A HREF="http://www.bbc.co.uk/blogs/rad/2009/08/html5.html">http://www.bbc.co.uk/blogs/rad/2009/08/html5.html</A>). The video element 
</I>&gt;<i> would have a track with 'chapter' as its role attribute, and the 
</I>&gt;<i> location of the chapter data file as its src. The data file would 
</I>&gt;<i> consist of an array of 'chapter' objects, each representing some timed 
</I>&gt;<i> data. Every object in the track source would require a start and/or end 
</I>&gt;<i> values, and a content value with arbitrary properties:
</I>&gt;<i> 
</I>&gt;<i> {
</I>&gt;<i>     start: 10.00,
</I>&gt;<i>     end: 20.00,
</I>&gt;<i>     content: {
</I>&gt;<i>         title: &quot;Chapter 2&quot;,
</I>&gt;<i>         description: &quot;Some blah relating to chapter 2&quot;,
</I>&gt;<i>         image: &quot;/images/chapter2.png&quot;
</I>&gt;<i>    }
</I>&gt;<i> },
</I>&gt;<i> {
</I>&gt;<i>     start: 20.00,
</I>&gt;<i>     end: 30.00,
</I>&gt;<i>     content: {
</I>&gt;<i>         title: &quot;Chapter 3&quot;,
</I>&gt;<i>         description: &quot;Chapter 3 blah&quot;,
</I>&gt;<i>         image: &quot;/images/chapter3.png&quot;
</I>&gt;<i>    }
</I>&gt;<i> }
</I>
In WebSRT, this would be:

   10:00.000 --&gt; 20:00.000
   { title: &quot;Chapter 2&quot;, description: &quot;Some blah relating to chapter 2&quot;, image: &quot;/images/chapter2.png&quot; }

   20:00.000 --&gt; 30:00.000
   { title: &quot;Chapter 3&quot;, description: &quot;Chapter 3 blah&quot;, image: &quot;/images/chapter3.png&quot; }

(Here I'm assuming that you want to store the data as JSON. For 
kind=metadata files, you can put anything you want in the cue so long as 
you don't have a blank line in there.)


&gt;<i> In this example, selecting the chapter track for the video would cause 
</I>&gt;<i> the video element to emit segment entry/exit events -- a bit like the 
</I>&gt;<i> Cue Ranges idea. In this example, each event would correspond to an 
</I>&gt;<i> object in the chapter data source.
</I>
This is consistent with what the spec now has. Each WebSRT cue gets events 
fired on it when it goes in and out.


On Tue, 20 Apr 2010, Silvia Pfeiffer wrote:
&gt;<i> 
</I>&gt;<i> Firstly about the Lyrics. I think they are just the same as captions and 
</I>&gt;<i> should go back into the first document. In particular since we are 
</I>&gt;<i> talking about captions and subtitles for both the &lt;video&gt; and the 
</I>&gt;<i> &lt;audio&gt; element and this shows some good examples of how lyrics are 
</I>&gt;<i> being displayed as time-aligned text with audio resources. Most of these 
</I>&gt;<i> examples are widgets used on the Web, so I think they are totally 
</I>&gt;<i> relevant.
</I>&gt;<i> 
</I>&gt;<i> Lyrics (LRC) files typically look like this:
</I>&gt;<i> 
</I>&gt;<i> [ti:Can't Buy Me Love]
</I>&gt;<i> [ar:Beatles, The]
</I>&gt;<i> [au:Lennon &amp; McCartney]
</I>&gt;<i> [al:Beatles 1 - 27 #1 Singles]
</I>&gt;<i> [by:Wooden Ghost]
</I>&gt;<i> [re:A2 Media Player V2.2 lrc format]
</I>&gt;<i> [ve:V2.20]
</I>&gt;<i> [00:00.45]Can't &lt;00:00.75&gt;buy &lt;00:00.95&gt;me &lt;00:01.40&gt;love,
</I>&gt;<i> &lt;00:02.60&gt;love&lt;00:03.30&gt;, &lt;00:03.95&gt;love, &lt;00:05.30&gt;love&lt;00:05.60&gt;
</I>&gt;<i> [00:05.70]&lt;00:05.90&gt;Can't &lt;00:06.20&gt;buy &lt;00:06.40&gt;me &lt;00:06.70&gt;love,
</I>&gt;<i> &lt;00:08.00&gt;love&lt;00:08.90&gt;
</I>&gt;<i> 
</I>&gt;<i> There is some metadata at the start and then there are time fragments, 
</I>&gt;<i> possibly overloaded with explicit subtiming for individual works in 
</I>&gt;<i> karaoke-style. This is not very different from SRT and in fact should 
</I>&gt;<i> fit with your Karaoke use case.
</I>
I've used the &lt;mm:ss.hh&gt; idea from LRC to augment WebSRT with this kind of 
metadata.


&gt;<i> I'm also confused about the removal of the chapter tracks. These are
</I>&gt;<i> also time-aligned text files and again look very similar to SRT.
</I>
I've also included support for chapters. Currently this support is not 
really fully fleshed out; in particular it's not defined how a UA should 
get chapter names out of the WebSRT file. I would like implementation 
feedback on this topic -- what do browser vendors envisage exposing in 
their UI when it comes to chapters? Just markers in the timeline? A 
dropdown of times? Chapter titles? Styled, unstyled?

Currently a cue payload can be either cue text (simple markup) or metadata 
text (arbitrary data for scripts). We could add a third form consisting of 
just plain text for chapter titles, or we could reuse cue text, depending 
on what is needed here. Currently the spec requires them to be cue text 
but doesn't say how to get plain text out of them.


On Sat, 22 May 2010, Carlos Andr&#233;s Sol&#237;s wrote:
&gt;<i> 
</I>&gt;<i> As you might know, there are basic subtitle formats that are formed by 
</I>&gt;<i> timed plain text and little else (like SRT or the proposed WebSRT), and 
</I>&gt;<i> there are full-blown subtitle formats that allow for extreme formatting 
</I>&gt;<i> and typesetting (like Advanced SubStation Alpha).
</I>
WebSRT allows for &quot;extreme&quot; formatting and typesetting too, at least in 
principle, via CSS. The difference is that ASSA has inline formatting, 
like the &quot;bad old days&quot; of &lt;font&gt; on the Web, whereas WebSRT has 
structured text and a separate styling layer, which leads to more 
consistent effects and easier-to-maintain captions.


&gt;<i> The basic subtitles have the advantage of being easily editable by hand, 
</I>&gt;<i> but sacrificing capabilities that advanced formats allow with the cost 
</I>&gt;<i> of harder-to-understand syntax.
</I>
I don't think that sacrifice is necessary; as noted above, WebSRT can do 
much just with CSS. I haven't checked it feature-for-feature against ASSA, 
but I would expect there to be a wash. Having everything that CSS can do, 
or even a big chunk of it, is not to be scoffed at. For example, as soon 
as we add gradient paint servers to CSS, we have them in WebSRT. Add 3D 
perspective transforms to CSS, and we have them in WebSRT. (Both of these 
are being added to CSS, this isn't hypothetical.)


On Sun, 23 May 2010, Odin Omdal H&#248;rthe wrote:
&gt;<i> 
</I>&gt;<i> I want to use it for slide sync information. Right now I have a 
</I>&gt;<i> websocket that listens for the file name it wants to show (as next image 
</I>&gt;<i> slide), but it's IMPOSSIBLE to sync video/slides with the features that 
</I>&gt;<i> are in browsers now. Because I can't get the real timestamp from the Ogg 
</I>&gt;<i> Theora video. Also, having that &quot;what slide are we on&quot; information in 
</I>&gt;<i> the video stream is also rather nice.
</I>&gt;<i> 
</I>&gt;<i> If WebSRT had classes, it could be used for all sorts of things. You 
</I>&gt;<i> would parse the incoming WebSRT-stream in javascript and use stylesheets 
</I>&gt;<i> to build text overlays like youtube has etc. Always a tradeoff between 
</I>&gt;<i> easy format and features. If you could optionally put html in there to 
</I>&gt;<i> do advanced stuff that might work. With some rules for readers that 
</I>&gt;<i> don't understand 3., just stripping all tags and showing the result; or 
</I>&gt;<i> even have a method for saying &quot;don't show this if you don't support 
</I>&gt;<i> fancy stuff&quot;. I might be trying to mix this in a bad way.
</I>&gt;<i> 
</I>&gt;<i> Anyway, as of now I'm just waiting for a way to tell my webapp what 
</I>&gt;<i> slide we're on (sync with the live streaming video).
</I>
WebSRT has classes, if I understand you correctly (search for &quot;voice&quot;).

With metadata tracks, you can do everything YouTube does -- you could 
basically put paint commands into your WebSRT, and paint a new canvas each 
time a new cue arrives, if you wanted.

With the events cues get, you can also sync slides pretty easily now.


On Sun, 23 May 2010, Odin Omdal H&#248;rthe wrote:
&gt;<i> 
</I>&gt;<i> I start the streaming.
</I>&gt;<i> 
</I>&gt;<i> 10 minutes later, Leslie connects and gets the video maybe 1 minute 
</I>&gt;<i> delayed because of IceCast2 buffering.
</I>&gt;<i> 
</I>&gt;<i> Her browser (Chromium and Firefox, haven't tested Opera), starts telling 
</I>&gt;<i> &#171;currentTime&#187; from when SHE started to look at the live stream. Instead 
</I>&gt;<i> of showing when the stream started.
</I>&gt;<i> 
</I>&gt;<i> So it's quite impossible to use that for syncing. I asked about that 
</I>&gt;<i> here in this list, and got the answer that this is what we have 
</I>&gt;<i> startTime property for, -- but it is not implemented correctly in any 
</I>&gt;<i> browsers. startTime would then maybe say 0:00:00 for most clips, but on 
</I>&gt;<i> streaming Leslie would have 0:10:00, and then I can use that for 
</I>&gt;<i> syncing.
</I>
Per spec, everyone's currentTime should be the same, and their startTime 
should be whatever the earliest time they can seek to is. If browsers 
haven't implemented that, file bugs.


On Sun, 30 May 2010, Carlos Andr&#233;s Sol&#237;s wrote:
&gt;<i>
</I>&gt;<i> I've been thinking on using an XML-like markup as a format to implement 
</I>&gt;<i> subtitles. XML is reasonable enough to be implemented by both media 
</I>&gt;<i> players and web browsers, and so leaves us with little problems 
</I>&gt;<i> regarding compatibility. My proposal takes most of the elements from 
</I>&gt;<i> ASSA (save for vectorial drawing, that can be done later or be replaced 
</I>&gt;<i> by dingbat fonts in the meanwhile) and renders them in a nifty and 
</I>&gt;<i> easy-to-read file by using markup. Right now I've thought of three or 
</I>&gt;<i> four main markup segments: styles, karaoke-specialized styles, 
</I>&gt;<i> animation-specialized styles and, of course, the time divisions to 
</I>&gt;<i> insert the text. Here is my mock-up file, which I hope is as 
</I>&gt;<i> self-explanatory as I think.
</I>&gt;<i> 
</I>&gt;<i> &lt;subtitle name=&quot;Betatesting X c001&quot; creator=&quot;AnonIsLegion no Fansub&quot;
</I>&gt;<i> date=&quot;2010/05/30&quot;&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;styledef&gt;
</I>&gt;<i> &lt;!-- rtl: right-to-left text; utd: up-to-down text; fontstyle=bold, italic,
</I>&gt;<i> strike, and some others; clipstyle:per_line, per_block; rotations are in
</I>&gt;<i> degrees --&gt;
</I>&gt;<i> &lt;style name=&quot;Kyoh&quot; fontsize=18 fontname=&quot;serif, DejaVu Sans, Arial Unicode
</I>&gt;<i> MS&quot; fontxscale=100% fontyscale=150% rtl=false utd=false fontstyle=&quot;bold&quot;
</I>&gt;<i> fontcolor=&quot;red&quot; fontalpha=100% outlinesize=1 outlinecolor=&quot;white&quot;
</I>&gt;<i> outlinealpha=fontalpha karaokecolor=&quot;orange&quot; karaokealpha=75%
</I>&gt;<i> karaokeoutlinecolor=karaokecolor karaokeoutlinealpha=karaokealpha
</I>&gt;<i> karaokeoutlinesize=outlinesize karaokeoutlinealpha=karaokealpha shadowsize=1
</I>&gt;<i> shadowcolor=&quot;black&quot; shadowalpha=50% blursize=2 blurtype=&quot;square&quot;
</I>&gt;<i> blurintensity=1 positionx=90% positiony=50% marginup=1 margindown=1
</I>&gt;<i> marginleft=2 marginright=2 rotationx=0 rotationy=0 rotationz=0
</I>&gt;<i> clipstyle=&quot;per_line&quot; clipup=0 clipdown=0 clipleft=0 clipright=0 /&gt;
</I>&gt;<i> &lt;style name=&quot;Kenji&quot; inherits=&quot;Kyoh&quot; fontcolor=&quot;blue&quot; /&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;karstyle name=&quot;kardefault&quot; start=0:00 end=0:00.1 karaokecolor=&quot;white&quot;
</I>&gt;<i> karaokealpha=75% karaokeoutlinecolor=&quot;gray&quot; karaokeoutlinealpha=karaokealpha
</I>&gt;<i> karaokeoutline size=outlinesize /&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;animation name=&quot;animdefault&quot;&gt;
</I>&gt;<i>     &lt;!-- start and end times here are either absolute from the section
</I>&gt;<i> start, or relative to the chronological order (default); ordering can be
</I>&gt;<i> overriden using from=element_you_want_to_start_times_from --&gt;
</I>&gt;<i>     &lt;animsection name=&quot;1&quot; order=&quot;absolute&quot; start=0:00 end=0:00.5
</I>&gt;<i> acceleration=100% accelerationtype=&quot;constant&quot;&gt; &lt;!-- accelerationtype:
</I>&gt;<i> constant, exponential --&gt;
</I>&gt;<i>         &lt;style positionx=90% positiony=50%&gt;
</I>&gt;<i>     &lt;/animsection&gt;
</I>&gt;<i>     &lt;animsection name=&quot;2&quot; from=&quot;1&quot; inherits=&quot;1&quot; start=0:00 end=0:00.5&gt;
</I>&gt;<i>         &lt;style positionx=10% rotationz=180&gt;
</I>&gt;<i>     &lt;/animsection&gt;
</I>&gt;<i> &lt;/animation&gt;
</I>&gt;<i> &lt;/styledef&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;defaultstyle setstyle=&quot;Kyoh&quot; setkarstyle=&quot;kardefault&quot;
</I>&gt;<i> setanimstyle=&quot;animdefault&quot;&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;time start=0:00 end=0:00.001&gt;
</I>&gt;<i> A very brief line.&lt;br&gt;
</I>&gt;<i> Above another very brief line.
</I>&gt;<i> &lt;/time&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;time start=0:05 end=0:05.5&gt;
</I>&gt;<i> &lt;kar&gt;Ka&lt;/kar&gt;&lt;kar&gt;ra&lt;/kar&gt;&lt;kar&gt;&lt;style karaokecolor=&quot;red&quot;&gt;o&lt;/style&gt;&lt;/kar&gt;&lt;kar
</I>&gt;<i> end=0:00.2&gt;ke!&lt;/kar&gt;
</I>&gt;<i> &lt;/time&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;time start=0:07 end=0:08&gt;
</I>&gt;<i> &lt;animation name=&quot;animdefault&quot;&gt;
</I>&gt;<i> This text shall move.
</I>&gt;<i> &lt;/animation&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;!-- TODO: Importing images and SVGs to be used in subtitles. In the
</I>&gt;<i> meanwhile a good set of dingbat fonts should suffice. --&gt;
</I>&gt;<i> 
</I>&gt;<i> &lt;/subtitle&gt;
</I>
Here's the equivalent WebSRT (I took some guesses as to what each bit 
meant):

   00:00.000 --&gt; 00:00.001
   A very brief line.
   Above another very brief line.

   00:05.000 --&gt; 00:05.500
   Ka&lt;00:00.000&gt;ra&lt;00:00.000&gt;&lt;b&gt;o&lt;/b&gt;&lt;00:00.200&gt;ke

   00:07.000 --&gt; 00:08.000
   &lt;1&gt;This text shall move

...with the following CSS (as far as I could work out):

   ::cue {
     font: bold 18px serif, DejaVu Sans, Arial Unicode MS;
     color: red;
     text-shadow: rgba(0,0,0,0.5) 1 1 2;
   }
   ::cue(future) { color: rgba(255,128,0,0.75); }

   ::cue-part(b future) { color: red; }
   ::cue-part(1) {
      -webkit-animation-name: animdefault; 
      -webkit-animation-duration: 1s;
   }

   @-webkit-keyframes animdefault {
     /* currently movement isn't possible; we should add 
        left/right padding at some point */
     from { ... }
     to { ... }
   }

The moving text thing isn't currently supported, but that's just because I 
haven't gone down the list of properties to make everything work yet.

I feel pretty confident in saying that the WebSRT version is clearer.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>


<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="069209.html">[whatwg] My proposal of a subtitle format via an XML-like markup (in progress)
</A></li>
	<LI>Next message: <A HREF="069548.html">[whatwg] Timed tracks for &lt;video&gt;
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27386">[ date ]</a>
              <a href="thread.html#27386">[ thread ]</a>
              <a href="subject.html#27386">[ subject ]</a>
              <a href="author.html#27386">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
