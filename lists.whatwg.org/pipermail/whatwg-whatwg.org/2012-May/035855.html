<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Features for responsive Web design
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Features%20for%20responsive%20Web%20design&In-Reply-To=%3CPine.LNX.4.64.1205082141400.17060%40ps20323.dreamhostps.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="078135.html">
   <LINK REL="Next"  HREF="078130.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Features for responsive Web design</H1>
<!--htdig_noindex-->
    <B>Ian Hickson</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Features%20for%20responsive%20Web%20design&In-Reply-To=%3CPine.LNX.4.64.1205082141400.17060%40ps20323.dreamhostps.com%3E"
       TITLE="[whatwg] Features for responsive Web design">ian at hixie.ch
       </A><BR>
    <I>Tue May 15 00:28:54 PDT 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="078135.html">[whatwg] &lt;picture&gt;, `img set`, and polyfills
</A></li>
        <LI>Next message: <A HREF="078130.html">[whatwg] Features for responsive Web design
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35855">[ date ]</a>
              <a href="thread.html#35855">[ thread ]</a>
              <a href="subject.html#35855">[ subject ]</a>
              <a href="author.html#35855">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Wed, 25 Jan 2012, Matthew Wilcox wrote:
&gt;<i> On 24 January 2012 23:26, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;<i> &gt; On Wed, 24 Aug 2011, Anselm Hannemann - Novolo Designagentur wrote:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; As we now have the possibility of creating fluid and responsive 
</I>&gt;<i> &gt; &gt; layouts in several ways we have a problem with images.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; There's currently no good feature to implement something like 
</I>&gt;<i> &gt; &gt; responsive images which adapt to the different device-resolutions. 
</I>&gt;<i> &gt; &gt; We only can implement one image with one resolution scaling-up and 
</I>&gt;<i> &gt; &gt; down.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; You can do adaptive sites using media queries.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   &lt;!-- HTML --&gt;
</I>&gt;<i> &gt;   &lt;h1&gt;My Site&lt;/h1&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   // CSS
</I>&gt;<i> &gt;   @media (min-width: 320px and max-width: 640px) {
</I>&gt;<i> &gt;     h1::before { content: url(<A HREF="http://cdn.url.com/img/myimage_xs.jpg">http://cdn.url.com/img/myimage_xs.jpg</A>) }
</I>&gt;<i> &gt;   }
</I>&gt;<i> &gt;   @media (min-width: 640px and max-width: 1024px) {
</I>&gt;<i> &gt;     h1::before { content: url(<A HREF="http://cdn.url.com/img/myimage_m.jpg">http://cdn.url.com/img/myimage_m.jpg</A>) }
</I>&gt;<i> &gt;   }
</I>&gt;<i> &gt;   @media (min-width: 1024px) {
</I>&gt;<i> &gt;     h1::before { content: url(<A HREF="http://cdn.url.com/img/myimage_xsl.jpg">http://cdn.url.com/img/myimage_xsl.jpg</A>) }
</I>&gt;<i> &gt;   }
</I>&gt;<i>
</I>&gt;<i> This is of no use to content images - which are the real problem. CSS 
</I>&gt;<i> supplied images are not an issue.
</I>
Fair enough.


Looking at the feedback on these threads over the past few months (I 
didn't quote it all here, but thank you to everyone for making very good 
points, both here on the list and on numerous blog posts and documents on 
the Web, referenced from these threads), it seems there are three main 
axes that control what image one might want to use on a page, assuming 
that one is rendering to a graphical display:

 - the size of the viewport into which the image is being rendered

 - the pixel density of the display device

 - the network bandwidth available to the page to obtain resources

Now I'm not sure what to do about the bandwidth one. It's very hard for a 
user agent to estimate its bandwidth availability -- it depends on the 
server, and the network location of the server, almost as much as on the 
location of the client; it depends on the current network congestion, it 
depends on the other things the browser is doing; it depends on whether 
the user is about to go through a tunnel or is about to switch to wifi; it 
depends on whether the user is roaming out of network or is on an OC48 
network pipe. It's hugely variable. It's not clear to me how to 
characterise it, either. It's also something that's changing very rapidly. 
On the more modern mobile networks, the real problem seems to be latency, 
not bandwidth; once you've actually kicked off a download, you can get the 
data very fast, it just takes forever to kick it off. That kind of problem 
is better solved by something like SPDY than by downloading smaller 
images. Downloading smaller images also screws up zooming images, which 
happens a lot more on mobile than on desktop.

A number of people proposed solutions that are variants on the 
&lt;video&gt;/&lt;source&gt; mechanism, where you have an abundance of elements to 
replace the lonely &lt;img&gt;. Looking at the examples of this, though, I could 
not get over how verbose the result is. If we're expecting this to be 
common -- which I think we are -- then really can't be asking authors to 
be providing dense collections of media queries, switch-statement like 
lists of URLs, and so forth, with each image.

Nor can we ask authors to provide a default and then have an external CSS 
file give alternatives. The syntax is different (and in some proposals 
actually already possible today), but the fundamental problem still 
exists: it's way too much work for just inserting an image in a page.

Another proposal that various people advocated is a header that the 
servers can use to determine what content to use. Besides a wide number of 
problems that people pointed out with this on the thread (such as the 
privacy issues due to fingerprinting, the many ways that such information 
gets abused, the high aggregate bandwidth cost, the difficulties with 
using headers in offline scenarios, etc), the biggest problem with this 
idea, IMHO, is that authors have shown that HTTP headers are simply a 
non-starter. Content-Type headers are perenially wrong, Accept headers are 
mishandled all over the place, adding Origin headers has caused 
compatibility issues... HTTP headers are a disaster. If there's ever an 
option to solve a problem without HTTP headers, we should take it, IMHO.


On Tue, 7 Feb 2012, Kornel Lesi&#195;&#133;~Dski wrote:
&gt;<i> 
</I>&gt;<i> You could just say &quot;I've got these image sizes available, choose which 
</I>&gt;<i> one suits you best&quot;, and browser would pick one that makes most sense. 
</I>&gt;<i> You (and every other web developer) wouldn't have to write and maintain 
</I>&gt;<i> code for computation of bandwidth/latency/battery/screen 
</I>&gt;<i> size/density/zoom/cpu speed/memory tradeoffs. With so many variables I'm 
</I>&gt;<i> afraid that average developer wouldn't make better choices than mobile 
</I>&gt;<i> browsers themselves can.
</I>
Indeed.

One thing I noticed when looking at the proposals is that they all 
conveyed a lot of information:

 - a list of files, each with a particular dimension in CSS pixels and
   each intended for a particular display pixel density, bandwidth 
   level, and layout dimensions

 - a list of conditions consisting of layout dimensions, pixel densities, 
   bandwidth characterisations

 - glue to keep it all together and to tie in non-graphical fallback

A lot of this is redundant, though. When would an author ever say &quot;hey, 
use my 1024x768 image&quot; when the display is 640x480? When would an author 
say &quot;use this 4 device-pixel-per-CSS-pixel image&quot; when the display is a 
regular low-density display?

In fact, as Kornel suggests, would it be possible to just enumerate the 
files and their characteristics, and let the browser figure out which one 
to use?

Of course, if we do that, we still end up having to list a lot of 
redundant information, namely which URL maps to which set of 
characteristics. That's sad, because it's almost always going to be the 
case that the author will put the characteristics in the filename, since 
otherwise it becomes a maintenance nightmare.

So why not just give the UA the characteristics and a template to use to 
build the file names itself? That way we still give the UA all the same 
information, but it is much less verbose and still solves all the same use 
cases. Thus:

   &lt;img src=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">face-600-200 at 1.jpeg</A>&quot; alt=&quot;&quot;
        src-template=&quot;face-%w-%h@%r.jpeg&quot;
        src-versions=&quot;600x200x1 600x200x2 200x200x1&quot;&gt;

(The first src=&quot;&quot; would be optional; its purpose is legacy fallback.)

The algorithm for picking an image could be to sort the images by width, 
and remove all those that are wider than the available width (except for 
the narrowest one if they're all too wide), then sort them by height and 
remove all those that are taller than the available height (except the 
shortest one if they are all too tall), then sort them by pixel density 
and remove all those that are for densities greater than the current one 
(except the lowest one if they are all greater), then remove all those 
that are for densities less than the current one (except the highest one 
if they are all lower), then of the remaining images pick the widest one, 
tie-breaking by picking the tallest one (that should leave just one 
possible file name).

This doesn't handle bandwidth concerns; as mentioned above, I'm not sure 
how to do that even at a theoretical level.

As people on #whatwg pointed out when I floated it there, the problems 
with this idea are two-fold: first, by helping authors who use consistent 
naming schemes it forces all authors into using schemes that have the 
height, width, and/or resolution baked in literally, and second, it forces 
authors who only care about one or two of the axes to list all three.

For example, some people only want to decide whether to use &quot;low res&quot; and 
&quot;retina&quot; versions of their images, with filenames like &quot;foo.jpeg&quot; and 
&quot;foo-HD.jpeg&quot;. They don't want to specify dimensions at all.

Over in CSS land, there have been proposals for similar features, e.g. 
image-set:

   <A HREF="http://lists.w3.org/Archives/Public/www-style/2012Feb/1103.html">http://lists.w3.org/Archives/Public/www-style/2012Feb/1103.html</A>

In fact, hober proposed a variant of that on this list recently too.

If we use a syntax a bit like that one, we could increase the verbosity a 
little, while handling a few more cases:

   &lt;img src=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">face-600-200 at 1.jpeg</A>&quot; alt=&quot;&quot;
        srcset=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">face-600-200 at 1.jpeg</A> 600w 200h 1x,
                <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">face-600-200 at 2.jpeg</A> 600w 200h 2x,
                face-icon.png       200w 200h&quot;&gt;

The verbosity is still not completely insane (though now we are back to 
duplicating information a bit), but we have more flexibility in the 
filename scheme and less restriction on the list of values that have to be 
specified.

The algorithm here could be to sort the images by width, and remove all 
those that are wider than the available width (except for the narrowest 
one if they're all too wide) or that don't have a width unless none have 
widths, then sort them by height and remove all those that are taller than 
the available height (except the shortest one if they are all too tall) or 
that don't have a height unless none have heights, then sort them by pixel 
density and remove all those that are for densities greater than the 
current one (except the lowest one if they are all greater), then remove 
all those that are for densities less than the current one (except the 
highest one if they are all lower), assuming that any without a specified 
density are implicitly 1x, then of the remaining images pick the widest 
one, if any have a width, tie-breaking by picking the tallest one, if any 
have a height, finally tie-breaking by picking the first one, if none have 
any dimensions.

If a user agent has picked a resource with a pixel density other than 1x, 
it would scale its intrinsic dimensions by the reciprocal of the pixel 
density (i.e. if the pixel density is given as 1.5x, then a 150 pixel 
image would be rendered at 100px (CSS pixels), btu with the full 150 
pixels used for rendering if the display has a higher resolution than the 
CSS pixel 96dpi-equivalent).

Authoring-conformance-wise, that means that if any specify a width, they 
all must; if any specify a height, they all must; and omitting the pixel 
density is fine but is treated as 1x. At least one of the three must be 
specified, since otherwise a comma after the value would be confused as 
being part of the URL. No two entries can have the same descriptors.

For convenience we could say that there is an implicit entry with no 
height and width and with resolution 1x that is the value of the src=&quot;&quot; 
attribute, so then to have a 1x/2x alternative we'd just write:

   &lt;img src=&quot;logo.png&quot; alt=&quot;SampleCorp&quot; srcset=&quot;logo-HD.png 2x&quot;&gt;


The problem with this proposal is that user agents want to prefetch the 
images before they start layout. This means they don't know what the 
available dimensions _are_.

In practice, the only information regarding dimensions that can be 
usefully leveraged here is the viewport dimensions. This isn't the end of 
the world, though -- there's often going to be a direct correlation 
between the dimensions of the viewport and the dimensions of the images. 
For example, a page's heading banner will typically be as wide as the 
page. If there's two columns, each column is likely to be half the width 
of the page. If there's a fixed-width column that has one width at wide 
resolutions and another width at narrow resolutions, then it will likely 
have a graphical header, or background image, that is also fixed width, 
with a different fixed width based on the width of the page.

The net result of this is that we can just change the proposal above to 
use the viewport dimensions instead of the available width, and it should 
work about as well. It does mean, though, that we can't use the height=&quot;&quot; 
and width=&quot;&quot; attributes as fallback dimensions for the other ones.

Another change we can make is to not require that all candidates have all 
the descriptors. We already said above that a missing pixel resolution 
would mean 1x, but what about missing dimensions? Well, one option is to 
just say that if you have no dimensions, you're appropriate for infinitely 
wide screens. This gets around the problem of saying that you have to 
basically give an arbitrarily large dimension for the biggest image, or 
saying that we have to have to use the widest image if none of the images 
are wide enough. (And ditto height.)

The resulting proposal is what I've put in the spec.


On Sat, 4 Feb 2012, irakli wrote:
&gt;<i> 
</I>&gt;<i> Something as simple as if browsers passed along device's width/height 
</I>&gt;<i> information as part of the initial request headers would go a very very 
</I>&gt;<i> long way, making it possible to make a lot of intelligent decisions on 
</I>&gt;<i> the server-side (eventually allowing &quot;media-queries-like&quot; systems on the 
</I>&gt;<i> server-side).
</I>
I don't think it makes sense to base anything on the _device_ dimensions. 
You'd want to base it on the dimensions of the available space, which can 
change dynamically. (On my iMac at home, I never browse full-screen.)


On Mon, 6 Feb 2012, Matthew Wilcox wrote:
&gt;<i> 
</I>&gt;<i> The problem with using viewport instead of device size is client-side 
</I>&gt;<i> caching. It completely breaks things. As follows:
</I>&gt;<i> 
</I>&gt;<i> 1) The user requests the site with a viewport at less than the device
</I>&gt;<i> screen size.
</I>&gt;<i> 2) The user browses around for a bit on a few pages.
</I>&gt;<i> 3) The user maximises their browser.
</I>&gt;<i> 4) All of the images now in the browser cache are too small.
</I>&gt;<i> 
</I>&gt;<i> How does the client know to re-request all those pre-cached images, 
</I>&gt;<i> without making an arduous manual JS-reliant cache manifest? Or without 
</I>&gt;<i> turning off caching entirely?
</I>
With the logic proposed above, the user agent could change the image on 
the fly. It would also handle the user zooming, the user changing 
monitors, the user plugging in a new monitor, etc.


On Mon, 6 Feb 2012, James Graham wrote:
&gt;<i> On Mon, 6 Feb 2012, Boris Zbarsky wrote:
</I>&gt;<i> &gt; On 2/6/12 11:42 AM, James Graham wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt; Sure.  I'm not entirely sure how sympathetic I am to the need to 
</I>&gt;<i> &gt; produce &quot;reduced-functionality&quot; pages...  The examples I've 
</I>&gt;<i> &gt; encountered have mostly been in one of three buckets:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 1) &quot;Why isn't the desktop version just like this vastly better mobile one?&quot;
</I>&gt;<i> &gt; 2) &quot;The mobile version has a completely different workflow necessitating a
</I>&gt;<i> &gt; different url structure, not just different images and CSS&quot;
</I>&gt;<i> &gt; 3) &quot;We'll randomly lock you out of features even though your browser and
</I>&gt;<i> &gt; device can handle them just fine&quot;
</I>&gt;<i> 
</I>&gt;<i> The example I had in mind was one of our developers who was hacking an 
</I>&gt;<i> internal tool so that he could use it efficiently on his phone.
</I>&gt;<i> 
</I>&gt;<i> AFAICT his requirements were:
</I>&gt;<i> 1) Same URL structure as the main site
</I>&gt;<i> 2) Less (only critical) information on each screen
</I>&gt;<i> 3) No looking up / transfering information that would later be thrown away
</I>&gt;<i> 4) Fast =&gt; No extra round trip to report device properties
</I>&gt;<i> 
</I>&gt;<i> AFAIK he finally decided to UA sniff Opera mobile. Which is pretty sucky even
</I>&gt;<i> for an intranet app. But I didn't really have a better story to offer him. It
</I>&gt;<i> would be nice to address this kind of use case somehow.
</I>
I'm not really convinced we want to encourage #2. It drives me crazy when 
I find I can't use a site because the site decided I was using a phone 
instead of a computer. (The others are satisfied by just making the site 
work at all window sizes, nothing to do with mobile vs desktop.)


On Tue, 7 Feb 2012, James Graham wrote:
&gt;<i> 
</I>&gt;<i> This basically amounts to &quot;the requirements were wrong&quot;. Since the same 
</I>&gt;<i> developer made both the desktop and mobile frontends and he is one of 
</I>&gt;<i> the major users of the system, and the mobile frontend was purely 
</I>&gt;<i> scratching his own itch, I find it very difficult to justify the 
</I>&gt;<i> position that he ought to have wanted something different to what he 
</I>&gt;<i> actually wanted and made.
</I>
I agree that some people do want this. I'm just saying we should probably 
not encourage it.


&gt;<i> In general the idea that sites/applications should be essentially the 
</I>&gt;<i> same, but perhaps slightly rearranged, regardless of the device they run 
</I>&gt;<i> on just doesn't seem to be something that the market agrees with. It 
</I>&gt;<i> seems to me that we can either pretend that this isn't true, and watch 
</I>&gt;<i> as platform-specific apps become increasingly entrenched, or work out 
</I>&gt;<i> ways to make the UX on sites that target multiple types of hardware as 
</I>&gt;<i> good as possible.
</I>
Honestly I think as devices get more capable, the direction will be 
towards there being just One Web. We're already seeing mobile sites become 
much more functional than they were a few years ago.

They'll always be a little different, because the user interaction is 
different (touch vs keyboard/mouse, e.g.), but with new product classes 
being introduced (tablets, smaller laptops, bigger &quot;phablets&quot;, etc) I just 
don't see it as viable for us to continue having per-product-class Web 
sites; we'll instead see &quot;responsive design&quot;.


On Mon, 13 Feb 2012, Gray Zhang wrote:
&gt;<i> 
</I>&gt;<i> 1. On a product description page of a shopping site, there are several 
</I>&gt;<i> *main* pictures of the product, along with about twenty or so camera 
</I>&gt;<i> pictures of the product taken from different angles. When the HTML is 
</I>&gt;<i> parsed, browsers by default simultaneously start downloading all images, 
</I>&gt;<i> potentially making some of the *main* ones invisible.
</I>
This seems like something that's currently relatively easily handled using 
hidden=&quot;&quot; or CSS, with some JS (or more CSS) to decide when to show what.


&gt;<i> 2. On an album page where hundreds of pictures are expected to be shown, 
</I>&gt;<i> it is often required that pictures currently in a user's screen should 
</I>&gt;<i> appear as fast as possible. Loading of a picture outside the screen can 
</I>&gt;<i> be deferred to the time that the picture enters or is about to enter the 
</I>&gt;<i> screen, for the purpose of optimization user experience.
</I>
This seems like something the browser can do automatically today.


&gt;<i> 3. For a site with limited bandwidth on the server side, it is 
</I>&gt;<i> preferable to minimize the amount of data transferred per each page 
</I>&gt;<i> view. 70% of the users only read the first screen and hence pictures 
</I>&gt;<i> outside the first screen don't need to be downloaded before the user 
</I>&gt;<i> starts to scroll the page. This is to reduce server-side cost.
</I>
This is harder for browsers to do automatically, since many pages depend 
on non-displayed images getting downloaded.


&gt;<i>  Current Solution and It's Drawbacks
</I>&gt;<i> 
</I>&gt;<i> The current solution pretty much consists of three steps:
</I>&gt;<i> 
</I>&gt;<i> 1. The server outputs &lt;img&gt;s with @src pointing to a transparent image,
</I>&gt;<i> transparent.gif, and with @data-src pointing to the real location of the
</I>&gt;<i> image.
</I>&gt;<i> 2. Listen to the window.onscroll event.
</I>&gt;<i> 3. The event handler finds all &lt;img&gt;s in the visible area and set their
</I>&gt;<i> @src to @data-src that were stored.
</I>
Not ideal, yeah.

In practice, this is something that has indeed been done in JavaScript; 
indeed &quot;infinite scroll&quot; pages are something that has become quite common 
(see e.g. Bing's image search results). I don't know that it's especially 
critical to be able to have the &lt;img&gt; elements already in the page not yet 
load; it seems easier to just not add them to the page until the user 
scrolls down.


On Thu, 10 May 2012, Aryeh Gregor wrote:
&gt;<i> 
</I>&gt;<i> I'd like to throw in another use-case that might be addressable by the 
</I>&gt;<i> same feature: allowing &quot;Save As...&quot; to save a different version of the 
</I>&gt;<i> image (e.g., higher-res) than is actually displayed.  Wikipedia, for 
</I>&gt;<i> instance, often has very high-res images that get scaled down for 
</I>&gt;<i> article viewing to save bandwidth and avoid possibly-ugly rescaling. (At 
</I>&gt;<i> least historically, some browsers used very bad rescaling algorithms.)  
</I>&gt;<i> It would be nice if when users saved the image, they saved the full-res 
</I>&gt;<i> version.  Perhaps browsers could save the highest-res image available, 
</I>&gt;<i> rather than the one that happens to be used for display right now.
</I>
This seems like it would be handled adequately by the proposal above.


&gt;<i> Another obvious use-case I'd like to point out is print.  It's not quite 
</I>&gt;<i> as trendy as the iPhone Retina display -- in fact maybe it's getting 
</I>&gt;<i> pass&#195;&#131;&#194;&#169; :) -- but print is generally higher-res than display, and it's 
</I>&gt;<i> common for images to appear pixelated when printing.  This use-case 
</I>&gt;<i> might have the same requirements as the iPhone Retina display, but it 
</I>&gt;<i> should be kept in mind in case it doesn't.
</I>
Agreed.


&gt;<i> A fourth use-case I'd like to suggest is vector images.  Last I checked, 
</I>&gt;<i> many authors don't want to serve SVG directly because too many browsers 
</I>&gt;<i> don't support it in &lt;img&gt; (or at all).  Perhaps it should be possible to 
</I>&gt;<i> specify &quot;vector&quot; or something in place of a scale factor, to indicate 
</I>&gt;<i> that the image should be suitable for all resolutions.
</I>
Will there ever be any browsers that support srcset=&quot;&quot; but not SVG?


On Thu, 10 May 2012, Tab Atkins Jr. wrote:
&gt;<i> 
</I>&gt;<i> That all said, I don't like the &quot;2x&quot; notation.  It's declaring &quot;this 
</I>&gt;<i> image's resolution is twice that of a normal image&quot;.  This has two 
</I>&gt;<i> problems.  For one, we already have a unit that means that - the dppx 
</I>&gt;<i> unit.  Using &quot;2dppx&quot; is identical to the meaning of &quot;2x&quot;.  Since 
</I>&gt;<i> image-set() is newer than the dppx unit, we should change it to use 
</I>&gt;<i> &lt;resolution&gt; instead.
</I>
dppx is pretty ugly. I agree with hober's &quot;2x&quot; design.


&gt;<i> For two, I'm not sure that it's particularly obvious that when you say
</I>&gt;<i> &quot;2x&quot;, you should make sure your image was saved as 196dpi.  You have
</I>&gt;<i> to already know what the default resolution is.
</I>
You don't have to. The resolution of the image is ignored.


&gt;<i> As well, I think that values like 300dpi are pretty common, and they 
</I>&gt;<i> don't map to integral 'x' values.  If people say &quot;screw it&quot; and use 
</I>&gt;<i> &quot;3x&quot;, this'll be slightly wrong and I think will cause ugly blurring.  
</I>&gt;<i> If we make this take &lt;resolution&gt;, people can just use the dpi unit.
</I>
3.125x isn't particularly difficult to specify.


On Thu, 10 May 2012, Mathew Marquis wrote:
&gt;<i> 
</I>&gt;<i> Hey guys. Don&#194;&#146;t know if it&#194;&#146;s too early to chime in with this, but we 
</I>&gt;<i> were told by some members of the Chrome team that any browser that 
</I>&gt;<i> supports DNS prefetching &#194;&#151; including assets &#194;&#151; wouldn&#194;&#146;t consider 
</I>&gt;<i> &#194;&#147;looking-ahead&#194;&#148; on the img tag as an option. The original src would be 
</I>&gt;<i> fetched in any case, saddling users with a redundant download.
</I>
I don't understand what this means.


On Sun, 13 May 2012, Jason Grigsby described some use cases:
&gt;<i> 
</I>&gt;<i> Document author needs to display different versions of an image at 
</I>&gt;<i> different breakpoints based on what I&#146;m calling, for a lack of a better 
</I>&gt;<i> phrase, art direction merits.
</I>&gt;<i> 
</I>&gt;<i> * Example 1: News site shows photograph speaking at a auto factory. On 
</I>&gt;<i> wide screens, the news site includes a widescreen version of the 
</I>&gt;<i> photograph in which the cars being built can clearly be seen. On small 
</I>&gt;<i> screens, if the photograph is simply resized to fit the screen, Obama&#146;s 
</I>&gt;<i> face is too small to be seen. Instead, the document author may choose to 
</I>&gt;<i> crop the photograph so that it focuses in on Obama before resizing to 
</I>&gt;<i> fit the smaller screen.
</I>
   &lt;img alt=&quot;Obama spoke at the factory.&quot; src=&quot;factory.jpeg&quot;
        srcset=&quot;obama-factory-face.jpeg 500w&quot;&gt;


&gt;<i> * Example 2: On the Nokia Browser site where it describes the Meego 
</I>&gt;<i> browser, the Nokia Lumia is show horizontally on wide screens. As the 
</I>&gt;<i> screen narrows, the Nokia Lumia is then shown vertically and cropped. 
</I>&gt;<i> Bryan and Stephanie Rieger, the designers of the site, have talked about 
</I>&gt;<i> how on a wide screen, showing the full phone horizontally showed the 
</I>&gt;<i> browser best, but on small screens, changing the img to vertical made 
</I>&gt;<i> more sense because it allowed the reader to still make out the features 
</I>&gt;<i> of the browser in the image.
</I>
   &lt;img alt=&quot;The Nokia Browser for MeeGo can display the BBC site well.&quot;
        src=&quot;landscape.png&quot;
        srcset=&quot;vertical-cropped.png 500w&quot;&gt;


&gt;<i> For a variety of reasons, images of various pixel density are needed. 
</I>&gt;<i> These reasons include current network connection speed, display pixel 
</I>&gt;<i> density, user data plan, and user preferences.
</I>&gt;<i> 
</I>&gt;<i> * Example 1: The use of high-density images for the new iPad on 
</I>&gt;<i> Apple.com.
</I>
   &lt;img alt=&quot;&quot; src=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ipad at 1.png</A>&quot; srcset=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ipad at 2.png</A> 2x&quot;&gt;


&gt;<i> * Example 2: A user on a slow network or with limited data left may 
</I>&gt;<i> explicitly declare that he or she would like to download a high 
</I>&gt;<i> resolution because they need to see a sharper version of an image before 
</I>&gt;<i> buying product, etc.
</I>
That's up to the UA, but would be possible with the srcset=&quot;&quot; feature.


On Sat, 12 May 2012, Mathew Marquis wrote:
&gt;<i>
</I>&gt;<i> I don&#146;t mind saying that the `img set` markup is inscrutable to the 
</I>&gt;<i> point where I may well be missing the mark on what it&#146;s trying to 
</I>&gt;<i> achieve, but it certainly seems to overlap with many of the things for 
</I>&gt;<i> which media queries were intended&#151;albeit in a completely siloed way. As 
</I>&gt;<i> media queries continue to advance over time, are there plans to continue 
</I>&gt;<i> adding functionality to `img set` in parallel? I would hate to think we 
</I>&gt;<i> could be painting ourselves into a corner for the sake of easier 
</I>&gt;<i> implementation on the UA side.
</I>
I could see us adding more things, but I don't think it would be 
automatic, certainly.

I don't think reusing media-queries directly makes sense, they're a bit 
unwieldy for this kind of thing. I also don't think it would make sense to 
have a direct 1:1 mapping, since that would be more complicated than 
necessary without really solving any more problems.


On Mon, 14 May 2012, Odin H&#195;&#184;rthe Omdal wrote:
&gt;&gt;<i> 
</I>&gt;<i> All optional replacements of the src will have to be fitted in the same 
</I>&gt;<i> box as the original src. That might actually require you to specify both 
</I>&gt;<i> width and height upfront. Of course, people won't really do that, so I 
</I>&gt;<i> guess we're bound to get differing behaviour... Hm.
</I>&gt;<i> 
</I>&gt;<i> What do people think about that? What happens here? You have no info on 
</I>&gt;<i> the real size of the picture. I guess maybe the browser should never 
</I>&gt;<i> load any srcset alternatives then? If you have no information at all 
</I>&gt;<i> it's rather hard to make a judgement.
</I>&gt;<i> 
</I>&gt;<i> A photo gallery wants to show you a fullscreen picture, and give you:
</I>&gt;<i> 
</I>&gt;<i>    &lt;img src=2048px.jpg srcset=&quot;4096px.jpg 2x&quot;&gt;
</I>&gt;<i> 
</I>&gt;<i> In this example, us (humans :P) can easily see that one is 2048 px and 
</I>&gt;<i> the other 4096 px. If I'm viewing this on my highres Nokia N9, a na&#195;&#175;ve 
</I>&gt;<i> implementation could pick the 2x, because it knows that's nicely highres 
</I>&gt;<i> just like its own screen.
</I>&gt;<i> 
</I>&gt;<i> But it would actually be wrong! It would never need anything else than 
</I>&gt;<i> the 2048 px for normal viewing because it is anyway exceeding its real 
</I>&gt;<i> pixels on the screen.
</I>
The way I specced it, the 4096 picture would be rendered as 2048 
CSS pixels, at double density. So it will look better than if the 2048 
pixel image had been used.


On Sun, 13 May 2012, Odin H&#195;&#184;rthe Omdal wrote:
&gt;<i> 
</I>&gt;<i> Say if you're in a browser optimizing for low bandwidth usage, and some 
</I>&gt;<i> quality at the cost of speed.  The viewport is 800x600.  In the normal 
</I>&gt;<i> case, the browser would choose hero.jpg because it fits well with its 
</I>&gt;<i> resource algorithm. However, since being in the special mode, it defers 
</I>&gt;<i> the prefetch of the image and waits for layout, where it can see that 
</I>&gt;<i> this picture lies inside a 150px wide box - so it fetches hero-lo.jpg 
</I>&gt;<i> because it doesn't need more.
</I>
I've made sure that the browser has that flexibility.


On Sun, 13 May 2012, Mathew Marquis wrote:
&gt;<i> 
</I>&gt;<i> The amount of &#147;developers can never be trusted with this&#148; sentiment I&#146;ve 
</I>&gt;<i> heard from the members of this group is incredibly depressing.
</I>
Agreed that it's depressing. But I don't think it's misplaced.

It's not all authors. It's sufficient authors that it matters, though.


On Sun, 13 May 2012, Jason Grigsby wrote:
&gt;<i> 
</I>&gt;<i> Edward&#146;s original &lt;img srcset&gt; proposal was pretty straight forward, but 
</I>&gt;<i> as it has grown to try to address more use cases, the syntax has become 
</I>&gt;<i> more convoluted[1]. I read the latest proposal multiple times last night 
</I>&gt;<i> and still couldn&#146;t figure out how it would work.
</I>&gt;<i> [1] <A HREF="http://junkyard.damowmow.com/507">http://junkyard.damowmow.com/507</A>
</I>&gt;<i> 
</I>&gt;<i> It may be that the proposal is written in language that implementors 
</I>&gt;<i> understand and that it needs to be rewritten to make it clearer for 
</I>&gt;<i> authors how it would work. Or it could be an indication that the syntax 
</I>&gt;<i> is too terse and confusing for authors (which is currently the feedback 
</I>&gt;<i> the community group is receiving).
</I>
Oh don't pay any attention to that, that's just a draft (an extract from a 
draft of this very e-mail in fact!) that I was showing some people on IRC 
for a sanity check. This e-mail and the draft extract above that is from 
this e-mail is intended for discussion here amongst the context of this 
thread, it's not intended to be spec text.

The spec text is both more obtuse and precise (and aimed at implementors) 
and hopefully more understandable (and aimed at authors and tutorial 
writers). Hopefully the text in the spec is thus clearer.


On Sun, 13 May 2012, Benjamin Hawkes-Lewis wrote:
&gt;<i> 
</I>&gt;<i> Perhaps changing the syntax to avoid confusion with units might help too:
</I>&gt;<i> 
</I>&gt;<i>   &lt;img src=&quot;a.jpg&quot; alt=&quot;&quot;
</I>&gt;<i>         set=&quot;a.jpg 600x200 1x,
</I>&gt;<i>                 b.jpg 600x200 2x,
</I>&gt;<i>                 c.jpg 200x200&quot;&gt;
</I>
I imagine in most cases the vertical dimension will be omitted, at least 
in sites with Western typography.


On Sun, 13 May 2012, Bjartur Thorlacius wrote:
&gt;<i> On 5/13/12, Kornel Lesi&#197;&#132;ski &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">kornel at geekhood.net</A>&gt; wrote:
</I>&gt;<i> &gt; I think layout (media queries) and optimisation cases are orthogonal 
</I>&gt;<i> &gt; and it would be a mistake to do both with the same mechanism.
</I>&gt;<i>
</I>&gt;<i> My knee-jerk reaction to the above thought is that layout should be done 
</I>&gt;<i> using CSS and any optimizations left up to the UA. A bandwidth 
</I>&gt;<i> constrained UA could request a downsized thumbnail that fits the size of 
</I>&gt;<i> the &lt;object&gt;/&lt;img&gt;/&lt;video poster&gt;/&lt;a&gt; element, or render an 
</I>&gt;<i> appropriately sized bitmap from a SVG.
</I>&gt;<i> 
</I>&gt;<i> The problem with that, though, is that then bandwidth constraints can't 
</I>&gt;<i> affect layout. Users should be able to configure UAs to use downsized 
</I>&gt;<i> images even given a large viewport, if only to save bandwidth and 
</I>&gt;<i> reserve a larger fraction of the viewport for text columns.
</I>
I'm not sure what the solution for bandwidth should be -- so far I haven't 
seen any clear indication of how to address it. The client doesn't know 
what the bandwidth is like; the server sort of does (since it can know its 
own bandwidth and can therefore deduce if the other end is more 
constrained than it is) but even then it's highly variable and it's not 
clear what to do about it. (See my earlier comments.)

Leaving the bandwidth issues out of it, I agree with your other comments 
-- the layout issues, and media queries, belong in CSS. What belongs in 
the markup is the issue of different content for different environments. 
The two are of course linked, but not inextricably.


On Sun, 13 May 2012, Benjamin Hawkes-Lewis wrote:
&gt;<i> On Sun, May 13, 2012 at 8:55 PM, Bjartur Thorlacius 
</I>&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">svartman95 at gmail.com</A>&gt; wrote:
</I>&gt;<i> &gt; But the chosen image resolution might be a factor for choosing layout.
</I>&gt;<i> 
</I>&gt;<i> Maybe we should think of a way to expose _that_ information to CSS, 
</I>&gt;<i> rather than going in the other direction.
</I>&gt;<i> 
</I>&gt;<i> &lt;section&gt;
</I>&gt;<i>   &lt;img src=&quot;a.jpg&quot; alt=&quot;&quot;
</I>&gt;<i>        set=&quot;a.jpg 600x200 1x,
</I>&gt;<i>                b.jpg 600x200 2x,
</I>&gt;<i>                c.jpg 200x200&quot;&gt;
</I>&gt;<i> &lt;/section&gt;
</I>&gt;<i> 
</I>&gt;<i> section { /* generic style rules */ }
</I>&gt;<i> section! img:intrinsic-aspect-ratio(&lt;2) { /* specific overrides for
</I>&gt;<i> section when the UA picks the narrow image */ }
</I>
That seems reasonable to me, but we shouldh let the CSSWG address it.


On Sun, 13 May 2012, Kornel Lesi&#197;~Dski wrote:
&gt;<i> 
</I>&gt;<i> For pure bandwidth optimisation on 100dpi displays (rather than avoiding 
</I>&gt;<i> sending too large 200dpi images to users with 100dpi displays) an 
</I>&gt;<i> explicit filesize information may be the solution:
</I>&gt;<i> 
</I>&gt;<i> &lt;img srcset=&quot;q95percent.jpg size=100KB, q30percent.jpg size=20KB&quot;&gt;
</I>&gt;<i> 
</I>&gt;<i> then UA can easily make decision how much bandwidth it can use (e.g. aim 
</I>&gt;<i> to download any page in 5 seconds, so try to get image sizes to add up 
</I>&gt;<i> to less than 5*network B/s).
</I>
That would be an interesting way of giving the user agent the information, 
true (or something similar, e.g. &quot;foo.jpe 240k 100w&quot;, for &quot;kilobyte&quot;). But 
that doesn't address the question of how the user agent is supposed to 
know what to do with that information.


On Mon, 14 May 2012, Anne van Kesteren wrote:
&gt;<i> On Mon, May 14, 2012 at 10:55 AM, Matthew Wilcox &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">mail at matthewwilcox.com</A>&gt; wrote:
</I>&gt;<i> &gt; have any of you seen this proposal for an alternative solution to the 
</I>&gt;<i> &gt; problem?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; <A HREF="http://www.w3.org/community/respimg/2012/05/13/an-alternative-proposition-to-and-srcset-with-wider-scope/">http://www.w3.org/community/respimg/2012/05/13/an-alternative-proposition-to-and-srcset-with-wider-scope/</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I like the general idea and from an author perspective this seems 
</I>&gt;<i> &gt; great; but I know nothing of the browser/vendor side of the equation - 
</I>&gt;<i> &gt; is this do-able?
</I>&gt;<i> 
</I>&gt;<i> Adding a level of indirection is actually not that great as it makes it 
</I>&gt;<i> harder to understand what is going on. Also if you work on sites in 
</I>&gt;<i> teams it's not always a given access to &lt;head&gt; is equal to the templates 
</I>&gt;<i> that are being authored. Let alone full control over how resources are 
</I>&gt;<i> stored.
</I>
On Mon, 14 May 2012, Matthew Wilcox wrote:
&gt;<i>
</I>&gt;<i> I'd contest that it is no harder to understand than it is to understand 
</I>&gt;<i> why your CSS behaves differently when a JS element acts on the mark-up. 
</I>&gt;<i> We are used to one stack defining how another acts. We do it all the 
</I>&gt;<i> time. Adding classes to mark-up to control display, or just the cascade 
</I>&gt;<i> on its own does this.
</I>
A lot of authors have huge trouble with class selectors, script 
manipulating the DOM, and the cascade. So that's not necessarily a good 
argument. :-) Indirection has proven quite challenging.


&gt;<i> Is this harder to understand than &lt;picture&gt; or srcset is what really 
</I>&gt;<i> matters. Anything we do to resolve this resource adaption problem will 
</I>&gt;<i> by necessity complicate things. Is this better than the alternatives?
</I>
Well, srcset doesn't have indirection. That goes a long way towards making 
it simpler!


On Mon, 14 May 2012, Mathew Marquis wrote:
&gt;<i>
</I>&gt;<i> It&#146;s worth noting that a practical polyfill may not be possible when 
</I>&gt;<i> using `img set`, for reasons detailed at length elsewhere:
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://www.alistapart.com/articles/responsive-images-how-they-almost-worked-and-what-we-need/">http://www.alistapart.com/articles/responsive-images-how-they-almost-worked-and-what-we-need/</A>
</I>&gt;<i> <A HREF="http://www.netmagazine.com/features/state-responsive-images">http://www.netmagazine.com/features/state-responsive-images</A>
</I>&gt;<i> 
</I>&gt;<i> Long story short: attempting to write a polyfill for `img set` leaves us 
</I>&gt;<i> in the exact situation we were in while trying to solve the issue of 
</I>&gt;<i> responsive images strictly on the front-end. We would be saddling users 
</I>&gt;<i> with a redundant download&#151;first for the original src, then for the 
</I>&gt;<i> appropriately-sized source if needed.
</I>&gt;<i> 
</I>&gt;<i> Where the new element would be all but ignored by existing browsers, 
</I>&gt;<i> efficient polyfills become possible. In fact, two `picture` polyfills 
</I>&gt;<i> exist today: 
</I>&gt;<i> <A HREF="http://wiki.whatwg.org/wiki/Adaptive_images#Functional_Polyfills">http://wiki.whatwg.org/wiki/Adaptive_images#Functional_Polyfills</A>
</I>
As a general rule, the approach we have taken with HTML is to focus on 
what can be backwards-compatible -- what can degrade in legacy UAs -- 
while leaving the new features just for new browsers. Certainly, focusing 
on the short-term issue of what can be shimmed and what cannot is not 
optimising for the long term, which is the higher concern.

-- 
Ian Hickson               U+1047E                )\._.,--....,'``.    fL
<A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A>       U+263A                /,   _.. \   _\  ;`._ ,.
Things that are impossible just take longer.   `._.-(,_..'--(,_..'`-.;.'
</PRE>










<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="078135.html">[whatwg] &lt;picture&gt;, `img set`, and polyfills
</A></li>
	<LI>Next message: <A HREF="078130.html">[whatwg] Features for responsive Web design
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35855">[ date ]</a>
              <a href="thread.html#35855">[ thread ]</a>
              <a href="subject.html#35855">[ subject ]</a>
              <a href="author.html#35855">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
