<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Features for responsive Web design
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Features%20for%20responsive%20Web%20design&In-Reply-To=%3CCAMCRKiKYjeOsdi%3DwnkDjZvmi1HXKLg09z9eAbKrbLwOJKzPpfw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="035855.html">
   <LINK REL="Next"  HREF="078131.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Features for responsive Web design</H1>
<!--htdig_noindex-->
    <B>Matthew Wilcox</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Features%20for%20responsive%20Web%20design&In-Reply-To=%3CCAMCRKiKYjeOsdi%3DwnkDjZvmi1HXKLg09z9eAbKrbLwOJKzPpfw%40mail.gmail.com%3E"
       TITLE="[whatwg] Features for responsive Web design">mail at matthewwilcox.com
       </A><BR>
    <I>Tue May 15 02:38:26 PDT 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="035855.html">[whatwg] Features for responsive Web design
</A></li>
        <LI>Next message: <A HREF="078131.html">[whatwg] Features for responsive Web design
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#78130">[ date ]</a>
              <a href="thread.html#78130">[ thread ]</a>
              <a href="subject.html#78130">[ subject ]</a>
              <a href="author.html#78130">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Please, have you taken a look at the latest idea?

<A HREF="http://www.w3.org/community/respimg/2012/05/13/an-alternative-proposition-to-and-srcset-with-wider-scope/">http://www.w3.org/community/respimg/2012/05/13/an-alternative-proposition-to-and-srcset-with-wider-scope/</A>

It solves many issues:

1) works with pre-fetch
2) is not verbose
3) is backward compatible with current browsers
4) is aimed for future-proofing - a re-design later with new or
different breakpoints would result in no edits to the mark-up
5) Avoids repetition and excessive processing of multiple media tests

I'd greatly appreciate more feedback on this approach at the Community Group.


Kind regards,
Matt Wilcox

On 15 May 2012 08:28, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
&gt;<i> On Wed, 25 Jan 2012, Matthew Wilcox wrote:
</I>&gt;&gt;<i> On 24 January 2012 23:26, Ian Hickson &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ian at hixie.ch</A>&gt; wrote:
</I>&gt;&gt;<i> &gt; On Wed, 24 Aug 2011, Anselm Hannemann - Novolo Designagentur wrote:
</I>&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;<i> &gt; &gt; As we now have the possibility of creating fluid and responsive
</I>&gt;&gt;<i> &gt; &gt; layouts in several ways we have a problem with images.
</I>&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;<i> &gt; &gt; There's currently no good feature to implement something like
</I>&gt;&gt;<i> &gt; &gt; responsive images which adapt to the different device-resolutions.
</I>&gt;&gt;<i> &gt; &gt; We only can implement one image with one resolution scaling-up and
</I>&gt;&gt;<i> &gt; &gt; down.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; You can do adaptive sites using media queries.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; &#160; &lt;!-- HTML --&gt;
</I>&gt;&gt;<i> &gt; &#160; &lt;h1&gt;My Site&lt;/h1&gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; &#160; // CSS
</I>&gt;&gt;<i> &gt; &#160; @media (min-width: 320px and max-width: 640px) {
</I>&gt;&gt;<i> &gt; &#160; &#160; h1::before { content: url(<A HREF="http://cdn.url.com/img/myimage_xs.jpg">http://cdn.url.com/img/myimage_xs.jpg</A>) }
</I>&gt;&gt;<i> &gt; &#160; }
</I>&gt;&gt;<i> &gt; &#160; @media (min-width: 640px and max-width: 1024px) {
</I>&gt;&gt;<i> &gt; &#160; &#160; h1::before { content: url(<A HREF="http://cdn.url.com/img/myimage_m.jpg">http://cdn.url.com/img/myimage_m.jpg</A>) }
</I>&gt;&gt;<i> &gt; &#160; }
</I>&gt;&gt;<i> &gt; &#160; @media (min-width: 1024px) {
</I>&gt;&gt;<i> &gt; &#160; &#160; h1::before { content: url(<A HREF="http://cdn.url.com/img/myimage_xsl.jpg">http://cdn.url.com/img/myimage_xsl.jpg</A>) }
</I>&gt;&gt;<i> &gt; &#160; }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is of no use to content images - which are the real problem. CSS
</I>&gt;&gt;<i> supplied images are not an issue.
</I>&gt;<i>
</I>&gt;<i> Fair enough.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Looking at the feedback on these threads over the past few months (I
</I>&gt;<i> didn't quote it all here, but thank you to everyone for making very good
</I>&gt;<i> points, both here on the list and on numerous blog posts and documents on
</I>&gt;<i> the Web, referenced from these threads), it seems there are three main
</I>&gt;<i> axes that control what image one might want to use on a page, assuming
</I>&gt;<i> that one is rendering to a graphical display:
</I>&gt;<i>
</I>&gt;<i> &#160;- the size of the viewport into which the image is being rendered
</I>&gt;<i>
</I>&gt;<i> &#160;- the pixel density of the display device
</I>&gt;<i>
</I>&gt;<i> &#160;- the network bandwidth available to the page to obtain resources
</I>&gt;<i>
</I>&gt;<i> Now I'm not sure what to do about the bandwidth one. It's very hard for a
</I>&gt;<i> user agent to estimate its bandwidth availability -- it depends on the
</I>&gt;<i> server, and the network location of the server, almost as much as on the
</I>&gt;<i> location of the client; it depends on the current network congestion, it
</I>&gt;<i> depends on the other things the browser is doing; it depends on whether
</I>&gt;<i> the user is about to go through a tunnel or is about to switch to wifi; it
</I>&gt;<i> depends on whether the user is roaming out of network or is on an OC48
</I>&gt;<i> network pipe. It's hugely variable. It's not clear to me how to
</I>&gt;<i> characterise it, either. It's also something that's changing very rapidly.
</I>&gt;<i> On the more modern mobile networks, the real problem seems to be latency,
</I>&gt;<i> not bandwidth; once you've actually kicked off a download, you can get the
</I>&gt;<i> data very fast, it just takes forever to kick it off. That kind of problem
</I>&gt;<i> is better solved by something like SPDY than by downloading smaller
</I>&gt;<i> images. Downloading smaller images also screws up zooming images, which
</I>&gt;<i> happens a lot more on mobile than on desktop.
</I>&gt;<i>
</I>&gt;<i> A number of people proposed solutions that are variants on the
</I>&gt;<i> &lt;video&gt;/&lt;source&gt; mechanism, where you have an abundance of elements to
</I>&gt;<i> replace the lonely &lt;img&gt;. Looking at the examples of this, though, I could
</I>&gt;<i> not get over how verbose the result is. If we're expecting this to be
</I>&gt;<i> common -- which I think we are -- then really can't be asking authors to
</I>&gt;<i> be providing dense collections of media queries, switch-statement like
</I>&gt;<i> lists of URLs, and so forth, with each image.
</I>&gt;<i>
</I>&gt;<i> Nor can we ask authors to provide a default and then have an external CSS
</I>&gt;<i> file give alternatives. The syntax is different (and in some proposals
</I>&gt;<i> actually already possible today), but the fundamental problem still
</I>&gt;<i> exists: it's way too much work for just inserting an image in a page.
</I>&gt;<i>
</I>&gt;<i> Another proposal that various people advocated is a header that the
</I>&gt;<i> servers can use to determine what content to use. Besides a wide number of
</I>&gt;<i> problems that people pointed out with this on the thread (such as the
</I>&gt;<i> privacy issues due to fingerprinting, the many ways that such information
</I>&gt;<i> gets abused, the high aggregate bandwidth cost, the difficulties with
</I>&gt;<i> using headers in offline scenarios, etc), the biggest problem with this
</I>&gt;<i> idea, IMHO, is that authors have shown that HTTP headers are simply a
</I>&gt;<i> non-starter. Content-Type headers are perenially wrong, Accept headers are
</I>&gt;<i> mishandled all over the place, adding Origin headers has caused
</I>&gt;<i> compatibility issues... HTTP headers are a disaster. If there's ever an
</I>&gt;<i> option to solve a problem without HTTP headers, we should take it, IMHO.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Tue, 7 Feb 2012, Kornel Lesi&#197;~Dski wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You could just say &quot;I've got these image sizes available, choose which
</I>&gt;&gt;<i> one suits you best&quot;, and browser would pick one that makes most sense.
</I>&gt;&gt;<i> You (and every other web developer) wouldn't have to write and maintain
</I>&gt;&gt;<i> code for computation of bandwidth/latency/battery/screen
</I>&gt;&gt;<i> size/density/zoom/cpu speed/memory tradeoffs. With so many variables I'm
</I>&gt;&gt;<i> afraid that average developer wouldn't make better choices than mobile
</I>&gt;&gt;<i> browsers themselves can.
</I>&gt;<i>
</I>&gt;<i> Indeed.
</I>&gt;<i>
</I>&gt;<i> One thing I noticed when looking at the proposals is that they all
</I>&gt;<i> conveyed a lot of information:
</I>&gt;<i>
</I>&gt;<i> &#160;- a list of files, each with a particular dimension in CSS pixels and
</I>&gt;<i> &#160; each intended for a particular display pixel density, bandwidth
</I>&gt;<i> &#160; level, and layout dimensions
</I>&gt;<i>
</I>&gt;<i> &#160;- a list of conditions consisting of layout dimensions, pixel densities,
</I>&gt;<i> &#160; bandwidth characterisations
</I>&gt;<i>
</I>&gt;<i> &#160;- glue to keep it all together and to tie in non-graphical fallback
</I>&gt;<i>
</I>&gt;<i> A lot of this is redundant, though. When would an author ever say &quot;hey,
</I>&gt;<i> use my 1024x768 image&quot; when the display is 640x480? When would an author
</I>&gt;<i> say &quot;use this 4 device-pixel-per-CSS-pixel image&quot; when the display is a
</I>&gt;<i> regular low-density display?
</I>&gt;<i>
</I>&gt;<i> In fact, as Kornel suggests, would it be possible to just enumerate the
</I>&gt;<i> files and their characteristics, and let the browser figure out which one
</I>&gt;<i> to use?
</I>&gt;<i>
</I>&gt;<i> Of course, if we do that, we still end up having to list a lot of
</I>&gt;<i> redundant information, namely which URL maps to which set of
</I>&gt;<i> characteristics. That's sad, because it's almost always going to be the
</I>&gt;<i> case that the author will put the characteristics in the filename, since
</I>&gt;<i> otherwise it becomes a maintenance nightmare.
</I>&gt;<i>
</I>&gt;<i> So why not just give the UA the characteristics and a template to use to
</I>&gt;<i> build the file names itself? That way we still give the UA all the same
</I>&gt;<i> information, but it is much less verbose and still solves all the same use
</I>&gt;<i> cases. Thus:
</I>&gt;<i>
</I>&gt;<i> &#160; &lt;img src=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">face-600-200 at 1.jpeg</A>&quot; alt=&quot;&quot;
</I>&gt;<i> &#160; &#160; &#160; &#160;src-template=&quot;face-%w-%h@%r.jpeg&quot;
</I>&gt;<i> &#160; &#160; &#160; &#160;src-versions=&quot;600x200x1 600x200x2 200x200x1&quot;&gt;
</I>&gt;<i>
</I>&gt;<i> (The first src=&quot;&quot; would be optional; its purpose is legacy fallback.)
</I>&gt;<i>
</I>&gt;<i> The algorithm for picking an image could be to sort the images by width,
</I>&gt;<i> and remove all those that are wider than the available width (except for
</I>&gt;<i> the narrowest one if they're all too wide), then sort them by height and
</I>&gt;<i> remove all those that are taller than the available height (except the
</I>&gt;<i> shortest one if they are all too tall), then sort them by pixel density
</I>&gt;<i> and remove all those that are for densities greater than the current one
</I>&gt;<i> (except the lowest one if they are all greater), then remove all those
</I>&gt;<i> that are for densities less than the current one (except the highest one
</I>&gt;<i> if they are all lower), then of the remaining images pick the widest one,
</I>&gt;<i> tie-breaking by picking the tallest one (that should leave just one
</I>&gt;<i> possible file name).
</I>&gt;<i>
</I>&gt;<i> This doesn't handle bandwidth concerns; as mentioned above, I'm not sure
</I>&gt;<i> how to do that even at a theoretical level.
</I>&gt;<i>
</I>&gt;<i> As people on #whatwg pointed out when I floated it there, the problems
</I>&gt;<i> with this idea are two-fold: first, by helping authors who use consistent
</I>&gt;<i> naming schemes it forces all authors into using schemes that have the
</I>&gt;<i> height, width, and/or resolution baked in literally, and second, it forces
</I>&gt;<i> authors who only care about one or two of the axes to list all three.
</I>&gt;<i>
</I>&gt;<i> For example, some people only want to decide whether to use &quot;low res&quot; and
</I>&gt;<i> &quot;retina&quot; versions of their images, with filenames like &quot;foo.jpeg&quot; and
</I>&gt;<i> &quot;foo-HD.jpeg&quot;. They don't want to specify dimensions at all.
</I>&gt;<i>
</I>&gt;<i> Over in CSS land, there have been proposals for similar features, e.g.
</I>&gt;<i> image-set:
</I>&gt;<i>
</I>&gt;<i> &#160; <A HREF="http://lists.w3.org/Archives/Public/www-style/2012Feb/1103.html">http://lists.w3.org/Archives/Public/www-style/2012Feb/1103.html</A>
</I>&gt;<i>
</I>&gt;<i> In fact, hober proposed a variant of that on this list recently too.
</I>&gt;<i>
</I>&gt;<i> If we use a syntax a bit like that one, we could increase the verbosity a
</I>&gt;<i> little, while handling a few more cases:
</I>&gt;<i>
</I>&gt;<i> &#160; &lt;img src=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">face-600-200 at 1.jpeg</A>&quot; alt=&quot;&quot;
</I>&gt;<i> &#160; &#160; &#160; &#160;srcset=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">face-600-200 at 1.jpeg</A> 600w 200h 1x,
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">face-600-200 at 2.jpeg</A> 600w 200h 2x,
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;face-icon.png &#160; &#160; &#160; 200w 200h&quot;&gt;
</I>&gt;<i>
</I>&gt;<i> The verbosity is still not completely insane (though now we are back to
</I>&gt;<i> duplicating information a bit), but we have more flexibility in the
</I>&gt;<i> filename scheme and less restriction on the list of values that have to be
</I>&gt;<i> specified.
</I>&gt;<i>
</I>&gt;<i> The algorithm here could be to sort the images by width, and remove all
</I>&gt;<i> those that are wider than the available width (except for the narrowest
</I>&gt;<i> one if they're all too wide) or that don't have a width unless none have
</I>&gt;<i> widths, then sort them by height and remove all those that are taller than
</I>&gt;<i> the available height (except the shortest one if they are all too tall) or
</I>&gt;<i> that don't have a height unless none have heights, then sort them by pixel
</I>&gt;<i> density and remove all those that are for densities greater than the
</I>&gt;<i> current one (except the lowest one if they are all greater), then remove
</I>&gt;<i> all those that are for densities less than the current one (except the
</I>&gt;<i> highest one if they are all lower), assuming that any without a specified
</I>&gt;<i> density are implicitly 1x, then of the remaining images pick the widest
</I>&gt;<i> one, if any have a width, tie-breaking by picking the tallest one, if any
</I>&gt;<i> have a height, finally tie-breaking by picking the first one, if none have
</I>&gt;<i> any dimensions.
</I>&gt;<i>
</I>&gt;<i> If a user agent has picked a resource with a pixel density other than 1x,
</I>&gt;<i> it would scale its intrinsic dimensions by the reciprocal of the pixel
</I>&gt;<i> density (i.e. if the pixel density is given as 1.5x, then a 150 pixel
</I>&gt;<i> image would be rendered at 100px (CSS pixels), btu with the full 150
</I>&gt;<i> pixels used for rendering if the display has a higher resolution than the
</I>&gt;<i> CSS pixel 96dpi-equivalent).
</I>&gt;<i>
</I>&gt;<i> Authoring-conformance-wise, that means that if any specify a width, they
</I>&gt;<i> all must; if any specify a height, they all must; and omitting the pixel
</I>&gt;<i> density is fine but is treated as 1x. At least one of the three must be
</I>&gt;<i> specified, since otherwise a comma after the value would be confused as
</I>&gt;<i> being part of the URL. No two entries can have the same descriptors.
</I>&gt;<i>
</I>&gt;<i> For convenience we could say that there is an implicit entry with no
</I>&gt;<i> height and width and with resolution 1x that is the value of the src=&quot;&quot;
</I>&gt;<i> attribute, so then to have a 1x/2x alternative we'd just write:
</I>&gt;<i>
</I>&gt;<i> &#160; &lt;img src=&quot;logo.png&quot; alt=&quot;SampleCorp&quot; srcset=&quot;logo-HD.png 2x&quot;&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The problem with this proposal is that user agents want to prefetch the
</I>&gt;<i> images before they start layout. This means they don't know what the
</I>&gt;<i> available dimensions _are_.
</I>&gt;<i>
</I>&gt;<i> In practice, the only information regarding dimensions that can be
</I>&gt;<i> usefully leveraged here is the viewport dimensions. This isn't the end of
</I>&gt;<i> the world, though -- there's often going to be a direct correlation
</I>&gt;<i> between the dimensions of the viewport and the dimensions of the images.
</I>&gt;<i> For example, a page's heading banner will typically be as wide as the
</I>&gt;<i> page. If there's two columns, each column is likely to be half the width
</I>&gt;<i> of the page. If there's a fixed-width column that has one width at wide
</I>&gt;<i> resolutions and another width at narrow resolutions, then it will likely
</I>&gt;<i> have a graphical header, or background image, that is also fixed width,
</I>&gt;<i> with a different fixed width based on the width of the page.
</I>&gt;<i>
</I>&gt;<i> The net result of this is that we can just change the proposal above to
</I>&gt;<i> use the viewport dimensions instead of the available width, and it should
</I>&gt;<i> work about as well. It does mean, though, that we can't use the height=&quot;&quot;
</I>&gt;<i> and width=&quot;&quot; attributes as fallback dimensions for the other ones.
</I>&gt;<i>
</I>&gt;<i> Another change we can make is to not require that all candidates have all
</I>&gt;<i> the descriptors. We already said above that a missing pixel resolution
</I>&gt;<i> would mean 1x, but what about missing dimensions? Well, one option is to
</I>&gt;<i> just say that if you have no dimensions, you're appropriate for infinitely
</I>&gt;<i> wide screens. This gets around the problem of saying that you have to
</I>&gt;<i> basically give an arbitrarily large dimension for the biggest image, or
</I>&gt;<i> saying that we have to have to use the widest image if none of the images
</I>&gt;<i> are wide enough. (And ditto height.)
</I>&gt;<i>
</I>&gt;<i> The resulting proposal is what I've put in the spec.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sat, 4 Feb 2012, irakli wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Something as simple as if browsers passed along device's width/height
</I>&gt;&gt;<i> information as part of the initial request headers would go a very very
</I>&gt;&gt;<i> long way, making it possible to make a lot of intelligent decisions on
</I>&gt;&gt;<i> the server-side (eventually allowing &quot;media-queries-like&quot; systems on the
</I>&gt;&gt;<i> server-side).
</I>&gt;<i>
</I>&gt;<i> I don't think it makes sense to base anything on the _device_ dimensions.
</I>&gt;<i> You'd want to base it on the dimensions of the available space, which can
</I>&gt;<i> change dynamically. (On my iMac at home, I never browse full-screen.)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Mon, 6 Feb 2012, Matthew Wilcox wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The problem with using viewport instead of device size is client-side
</I>&gt;&gt;<i> caching. It completely breaks things. As follows:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1) The user requests the site with a viewport at less than the device
</I>&gt;&gt;<i> screen size.
</I>&gt;&gt;<i> 2) The user browses around for a bit on a few pages.
</I>&gt;&gt;<i> 3) The user maximises their browser.
</I>&gt;&gt;<i> 4) All of the images now in the browser cache are too small.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> How does the client know to re-request all those pre-cached images,
</I>&gt;&gt;<i> without making an arduous manual JS-reliant cache manifest? Or without
</I>&gt;&gt;<i> turning off caching entirely?
</I>&gt;<i>
</I>&gt;<i> With the logic proposed above, the user agent could change the image on
</I>&gt;<i> the fly. It would also handle the user zooming, the user changing
</I>&gt;<i> monitors, the user plugging in a new monitor, etc.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Mon, 6 Feb 2012, James Graham wrote:
</I>&gt;&gt;<i> On Mon, 6 Feb 2012, Boris Zbarsky wrote:
</I>&gt;&gt;<i> &gt; On 2/6/12 11:42 AM, James Graham wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; Sure. &#160;I'm not entirely sure how sympathetic I am to the need to
</I>&gt;&gt;<i> &gt; produce &quot;reduced-functionality&quot; pages... &#160;The examples I've
</I>&gt;&gt;<i> &gt; encountered have mostly been in one of three buckets:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; 1) &quot;Why isn't the desktop version just like this vastly better mobile one?&quot;
</I>&gt;&gt;<i> &gt; 2) &quot;The mobile version has a completely different workflow necessitating a
</I>&gt;&gt;<i> &gt; different url structure, not just different images and CSS&quot;
</I>&gt;&gt;<i> &gt; 3) &quot;We'll randomly lock you out of features even though your browser and
</I>&gt;&gt;<i> &gt; device can handle them just fine&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The example I had in mind was one of our developers who was hacking an
</I>&gt;&gt;<i> internal tool so that he could use it efficiently on his phone.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> AFAICT his requirements were:
</I>&gt;&gt;<i> 1) Same URL structure as the main site
</I>&gt;&gt;<i> 2) Less (only critical) information on each screen
</I>&gt;&gt;<i> 3) No looking up / transfering information that would later be thrown away
</I>&gt;&gt;<i> 4) Fast =&gt; No extra round trip to report device properties
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> AFAIK he finally decided to UA sniff Opera mobile. Which is pretty sucky even
</I>&gt;&gt;<i> for an intranet app. But I didn't really have a better story to offer him. It
</I>&gt;&gt;<i> would be nice to address this kind of use case somehow.
</I>&gt;<i>
</I>&gt;<i> I'm not really convinced we want to encourage #2. It drives me crazy when
</I>&gt;<i> I find I can't use a site because the site decided I was using a phone
</I>&gt;<i> instead of a computer. (The others are satisfied by just making the site
</I>&gt;<i> work at all window sizes, nothing to do with mobile vs desktop.)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Tue, 7 Feb 2012, James Graham wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This basically amounts to &quot;the requirements were wrong&quot;. Since the same
</I>&gt;&gt;<i> developer made both the desktop and mobile frontends and he is one of
</I>&gt;&gt;<i> the major users of the system, and the mobile frontend was purely
</I>&gt;&gt;<i> scratching his own itch, I find it very difficult to justify the
</I>&gt;&gt;<i> position that he ought to have wanted something different to what he
</I>&gt;&gt;<i> actually wanted and made.
</I>&gt;<i>
</I>&gt;<i> I agree that some people do want this. I'm just saying we should probably
</I>&gt;<i> not encourage it.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> In general the idea that sites/applications should be essentially the
</I>&gt;&gt;<i> same, but perhaps slightly rearranged, regardless of the device they run
</I>&gt;&gt;<i> on just doesn't seem to be something that the market agrees with. It
</I>&gt;&gt;<i> seems to me that we can either pretend that this isn't true, and watch
</I>&gt;&gt;<i> as platform-specific apps become increasingly entrenched, or work out
</I>&gt;&gt;<i> ways to make the UX on sites that target multiple types of hardware as
</I>&gt;&gt;<i> good as possible.
</I>&gt;<i>
</I>&gt;<i> Honestly I think as devices get more capable, the direction will be
</I>&gt;<i> towards there being just One Web. We're already seeing mobile sites become
</I>&gt;<i> much more functional than they were a few years ago.
</I>&gt;<i>
</I>&gt;<i> They'll always be a little different, because the user interaction is
</I>&gt;<i> different (touch vs keyboard/mouse, e.g.), but with new product classes
</I>&gt;<i> being introduced (tablets, smaller laptops, bigger &quot;phablets&quot;, etc) I just
</I>&gt;<i> don't see it as viable for us to continue having per-product-class Web
</I>&gt;<i> sites; we'll instead see &quot;responsive design&quot;.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Mon, 13 Feb 2012, Gray Zhang wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. On a product description page of a shopping site, there are several
</I>&gt;&gt;<i> *main* pictures of the product, along with about twenty or so camera
</I>&gt;&gt;<i> pictures of the product taken from different angles. When the HTML is
</I>&gt;&gt;<i> parsed, browsers by default simultaneously start downloading all images,
</I>&gt;&gt;<i> potentially making some of the *main* ones invisible.
</I>&gt;<i>
</I>&gt;<i> This seems like something that's currently relatively easily handled using
</I>&gt;<i> hidden=&quot;&quot; or CSS, with some JS (or more CSS) to decide when to show what.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> 2. On an album page where hundreds of pictures are expected to be shown,
</I>&gt;&gt;<i> it is often required that pictures currently in a user's screen should
</I>&gt;&gt;<i> appear as fast as possible. Loading of a picture outside the screen can
</I>&gt;&gt;<i> be deferred to the time that the picture enters or is about to enter the
</I>&gt;&gt;<i> screen, for the purpose of optimization user experience.
</I>&gt;<i>
</I>&gt;<i> This seems like something the browser can do automatically today.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> 3. For a site with limited bandwidth on the server side, it is
</I>&gt;&gt;<i> preferable to minimize the amount of data transferred per each page
</I>&gt;&gt;<i> view. 70% of the users only read the first screen and hence pictures
</I>&gt;&gt;<i> outside the first screen don't need to be downloaded before the user
</I>&gt;&gt;<i> starts to scroll the page. This is to reduce server-side cost.
</I>&gt;<i>
</I>&gt;<i> This is harder for browsers to do automatically, since many pages depend
</I>&gt;<i> on non-displayed images getting downloaded.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> &#160;Current Solution and It's Drawbacks
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The current solution pretty much consists of three steps:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. The server outputs &lt;img&gt;s with @src pointing to a transparent image,
</I>&gt;&gt;<i> transparent.gif, and with @data-src pointing to the real location of the
</I>&gt;&gt;<i> image.
</I>&gt;&gt;<i> 2. Listen to the window.onscroll event.
</I>&gt;&gt;<i> 3. The event handler finds all &lt;img&gt;s in the visible area and set their
</I>&gt;&gt;<i> @src to @data-src that were stored.
</I>&gt;<i>
</I>&gt;<i> Not ideal, yeah.
</I>&gt;<i>
</I>&gt;<i> In practice, this is something that has indeed been done in JavaScript;
</I>&gt;<i> indeed &quot;infinite scroll&quot; pages are something that has become quite common
</I>&gt;<i> (see e.g. Bing's image search results). I don't know that it's especially
</I>&gt;<i> critical to be able to have the &lt;img&gt; elements already in the page not yet
</I>&gt;<i> load; it seems easier to just not add them to the page until the user
</I>&gt;<i> scrolls down.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Thu, 10 May 2012, Aryeh Gregor wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'd like to throw in another use-case that might be addressable by the
</I>&gt;&gt;<i> same feature: allowing &quot;Save As...&quot; to save a different version of the
</I>&gt;&gt;<i> image (e.g., higher-res) than is actually displayed. &#160;Wikipedia, for
</I>&gt;&gt;<i> instance, often has very high-res images that get scaled down for
</I>&gt;&gt;<i> article viewing to save bandwidth and avoid possibly-ugly rescaling. (At
</I>&gt;&gt;<i> least historically, some browsers used very bad rescaling algorithms.)
</I>&gt;&gt;<i> It would be nice if when users saved the image, they saved the full-res
</I>&gt;&gt;<i> version. &#160;Perhaps browsers could save the highest-res image available,
</I>&gt;&gt;<i> rather than the one that happens to be used for display right now.
</I>&gt;<i>
</I>&gt;<i> This seems like it would be handled adequately by the proposal above.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Another obvious use-case I'd like to point out is print. &#160;It's not quite
</I>&gt;&gt;<i> as trendy as the iPhone Retina display -- in fact maybe it's getting
</I>&gt;&gt;<i> pass&#195;&#169; :) -- but print is generally higher-res than display, and it's
</I>&gt;&gt;<i> common for images to appear pixelated when printing. &#160;This use-case
</I>&gt;&gt;<i> might have the same requirements as the iPhone Retina display, but it
</I>&gt;&gt;<i> should be kept in mind in case it doesn't.
</I>&gt;<i>
</I>&gt;<i> Agreed.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> A fourth use-case I'd like to suggest is vector images. &#160;Last I checked,
</I>&gt;&gt;<i> many authors don't want to serve SVG directly because too many browsers
</I>&gt;&gt;<i> don't support it in &lt;img&gt; (or at all). &#160;Perhaps it should be possible to
</I>&gt;&gt;<i> specify &quot;vector&quot; or something in place of a scale factor, to indicate
</I>&gt;&gt;<i> that the image should be suitable for all resolutions.
</I>&gt;<i>
</I>&gt;<i> Will there ever be any browsers that support srcset=&quot;&quot; but not SVG?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Thu, 10 May 2012, Tab Atkins Jr. wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That all said, I don't like the &quot;2x&quot; notation. &#160;It's declaring &quot;this
</I>&gt;&gt;<i> image's resolution is twice that of a normal image&quot;. &#160;This has two
</I>&gt;&gt;<i> problems. &#160;For one, we already have a unit that means that - the dppx
</I>&gt;&gt;<i> unit. &#160;Using &quot;2dppx&quot; is identical to the meaning of &quot;2x&quot;. &#160;Since
</I>&gt;&gt;<i> image-set() is newer than the dppx unit, we should change it to use
</I>&gt;&gt;<i> &lt;resolution&gt; instead.
</I>&gt;<i>
</I>&gt;<i> dppx is pretty ugly. I agree with hober's &quot;2x&quot; design.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> For two, I'm not sure that it's particularly obvious that when you say
</I>&gt;&gt;<i> &quot;2x&quot;, you should make sure your image was saved as 196dpi. &#160;You have
</I>&gt;&gt;<i> to already know what the default resolution is.
</I>&gt;<i>
</I>&gt;<i> You don't have to. The resolution of the image is ignored.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> As well, I think that values like 300dpi are pretty common, and they
</I>&gt;&gt;<i> don't map to integral 'x' values. &#160;If people say &quot;screw it&quot; and use
</I>&gt;&gt;<i> &quot;3x&quot;, this'll be slightly wrong and I think will cause ugly blurring.
</I>&gt;&gt;<i> If we make this take &lt;resolution&gt;, people can just use the dpi unit.
</I>&gt;<i>
</I>&gt;<i> 3.125x isn't particularly difficult to specify.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Thu, 10 May 2012, Mathew Marquis wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hey guys. Don&#8217;t know if it&#8217;s too early to chime in with this, but we
</I>&gt;&gt;<i> were told by some members of the Chrome team that any browser that
</I>&gt;&gt;<i> supports DNS prefetching &#8212; including assets &#8212; wouldn&#8217;t consider
</I>&gt;&gt;<i> &#8220;looking-ahead&#8221; on the img tag as an option. The original src would be
</I>&gt;&gt;<i> fetched in any case, saddling users with a redundant download.
</I>&gt;<i>
</I>&gt;<i> I don't understand what this means.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, 13 May 2012, Jason Grigsby described some use cases:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Document author needs to display different versions of an image at
</I>&gt;&gt;<i> different breakpoints based on what I&#8217;m calling, for a lack of a better
</I>&gt;&gt;<i> phrase, art direction merits.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Example 1: News site shows photograph speaking at a auto factory. On
</I>&gt;&gt;<i> wide screens, the news site includes a widescreen version of the
</I>&gt;&gt;<i> photograph in which the cars being built can clearly be seen. On small
</I>&gt;&gt;<i> screens, if the photograph is simply resized to fit the screen, Obama&#8217;s
</I>&gt;&gt;<i> face is too small to be seen. Instead, the document author may choose to
</I>&gt;&gt;<i> crop the photograph so that it focuses in on Obama before resizing to
</I>&gt;&gt;<i> fit the smaller screen.
</I>&gt;<i>
</I>&gt;<i> &#160; &lt;img alt=&quot;Obama spoke at the factory.&quot; src=&quot;factory.jpeg&quot;
</I>&gt;<i> &#160; &#160; &#160; &#160;srcset=&quot;obama-factory-face.jpeg 500w&quot;&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> * Example 2: On the Nokia Browser site where it describes the Meego
</I>&gt;&gt;<i> browser, the Nokia Lumia is show horizontally on wide screens. As the
</I>&gt;&gt;<i> screen narrows, the Nokia Lumia is then shown vertically and cropped.
</I>&gt;&gt;<i> Bryan and Stephanie Rieger, the designers of the site, have talked about
</I>&gt;&gt;<i> how on a wide screen, showing the full phone horizontally showed the
</I>&gt;&gt;<i> browser best, but on small screens, changing the img to vertical made
</I>&gt;&gt;<i> more sense because it allowed the reader to still make out the features
</I>&gt;&gt;<i> of the browser in the image.
</I>&gt;<i>
</I>&gt;<i> &#160; &lt;img alt=&quot;The Nokia Browser for MeeGo can display the BBC site well.&quot;
</I>&gt;<i> &#160; &#160; &#160; &#160;src=&quot;landscape.png&quot;
</I>&gt;<i> &#160; &#160; &#160; &#160;srcset=&quot;vertical-cropped.png 500w&quot;&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> For a variety of reasons, images of various pixel density are needed.
</I>&gt;&gt;<i> These reasons include current network connection speed, display pixel
</I>&gt;&gt;<i> density, user data plan, and user preferences.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * Example 1: The use of high-density images for the new iPad on
</I>&gt;&gt;<i> Apple.com.
</I>&gt;<i>
</I>&gt;<i> &#160; &lt;img alt=&quot;&quot; src=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ipad at 1.png</A>&quot; srcset=&quot;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">ipad at 2.png</A> 2x&quot;&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> * Example 2: A user on a slow network or with limited data left may
</I>&gt;&gt;<i> explicitly declare that he or she would like to download a high
</I>&gt;&gt;<i> resolution because they need to see a sharper version of an image before
</I>&gt;&gt;<i> buying product, etc.
</I>&gt;<i>
</I>&gt;<i> That's up to the UA, but would be possible with the srcset=&quot;&quot; feature.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sat, 12 May 2012, Mathew Marquis wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I don&#8217;t mind saying that the `img set` markup is inscrutable to the
</I>&gt;&gt;<i> point where I may well be missing the mark on what it&#8217;s trying to
</I>&gt;&gt;<i> achieve, but it certainly seems to overlap with many of the things for
</I>&gt;&gt;<i> which media queries were intended&#8212;albeit in a completely siloed way. As
</I>&gt;&gt;<i> media queries continue to advance over time, are there plans to continue
</I>&gt;&gt;<i> adding functionality to `img set` in parallel? I would hate to think we
</I>&gt;&gt;<i> could be painting ourselves into a corner for the sake of easier
</I>&gt;&gt;<i> implementation on the UA side.
</I>&gt;<i>
</I>&gt;<i> I could see us adding more things, but I don't think it would be
</I>&gt;<i> automatic, certainly.
</I>&gt;<i>
</I>&gt;<i> I don't think reusing media-queries directly makes sense, they're a bit
</I>&gt;<i> unwieldy for this kind of thing. I also don't think it would make sense to
</I>&gt;<i> have a direct 1:1 mapping, since that would be more complicated than
</I>&gt;<i> necessary without really solving any more problems.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Mon, 14 May 2012, Odin H&#248;rthe Omdal wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> All optional replacements of the src will have to be fitted in the same
</I>&gt;&gt;<i> box as the original src. That might actually require you to specify both
</I>&gt;&gt;<i> width and height upfront. Of course, people won't really do that, so I
</I>&gt;&gt;<i> guess we're bound to get differing behaviour... Hm.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What do people think about that? What happens here? You have no info on
</I>&gt;&gt;<i> the real size of the picture. I guess maybe the browser should never
</I>&gt;&gt;<i> load any srcset alternatives then? If you have no information at all
</I>&gt;&gt;<i> it's rather hard to make a judgement.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A photo gallery wants to show you a fullscreen picture, and give you:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &#160;&lt;img src=2048px.jpg srcset=&quot;4096px.jpg 2x&quot;&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In this example, us (humans :P) can easily see that one is 2048 px and
</I>&gt;&gt;<i> the other 4096 px. If I'm viewing this on my highres Nokia N9, a na&#239;ve
</I>&gt;&gt;<i> implementation could pick the 2x, because it knows that's nicely highres
</I>&gt;&gt;<i> just like its own screen.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> But it would actually be wrong! It would never need anything else than
</I>&gt;&gt;<i> the 2048 px for normal viewing because it is anyway exceeding its real
</I>&gt;&gt;<i> pixels on the screen.
</I>&gt;<i>
</I>&gt;<i> The way I specced it, the 4096 picture would be rendered as 2048
</I>&gt;<i> CSS pixels, at double density. So it will look better than if the 2048
</I>&gt;<i> pixel image had been used.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, 13 May 2012, Odin H&#248;rthe Omdal wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Say if you're in a browser optimizing for low bandwidth usage, and some
</I>&gt;&gt;<i> quality at the cost of speed. &#160;The viewport is 800x600. &#160;In the normal
</I>&gt;&gt;<i> case, the browser would choose hero.jpg because it fits well with its
</I>&gt;&gt;<i> resource algorithm. However, since being in the special mode, it defers
</I>&gt;&gt;<i> the prefetch of the image and waits for layout, where it can see that
</I>&gt;&gt;<i> this picture lies inside a 150px wide box - so it fetches hero-lo.jpg
</I>&gt;&gt;<i> because it doesn't need more.
</I>&gt;<i>
</I>&gt;<i> I've made sure that the browser has that flexibility.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, 13 May 2012, Mathew Marquis wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The amount of &#8220;developers can never be trusted with this&#8221; sentiment I&#8217;ve
</I>&gt;&gt;<i> heard from the members of this group is incredibly depressing.
</I>&gt;<i>
</I>&gt;<i> Agreed that it's depressing. But I don't think it's misplaced.
</I>&gt;<i>
</I>&gt;<i> It's not all authors. It's sufficient authors that it matters, though.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, 13 May 2012, Jason Grigsby wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Edward&#8217;s original &lt;img srcset&gt; proposal was pretty straight forward, but
</I>&gt;&gt;<i> as it has grown to try to address more use cases, the syntax has become
</I>&gt;&gt;<i> more convoluted[1]. I read the latest proposal multiple times last night
</I>&gt;&gt;<i> and still couldn&#8217;t figure out how it would work.
</I>&gt;&gt;<i> [1] <A HREF="http://junkyard.damowmow.com/507">http://junkyard.damowmow.com/507</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It may be that the proposal is written in language that implementors
</I>&gt;&gt;<i> understand and that it needs to be rewritten to make it clearer for
</I>&gt;&gt;<i> authors how it would work. Or it could be an indication that the syntax
</I>&gt;&gt;<i> is too terse and confusing for authors (which is currently the feedback
</I>&gt;&gt;<i> the community group is receiving).
</I>&gt;<i>
</I>&gt;<i> Oh don't pay any attention to that, that's just a draft (an extract from a
</I>&gt;<i> draft of this very e-mail in fact!) that I was showing some people on IRC
</I>&gt;<i> for a sanity check. This e-mail and the draft extract above that is from
</I>&gt;<i> this e-mail is intended for discussion here amongst the context of this
</I>&gt;<i> thread, it's not intended to be spec text.
</I>&gt;<i>
</I>&gt;<i> The spec text is both more obtuse and precise (and aimed at implementors)
</I>&gt;<i> and hopefully more understandable (and aimed at authors and tutorial
</I>&gt;<i> writers). Hopefully the text in the spec is thus clearer.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, 13 May 2012, Benjamin Hawkes-Lewis wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Perhaps changing the syntax to avoid confusion with units might help too:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &lt;img src=&quot;a.jpg&quot; alt=&quot;&quot;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; set=&quot;a.jpg 600x200 1x,
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; b.jpg 600x200 2x,
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; c.jpg 200x200&quot;&gt;
</I>&gt;<i>
</I>&gt;<i> I imagine in most cases the vertical dimension will be omitted, at least
</I>&gt;<i> in sites with Western typography.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, 13 May 2012, Bjartur Thorlacius wrote:
</I>&gt;&gt;<i> On 5/13/12, Kornel Lesi&#324;ski &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">kornel at geekhood.net</A>&gt; wrote:
</I>&gt;&gt;<i> &gt; I think layout (media queries) and optimisation cases are orthogonal
</I>&gt;&gt;<i> &gt; and it would be a mistake to do both with the same mechanism.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My knee-jerk reaction to the above thought is that layout should be done
</I>&gt;&gt;<i> using CSS and any optimizations left up to the UA. A bandwidth
</I>&gt;&gt;<i> constrained UA could request a downsized thumbnail that fits the size of
</I>&gt;&gt;<i> the &lt;object&gt;/&lt;img&gt;/&lt;video poster&gt;/&lt;a&gt; element, or render an
</I>&gt;&gt;<i> appropriately sized bitmap from a SVG.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The problem with that, though, is that then bandwidth constraints can't
</I>&gt;&gt;<i> affect layout. Users should be able to configure UAs to use downsized
</I>&gt;&gt;<i> images even given a large viewport, if only to save bandwidth and
</I>&gt;&gt;<i> reserve a larger fraction of the viewport for text columns.
</I>&gt;<i>
</I>&gt;<i> I'm not sure what the solution for bandwidth should be -- so far I haven't
</I>&gt;<i> seen any clear indication of how to address it. The client doesn't know
</I>&gt;<i> what the bandwidth is like; the server sort of does (since it can know its
</I>&gt;<i> own bandwidth and can therefore deduce if the other end is more
</I>&gt;<i> constrained than it is) but even then it's highly variable and it's not
</I>&gt;<i> clear what to do about it. (See my earlier comments.)
</I>&gt;<i>
</I>&gt;<i> Leaving the bandwidth issues out of it, I agree with your other comments
</I>&gt;<i> -- the layout issues, and media queries, belong in CSS. What belongs in
</I>&gt;<i> the markup is the issue of different content for different environments.
</I>&gt;<i> The two are of course linked, but not inextricably.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, 13 May 2012, Benjamin Hawkes-Lewis wrote:
</I>&gt;&gt;<i> On Sun, May 13, 2012 at 8:55 PM, Bjartur Thorlacius
</I>&gt;&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">svartman95 at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> &gt; But the chosen image resolution might be a factor for choosing layout.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Maybe we should think of a way to expose _that_ information to CSS,
</I>&gt;&gt;<i> rather than going in the other direction.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &lt;section&gt;
</I>&gt;&gt;<i> &#160; &lt;img src=&quot;a.jpg&quot; alt=&quot;&quot;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160;set=&quot;a.jpg 600x200 1x,
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;b.jpg 600x200 2x,
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;c.jpg 200x200&quot;&gt;
</I>&gt;&gt;<i> &lt;/section&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> section { /* generic style rules */ }
</I>&gt;&gt;<i> section! img:intrinsic-aspect-ratio(&lt;2) { /* specific overrides for
</I>&gt;&gt;<i> section when the UA picks the narrow image */ }
</I>&gt;<i>
</I>&gt;<i> That seems reasonable to me, but we shouldh let the CSSWG address it.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sun, 13 May 2012, Kornel Lesi&#197;~Dski wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For pure bandwidth optimisation on 100dpi displays (rather than avoiding
</I>&gt;&gt;<i> sending too large 200dpi images to users with 100dpi displays) an
</I>&gt;&gt;<i> explicit filesize information may be the solution:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &lt;img srcset=&quot;q95percent.jpg size=100KB, q30percent.jpg size=20KB&quot;&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> then UA can easily make decision how much bandwidth it can use (e.g. aim
</I>&gt;&gt;<i> to download any page in 5 seconds, so try to get image sizes to add up
</I>&gt;&gt;<i> to less than 5*network B/s).
</I>&gt;<i>
</I>&gt;<i> That would be an interesting way of giving the user agent the information,
</I>&gt;<i> true (or something similar, e.g. &quot;foo.jpe 240k 100w&quot;, for &quot;kilobyte&quot;). But
</I>&gt;<i> that doesn't address the question of how the user agent is supposed to
</I>&gt;<i> know what to do with that information.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Mon, 14 May 2012, Anne van Kesteren wrote:
</I>&gt;&gt;<i> On Mon, May 14, 2012 at 10:55 AM, Matthew Wilcox &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">mail at matthewwilcox.com</A>&gt; wrote:
</I>&gt;&gt;<i> &gt; have any of you seen this proposal for an alternative solution to the
</I>&gt;&gt;<i> &gt; problem?
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; <A HREF="http://www.w3.org/community/respimg/2012/05/13/an-alternative-proposition-to-and-srcset-with-wider-scope/">http://www.w3.org/community/respimg/2012/05/13/an-alternative-proposition-to-and-srcset-with-wider-scope/</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; I like the general idea and from an author perspective this seems
</I>&gt;&gt;<i> &gt; great; but I know nothing of the browser/vendor side of the equation -
</I>&gt;&gt;<i> &gt; is this do-able?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Adding a level of indirection is actually not that great as it makes it
</I>&gt;&gt;<i> harder to understand what is going on. Also if you work on sites in
</I>&gt;&gt;<i> teams it's not always a given access to &lt;head&gt; is equal to the templates
</I>&gt;&gt;<i> that are being authored. Let alone full control over how resources are
</I>&gt;&gt;<i> stored.
</I>&gt;<i>
</I>&gt;<i> On Mon, 14 May 2012, Matthew Wilcox wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'd contest that it is no harder to understand than it is to understand
</I>&gt;&gt;<i> why your CSS behaves differently when a JS element acts on the mark-up.
</I>&gt;&gt;<i> We are used to one stack defining how another acts. We do it all the
</I>&gt;&gt;<i> time. Adding classes to mark-up to control display, or just the cascade
</I>&gt;&gt;<i> on its own does this.
</I>&gt;<i>
</I>&gt;<i> A lot of authors have huge trouble with class selectors, script
</I>&gt;<i> manipulating the DOM, and the cascade. So that's not necessarily a good
</I>&gt;<i> argument. :-) Indirection has proven quite challenging.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Is this harder to understand than &lt;picture&gt; or srcset is what really
</I>&gt;&gt;<i> matters. Anything we do to resolve this resource adaption problem will
</I>&gt;&gt;<i> by necessity complicate things. Is this better than the alternatives?
</I>&gt;<i>
</I>&gt;<i> Well, srcset doesn't have indirection. That goes a long way towards making
</I>&gt;<i> it simpler!
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Mon, 14 May 2012, Mathew Marquis wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It&#8217;s worth noting that a practical polyfill may not be possible when
</I>&gt;&gt;<i> using `img set`, for reasons detailed at length elsewhere:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> <A HREF="http://www.alistapart.com/articles/responsive-images-how-they-almost-worked-and-what-we-need/">http://www.alistapart.com/articles/responsive-images-how-they-almost-worked-and-what-we-need/</A>
</I>&gt;&gt;<i> <A HREF="http://www.netmagazine.com/features/state-responsive-images">http://www.netmagazine.com/features/state-responsive-images</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Long story short: attempting to write a polyfill for `img set` leaves us
</I>&gt;&gt;<i> in the exact situation we were in while trying to solve the issue of
</I>&gt;&gt;<i> responsive images strictly on the front-end. We would be saddling users
</I>&gt;&gt;<i> with a redundant download&#8212;first for the original src, then for the
</I>&gt;&gt;<i> appropriately-sized source if needed.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Where the new element would be all but ignored by existing browsers,
</I>&gt;&gt;<i> efficient polyfills become possible. In fact, two `picture` polyfills
</I>&gt;&gt;<i> exist today:
</I>&gt;&gt;<i> <A HREF="http://wiki.whatwg.org/wiki/Adaptive_images#Functional_Polyfills">http://wiki.whatwg.org/wiki/Adaptive_images#Functional_Polyfills</A>
</I>&gt;<i>
</I>&gt;<i> As a general rule, the approach we have taken with HTML is to focus on
</I>&gt;<i> what can be backwards-compatible -- what can degrade in legacy UAs --
</I>&gt;<i> while leaving the new features just for new browsers. Certainly, focusing
</I>&gt;<i> on the short-term issue of what can be shimmed and what cannot is not
</I>&gt;<i> optimising for the long term, which is the higher concern.
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> Ian Hickson &#160; &#160; &#160; &#160; &#160; &#160; &#160; U+1047E &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;)\._.,--....,'``. &#160; &#160;fL
</I>&gt;<i> <A HREF="http://ln.hixie.ch/">http://ln.hixie.ch/</A> &#160; &#160; &#160; U+263A &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/, &#160; _.. \ &#160; _\ &#160;;`._ ,.
</I>&gt;<i> Things that are impossible just take longer. &#160; `._.-(,_..'--(,_..'`-.;.'
</I>
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="035855.html">[whatwg] Features for responsive Web design
</A></li>
	<LI>Next message: <A HREF="078131.html">[whatwg] Features for responsive Web design
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#78130">[ date ]</a>
              <a href="thread.html#78130">[ thread ]</a>
              <a href="subject.html#78130">[ subject ]</a>
              <a href="author.html#78130">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
