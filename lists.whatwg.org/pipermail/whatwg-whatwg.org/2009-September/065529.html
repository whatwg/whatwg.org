<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Structured clone algorithm on LocalStorage
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Structured%20clone%20algorithm%20on%20LocalStorage&In-Reply-To=%3C63df84f0909292348h21f51a30r208ea1cd25375686%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="065506.html">
   <LINK REL="Next"  HREF="065465.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Structured clone algorithm on LocalStorage</H1>
<!--htdig_noindex-->
    <B>Jonas Sicking</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Structured%20clone%20algorithm%20on%20LocalStorage&In-Reply-To=%3C63df84f0909292348h21f51a30r208ea1cd25375686%40mail.gmail.com%3E"
       TITLE="[whatwg] Structured clone algorithm on LocalStorage">jonas at sicking.cc
       </A><BR>
    <I>Tue Sep 29 23:48:56 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="065506.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
        <LI>Next message: <A HREF="065465.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65529">[ date ]</a>
              <a href="thread.html#65529">[ thread ]</a>
              <a href="subject.html#65529">[ subject ]</a>
              <a href="author.html#65529">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Tue, Sep 29, 2009 at 12:19 AM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt; wrote:
&gt;<i> On Thu, Sep 24, 2009 at 11:57 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Thu, Sep 24, 2009 at 9:04 PM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt; wrote:
</I>&gt;&gt;<i> &gt; On Thu, Sep 24, 2009 at 4:43 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt; wrote:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; On Thu, Sep 24, 2009 at 10:52 AM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt;
</I>&gt;&gt;<i> &gt;&gt; wrote:
</I>&gt;&gt;<i> &gt;&gt; &gt; On Thu, Sep 24, 2009 at 10:40 AM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt; wrote:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; On Thu, Sep 24, 2009 at 1:17 AM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; wrote:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; On Thu, Sep 24, 2009 at 12:20 AM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; wrote:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; On Wed, Sep 23, 2009 at 10:19 PM, Darin Fisher
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; wrote:
</I>&gt;<i>
</I>&gt;<i> ... snip ...
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; multi-core is the future. &#160;what's the opposite of fine-grained
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; locking?
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; &#160;it's not good ;-)
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; the implicit locking mechanism as spec'd is super lame.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; &#160;implicitly
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; unlocking under
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; mysterious-to-the-developer circumstances! &#160;how can that be a
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; good
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; thing?
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; storage.setItem(&quot;y&quot;,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; function_involving_implicit_unlocking(storage.getItem(&quot;x&quot;)));
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; I totally agree on all points. The current API has big
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; imperfections.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; However I haven't seen any workable counter proposals so far, and
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; I
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; honestly don't believe there are any as long as our goals are:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; * Don't break existing users of the current implementations.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; * Don't expose race conditions to the web.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; * Don't rely on authors getting explicit locking mechanisms
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; right.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; The current API exposes race conditions to the web. &#160;The implicit
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; dropping of the storage lock is that. &#160;In Chrome, we'll have to
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; drop
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; an existing lock whenever a new lock is acquired. &#160;That can happen
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; due to a variety of really odd cases (usually related to nested
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; loops
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; or nested JS execution), which will be difficult for developers&#160;to
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; predict, especially if they are relying on third-party JS
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; libraries.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; This issue seems to be discounted for reasons I do not understand.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; I don't believe we've heard about this before, so that would be the
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; reason it hasn't been taken into account.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; So you're saying that chrome would be unable implement the current
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; storage mutex as specified in spec? I.e. one that is only released
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; at
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; the explicit points that the spec defines? That seems like a huge
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; problem.
</I>&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt; No, no... my point is that to the application developer, those
</I>&gt;&gt;<i> &gt;&gt; &gt; &quot;explicit&quot;
</I>&gt;&gt;<i> &gt;&gt; &gt; points will appear quite implicit and mysterious. &#160;This is why I
</I>&gt;&gt;<i> &gt;&gt; &gt; called
</I>&gt;&gt;<i> &gt;&gt; &gt; out third-party JS libraries. &#160;One day, a function that you are using
</I>&gt;&gt;<i> &gt;&gt; &gt; might transition to scripting a plugin, which might cause a nested
</I>&gt;&gt;<i> &gt;&gt; &gt; loop, which could then force the lock to be released. &#160;As a
</I>&gt;&gt;<i> &gt;&gt; &gt; programmer,
</I>&gt;&gt;<i> &gt;&gt; &gt; the unlocking is not explicit or predictable.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Ah, indeed, this is a problem. However the unfortunate fact remains
</I>&gt;&gt;<i> &gt;&gt; that so far no other workable solution has been proposed.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; OK, so we agree that the current solution doesn't meet the goals&#160;you
</I>&gt;&gt;<i> &gt; stated above :-(
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Well, it addresses them as long as users are aware of the risk, and
</I>&gt;&gt;<i> properly document weather their various library functions will release
</I>&gt;&gt;<i> the lock or not. However I agree that it's unlikely that they will do
</I>&gt;&gt;<i> so correctly.
</I>&gt;<i>
</I>&gt;<i> I thought the point of not having lock APIs was that users shouldn't have
</I>&gt;<i> to understand locks ;-) &#160;The issue I've raised here is super subtle. &#160;We
</I>&gt;<i> have not succeeded in avoiding subtlety!
</I>
I think we're mostly in agreement. What I'm not sure about is what you
are proposing we do with localStorage? Remove it from the spec? Change
the API? Something else?

&gt;&gt;<i> &gt;&gt; &gt; Moreover, there are other examples which have been discussed on the
</I>&gt;&gt;<i> &gt;&gt; &gt; list. &#160;There are some DOM operations that can result in a frame
</I>&gt;&gt;<i> &gt;&gt; &gt; receiving
</I>&gt;&gt;<i> &gt;&gt; &gt; a DOM event synchronously. &#160;That can result in a nesting of storage
</I>&gt;&gt;<i> &gt;&gt; &gt; locks,
</I>&gt;&gt;<i> &gt;&gt; &gt; which can force us to have to implicitly unlock the outermost lock to
</I>&gt;&gt;<i> &gt;&gt; &gt; avoid
</I>&gt;&gt;<i> &gt;&gt; &gt; deadlocks. &#160;Again, the programmer will have very poor visibility into
</I>&gt;&gt;<i> &gt;&gt; &gt; when
</I>&gt;&gt;<i> &gt;&gt; &gt; these things can happen.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; So far I don't think it has been shown that these events need to be
</I>&gt;&gt;<i> &gt;&gt; synchronous. They all appear to be asynchronous in gecko, and in the
</I>&gt;&gt;<i> &gt;&gt; case of different-origin frames, I'm not even sure there's a way for
</I>&gt;&gt;<i> &gt;&gt; pages to detect if the event was fired asynchronously or not.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; IE and WebKit dispatch some of them synchronously. &#160;It's hard to say
</I>&gt;&gt;<i> &gt; which
</I>&gt;&gt;<i> &gt; is correct or if it causes any web compat isues. &#160;I'm also not sure that
</I>&gt;&gt;<i> &gt; we
</I>&gt;&gt;<i> &gt; have covered all of the cases.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It still seems to me that it's extremely unlikely that pages depend on
</I>&gt;&gt;<i> cross origin events to fire synchronously. I can't even think of a way
</I>&gt;&gt;<i> to test if a browser dispatches these events synchronously or not. Can
</I>&gt;&gt;<i> you?
</I>&gt;<i>
</I>&gt;<i> i agree that it seems uncommon. &#160;maybe there could be some odd app that
</I>&gt;<i> does something after resizing an iframe that could be dependent on the
</I>&gt;<i> event handler setting some data field. &#160;this kind of thing is probably even
</I>&gt;<i> less common in the cross-origin case.
</I>
But how would you read that data field in the cross-origin frame? I
think it might be possible, but extremely hard.

&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; But, as imperfect as the current API is, I think the following is
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; a
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; decent way forward:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; * Allow pages that want the convenience of localStorage to use
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; it.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; For
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; multi-process browsers this will mean poor UI *for pages that use
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; localStorage*. Especially when said pages hold on to localStorage
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; for
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; a long time.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; * Add alternative APIs that don't suffer from the same problems.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; More
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; below.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; In addition, this argument assumes that Microsoft (and other
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; UAs)
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; will
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; implement the structured clone version of LocalStorage. &#160;Has
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; anyone
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; (or
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; can
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; anyone) from Microsoft comment on this?
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; Given that I've never heard microsoft commit to a webstandard,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; ever,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; I
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; doubt that we'll hear anything here. Or that the lack of
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; hearing
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; anything means we can draw any conclusions.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; This is not a small feature to add. &#160;Yes, it's smaller than
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; creating
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; a
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; new
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; storage mechanism (that everyone is willing to adopt), but I
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; still
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; think
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; that's what we should be looking at. &#160;Rather than polishing
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; a
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt; turd.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; I do think that localStorage is a decent API that developers
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; will
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; want
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; to, and should, use. I think looking into adding a async
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; accessor
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; to
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; get a storage object so that people can use an
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; localStorage-like
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; API
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; while avoiding risks of blocking. This would also allow
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; sharing
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; data
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; between worker threads and the main window.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; i think the async callback to get a storage object is an
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; improvement,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; but
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; i'm not sure that it addresses all of the problems. &#160;for
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; example,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; if
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; a
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; worker
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; wants to read values from storage, compute, and then put a
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; value
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; into
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; storage, it would probably do all of this from the storage
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; callback.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; &#160;that
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; would result in holding the lock for a long time, which would
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; lock
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; out
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; any
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; other threads, including non-worker threads.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; the problem here is that localStorage is a pile of global
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; variables.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; &#160;we
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; are
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; trying to give people global variables without giving them
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; tools
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; to
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; synchronize
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; access to them. &#160;the claim i've heard is that developers are
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; not
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; savy
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; enough
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; to use those tools properly. &#160;i agree that developers tend to
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; use
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; tools
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; without
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; fully understanding them. &#160;ok, but then why are we giving them
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; global
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; variables?
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; there has to be a better answer.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; I actually described an potential solution in the thread on
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; worker
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; storage.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; The problem you describe is a worker holding on the the storage
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; for
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; an
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; very long (indefinite) time, thereby locking out other
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; threads/windows
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; from accessing the same storage area. This seems inevitable if we
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; want
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; to prevent race conditions while at the same time not forcing the
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; complexities of locks onto web developers. The WebDatabase API
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; suffers
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; from exactly the same problem.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; Hmm... are you saying that from the&#160;SQLStatementCallback used to
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; read
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; some data out of the database, you might compute on that data, and
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; then
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; issue an executeSql call to write a computed result, and that in
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; this
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; scenario,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; the fact that it is the same transaction means that other threads
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; are
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; locked
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; out of accessing the same database? &#160;I hadn't considered chaining
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; executeSql
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; calls like this to keep the transaction alive. &#160;Hmm...
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; Indeed.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; However, we can lessen the problem. By adding multiple storage
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; areas,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; we can allow a worker to use one storage area, while allowing
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; other
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; parties to simultaneously use other storage areas. This way, if a
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; worker and a window aren't sharing data at all, they never get in
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; the
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; way of each other.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; So a very simplistic design would be something like the
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; following:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; getStorageArea(name, callback)
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; when called will asynchronously call the callback parameter once
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; the
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; storage area named by the first parameter becomes available. The
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; callback receives the storage area as an argument. We would also
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; have
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; the function
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; getMultipleStorageAreas(names, callback)
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; Same as above, but names is an array of strings indicating
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; multiple
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; storage areas that need to be acquired before the callback is
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; called.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; The callback receives all the areas in an array as an argument.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; This
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; function allows transferring data between multiple storage areas
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; without risking racing.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; There's several problems with this, such as the names are sort of
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; crappy, and that getting storage areas an array isn't very
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; friendly.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; However you get the basic idea.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; We don't even need to use Storage objects for this. In fact, I
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; hope
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; mozilla will in a not too distant future come up with an
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; alternative
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; proposal to the WebDatabase SQL API. Something like this might
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; fit
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; into such a proposal as I think that'll have multiple separate
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; storage
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; areas anyway.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; / Jonas
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; Maybe we should just invent a similar transaction method for
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; name/value
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; storage? &#160;Wouldn't that be better than inventing a new idiom?
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; &#160;Ideally,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; we'd also make reads and writes on storage be asynchronous. &#160;The
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; transaction would then be usable to hold the lock across multiple
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; asynchronous reads and writes. &#160;Since local storage is backed&#160;by
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; disk,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; it seems like a more ideal local storage API would not
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; require&#160;synchronous
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; filesystem access.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; Not quite following what you're suggesting, but there's lots of ways
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; to design this. The critical part is to allow grabbing (with
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; associated locking) of just a subset of the available storage space.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; / Jonas
</I>&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt; I was suggesting that we only provide asynchronous getItem / setItem
</I>&gt;&gt;<i> &gt;&gt; &gt; calls,
</I>&gt;&gt;<i> &gt;&gt; &gt; where
</I>&gt;&gt;<i> &gt;&gt; &gt; each call is parameterized by a transaction. &#160;This is how database
</I>&gt;&gt;<i> &gt;&gt; &gt; works.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Not quite sure I follow your proposal. How would you for example
</I>&gt;&gt;<i> &gt;&gt; increase the value of a property by one without risking race
</I>&gt;&gt;<i> &gt;&gt; conditions? Or keep two values in different properties in sync? I.e.
</I>&gt;&gt;<i> &gt;&gt; so that if you update one always update the other, so that they never
</I>&gt;&gt;<i> &gt;&gt; have different values.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; / Jonas
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Easy. &#160;Just like with database, the transaction is the storage lock.
</I>&gt;&gt;<i> &gt; &#160;Any
</I>&gt;&gt;<i> &gt; storage
</I>&gt;&gt;<i> &gt; operation performed on that transaction are done atomically. &#160;However,
</I>&gt;&gt;<i> &gt; all
</I>&gt;&gt;<i> &gt; storage
</I>&gt;&gt;<i> &gt; operations are asynchronous. &#160;You basically string together asynchronous
</I>&gt;&gt;<i> &gt; storage
</I>&gt;&gt;<i> &gt; operations by using the same transaction for each.
</I>&gt;&gt;<i> &gt; We could add methods to get/set multiple items at once to simplify life
</I>&gt;&gt;<i> &gt; for
</I>&gt;&gt;<i> &gt; the coder.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think I still don't understand your proposal, could you give some
</I>&gt;&gt;<i> code examples?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ripping off database:
</I>&gt;<i> interface ValueStorage {
</I>&gt;<i> &#160;&#160;void transaction(in DOMString namespace, in
</I>&gt;<i> ValueStorageTransactionCallback callback);
</I>&gt;<i> };
</I>&gt;<i> interface ValueStorageTransactionCallback {
</I>&gt;<i> &#160;&#160;void handleEvent(in ValueStorageTransaction transaction);
</I>&gt;<i> };
</I>&gt;<i> interface ValueStorageTransaction {
</I>&gt;<i> &#160;&#160;void readValue(in DOMString name, in ValueStorageReadCallback callback);
</I>&gt;<i> &#160;&#160;void writeValue(in DOMString name, in DOMString value);
</I>&gt;<i> };
</I>&gt;<i> interface ValueStorageReadCallback {
</I>&gt;<i> &#160;&#160;void handleEvent(in ValueStorageTransaction transaction, in DOMString
</I>&gt;<i> value);
</I>&gt;<i> };
</I>&gt;<i> then, to use these interfaces, you could implement thread-safe increment:
</I>&gt;<i> window.localStorage.transaction(&quot;slice&quot;, function(transaction) {
</I>&gt;<i> &#160;&#160;transaction.readValue(&quot;foo&quot;, function(transaction, fooValue) {
</I>&gt;<i> &#160;&#160; &#160;transaction.writeValue(&quot;foo&quot;, ++fooValue);
</I>&gt;<i> &#160;&#160;})
</I>&gt;<i> })
</I>&gt;<i> to fetch multiple values, you could do this:
</I>&gt;<i> var values = [];
</I>&gt;<i> var numValues = 10;
</I>&gt;<i> function readNextValue(transaction) {
</I>&gt;<i> &#160;&#160;if (values.length == numValues)
</I>&gt;<i> &#160;&#160; return; &#160;// done!
</I>&gt;<i> &#160;&#160;var index = values.length;
</I>&gt;<i> &#160;&#160;transaction.readValue(&quot;value&quot; + index, function(transaction, value) {
</I>&gt;<i> &#160;&#160; &#160;values.push(value);
</I>&gt;<i> &#160;&#160; &#160;readNextValue(transaction);
</I>&gt;<i> &#160;&#160;})
</I>&gt;<i> }
</I>&gt;<i> window.localStorage.transaction(&quot;slice&quot;, readNextValue);
</I>&gt;<i> This has the property that all IO is non-blocking and the &quot;lock&quot; is held
</I>&gt;<i> only
</I>&gt;<i> for a very limited scope. &#160;The programmer is however free to extend the
</I>&gt;<i> life of the lock as needed.
</I>
What do you mean by that the &quot;lock&quot; is held for only a very limited
scope? You still want to prevent modifications for as long as the
transaction is being used right? I.e. no modifications can happen
between the read and the write in the first example, and between the
different reads in the second.

/ Jonas

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="065506.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
	<LI>Next message: <A HREF="065465.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65529">[ date ]</a>
              <a href="thread.html#65529">[ thread ]</a>
              <a href="subject.html#65529">[ subject ]</a>
              <a href="author.html#65529">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
