<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Structured clone algorithm on LocalStorage
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Structured%20clone%20algorithm%20on%20LocalStorage&In-Reply-To=%3Cbd8f24d20909241052s2c95623p33497027e9d5e77%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="065458.html">
   <LINK REL="Next"  HREF="065463.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Structured clone algorithm on LocalStorage</H1>
<!--htdig_noindex-->
    <B>Darin Fisher</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Structured%20clone%20algorithm%20on%20LocalStorage&In-Reply-To=%3Cbd8f24d20909241052s2c95623p33497027e9d5e77%40mail.gmail.com%3E"
       TITLE="[whatwg] Structured clone algorithm on LocalStorage">darin at chromium.org
       </A><BR>
    <I>Thu Sep 24 10:52:16 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="065458.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
        <LI>Next message: <A HREF="065463.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65459">[ date ]</a>
              <a href="thread.html#65459">[ thread ]</a>
              <a href="subject.html#65459">[ subject ]</a>
              <a href="author.html#65459">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>On Thu, Sep 24, 2009 at 10:40 AM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt; wrote:

&gt;<i> On Thu, Sep 24, 2009 at 1:17 AM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt; wrote:
</I>&gt;<i> &gt; On Thu, Sep 24, 2009 at 12:20 AM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; On Wed, Sep 23, 2009 at 10:19 PM, Darin Fisher &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">darin at chromium.org</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; On Wed, Sep 23, 2009 at 8:10 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; On Wed, Sep 23, 2009 at 3:29 PM, Jeremy Orlow &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jorlow at chromium.org</A>&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; wrote:
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; On Wed, Sep 23, 2009 at 3:15 PM, Jonas Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; wrote:
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; On Wed, Sep 23, 2009 at 2:53 PM, Brett Cannon &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">brett at python.org</A>&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; wrote:
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; On Wed, Sep 23, 2009 at 13:35, Jeremy Orlow &lt;
</I>&gt;<i> <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jorlow at chromium.org</A>&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; wrote:
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; What are the use cases for wanting to store data beyond strings
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; (and
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; what
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; can be serialized into strings) in LocalStorage?  I can't think
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; of
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; any
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; that
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; outweigh the negatives:
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; 1)  From previous threads, I think it's fair to say that we can
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; all
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; agreed
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; that LocalStorage is a regrettable API (mainly due to its
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; synchronous
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; nature).  If so, it seems that making it more powerful and thus
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; more
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; attractive to developers is just asking for trouble.  After
</I>&gt;<i> all,
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; the
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; more
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; people use it, the more lock contention there'll be, and the
</I>&gt;<i> more
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; browser UI
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; jank users will be sure to experience.  This will also be worse
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; because
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; it'll be easier for developers to store large objects in
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; LoaclStorage.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; 2)  As far as I can tell, there's no where else in the spec
</I>&gt;<i> where
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; you
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; have
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; to serialize structured clone(able) data to disk.  Given that
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; LocalStorage
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; is supposed to throw an exception if any ImageData is contained
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; and
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; since
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; File and FileData objects are legal, it seems as though making
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; LocalStorage
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; handle structured clone data has a fairly high cost to
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; implementors.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;  Not to
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; mention that disallowing ImageData in only this one case is not
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; intuitive.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; I think allowing structured clone(able) data in LocalStorage is
</I>&gt;<i> a
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; big
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; mistake.  Enough so that, if SessionStorage and LocalStorage
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; can't
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; diverge
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; on this issue, it'd be worth taking the power away from
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; SessionStorage.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; J
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; Speaking from experience, I have been using localStorage in my
</I>&gt;<i> PhD
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; thesis work w/o any real need for structured clones (I would
</I>&gt;<i> have
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; used
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; Web Database but it isn't widely used yet and I was not sure if
</I>&gt;<i> it
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; was
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; going to make the cut in the end). All it took to come close to
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; simulating structured clones now was to develop my own
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; compatibility
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; wrapper for localStorage (<A HREF="http://realstorage.googlecode.com">http://realstorage.googlecode.com</A> for
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; those
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; who care) and add setJSONObject() and getJSONObject() methods on
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; the
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; wrapper. Works w/o issue.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; Actually, this seems like a prime reason *to* add structured
</I>&gt;<i> storage
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; support. Obviously string data wasn't enough for you so you had to
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; write extra code in order to work around that. If structured
</I>&gt;<i> clones
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; had been natively supported you both would have had to write less
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; code, and the resulting algorithms would have been faster. Faster
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; since the browser can serialize/parser to/from a binary internal
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; format faster than to/from JSON through the JSON
</I>&gt;<i> serializer/parser.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; Yes, but since LocalStorage is already widely deployed, authors are
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; stuck
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; with the the structured clone-less version of LocalStorage for a
</I>&gt;<i> very
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; long
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; time.  So the only way an app can store anything that can't be
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; JSONified
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; is
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; to break backwards compatibility.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; On Wed, Sep 23, 2009 at 3:11 PM, Jonas
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; Sicking &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jonas at sicking.cc</A>&gt; wrote:
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; On Wed, Sep 23, 2009 at 1:35 PM, Jeremy Orlow &lt;
</I>&gt;<i> <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">jorlow at chromium.org</A>&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; wrote:
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; What are the use cases for wanting to store data beyond strings
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; (and
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; what
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; can be serialized into strings) in LocalStorage?  I can't think
</I>&gt;<i> of
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; any
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; that
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; outweigh the negatives:
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; 1)  From previous threads, I think it's fair to say that we can
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; all
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; agreed
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; that LocalStorage is a regrettable API (mainly due to its
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; synchronous
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; nature).  If so, it seems that making it more powerful and thus
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; more
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; attractive to developers is just asking for trouble.  After all,
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; the
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; more
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; people use it, the more lock contention there'll be, and the
</I>&gt;<i> more
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; browser UI
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; jank users will be sure to experience.  This will also be worse
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; because
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; it'll be easier for developers to store large objects in
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; LoaclStorage.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; 2)  As far as I can tell, there's no where else in the spec
</I>&gt;<i> where
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; you
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; have
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; to serialize structured clone(able) data to disk.  Given that
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; LocalStorage
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; is supposed to throw an exception if any ImageData is contained
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; and
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; since
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; File and FileData objects are legal, it seems as though making
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; LocalStorage
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; handle structured clone data has a fairly high cost to
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; implementors.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;  Not to
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; mention that disallowing ImageData in only this one case is not
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; intuitive.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; I think allowing structured clone(able) data in LocalStorage is
</I>&gt;<i> a
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; big
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; mistake.  Enough so that, if SessionStorage and LocalStorage
</I>&gt;<i> can't
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; diverge
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; on this issue, it'd be worth taking the power away from
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; SessionStorage.
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; Despite localStorage unfortunate locking contention problem, it's
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; become quite a popular API. It's also very successful in terms of
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; browser deployment since it's available in at least latest
</I>&gt;<i> versions
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; of
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; IE, Safari, Firefox, and Chrome. Don't know about support in
</I>&gt;<i> Opera?
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; The more popular it becomes, the more it's going to hurt UA
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; developers,
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; web
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; developers, and users.  I don't see why this is an argument for
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; making
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; it
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; more powerful.
</I>&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; How will it hurt UA developers? I think we're stuck forever to
</I>&gt;<i> &gt;&gt; &gt;&gt; implement the locking mechanism. Adding more datatypes to the API
</I>&gt;<i> &gt;&gt; &gt;&gt; doesn't mean that we'll have to implement it more.
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; multi-core is the future.  what's the opposite of fine-grained
</I>&gt;<i> locking?
</I>&gt;<i> &gt;&gt; &gt;  it's not good ;-)
</I>&gt;<i> &gt;&gt; &gt; the implicit locking mechanism as spec'd is super lame.  implicitly
</I>&gt;<i> &gt;&gt; &gt; unlocking under
</I>&gt;<i> &gt;&gt; &gt; mysterious-to-the-developer circumstances!  how can that be a good
</I>&gt;<i> &gt;&gt; &gt; thing?
</I>&gt;<i> &gt;&gt; &gt; storage.setItem(&quot;y&quot;,
</I>&gt;<i> &gt;&gt; &gt; function_involving_implicit_unlocking(storage.getItem(&quot;x&quot;)));
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I totally agree on all points. The current API has big imperfections.
</I>&gt;<i> &gt;&gt; However I haven't seen any workable counter proposals so far, and I
</I>&gt;<i> &gt;&gt; honestly don't believe there are any as long as our goals are:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; * Don't break existing users of the current implementations.
</I>&gt;<i> &gt;&gt; * Don't expose race conditions to the web.
</I>&gt;<i> &gt;&gt; * Don't rely on authors getting explicit locking mechanisms right.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The current API exposes race conditions to the web.  The implicit
</I>&gt;<i> &gt; dropping of the storage lock is that.  In Chrome, we'll have to drop
</I>&gt;<i> &gt; an existing lock whenever a new lock is acquired.  That can happen
</I>&gt;<i> &gt; due to a variety of really odd cases (usually related to nested loops
</I>&gt;<i> &gt; or nested JS execution), which will be difficult for developers to
</I>&gt;<i> &gt; predict, especially if they are relying on third-party JS libraries.
</I>&gt;<i> &gt; This issue seems to be discounted for reasons I do not understand.
</I>&gt;<i>
</I>&gt;<i> I don't believe we've heard about this before, so that would be the
</I>&gt;<i> reason it hasn't been taken into account.
</I>&gt;<i>
</I>&gt;<i> So you're saying that chrome would be unable implement the current
</I>&gt;<i> storage mutex as specified in spec? I.e. one that is only released at
</I>&gt;<i> the explicit points that the spec defines? That seems like a huge
</I>&gt;<i> problem.
</I>&gt;<i>
</I>
No, no... my point is that to the application developer, those &quot;explicit&quot;
points will appear quite implicit and mysterious.  This is why I called
out third-party JS libraries.  One day, a function that you are using
might transition to scripting a plugin, which might cause a nested
loop, which could then force the lock to be released.  As a programmer,
the unlocking is not explicit or predictable.

Moreover, there are other examples which have been discussed on the
list.  There are some DOM operations that can result in a frame receiving
a DOM event synchronously.  That can result in a nesting of storage locks,
which can force us to have to implicitly unlock the outermost lock to avoid
deadlocks.  Again, the programmer will have very poor visibility into when
these things can happen.



&gt;<i>
</I>&gt;<i> &gt;&gt; But, as imperfect as the current API is, I think the following is a
</I>&gt;<i> &gt;&gt; decent way forward:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; * Allow pages that want the convenience of localStorage to use it. For
</I>&gt;<i> &gt;&gt; multi-process browsers this will mean poor UI *for pages that use
</I>&gt;<i> &gt;&gt; localStorage*. Especially when said pages hold on to localStorage for
</I>&gt;<i> &gt;&gt; a long time.
</I>&gt;<i> &gt;&gt; * Add alternative APIs that don't suffer from the same problems. More
</I>&gt;<i> &gt;&gt; below.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; In addition, this argument assumes that Microsoft (and other UAs)
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; will
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; implement the structured clone version of LocalStorage.  Has anyone
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; (or
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; can
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; anyone) from Microsoft comment on this?
</I>&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; Given that I've never heard microsoft commit to a webstandard, ever,
</I>&gt;<i> I
</I>&gt;<i> &gt;&gt; &gt;&gt; doubt that we'll hear anything here. Or that the lack of hearing
</I>&gt;<i> &gt;&gt; &gt;&gt; anything means we can draw any conclusions.
</I>&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; This is not a small feature to add.  Yes, it's smaller than
</I>&gt;<i> creating
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; a
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; new
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; storage mechanism (that everyone is willing to adopt), but I still
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; think
</I>&gt;<i> &gt;&gt; &gt;&gt; &gt; that's what we should be looking at.  Rather than polishing a turd.
</I>&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;<i> &gt;&gt; &gt;&gt; I do think that localStorage is a decent API that developers will
</I>&gt;<i> want
</I>&gt;<i> &gt;&gt; &gt;&gt; to, and should, use. I think looking into adding a async accessor to
</I>&gt;<i> &gt;&gt; &gt;&gt; get a storage object so that people can use an localStorage-like API
</I>&gt;<i> &gt;&gt; &gt;&gt; while avoiding risks of blocking. This would also allow sharing data
</I>&gt;<i> &gt;&gt; &gt;&gt; between worker threads and the main window.
</I>&gt;<i> &gt;&gt; &gt;
</I>&gt;<i> &gt;&gt; &gt; i think the async callback to get a storage object is an improvement,
</I>&gt;<i> &gt;&gt; &gt; but
</I>&gt;<i> &gt;&gt; &gt; i'm not sure that it addresses all of the problems.  for example, if a
</I>&gt;<i> &gt;&gt; &gt; worker
</I>&gt;<i> &gt;&gt; &gt; wants to read values from storage, compute, and then put a value into
</I>&gt;<i> &gt;&gt; &gt; storage, it would probably do all of this from the storage callback.
</I>&gt;<i> &gt;&gt; &gt;  that
</I>&gt;<i> &gt;&gt; &gt; would result in holding the lock for a long time, which would lock out
</I>&gt;<i> &gt;&gt; &gt; any
</I>&gt;<i> &gt;&gt; &gt; other threads, including non-worker threads.
</I>&gt;<i> &gt;&gt; &gt; the problem here is that localStorage is a pile of global variables.
</I>&gt;<i>  we
</I>&gt;<i> &gt;&gt; &gt; are
</I>&gt;<i> &gt;&gt; &gt; trying to give people global variables without giving them tools to
</I>&gt;<i> &gt;&gt; &gt; synchronize
</I>&gt;<i> &gt;&gt; &gt; access to them.  the claim i've heard is that developers are not savy
</I>&gt;<i> &gt;&gt; &gt; enough
</I>&gt;<i> &gt;&gt; &gt; to use those tools properly.  i agree that developers tend to use
</I>&gt;<i> tools
</I>&gt;<i> &gt;&gt; &gt; without
</I>&gt;<i> &gt;&gt; &gt; fully understanding them.  ok, but then why are we giving them global
</I>&gt;<i> &gt;&gt; &gt; variables?
</I>&gt;<i> &gt;&gt; &gt; there has to be a better answer.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I actually described an potential solution in the thread on worker
</I>&gt;<i> &gt;&gt; storage.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; The problem you describe is a worker holding on the the storage for an
</I>&gt;<i> &gt;&gt; very long (indefinite) time, thereby locking out other threads/windows
</I>&gt;<i> &gt;&gt; from accessing the same storage area. This seems inevitable if we want
</I>&gt;<i> &gt;&gt; to prevent race conditions while at the same time not forcing the
</I>&gt;<i> &gt;&gt; complexities of locks onto web developers. The WebDatabase API suffers
</I>&gt;<i> &gt;&gt; from exactly the same problem.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Hmm... are you saying that from the SQLStatementCallback used to read
</I>&gt;<i> &gt; some data out of the database, you might compute on that data, and then
</I>&gt;<i> &gt; issue an executeSql call to write a computed result, and that in this
</I>&gt;<i> &gt; scenario,
</I>&gt;<i> &gt; the fact that it is the same transaction means that other threads are
</I>&gt;<i> locked
</I>&gt;<i> &gt; out of accessing the same database?  I hadn't considered chaining
</I>&gt;<i> executeSql
</I>&gt;<i> &gt; calls like this to keep the transaction alive.  Hmm...
</I>&gt;<i>
</I>&gt;<i> Indeed.
</I>&gt;<i>
</I>&gt;<i> &gt;&gt; However, we can lessen the problem. By adding multiple storage areas,
</I>&gt;<i> &gt;&gt; we can allow a worker to use one storage area, while allowing other
</I>&gt;<i> &gt;&gt; parties to simultaneously use other storage areas. This way, if a
</I>&gt;<i> &gt;&gt; worker and a window aren't sharing data at all, they never get in the
</I>&gt;<i> &gt;&gt; way of each other.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; So a very simplistic design would be something like the following:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; getStorageArea(name, callback)
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; when called will asynchronously call the callback parameter once the
</I>&gt;<i> &gt;&gt; storage area named by the first parameter becomes available. The
</I>&gt;<i> &gt;&gt; callback receives the storage area as an argument. We would also have
</I>&gt;<i> &gt;&gt; the function
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; getMultipleStorageAreas(names, callback)
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Same as above, but names is an array of strings indicating multiple
</I>&gt;<i> &gt;&gt; storage areas that need to be acquired before the callback is called.
</I>&gt;<i> &gt;&gt; The callback receives all the areas in an array as an argument. This
</I>&gt;<i> &gt;&gt; function allows transferring data between multiple storage areas
</I>&gt;<i> &gt;&gt; without risking racing.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; There's several problems with this, such as the names are sort of
</I>&gt;<i> &gt;&gt; crappy, and that getting storage areas an array isn't very friendly.
</I>&gt;<i> &gt;&gt; However you get the basic idea.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; We don't even need to use Storage objects for this. In fact, I hope
</I>&gt;<i> &gt;&gt; mozilla will in a not too distant future come up with an alternative
</I>&gt;<i> &gt;&gt; proposal to the WebDatabase SQL API. Something like this might fit
</I>&gt;<i> &gt;&gt; into such a proposal as I think that'll have multiple separate storage
</I>&gt;<i> &gt;&gt; areas anyway.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; / Jonas
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Maybe we should just invent a similar transaction method for name/value
</I>&gt;<i> &gt; storage?  Wouldn't that be better than inventing a new idiom?  Ideally,
</I>&gt;<i> &gt; we'd also make reads and writes on storage be asynchronous.  The
</I>&gt;<i> &gt; transaction would then be usable to hold the lock across multiple
</I>&gt;<i> &gt; asynchronous reads and writes.  Since local storage is backed by disk,
</I>&gt;<i> &gt; it seems like a more ideal local storage API would not
</I>&gt;<i> require synchronous
</I>&gt;<i> &gt; filesystem access.
</I>&gt;<i>
</I>&gt;<i> Not quite following what you're suggesting, but there's lots of ways
</I>&gt;<i> to design this. The critical part is to allow grabbing (with
</I>&gt;<i> associated locking) of just a subset of the available storage space.
</I>&gt;<i>
</I>&gt;<i> / Jonas
</I>&gt;<i>
</I>

I was suggesting that we only provide asynchronous getItem / setItem calls,
where
each call is parameterized by a transaction.  This is how database works.

-Darin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20090924/5039ff4d/attachment-0002.htm">http://lists.whatwg.org/pipermail/whatwg-whatwg.org/attachments/20090924/5039ff4d/attachment-0002.htm</A>&gt;
</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="065458.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
	<LI>Next message: <A HREF="065463.html">[whatwg] Structured clone algorithm on LocalStorage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65459">[ date ]</a>
              <a href="thread.html#65459">[ thread ]</a>
              <a href="subject.html#65459">[ subject ]</a>
              <a href="author.html#65459">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
