<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] HTML5 video: frame accuracy / SMPTE
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20HTML5%20video%3A%20frame%20accuracy%20/%20SMPTE&In-Reply-To=%3CAANLkTik%3DKCkLhwAQ9R7ih3_CpWE7_Ojk3%2B3Vtoimd-Fa%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030514.html">
   <LINK REL="Next"  HREF="030529.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] HTML5 video: frame accuracy / SMPTE</H1>
<!--htdig_noindex-->
    <B>Rob Coenen</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20HTML5%20video%3A%20frame%20accuracy%20/%20SMPTE&In-Reply-To=%3CAANLkTik%3DKCkLhwAQ9R7ih3_CpWE7_Ojk3%2B3Vtoimd-Fa%40mail.gmail.com%3E"
       TITLE="[whatwg] HTML5 video: frame accuracy / SMPTE">coenen.rob at gmail.com
       </A><BR>
    <I>Tue Feb 15 13:46:19 PST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="030514.html">[whatwg] HTML5 video: frame accuracy / SMPTE
</A></li>
        <LI>Next message: <A HREF="030529.html">[whatwg] Allowing size and maxlength attributes for all new input	types would provide better fallbacks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30515">[ date ]</a>
              <a href="thread.html#30515">[ thread ]</a>
              <a href="subject.html#30515">[ subject ]</a>
              <a href="author.html#30515">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Rather than trying to sum up all use cases I think that the media asset
should be fully random accessible and frame accurate to cover any current
and future us ecasse. You should be able to write Javascripts that tell the
asset to go to any point in time.

That way a web developer (or implementers such as the guys of JWPlayer) can
come up with their own mechanisms for stuff such as &quot;chapters&quot; etc. I don't
believe that chapters should be part of the HTML5 spec.

the current spec, if implemented correctly, takes care of this AFAIK?

On Tue, Feb 15, 2011 at 9:10 PM, Kevin Marks &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">kevinmarks at gmail.com</A>&gt; wrote:

&gt;<i> Returning to this discussion, I think it is lacking in use cases.
</I>&gt;<i>
</I>&gt;<i> Consider the controllers we are used to - they tend to have frame step,
</I>&gt;<i> chapter step and some kind of scrub bar.
</I>&gt;<i>
</I>&gt;<i> Frame stepping is used when you want to mark an accurate in or our point,
</I>&gt;<i> or catch a still frame. This needs to be accurate, and it is always local.
</I>&gt;<i>
</I>&gt;<i> Chapter stepping means 'move me to the next meaningful break point in this
</I>&gt;<i> media. There is a very natural structure for this in almost all professional
</I>&gt;<i> media, and it is definitely worth getting this right. This is a long range
</I>&gt;<i> jump, but it is likely to be a key frame or start of new file segment.
</I>&gt;<i>
</I>&gt;<i> Scrubbing is when you are dragging the bar back and forth to find a
</I>&gt;<i> particular point. It is intermediate in resolution between the previous two,
</I>&gt;<i> but it needs to be responsive to work - the lag between moving the bar and
</I>&gt;<i> showing something. In many cases decoding only key frames in this state
</I>&gt;<i> makes sense, as this is most responsive, and also likely to catch scene
</I>&gt;<i> boundaries, which are commonly key frames anyway.
</I>&gt;<i>
</I>&gt;<i>
</I>yep I agree, very important. Given the fact that the scrub-bar has a fixed
width (max the width of the screen, but usually its just equal to the width
of the video- or smaller- sayeg 640 pixels width) you could reason that it
is physically impossible to move the mouse more precise than 640 positions
left or right while scrubbing. That means you have a resolution of 640 steps
to scrub through the entire asset. My guess is that 99% of all assets will
have way more than 640 keyframes. It would be fantastics if we could somehow
preload 640 keyframes taken at every (asset duration)/640th position. That
way we could provide instant and realtime feedback even while streaming. The
user would already see where the scrub cursor is going to end up even before
the video streaming has started to sync.

I know that this is probably pretty hard to abstract to something than can
be abstracted as part of the HTML5 spec, but I have seen (and made myself-)
mockups in Flash that take this approach and it works pretty neat.


The degenerate case of scrubbing is 'fast-forwarding', where the stream is
&gt;<i> fetched faster than realtime, but again only keyframes are shown.
</I>&gt;<i>
</I>&gt;<i> Are we sure all of these use cases are represented by the options mentioned
</I>&gt;<i> below?
</I>&gt;<i>
</I>&gt;<i> On Mon, Jan 24, 2011 at 12:49 PM, Robert O'Callahan &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">robert at ocallahan.org</A>&gt;wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> On Tue, Jan 25, 2011 at 9:34 AM, Philip J&#228;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>
</I>&gt;&gt;<i> &gt;wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; On Mon, 24 Jan 2011 21:10:21 +0100, Robert O'Callahan &lt;
</I>&gt;&gt;<i> &gt; <A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">robert at ocallahan.org</A>&gt; wrote:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Interesting. It doesn't in Firefox; script always sees a snapshot of a
</I>&gt;&gt;<i> &gt;&gt; consistent state until it returns to the event loop or does something
</I>&gt;&gt;<i> &gt;&gt; modal
</I>&gt;&gt;<i> &gt;&gt; (although audio, and soon video, will continue to play while script
</I>&gt;&gt;<i> runs).
</I>&gt;&gt;<i> &gt;&gt; I'm not sure if the spec should require that ... overall our APIs try
</I>&gt;&gt;<i> &gt;&gt; pretty
</I>&gt;&gt;<i> &gt;&gt; hard not to expose races to JS.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; How does that work? Do you take a copy of all properties that could
</I>&gt;&gt;<i> &gt; possibly change during script execution, including ones that create a
</I>&gt;&gt;<i> new
</I>&gt;&gt;<i> &gt; object, like buffered and seekable?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> All script-accessible state exists on the main thread (the thread that
</I>&gt;&gt;<i> runs
</I>&gt;&gt;<i> the event loop), and is updated via asynchronous messages from decoder and
</I>&gt;&gt;<i> playback threads as necessary. 'buffered' is always in sync since data
</I>&gt;&gt;<i> arrival and eviction from the media data cache happen on the main thread.
</I>&gt;&gt;<i> (That cache can be read from other threads though.)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you instead only make a copy on the first read, isn't it still possible
</I>&gt;&gt;<i> &gt; to get an inconsistent state, e.g. where currentTime isn't in the
</I>&gt;&gt;<i> buffered
</I>&gt;&gt;<i> &gt; ranges?
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No, this wouldn't happen, although it might be possible for currentTime to
</I>&gt;&gt;<i> be outside the buffered ranges for other reasons.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> How about HTMLImageElement.complete, which the spec explicitly says can
</I>&gt;&gt;<i> &gt; change during script execution?
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Interesting, I didn't know about that.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In any case, it sounds like either HTMLMediaElement is underspecified or
</I>&gt;&gt;<i> one
</I>&gt;&gt;<i> &gt; of us has interpreted in incorrectly, some interop on this point would
</I>&gt;&gt;<i> be
</I>&gt;&gt;<i> &gt; nice.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Maybe. If the spec is clarified to allow races when accessing media
</I>&gt;&gt;<i> element
</I>&gt;&gt;<i> state, I guess it won't be the end of the world, although I predict
</I>&gt;&gt;<i> interop
</I>&gt;&gt;<i> difficulties. But that's always an easy prediction! :-)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The biggest use case is clicking a seek bar and ending up somewhere close
</I>&gt;&gt;<i> &gt; enough, but yes, being able to do fast relative seeking is a nice bonus.
</I>&gt;&gt;<i> &gt; Maybe we should do what many media frameworks do and use a &quot;reference&quot;
</I>&gt;&gt;<i> &gt; parameter, defining what the seek is relative to. Usually you can seek
</I>&gt;&gt;<i> &gt; relative to the beginning, end and current position, but perhaps we
</I>&gt;&gt;<i> could
</I>&gt;&gt;<i> &gt; reduce that to just &quot;absolute&quot; and &quot;relative&quot;. That's a bit less magic
</I>&gt;&gt;<i> than
</I>&gt;&gt;<i> &gt; inspecting currentTime when the method is called.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; So far:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; seek(t, ref, how);
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; ref is &quot;absolute&quot; (default) or &quot;relative&quot;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; how is &quot;accurate&quot; (default) or &quot;fast&quot;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; (or numeric enums, if that's what DOM interfaces usually have)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That works.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Rob
</I>&gt;&gt;<i> --
</I>&gt;&gt;<i> &quot;Now the Bereans were of more noble character than the Thessalonians, for
</I>&gt;&gt;<i> they received the message with great eagerness and examined the Scriptures
</I>&gt;&gt;<i> every day to see if what Paul said was true.&quot; [Acts 17:11]
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I></PRE>
































































































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030514.html">[whatwg] HTML5 video: frame accuracy / SMPTE
</A></li>
	<LI>Next message: <A HREF="030529.html">[whatwg] Allowing size and maxlength attributes for all new input	types would provide better fallbacks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30515">[ date ]</a>
              <a href="thread.html#30515">[ thread ]</a>
              <a href="subject.html#30515">[ subject ]</a>
              <a href="author.html#30515">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
