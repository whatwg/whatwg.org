<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Google Feedback on the HTML5 media a11y specifications
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Google%20Feedback%20on%20the%20HTML5%20media%20a11y%20specifications&In-Reply-To=%3CAANLkTimxiqmwGD9ZnQkd-%3DtRaeGXHNsA5f%3DVKn-557tY%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="072592.html">
   <LINK REL="Next"  HREF="072602.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Google Feedback on the HTML5 media a11y specifications</H1>
<!--htdig_noindex-->
    <B>Silvia Pfeiffer</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Google%20Feedback%20on%20the%20HTML5%20media%20a11y%20specifications&In-Reply-To=%3CAANLkTimxiqmwGD9ZnQkd-%3DtRaeGXHNsA5f%3DVKn-557tY%40mail.gmail.com%3E"
       TITLE="[whatwg] Google Feedback on the HTML5 media a11y specifications">silviapfeiffer1 at gmail.com
       </A><BR>
    <I>Tue Feb  8 18:57:37 PST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="072592.html">[whatwg] clarification for data-uris in window.open and SOP
</A></li>
        <LI>Next message: <A HREF="072602.html">[whatwg] Google Feedback on the HTML5 media a11y specifications
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30326">[ date ]</a>
              <a href="thread.html#30326">[ thread ]</a>
              <a href="subject.html#30326">[ subject ]</a>
              <a href="author.html#30326">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Hi Philip, all,


On Sun, Jan 23, 2011 at 1:23 AM, Philip J&#228;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt; wrote:
&gt;<i> On Fri, 14 Jan 2011 10:01:38 +0100, Silvia Pfeiffer
</I>&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">silviapfeiffer1 at gmail.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> There are two sections - the first one concerns the WebVTT format and
</I>&gt;&gt;<i> the second one the &lt;track&gt; specification.
</I>&gt;<i>
</I>&gt;<i> Thanks for compiling all of this feedback, Silvia! As usual, my inline
</I>&gt;<i> replies are sometimes terse, not to be mistaken for impatience or disrespect
</I>&gt;<i> :)
</I>
We all just want to get this right! :-)
(and: sorry for the delayed reply - I am keen to keep discussing this)



&gt;&gt;<i> A. Feedback on the WebVTT format
</I>&gt;<i>
</I>&gt;&gt;<i> 1. Introduce file-wide metadata
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> WebVTT requires a structure to add header-style metadata. We are here
</I>&gt;&gt;<i> talking about lists of name-value pairs as typically in use for header
</I>&gt;&gt;<i> information. The metadata can be optional, but we need a defined means
</I>&gt;&gt;<i> of adding them.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Required attributes in WebVTT files should be the main language in use
</I>&gt;&gt;<i> and the kind of data found in the WebVTT file - information that is
</I>&gt;&gt;<i> currently provided in the &lt;track&gt; element by the @srclang and @kind
</I>&gt;&gt;<i> attributes. These are necessary to allow the files to be interpreted
</I>&gt;&gt;<i> correctly by non-browser applications, for transcoding or to determine
</I>&gt;&gt;<i> if a file was created as a caption file or something else, in
</I>&gt;&gt;<i> particular the @kind=metadata. @srclang also sets the base
</I>&gt;&gt;<i> directionality for BiDi calculations.
</I>&gt;<i>
</I>&gt;<i> Are there non-browsers that use the language for font-selection or bidi? Is
</I>&gt;<i> auto-detection not likely to give a better user experience? Are there any
</I>&gt;<i> other use cases for knowing the language of the captions *after* they've
</I>&gt;<i> been opened?
</I>

I can't see a different way to let non-browser applications know what
font to choose, even how to provide the user with a menu of available
caption tracks for a video, or to set the base directionality for
BiDi. Also, language auto-detection is a huge burden to put onto
non-browser applications. Having a readable language tag at the
beginning of the file is useful to quickly figure it all out.

The language set in &lt;track&gt; would certainly overrule what is in the
file. Also, the last language attribute in the header would probably
win.

I guess it would also be ok to have language and kind optional -
different applications may then default to interpreting WebVTT files
differently, such as by default English and Captions - or English and
Descriptions, but that's probably acceptable from context.


&gt;<i> Why do non-browser players need to know the kind? All kinds are processed in
</I>&gt;<i> the same way except metadata, and there's no reason to use metadata tracks
</I>&gt;<i> with external players.
</I>
Maybe I have a different view of what applications will make use of
WebVTT files than most. My thinking is that there will also be uses
for metadata tracks in external applications. Aside from this, there
will be authoring applications and players, yes, but there will also
be automated processing tools. So, to know what type of content is
inside a file without having to look at more than the file's headers
is really important.


&gt;&gt;<i> Further metadata fields that are typically used by authors to keep
</I>&gt;&gt;<i> specific authoring information or usage hints are necessary, too. As
</I>&gt;&gt;<i> examples of current use see the format of MPlayer mpsub&#8217;s header
</I>&gt;&gt;<i> metadata [2], EBU STL&#8217;s General Subtitle Information block [3], and
</I>&gt;&gt;<i> even CEA-608&#8217;s Extended Data Service with its StartDate, Station,
</I>&gt;&gt;<i> Program, Category and TVRating information [4]. Rather than specifying
</I>&gt;&gt;<i> a specific subset of potential fields we recommend to just have the
</I>&gt;&gt;<i> means to provide name-value pairs and leave it to the negotiation
</I>&gt;&gt;<i> between the author and the publisher which fields they expect of each
</I>&gt;&gt;<i> other.
</I>&gt;<i>
</I>&gt;<i> This approach has worked very well with Vorbis Comments, probably mostly
</I>&gt;<i> because all interesting fields have been pre-defined in
</I>&gt;<i> <A HREF="http://www.xiph.org/vorbis/doc/v-comment.html">http://www.xiph.org/vorbis/doc/v-comment.html</A>
</I>&gt;<i>
</I>&gt;<i> For a web format though, wouldn't some kind of wiki registry be good to
</I>&gt;<i> avoid total mayhem, especially if there are some predefined fields? (Not
</I>&gt;<i> having file-wide metadata would also avoid such mayhem.)
</I>
It might be good to define a base set - the Vorbis Comments one or the
ID3 ones could be appropriate. Even the old Dublin Core set (the first
ones, not the current chaos) could be good. I could also analyse the
sets used in current typical caption formats and propose a superset of
those.

While I think you're right with suggesting a predefined set of fields,
I am mostly keen right now to agree on the general format of the
fields and how we need to parse them rather than what they actually
are.

So, I would suggest we allow lines of &quot;name=value&quot; under the WEBVTT
magic string. A blank line defines the end of the header section and
the beginning of the cues. Would be simple enough to parse, right?


&gt;&gt;<i> 2. Introduce file-wide cue settings
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> At the moment if authors want to change the default display of cues,
</I>&gt;&gt;<i> they can only set them per cue (with the D:, S:, L:, A: and T:. cue
</I>&gt;&gt;<i> settings) or have to use an external CSS file through a HTML page with
</I>&gt;&gt;<i> the ::cue pseudo-element. In particular when considering that all
</I>&gt;&gt;<i> Asian language files would require a &#8220;D:vertical&#8221; marker, it becomes
</I>&gt;&gt;<i> obvious that this replication of information in every cue is
</I>&gt;&gt;<i> inefficient and a waste of bandwidth, storage, and application speed.
</I>&gt;&gt;<i> A cue setting default section should be introduced into a file
</I>&gt;&gt;<i> header/setup area of WebVTT which will avoid such replication.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> An example document with cue setting defaults in the header could look
</I>&gt;&gt;<i> as follows:
</I>&gt;&gt;<i> ==
</I>&gt;&gt;<i> WEBVTT
</I>&gt;&gt;<i> Language=zh
</I>&gt;&gt;<i> Kind=Caption
</I>&gt;&gt;<i> CueSettings= A:end D:vertical
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:15.000 --&gt; 00:00:17.950
</I>&gt;&gt;<i> &#22312;&#24038;&#36793;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040;...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:18.160 --&gt; 00:00:20.080
</I>&gt;&gt;<i> &#22312;&#21491;&#36793;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040;...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:20.110 --&gt; 00:00:21.960
</I>&gt;&gt;<i> ...&#25429;&#34631;&#33609;&#26800;.
</I>&gt;&gt;<i> ==
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Note that you might consider that the solution to this problem is to
</I>&gt;&gt;<i> use external CSS to specify a change to all cues. However, this is not
</I>&gt;&gt;<i> acceptable for non-browser applications and therefore not an
</I>&gt;&gt;<i> acceptable solution to this problem.
</I>&gt;<i>
</I>&gt;<i> Indeed, repeating settings on each cue would be annoying. However, file-wide
</I>&gt;<i> settings seems like it would easily be too broad, and you'd have to
</I>&gt;<i> explicitly reverse the effect on the cues where you don't want it to apply.
</I>&gt;<i> Maybe classes of cue settings or some kind of macros would work better.
</I>
Hmm, maybe we can have file-wide cue settings and classes that can be
explicitly used to override the file-wide ones. I am not overly fussed
how we solve it, but I do want to avoid the repetition.


&gt;<i> Nitpick: Modern Chinese, including captions, is written left-to-right,
</I>&gt;<i> top-to-bottom, just like English.
</I>
Gah, I should have used the Japanese examples that I had! I speak
neither so it's all unreadable to me anyway.


&gt;&gt;<i> 3. Cue settings requirements
</I>&gt;<i>
</I>&gt;&gt;<i> * naming: The usage of single letter abbreviations for cue settings
</I>&gt;&gt;<i> has created quite a discussion here at Google. We all agree that
</I>&gt;&gt;<i> file-wide cue settings are required and that this will reduce the need
</I>&gt;&gt;<i> for cue-specific cue settings. We can thus afford a bit more
</I>&gt;&gt;<i> readability in the cue settings. We therefore believe that it would be
</I>&gt;&gt;<i> better if the cue settings were short names rather than single letter
</I>&gt;&gt;<i> codes. This would be more like CSS, too, and easier to learn and get
</I>&gt;&gt;<i> right. In the interface description, the 5 dimensions have proper
</I>&gt;&gt;<i> names which could be re-used (&#8220;direction&#8221;, &#8220;linePosition&#8221;,
</I>&gt;&gt;<i> &#8220;textPosition&#8221;, &#8220;size&#8221; and &#8220;align&quot;). We therefore recommend replacing
</I>&gt;&gt;<i> the single-letter cue commands with these longer names.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> An example document with more verbose cue settings could look as follows:
</I>&gt;&gt;<i> ==
</I>&gt;&gt;<i> WEBVTT
</I>&gt;&gt;<i> Language=zh
</I>&gt;&gt;<i> Kind=Caption
</I>&gt;&gt;<i> CueSettings= align:end direction:vertical
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:15.000 --&gt; 00:00:17.950 linePosition:80%
</I>&gt;&gt;<i> &#22312;&#24038;&#36793;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040;...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:18.160 --&gt; 00:00:20.080
</I>&gt;&gt;<i> &#22312;&#21491;&#36793;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040;...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:20.110 --&gt; 00:00:21.960 size:70%
</I>&gt;&gt;<i> ...&#25429;&#34631;&#33609;&#26800;.
</I>&gt;&gt;<i> ==
</I>&gt;<i>
</I>&gt;<i> I agree, every time I see the single-letter settings I have to go look at
</I>&gt;<i> the spec to figure out what they mean. I'd be happy to have more explicit
</I>&gt;<i> names. I'd be even happier if they match CSS terminology where possible.
</I>

I've been considering whether it should match CSS terminology where
possible. Since it's not possible for all of the settings and for some
it makes no sense to use a different term to the one CSS uses, we will
probably end up with some overlap. I'd not worry about it and just
ignore this fact, but not make it a design principle.



&gt;&gt;<i> 4. Cue formatting requirements
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In analysing the available cue formatting functionality, we have found
</I>&gt;&gt;<i> that some features are missing. Most of these features can be added
</I>&gt;&gt;<i> through using CSS on cues that have received a &lt;b&gt;, &lt;i&gt;, &lt;c&gt; or &lt;v&gt;
</I>&gt;&gt;<i> marker. The following features are core to traditional TV and exist in
</I>&gt;&gt;<i> EBU STL and CEA-608/708 captions. Support of these will be a core
</I>&gt;&gt;<i> requirement for browsers as well as non-browser applications and it
</I>&gt;&gt;<i> makes sense to add these to WebVTT rather than relying on external CSS
</I>&gt;&gt;<i> which cannot be used for non-browser captions:
</I>&gt;<i>
</I>&gt;<i> The unstated requirement here seems to be that WebVTT needs to work as an
</I>&gt;<i> interchange format for various TV captioning formats even in user agents
</I>&gt;<i> without any support for CSS (or JavaScript). I'm trying to not make a straw
</I>&gt;<i> man argument, but if want an interchange format, we should pick TTML, which
</I>&gt;<i> is explicitly designed to be just that and doesn't depend on CSS.
</I>&gt;<i>
</I>&gt;<i> Is it not enough that a lossy conversion can be made from various formats
</I>&gt;<i> into WebVTT+CSS(+JavaScript)? If not, the &quot;Web&quot; in &quot;WebVTT&quot; is highly
</I>&gt;<i> misleading...
</I>

We're trying to avoid the need for multiple transcodings and are
trying to achieve something like the following pipeline:
broadcast captions -&gt; transcode to WebVTT -&gt; show in browser -&gt;
transcode to broadcast devices -&gt; show

If we have to plug TTML into this pipeline, too, it will be much
slower and we would need to additionally define a mapping from TTML to
WebVTT and back.

I'm sure with SMPTE-TT around we will end up seeing things like
broadcast-&gt;TTML-&gt;WebVTT-&gt;browser, but even then we don't want WebVTT
to be a lossy format.


&gt;&gt;<i> * textcolor: In particular on European TV it is common to distinguish
</I>&gt;&gt;<i> between speakers by giving their speech different colors. The
</I>&gt;&gt;<i> following colors are supported by EBU STL, CEA-608 and CEA-708 and
</I>&gt;&gt;<i> should be supported in WebVTT without the use of external CSS: black,
</I>&gt;&gt;<i> red, green, yellow, blue, magenta, cyan, and white. As default we
</I>&gt;&gt;<i> recommend white on a grey transparent background.
</I>&gt;<i>
</I>&gt;<i> What's wrong with &lt;v Speaker&gt;? If a completely automatic conversion is
</I>&gt;<i> needed, why not &lt;c.yellow&gt;...&lt;/c&gt;? Both methods have the distinct advantage
</I>&gt;<i> of making it easy to change or disable the colors with only CSS changes.
</I>
I think indeed &lt;c.yellow&gt;...&lt;/c&gt; will satisfy this requirement.


&gt;&gt;<i> * underline: EBU STL, CEA-608 and CEA-708 support underlining of
</I>&gt;&gt;<i> characters. The underline character is also particularly important for
</I>&gt;&gt;<i> some Asian languages. Please make it possible to provide text
</I>&gt;&gt;<i> underlines without the use of CSS in WebVTT.
</I>&gt;<i>
</I>&gt;<i> Which Asian languages? If it's just the Chinese
</I>&gt;<i> &lt;<A HREF="http://en.wikipedia.org/wiki/Proper_name_mark">http://en.wikipedia.org/wiki/Proper_name_mark</A>&gt;, then I don't think that
</I>&gt;<i> needs &lt;u&gt; or similar. In my experience, use of the Chinese proper name mark
</I>&gt;<i> is in fact extremely rare in Chinese captions, at least in movies and TV
</I>&gt;<i> series from the mainland and Taiwan. It would be best to use e.g.
</I>&gt;<i> &#25105;&#20358;&#33258;&lt;c.pnm&gt;&#20013;&#22283;&lt;/c&gt; to make it easy to change the style between
</I>&gt;<i> single/double/wavy/no underline.
</I>
OK. So if we need underlined text, it will need to be
&lt;c.underline&gt;..&lt;/c&gt; and CSS underline? I guess in a Web context
underline text is usually a hyperlink so it makes sense to discourage
&lt;u&gt; for the Web. But is that also an argument for
captions/subtitles/descriptions? What is the argument against using
&lt;u&gt; in captions?


&gt;&gt;<i> * blink: As much as we would like to discourage blinking subtitles,
</I>&gt;&gt;<i> they are actually a core requirement for EBU STL and CEA-608/708
</I>&gt;&gt;<i> captions and in use in particular for emergency messages and similar
</I>&gt;&gt;<i> highly important information. Blinking can be considered optional for
</I>&gt;&gt;<i> implementation, but we should allow for it in the standard.
</I>&gt;<i>
</I>&gt;<i> 00:00.000 --&gt; 00:00.500
</I>&gt;<i> blinking
</I>&gt;<i>
</I>&gt;<i> 00:01.000 --&gt; 00:02.500
</I>&gt;<i> blinking
</I>&gt;<i>
</I>&gt;<i> 00:02.000 --&gt; 00:02.500
</I>&gt;<i> blinking
</I>&gt;<i>
</I>&gt;<i> Is that enough? In the context of the web there are much better ways to
</I>&gt;<i> convey very import information than through blinking captions. Event alert()
</I>&gt;<i> would be better.
</I>
If we were talking only about Web captions, I would agree. I laughed
about your solution and personally kinda like it. But from a
captioning/subtitling point of view it's probably hard to convert that
back to blinking text, since we've just lost the semantic by ripping
it into multiple cues (and every program would use different ways of
doing this). But I do think that &lt;c.alert&gt;...&lt;/c&gt; or &lt;c.blink&gt;
...&lt;/c&gt;could work as a solution. I hadn't really grasped the power of
the class span element yet.


&gt;&gt;<i> * font face: CEA-708 provides a choice of eight font tags: undefined,
</I>&gt;&gt;<i> monospaced serif, proportional serif, monospaced sans serif,
</I>&gt;&gt;<i> proportional sans serif, casual, cursive, small capital. These fonts
</I>&gt;&gt;<i> should be available for WebVTT as well. Is this the case?
</I>&gt;<i>
</I>&gt;<i> Does the choice of font ever carry any semantic meaning? Isn't it a good
</I>&gt;<i> thing that captions can't specify their own fonts, so that it's easy to pick
</I>&gt;<i> a style that's suitable for the embedding site?
</I>
The choice of fonts for captions has traditionally been a key to
providing quality captions. Some fonts are more readable than others.
So, captioning handbooks have traditionally prescribed the best fonts
to use for captioning to explicitly point out those that are easily
readable. After having checked with the handbooks that are available
to me it seems sans serif and proportional are the preferred ones, so
I do wonder why CEA-708 provides this choice of fonts. You are right
though that it makes more sense to provide semantic meaning and then
style through css. At minimum &lt;c.cursive&gt; etc would be possible with
an appropriate choice of font through styling, again using the class
span element to solve this.

Coming at it from a devices background, it's actually all a matter of
pre-defined choices. They're not going to package a large number of
fonts with every device, so it's good if all devices support a basic
subset that can be relied on to exist cross-device. We're increasingly
going to have to consider such requirements, too, because we will see
Web browsers run on devices with restricted capabilities, not just the
browser on a computer where you can install missing fonts.

I guess what we are discovering is that we can define the general
format of WebVTT for the Web, but that there may be an additional need
to provide minimum implementation needs (a &quot;profile&quot; if you want - as
much as I hate this word). This seems to apply to the file-wide
metadata fields, to some specific standard classes (underline, blink),
to the set of colors supported and to the set of fonts supported. I
don't think these are issues that browsers need to worry about, and
therefore are probably beyond what we need to specify here for WebVTT.
But there probably needs to be a group to do this eventually.


&gt;&gt;<i> [On a side note, we wonder if it would make sense to introduce an
</I>&gt;&gt;<i> @kind=&#8221;annotation&#8221; type of TimedText track, which can then allow full
</I>&gt;&gt;<i> innerHTML markup be rendered on top of the video viewport. This would
</I>&gt;&gt;<i> probably need to be matched with full CSS support, too. It would allow
</I>&gt;&gt;<i> people to introduce unconventional caption display such as captions in
</I>&gt;&gt;<i> speech bubbles that can track the characters as they move or know
</I>&gt;&gt;<i> about what important objects are on the screen, so never overlap them.
</I>&gt;&gt;<i> Note that script in innerHTML needs to be dealt with carefully to
</I>&gt;&gt;<i> avoid XSS attacks. @kind=&#8221;annotation&#8221; is not required for ordinary
</I>&gt;&gt;<i> captions, so we have not investigated this need in full detail.]
</I>&gt;<i>
</I>&gt;<i> Won't Implement ;) For reasons already discussed at length, I think HTML in
</I>&gt;<i> captions is a bad idea. Having *both* WebVTT cue text parsing and innerHTML
</I>&gt;<i> parsing would be even more complicated, though.
</I>
It's not a problem. I definitely think we need some experimentation
with @kind=&quot;metadata&quot; type applications before we define further @kind
values anyway. I know there are people that want to use it for
annotations and I know there are people that want hyperlinks. So,
let's see how this pans out before doing anything further here. I'd
definitely want to see captions, subtitles and descriptions supported
natively in browsers first - anything else can wait.


&gt;&gt;<i> 5. Markup changes
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We have a couple of recommendations for changes mostly for aesthetic
</I>&gt;&gt;<i> and efficiency reasons. We would like to point out that Google is very
</I>&gt;&gt;<i> concerned with the dense specification of data and every surplus
</I>&gt;&gt;<i> character, in particular if it is repeated a lot and doesn&#8217;t fulfill a
</I>&gt;&gt;<i> need, should be removed to reduce the load created on worldwide
</I>&gt;&gt;<i> networking and storage infrastructures and help render Web pages
</I>&gt;&gt;<i> faster.
</I>&gt;<i>
</I>&gt;<i> Nipick: Is network load really an issue here? Compared to the video files
</I>&gt;<i> they accompany, caption files are tiny, even more so with gzip/deflate.
</I>
Even text can amount to a substantial amount of data. Compressed http
delivery will help. Keeping the caption/subtitle tracks in separate
files and only delivering those that a user really wants helps, too.
But even then a caption file for a 2 hour video can be a fairly big
file and we want them downloaded to the browser as quickly as
possible, such that the video player is not held back from playback of
the video through still downloading the captions. So, serving billions
of caption files at as little latency as possible are both good
arguments for keeping the format dense.


&gt;&gt;<i> * Time markers: WebVTT time stamps follow no existing standard for
</I>&gt;&gt;<i> time markers. Has the use of NPT as introduced by RTSP[5] for time
</I>&gt;&gt;<i> markers been considered (in particular npt-hhmmss)?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [5] <A HREF="http://www.ietf.org/rfc/rfc2326.txt">http://www.ietf.org/rfc/rfc2326.txt</A>
</I>&gt;<i>
</I>&gt;<i> Unfortunately, the hour component is not optional in NPT. Also, the decimal
</I>&gt;<i> part of seconds is of arbitrary precision, which doesn't seem necessary.
</I>
OK.


&gt;&gt;<i> * Suggest dropping &#8220;--&gt;&#8221;: In the context of HTML, &#8220;--&gt;&#8221; is an end
</I>&gt;&gt;<i> comment marker. It may confuse Web developers and parsers if such a
</I>&gt;&gt;<i> sign is used as a separator. For example, some translation tools
</I>&gt;&gt;<i> expect HTML or XML-based interchange formats and interpret the &#8220;&gt;&#8221; as
</I>&gt;&gt;<i> part of a tag. Also, common caption convention often uses &#8220;&gt;&#8221; to
</I>&gt;&gt;<i> represent speaker identification. Thus it is more difficult to write a
</I>&gt;&gt;<i> filter which correctly escapes &#8220;--&gt;&#8221; but retains &#8220;&gt;&#8221; for speaker ID.
</I>&gt;<i>
</I>&gt;<i> Trying to use an HTML or XML parser to make any sense of WebVTT is going to
</I>&gt;<i> fail horrendously in any case, so if anything I think it's good that they
</I>&gt;<i> fail early. Also, a translation tool that has no concept of WebVTT is going
</I>&gt;<i> to make a mess of various magic strings used in the file format too.
</I>&gt;<i>
</I>&gt;&gt;<i> Since the &#8220;--&gt;&#8221; characters serve no obvious purpose, it should be
</I>&gt;&gt;<i> possible to safely replace them by a blank that separates start and
</I>&gt;&gt;<i> end time, thus making the format denser and removing annoying parsing
</I>&gt;&gt;<i> issues. (Or alternatively use a the npt-range spec of RTSP for time
</I>&gt;&gt;<i> ranges, which uses &#8220;-&#8221; as a separator.).
</I>&gt;<i>
</I>&gt;<i> No strong opinion, but I think a non-blank separator is more aesthetically
</I>&gt;<i> pleasing.
</I>
Maybe just a dash &quot;-&quot; then, which can also remove the extra blanks?


&gt;&gt;<i> * Duration specification: WebVTT time stamps are always absolute time
</I>&gt;&gt;<i> stamps calculated in relation to the base time of synchronisation with
</I>&gt;&gt;<i> the media resource. While this is simple to deal with for machines, it
</I>&gt;&gt;<i> is much easier for hand-created captions to deal with relative time
</I>&gt;&gt;<i> stamps for cue end times and for the timestamp markers within cues.
</I>&gt;&gt;<i> Cue start times should continue to stay absolute time stamps.
</I>&gt;&gt;<i> Timestamp markers within cues should be relative to the cue start
</I>&gt;&gt;<i> time. Cue end times should be possible to be specified either as
</I>&gt;&gt;<i> absolute or relative timestamps. The relative time stamps could be
</I>&gt;&gt;<i> specified through a prefix of &#8220;+&#8221; in front of a &#8220;ss.mmm&#8221; second and
</I>&gt;&gt;<i> millisecond specification. These are not only simpler to read and
</I>&gt;&gt;<i> author, but are also more compact and therefore create smaller files.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> An example document with relative timestamps is:
</I>&gt;&gt;<i> ==
</I>&gt;&gt;<i> WEBVTT
</I>&gt;&gt;<i> Language=en
</I>&gt;&gt;<i> Kind=Subtitle
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:15.000 &#160; +2.950
</I>&gt;&gt;<i> At the left we can see...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:18.160 &#160; &#160;+1.920
</I>&gt;&gt;<i> At the right we can see the...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 00:00:20.110 &#160; +1.850
</I>&gt;&gt;<i> ...the &lt;+0.400&gt;head-&lt;+0.800&gt;snarlers
</I>&gt;&gt;<i> ==
</I>&gt;<i>
</I>&gt;<i> I rather like it, although it might be confusing if &quot;-&quot; means &quot;to absolute
</I>&gt;<i> time&quot; and &quot;+&quot; means &quot;to relative time&quot;. That the intra-cue timings are
</I>&gt;<i> relative but the timing lines are absolute has bugged me a bit, so if the
</I>&gt;<i> distinction was more obvious just from the syntax, that'd be great!
</I>
With &quot;-&quot; you are referring to replacing &quot;--&gt;&quot; with &quot;-&quot; to arrive at things like:
15.000-17.950
At the left we can see...

as compared to:
15.000+2.950
At the left we can see...

I actually think they read fairly given that people are used to the
double meaning of &quot;-&quot;: to mean both &quot;from ... to&quot; and &quot;minus&quot;.
But we could use a different character for &quot;absolute time&quot; if you
prefer, e.g. &quot;/&quot;.
15.000/17.950
At the left we can see...

I find this fairly readable, too.


&gt;&gt;<i> 6. Format identifier
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We are happy to see the introduction of &#160;the magic file identifier for
</I>&gt;&gt;<i> WebVTT which will make it easier to identify the file format. We do
</I>&gt;&gt;<i> not believe the &#8220;FILE&#8221; part of the string is necessary.
</I>&gt;<i>
</I>&gt;<i> I agree, mostly because it's ugly. While we're bikeshedding, &quot;WebSRT&quot; is
</I>&gt;<i> prettier than &quot;WEBSRT&quot;.
</I>
&quot;WebVTT&quot; rather than &quot;WebSRT&quot;? ;-)


&gt;&gt;<i> However, we
</I>&gt;&gt;<i> recommend to also introduce a format version number that the file
</I>&gt;&gt;<i> adheres to, e.g. &#8220;WEBVTT 0.7&#8221;. This helps to make non-browser systems
</I>&gt;&gt;<i> that parse such files become aware of format changes. It can also help
</I>&gt;&gt;<i> identify proprietary standard metadata sets as used by a specific
</I>&gt;&gt;<i> company, such as &#8220;WEBVTT 0.7 ABC-meta1&#8221; which could signify that the
</I>&gt;&gt;<i> file adheres to WEBVTT 0.7 format specification with the ABC-meta1
</I>&gt;&gt;<i> metadata schema. Parsers are then made aware of what fields to expect
</I>&gt;&gt;<i> and can alert human operators of unexpected fields or markup.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Browsers can safely ignore such a marker and instead do a best effort
</I>&gt;&gt;<i> on parsing based on what they understand.
</I>&gt;<i>
</I>&gt;<i> I strongly disagree, WebVTT shouldn't have a version indicator for the same
</I>&gt;<i> reasons that HTML, CSS and JavaScript don't. Making proprietary extensions
</I>&gt;<i> easier to maintain should be an anti-goal.
</I>
In a contract between a caption provider and a caption consumer (I am
talking about companies here), the caption consumer will want to tell
the caption provider what kind of features they expect the caption
files to contain and features they want avoided. This links back to
the earlier identified need for &quot;profiles&quot;. This is actually probably
something outside the scope of this group, but I am sure there is a
need for such a feature, in particular if we want to keep the
development of the WebVTT specification open for future extensions.

I guess you could argue that such a profile is metadata on the file
and indeed we could use a name-value metadata field like &quot;profile=0.7&quot;
to communicate this. I am not fussed if this is the way it will have
to go. I can understand that browsers will ignore this information
anyway. It's like a promise of the file towards any consuming
application that only features that satisfy that profile (or version)
are used in the file, but it indeed has no bearing on browsers.



&gt;&gt;<i> 7. Comments
</I>&gt;<i>
</I>&gt;&gt;<i> we recommend the introduction of comments.
</I>&gt;<i>
</I>&gt;<i> I agree and think it needs to happen before WebVTT starts to get implemented
</I>&gt;<i> and used on the web. In other words: now.
</I>
Agreed. I'm happy for the previously suggested &quot;//&quot; at the line start
to be comments, or, for that matter, &quot;#&quot; or &quot;;&quot; or any other special
character. I would prefer not to use &quot;/*&quot; since it implies a &quot;*/&quot; is
required to end the comment. Similarly we should avoid &quot;&lt;!--&quot; and
&quot;--&gt;&quot; or anything else that requires a special comment end mark and
more than one or two characters.



&gt;&gt;<i> 8. Line wrapping
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> CEA-708 captions support automatic line wrapping in a more
</I>&gt;&gt;<i> sophisticated way than WebVTT -- see
</I>&gt;&gt;<i> <A HREF="http://en.wikipedia.org/wiki/CEA-708#Word_wrap.">http://en.wikipedia.org/wiki/CEA-708#Word_wrap.</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In our experience with YouTube we have found that in certain
</I>&gt;&gt;<i> situations this type of automatic line wrapping is very useful.
</I>&gt;&gt;<i> Captions that were authored for display in a full-screen video may
</I>&gt;&gt;<i> contain too many words to be displayed fully within the actual video
</I>&gt;&gt;<i> presentation (note that mobile / desktop / internet TV devices may
</I>&gt;&gt;<i> each have a different amount of space available, and embedded videos
</I>&gt;&gt;<i> may be of arbitrary sizes). Furthermore, user-selected fonts or font
</I>&gt;&gt;<i> sizes may be larger than expected, especially for viewers who need
</I>&gt;&gt;<i> larger print.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> WebVTT as currently specified wraps text at the edge of their
</I>&gt;&gt;<i> containing blocks, regardless of the value of the 'white-space'
</I>&gt;&gt;<i> property, even if doing so requires splitting a word where there is no
</I>&gt;&gt;<i> line breaking opportunity. This will tend to create poor quality
</I>&gt;&gt;<i> captions. &#160;For languages where it makes sense, line wrapping should
</I>&gt;&gt;<i> only be possible at carriage return, space, or hyphen characters, but
</I>&gt;&gt;<i> not on &nbsp; characters. &#160;(Note that CEA-708 also contains
</I>&gt;&gt;<i> non-breaking space and non-breaking transparent space characters to
</I>&gt;&gt;<i> help control wrapping.)However, this algorithm will not necessarily
</I>&gt;&gt;<i> work for all languages.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We therefore suggest that a better solution for line wrapping would be
</I>&gt;&gt;<i> to use the existing line wrapping algorithms of browsers, which are
</I>&gt;&gt;<i> presumably already language-sensitive.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [Note: the YouTube line wrapping algorithm goes even further by
</I>&gt;&gt;<i> splitting single caption cues into multiple cues if there is too much
</I>&gt;&gt;<i> text to reasonably fit within the area. YouTube then adjusts the times
</I>&gt;&gt;<i> of these caption cues so they appear sequentially. &#160;Perhaps this could
</I>&gt;&gt;<i> be mentioned as another option for server-side tools.]
</I>&gt;<i>
</I>&gt;<i> Yeah, with SRT people are manually line-wrapping when authoring the captions
</I>&gt;<i> and often enough the end result is that you get something rendered:
</I>&gt;<i>
</I>&gt;<i> - Who could have guessed that not all fonts are the same
</I>&gt;<i> size?
</I>&gt;<i> - That's news to me, so I get four lines of text where I
</I>&gt;<i> wanted two!
</I>&gt;<i>
</I>&gt;<i> I'm inclined to say that we should normalize all whitespace during parsing
</I>&gt;<i> and not have explicit line breaks at all. If people really want two lines,
</I>&gt;<i> they should use two cues. In practice, I don't know how well that would
</I>&gt;<i> fare, though. What other solutions are there?
</I>
I don't think I would go that far. The concern has mostly been with
the line wrapping of lines that are too long and the possibility of
splitting words that way. The particular concern was with this
paragraph:

&quot;Text runs must be wrapped at the edge of their containing blocks,
regardless of the value of the 'white-space' property, even if doing
so requires splitting a word where there is no line breaking
opportunity.&quot;
see <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#timed-text-tracks-0">http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#timed-text-tracks-0</A>

So we want to avoid splitting mid-word and we suggest introducing the
ability to have non-breaking spaces.



&gt;&gt;<i> B. Feedback on the &lt;track&gt; element
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. Pop-on/paint-on/roll-up support
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Three different types of captions are common on TV: pop-on, roll-up
</I>&gt;&gt;<i> and paint-on. Captions according to CEA-608/708 need to support
</I>&gt;&gt;<i> captions of all three of these types. We believe they are already
</I>&gt;&gt;<i> supported in WebVTT, but see a need to re-confirm.
</I>&gt;<i>
</I>&gt;<i> The underlying use case here is live captioning, right? Just copying the
</I>&gt;<i> styling used on broadcast TV seems like it wouldn't be enough, you also need
</I>&gt;<i> the ability to erase typos, right? Are there any existing captioning formats
</I>&gt;<i> that handle live captioning well from which one could draw inspiration?
</I>
Yes, CEA-608/609 do these things and we have analysed them for these
features. They have control characters for backspace (only within
row), delete to end of row, erase displayed memory and erase
non-displayed memory. Further there is the concept of a cursor and
there are means to move the cursor to other screen locations.

I don't think we really need the concept of a cursor or display memory
and we don't need backspace and delete etc. because we have the
concept of mutableTimedTrack. So, a live captioning application can
always remove an existing TimedTrackCue and replace it with a new one
where the errors are fixed. At Google we came to the conclusion that
this was sufficient and therefore did not see a need to request
features for this type of application.

However, the three types of captions are actually not just used in
live captioning, but they are three different captioning styles that
could all be created by live or &quot;canned&quot; captions. We think they can
be supported, so this is good news.


&gt;&gt;<i> 2. Duplicate track
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The HTML spec specifies that it is not allowed to have two tracks that
</I>&gt;&gt;<i> provide the same kind of data for the same language (potentially
</I>&gt;&gt;<i> empty) and for the same label (potentially empty). However, we need
</I>&gt;&gt;<i> clarification on what happens if there is a duplicate track, ie: does
</I>&gt;&gt;<i> the most recent one win or the first one or will both be made
</I>&gt;&gt;<i> available in the UI and JavaScript? The spec only states that the
</I>&gt;&gt;<i> combination of {kind, type, label} must be unique. It doesn't say what
</I>&gt;&gt;<i> happens if they are not.
</I>&gt;<i>
</I>&gt;<i> In &lt;<A HREF="http://whatwg.org/html#sourcing-out-of-band-text-tracks">http://whatwg.org/html#sourcing-out-of-band-text-tracks</A>&gt; all track are
</I>&gt;<i> added to the list of text tracks, even duplicates.
</I>&gt;<i>
</I>&gt;<i> In other words, it's just a requirement for validators, not user agents.
</I>
OK, so a browser still has to deal with &quot;duplicate tracks&quot; as though
they were not duplicates?


&gt;&gt;<i> Further, the spec says nothing about duplicate labels altogether -
</I>&gt;&gt;<i> what is a browser supposed to do when two tracks have been marked with
</I>&gt;&gt;<i> the same label?
</I>&gt;<i>
</I>&gt;<i> We'd show the same text in the context menu and let the user be confused, I
</I>&gt;<i> guess. It's very easy for authors who care about not confusing their users
</I>&gt;<i> to fix, so I don't think browsers need to be clever here.
</I>
OK, fair enough. :-)


&gt;&gt;<i> 4. Addressing individual cues through CSS
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> As far as we understand, you can currently address all cues through
</I>&gt;&gt;<i> ::cue and you can address a cue part through ::cue-part(&lt;voice&gt; ||
</I>&gt;&gt;<i> &lt;part&gt; || &lt;position&gt; || &lt;future-compatibility&gt;). However, if we
</I>&gt;&gt;<i> understand correctly, it doesn&#8217;t seem to be possible to address an
</I>&gt;&gt;<i> individual cue through CSS, even though cues have individual
</I>&gt;&gt;<i> identifiers. This is either an oversight or a misunderstanding on our
</I>&gt;&gt;<i> parts. Can you please clarify how it is possible to address an
</I>&gt;&gt;<i> individual cue through CSS?
</I>&gt;<i>
</I>&gt;<i> Since I've been arguing against the id's in WebVTT, I'm curious about the
</I>&gt;<i> use case here. Isn't using a unique class good enough?
</I>
This links in with the discussion above on CSS styling and classes.
Rather than define classes of cue settings and reference them from the
cues, this allows them to be applied to individual cues in style
sheets. I thought the whole reason of cue identifiers was to have this
addressing functionality, so this would just close the loop.

For example:

Style sheet of the Web page:
&lt;style&gt;
video track#t1 ::cue(cue10) {
  text-decoration: blink;
}
&lt;/style&gt;

The Web page (extract):
&lt;video src=&quot;video.webm&quot; controls&gt;
  &lt;track id=&quot;t1&quot; label=&quot;captions&quot; kind=&quot;captions&quot; srclang=&quot;en-US&quot;
src=&quot;cap1.vtt&quot;/&gt;
&lt;/video&gt;

The caption file cap1.vtt:
WEBVTT
Language=en-US
Kind=Captions

cue1
0.000-5.000
blab blah

cue10
40.000-60.000
ALERT: Your basement is flooding - evacuate!


Cue10 is addressed through CSS and turned into a blinking text without
a need to change the markup at all.


&gt;&gt;<i> 5. Ability to move captions out of the way
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Our experience with automated caption creation and positioning on
</I>&gt;&gt;<i> YouTube indicates that it is almost impossible to always place the
</I>&gt;&gt;<i> captions out of the way of where a user may be interested to look at.
</I>&gt;&gt;<i> We therefore allow users to dynamically move the caption rendering
</I>&gt;&gt;<i> area to a different viewport position to reveal what is underneath. We
</I>&gt;&gt;<i> recommend such drag-and-drop functionality also be made available for
</I>&gt;&gt;<i> TimedTrack captions on the Web, especially when no specific
</I>&gt;&gt;<i> positioning information is provided.
</I>&gt;<i>
</I>&gt;<i> This would indeed be rather nice, but wouldn't it interfere with text
</I>&gt;<i> selection? Detaching the captions into a floating, draggable window via the
</I>&gt;<i> context menu would be a theoretically possible solution, but that's getting
</I>&gt;<i> rather far ahead of ourselves before we have basic captioning support.
</I>
On YouTube you can only move them within the video viewport. You
should try it - it's really awesome actually.

When you say &quot;interfere with text selection&quot; are you suggesting that
the text of captions/subtitles should be able to be cut and pasted? I
wonder what copyright holders think about that.


Cheers,
Silvia.
</PRE>



























































































































































































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="072592.html">[whatwg] clarification for data-uris in window.open and SOP
</A></li>
	<LI>Next message: <A HREF="072602.html">[whatwg] Google Feedback on the HTML5 media a11y specifications
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30326">[ date ]</a>
              <a href="thread.html#30326">[ thread ]</a>
              <a href="subject.html#30326">[ subject ]</a>
              <a href="author.html#30326">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
