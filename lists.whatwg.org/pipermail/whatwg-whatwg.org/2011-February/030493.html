<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Google Feedback on the HTML5 media a11y specifications
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Google%20Feedback%20on%20the%20HTML5%20media%20a11y%20specifications&In-Reply-To=%3CAANLkTinpR%3Dmg2ciWt%2BNjSqjWefEL5W4ieGMZo1rTa608%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030466.html">
   <LINK REL="Next"  HREF="030501.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Google Feedback on the HTML5 media a11y specifications</H1>
<!--htdig_noindex-->
    <B>Silvia Pfeiffer</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Google%20Feedback%20on%20the%20HTML5%20media%20a11y%20specifications&In-Reply-To=%3CAANLkTinpR%3Dmg2ciWt%2BNjSqjWefEL5W4ieGMZo1rTa608%40mail.gmail.com%3E"
       TITLE="[whatwg] Google Feedback on the HTML5 media a11y specifications">silviapfeiffer1 at gmail.com
       </A><BR>
    <I>Mon Feb 14 19:28:36 PST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="030466.html">[whatwg] Google Feedback on the HTML5 media a11y specifications
</A></li>
        <LI>Next message: <A HREF="030501.html">[whatwg] Google Feedback on the HTML5 media a11y specifications
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30493">[ date ]</a>
              <a href="thread.html#30493">[ thread ]</a>
              <a href="subject.html#30493">[ subject ]</a>
              <a href="author.html#30493">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>Hi Philip,

On Tue, Feb 15, 2011 at 3:27 AM, Philip J&#228;genstedt &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">philipj at opera.com</A>&gt; wrote:
&gt;<i> On Wed, 09 Feb 2011 03:57:37 +0100, Silvia Pfeiffer
</I>&gt;<i> &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">silviapfeiffer1 at gmail.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> A. Feedback on the WebVTT format
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> 1. Introduce file-wide metadata
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> WebVTT requires a structure to add header-style metadata. We are here
</I>&gt;&gt;&gt;&gt;<i> talking about lists of name-value pairs as typically in use for header
</I>&gt;&gt;&gt;&gt;<i> information. The metadata can be optional, but we need a defined means
</I>&gt;&gt;&gt;&gt;<i> of adding them.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Required attributes in WebVTT files should be the main language in use
</I>&gt;&gt;&gt;&gt;<i> and the kind of data found in the WebVTT file - information that is
</I>&gt;&gt;&gt;&gt;<i> currently provided in the &lt;track&gt; element by the @srclang and @kind
</I>&gt;&gt;&gt;&gt;<i> attributes. These are necessary to allow the files to be interpreted
</I>&gt;&gt;&gt;&gt;<i> correctly by non-browser applications, for transcoding or to determine
</I>&gt;&gt;&gt;&gt;<i> if a file was created as a caption file or something else, in
</I>&gt;&gt;&gt;&gt;<i> particular the @kind=metadata. @srclang also sets the base
</I>&gt;&gt;&gt;&gt;<i> directionality for BiDi calculations.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Are there non-browsers that use the language for font-selection or bidi?
</I>&gt;&gt;&gt;<i> Is
</I>&gt;&gt;&gt;<i> auto-detection not likely to give a better user experience? Are there any
</I>&gt;&gt;&gt;<i> other use cases for knowing the language of the captions *after* they've
</I>&gt;&gt;&gt;<i> been opened?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I can't see a different way to let non-browser applications know what
</I>&gt;&gt;<i> font to choose, even how to provide the user with a menu of available
</I>&gt;&gt;<i> caption tracks for a video, or to set the base directionality for
</I>&gt;&gt;<i> BiDi. Also, language auto-detection is a huge burden to put onto
</I>&gt;&gt;<i> non-browser applications. Having a readable language tag at the
</I>&gt;&gt;<i> beginning of the file is useful to quickly figure it all out.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The language set in &lt;track&gt; would certainly overrule what is in the
</I>&gt;&gt;<i> file. Also, the last language attribute in the header would probably
</I>&gt;&gt;<i> win.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I guess it would also be ok to have language and kind optional -
</I>&gt;&gt;<i> different applications may then default to interpreting WebVTT files
</I>&gt;&gt;<i> differently, such as by default English and Captions - or English and
</I>&gt;&gt;<i> Descriptions, but that's probably acceptable from context.
</I>&gt;<i>
</I>&gt;<i> Given that most existing subtitle formats don't have any language metadata,
</I>&gt;<i> I'm a bit skeptical. However, if implementors of non-browser players want to
</I>&gt;<i> implement WebVTT and ask for this I won't stand in the way (not that I could
</I>&gt;<i> if I wanted to). For simplicity, I'd prefer the language metadata from the
</I>&gt;<i> file to not have any effect on browsers though, even if no language is given
</I>&gt;<i> on &lt;track&gt;.
</I>
There is also the Content-Language response header of HTTP, which
could have an influence on the browser, too. I'm not sure about the
best way to deal with all this overlapping information, but I'm sure
it can be sorted out.


&gt;&gt;&gt;<i> Why do non-browser players need to know the kind? All kinds are processed
</I>&gt;&gt;&gt;<i> in
</I>&gt;&gt;&gt;<i> the same way except metadata, and there's no reason to use metadata
</I>&gt;&gt;&gt;<i> tracks
</I>&gt;&gt;&gt;<i> with external players.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Maybe I have a different view of what applications will make use of
</I>&gt;&gt;<i> WebVTT files than most. My thinking is that there will also be uses
</I>&gt;&gt;<i> for metadata tracks in external applications. Aside from this, there
</I>&gt;&gt;<i> will be authoring applications and players, yes, but there will also
</I>&gt;&gt;<i> be automated processing tools. So, to know what type of content is
</I>&gt;&gt;<i> inside a file without having to look at more than the file's headers
</I>&gt;&gt;<i> is really important.
</I>&gt;<i>
</I>&gt;<i> For both of these cases, putting some magic strings inside comments that are
</I>&gt;<i> ignored by browsers sounds like it would be sufficient. Name-value metadata
</I>&gt;<i> that is ignored by browsers would be fine as well.
</I>
I'm for the second option: name-value metadata that is ignored by the
browser. I think in fact the browser should in general ignore all
name-value metadata with the exception of file-wide cue settings.


&gt;&gt;&gt;&gt;<i> Further metadata fields that are typically used by authors to keep
</I>&gt;&gt;&gt;&gt;<i> specific authoring information or usage hints are necessary, too. As
</I>&gt;&gt;&gt;&gt;<i> examples of current use see the format of MPlayer mpsub&#8217;s header
</I>&gt;&gt;&gt;&gt;<i> metadata [2], EBU STL&#8217;s General Subtitle Information block [3], and
</I>&gt;&gt;&gt;&gt;<i> even CEA-608&#8217;s Extended Data Service with its StartDate, Station,
</I>&gt;&gt;&gt;&gt;<i> Program, Category and TVRating information [4]. Rather than specifying
</I>&gt;&gt;&gt;&gt;<i> a specific subset of potential fields we recommend to just have the
</I>&gt;&gt;&gt;&gt;<i> means to provide name-value pairs and leave it to the negotiation
</I>&gt;&gt;&gt;&gt;<i> between the author and the publisher which fields they expect of each
</I>&gt;&gt;&gt;&gt;<i> other.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> This approach has worked very well with Vorbis Comments, probably mostly
</I>&gt;&gt;&gt;<i> because all interesting fields have been pre-defined in
</I>&gt;&gt;&gt;<i> <A HREF="http://www.xiph.org/vorbis/doc/v-comment.html">http://www.xiph.org/vorbis/doc/v-comment.html</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> For a web format though, wouldn't some kind of wiki registry be good to
</I>&gt;&gt;&gt;<i> avoid total mayhem, especially if there are some predefined fields? (Not
</I>&gt;&gt;&gt;<i> having file-wide metadata would also avoid such mayhem.)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It might be good to define a base set - the Vorbis Comments one or the
</I>&gt;&gt;<i> ID3 ones could be appropriate. Even the old Dublin Core set (the first
</I>&gt;&gt;<i> ones, not the current chaos) could be good. I could also analyse the
</I>&gt;&gt;<i> sets used in current typical caption formats and propose a superset of
</I>&gt;&gt;<i> those.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> While I think you're right with suggesting a predefined set of fields,
</I>&gt;&gt;<i> I am mostly keen right now to agree on the general format of the
</I>&gt;&gt;<i> fields and how we need to parse them rather than what they actually
</I>&gt;&gt;<i> are.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So, I would suggest we allow lines of &quot;name=value&quot; under the WEBVTT
</I>&gt;&gt;<i> magic string. A blank line defines the end of the header section and
</I>&gt;&gt;<i> the beginning of the cues. Would be simple enough to parse, right?
</I>&gt;<i>
</I>&gt;<i> Sure, it's already handled by the current parsing spec, since it ignores
</I>&gt;<i> everything up to the first blank line.
</I>
That's not quite how I'm reading the spec.

<A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#webvtt-0">http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#webvtt-0</A>
allows
&quot;Optionally, either a U+0020 SPACE character or a U+0009 CHARACTER
TABULATION (tab) character followed by any number of characters that
are not U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)
characters.&quot;
after the &quot;WEBVTT FILE&quot; magic.
To me that reads like all of the extra stuff has to be on the same line.
I'd prefer if this read &quot;any character except for two WebVTT line
terminators&quot;, then it would all be ready for such header-style
metadata.


&gt;&gt;&gt;&gt;<i> 4. Cue formatting requirements
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> In analysing the available cue formatting functionality, we have found
</I>&gt;&gt;&gt;&gt;<i> that some features are missing. Most of these features can be added
</I>&gt;&gt;&gt;&gt;<i> through using CSS on cues that have received a &lt;b&gt;, &lt;i&gt;, &lt;c&gt; or &lt;v&gt;
</I>&gt;&gt;&gt;&gt;<i> marker. The following features are core to traditional TV and exist in
</I>&gt;&gt;&gt;&gt;<i> EBU STL and CEA-608/708 captions. Support of these will be a core
</I>&gt;&gt;&gt;&gt;<i> requirement for browsers as well as non-browser applications and it
</I>&gt;&gt;&gt;&gt;<i> makes sense to add these to WebVTT rather than relying on external CSS
</I>&gt;&gt;&gt;&gt;<i> which cannot be used for non-browser captions:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The unstated requirement here seems to be that WebVTT needs to work as an
</I>&gt;&gt;&gt;<i> interchange format for various TV captioning formats even in user agents
</I>&gt;&gt;&gt;<i> without any support for CSS (or JavaScript). I'm trying to not make a
</I>&gt;&gt;&gt;<i> straw
</I>&gt;&gt;&gt;<i> man argument, but if want an interchange format, we should pick TTML,
</I>&gt;&gt;&gt;<i> which
</I>&gt;&gt;&gt;<i> is explicitly designed to be just that and doesn't depend on CSS.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Is it not enough that a lossy conversion can be made from various formats
</I>&gt;&gt;&gt;<i> into WebVTT+CSS(+JavaScript)? If not, the &quot;Web&quot; in &quot;WebVTT&quot; is highly
</I>&gt;&gt;&gt;<i> misleading...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We're trying to avoid the need for multiple transcodings and are
</I>&gt;&gt;<i> trying to achieve something like the following pipeline:
</I>&gt;&gt;<i> broadcast captions -&gt; transcode to WebVTT -&gt; show in browser -&gt;
</I>&gt;&gt;<i> transcode to broadcast devices -&gt; show
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If we have to plug TTML into this pipeline, too, it will be much
</I>&gt;&gt;<i> slower and we would need to additionally define a mapping from TTML to
</I>&gt;&gt;<i> WebVTT and back.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm sure with SMPTE-TT around we will end up seeing things like
</I>&gt;&gt;<i> broadcast-&gt;TTML-&gt;WebVTT-&gt;browser, but even then we don't want WebVTT
</I>&gt;&gt;<i> to be a lossy format.
</I>&gt;<i>
</I>&gt;<i> I can only disagree. Trying to make WebVTT into an interchange format will
</I>&gt;<i> inevitably turn it into a highly presentational format with lots of legacy
</I>&gt;<i> baggage. I can certainly see the use cases for an interchange format, but I
</I>&gt;<i> don't think it's worth the added complexity. I'd prefer an approach where
</I>&gt;<i> any format quirks that can't be mapped to WebVTT are expressed using &lt;c.foo&gt;
</I>&gt;<i> and if it turns out lots of people want the feature, we can add it to a
</I>&gt;<i> future revision.
</I>
I wouldn't go as far as to say it needs to become an interchange
format. But I can see us specifying what the browser parses, while
given options such as the header-metadata and span classes that allow
with some extra information to fully recover the broadcast
functionality. I actually think that is almost possible already.


&gt;&gt;&gt;&gt;<i> * underline: EBU STL, CEA-608 and CEA-708 support underlining of
</I>&gt;&gt;&gt;&gt;<i> characters. The underline character is also particularly important for
</I>&gt;&gt;&gt;&gt;<i> some Asian languages. Please make it possible to provide text
</I>&gt;&gt;&gt;&gt;<i> underlines without the use of CSS in WebVTT.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Which Asian languages? If it's just the Chinese
</I>&gt;&gt;&gt;<i> &lt;<A HREF="http://en.wikipedia.org/wiki/Proper_name_mark">http://en.wikipedia.org/wiki/Proper_name_mark</A>&gt;, then I don't think that
</I>&gt;&gt;&gt;<i> needs &lt;u&gt; or similar. In my experience, use of the Chinese proper name
</I>&gt;&gt;&gt;<i> mark
</I>&gt;&gt;&gt;<i> is in fact extremely rare in Chinese captions, at least in movies and TV
</I>&gt;&gt;&gt;<i> series from the mainland and Taiwan. It would be best to use e.g.
</I>&gt;&gt;&gt;<i> &#25105;&#20358;&#33258;&lt;c.pnm&gt;&#20013;&#22283;&lt;/c&gt; to make it easy to change the style between
</I>&gt;&gt;&gt;<i> single/double/wavy/no underline.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> OK. So if we need underlined text, it will need to be
</I>&gt;&gt;<i> &lt;c.underline&gt;..&lt;/c&gt; and CSS underline? I guess in a Web context
</I>&gt;&gt;<i> underline text is usually a hyperlink so it makes sense to discourage
</I>&gt;&gt;<i> &lt;u&gt; for the Web. But is that also an argument for
</I>&gt;&gt;<i> captions/subtitles/descriptions? What is the argument against using
</I>&gt;&gt;<i> &lt;u&gt; in captions?
</I>&gt;<i>
</I>&gt;<i> I don't really have an argument against it, I just questioned that it is
</I>&gt;<i> important for Asian languages in particular. Adding &lt;u&gt; would be really
</I>&gt;<i> simple, it's just a question of why. I've seldom seen underlining in
</I>&gt;<i> captions, so it's not clear to me how it's usually used.
</I>
I'm told &lt;u&gt; is fairly common in traditional captions. We don't do
&lt;c.italics&gt; either for such common stuff.
But if we really don't want this, I guess &lt;c.u&gt; would work, too and is
not that much longer.


&gt;&gt;&gt;&gt;<i> * font face: CEA-708 provides a choice of eight font tags: undefined,
</I>&gt;&gt;&gt;&gt;<i> monospaced serif, proportional serif, monospaced sans serif,
</I>&gt;&gt;&gt;&gt;<i> proportional sans serif, casual, cursive, small capital. These fonts
</I>&gt;&gt;&gt;&gt;<i> should be available for WebVTT as well. Is this the case?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Does the choice of font ever carry any semantic meaning? Isn't it a good
</I>&gt;&gt;&gt;<i> thing that captions can't specify their own fonts, so that it's easy to
</I>&gt;&gt;&gt;<i> pick
</I>&gt;&gt;&gt;<i> a style that's suitable for the embedding site?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The choice of fonts for captions has traditionally been a key to
</I>&gt;&gt;<i> providing quality captions. Some fonts are more readable than others.
</I>&gt;&gt;<i> So, captioning handbooks have traditionally prescribed the best fonts
</I>&gt;&gt;<i> to use for captioning to explicitly point out those that are easily
</I>&gt;&gt;<i> readable. After having checked with the handbooks that are available
</I>&gt;&gt;<i> to me it seems sans serif and proportional are the preferred ones, so
</I>&gt;&gt;<i> I do wonder why CEA-708 provides this choice of fonts. You are right
</I>&gt;&gt;<i> though that it makes more sense to provide semantic meaning and then
</I>&gt;&gt;<i> style through css. At minimum &lt;c.cursive&gt; etc would be possible with
</I>&gt;&gt;<i> an appropriate choice of font through styling, again using the class
</I>&gt;&gt;<i> span element to solve this.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Coming at it from a devices background, it's actually all a matter of
</I>&gt;&gt;<i> pre-defined choices. They're not going to package a large number of
</I>&gt;&gt;<i> fonts with every device, so it's good if all devices support a basic
</I>&gt;&gt;<i> subset that can be relied on to exist cross-device. We're increasingly
</I>&gt;&gt;<i> going to have to consider such requirements, too, because we will see
</I>&gt;&gt;<i> Web browsers run on devices with restricted capabilities, not just the
</I>&gt;&gt;<i> browser on a computer where you can install missing fonts.
</I>&gt;<i>
</I>&gt;<i> Personally, I think we're going to see more and more devices running full
</I>&gt;<i> browsers with webfonts support, and that this isn't going to be a big
</I>&gt;<i> problem.
</I>
I tend to agree and in fact I see that as the shiny future. Just not
quite yet. But I'm not fussed, because we can always declare classes
that represent certain fonts, such as &lt;c.serif&gt; -&gt; mapped to
font-family: serif; in CSS and whatever a device decides to pick for
that device.


&gt;&gt;<i> I guess what we are discovering is that we can define the general
</I>&gt;&gt;<i> format of WebVTT for the Web, but that there may be an additional need
</I>&gt;&gt;<i> to provide minimum implementation needs (a &quot;profile&quot; if you want - as
</I>&gt;&gt;<i> much as I hate this word). This seems to apply to the file-wide
</I>&gt;&gt;<i> metadata fields, to some specific standard classes (underline, blink),
</I>&gt;&gt;<i> to the set of colors supported and to the set of fonts supported. I
</I>&gt;&gt;<i> don't think these are issues that browsers need to worry about, and
</I>&gt;&gt;<i> therefore are probably beyond what we need to specify here for WebVTT.
</I>&gt;&gt;<i> But there probably needs to be a group to do this eventually.
</I>&gt;<i>
</I>&gt;<i> The way that all standalone players I've used work is allowing the user to
</I>&gt;<i> pick a font and size which is used for all captions. I know I quite
</I>&gt;<i> appreciate this and wouldn't be thrilled if the captions file forced a font
</I>&gt;<i> I didn't like. Of course we could make it such that the author picks a font
</I>&gt;<i> and the user can override that. If it's purely presentational I'd kind of
</I>&gt;<i> prefer to keep it out of WebVTT, though.
</I>
I think the user overruling should always be possible, even if there
is a font picked by the author. I'm happy to keep it out of WebVTT and
defer to the &lt;c&gt; element with a class for it.


&gt;&gt;<i> With &quot;-&quot; you are referring to replacing &quot;--&gt;&quot; with &quot;-&quot; to arrive at things
</I>&gt;&gt;<i> like:
</I>&gt;&gt;<i> 15.000-17.950
</I>&gt;&gt;<i> At the left we can see...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> as compared to:
</I>&gt;&gt;<i> 15.000+2.950
</I>&gt;&gt;<i> At the left we can see...
</I>&gt;<i>
</I>&gt;<i> Yes, that's what I meant.
</I>&gt;<i>
</I>&gt;&gt;<i> I actually think they read fairly given that people are used to the
</I>&gt;&gt;<i> double meaning of &quot;-&quot;: to mean both &quot;from ... to&quot; and &quot;minus&quot;.
</I>&gt;&gt;<i> But we could use a different character for &quot;absolute time&quot; if you
</I>&gt;&gt;<i> prefer, e.g. &quot;/&quot;.
</I>&gt;&gt;<i> 15.000/17.950
</I>&gt;&gt;<i> At the left we can see...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I find this fairly readable, too.
</I>&gt;<i>
</I>&gt;<i> Either would work for me. As I mentioned, the room for improvement here
</I>&gt;<i> isn't only the syntax of the timing line, but also to make it obvious that
</I>&gt;<i> cue timestamps like &lt;00:01.000&gt; are relative. Using + for relative
</I>&gt;<i> timestamps is potentially confusing too, as one might think that many
</I>&gt;<i> consecutive &lt;+00:01.000&gt; are cumulative, rather than all being 1 second from
</I>&gt;<i> the start time of the cue.
</I>
That's true and in fact the way in which I have authored my examples,
now that I look back at them. It makes the timings smaller and I think
it's a bit more logical. But really we just have to decide on one
meaning:

5-10
This &lt;+1&gt;is &lt;+1&gt;a &lt;+1&gt;simple &lt;+1&gt;example.

I find I actually prefer this over

5-10
This &lt;+1&gt;is &lt;+2&gt;a &lt;+3&gt;simple &lt;+4&gt;example.


&gt;&gt;&gt;&gt;<i> 7. Comments
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> we recommend the introduction of comments.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I agree and think it needs to happen before WebVTT starts to get
</I>&gt;&gt;&gt;<i> implemented
</I>&gt;&gt;&gt;<i> and used on the web. In other words: now.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Agreed. I'm happy for the previously suggested &quot;//&quot; at the line start
</I>&gt;&gt;<i> to be comments, or, for that matter, &quot;#&quot; or &quot;;&quot; or any other special
</I>&gt;&gt;<i> character. I would prefer not to use &quot;/*&quot; since it implies a &quot;*/&quot; is
</I>&gt;&gt;<i> required to end the comment. Similarly we should avoid &quot;&lt;!--&quot; and
</I>&gt;&gt;<i> &quot;--&gt;&quot; or anything else that requires a special comment end mark and
</I>&gt;&gt;<i> more than one or two characters.
</I>&gt;<i>
</I>&gt;<i> I'd quite like to have block comments, so I think the best options are:
</I>&gt;<i>
</I>&gt;<i> 1. // and /* */ like JavaScript
</I>&gt;<i> 2. &lt;!-- --&gt; like HTML/XML
</I>
If the main use case for the comments is to comment out a line,
something at the line start alone would be sufficient. If we have to
have both, I would prefer the shorter first option.


&gt;<i> I think that the main difficulty is actually not picking a syntax, but
</I>&gt;<i> deciding how it works in the parser. Unlike HTML, I don't think we want the
</I>&gt;<i> comments to show up in the &quot;DOM&quot;, since that would only work for intra-cue
</I>&gt;<i> comments. Ideally it would be preprocessor-ish, but yet the magic bytes
</I>&gt;<i> (&quot;WEBVTT FILE&quot;) should be checked first as otherwise identifying WebVTT
</I>&gt;<i> would require implementing its preprocessor steps :/
</I>
As I would not want the comments not to be handed into the DOM or to
JavaScript, it doesn't matter if they are not like HTML. I would
regard them more as pre-processor style comments.


&gt;&gt;&gt;&gt;<i> 8. Line wrapping
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> CEA-708 captions support automatic line wrapping in a more
</I>&gt;&gt;&gt;&gt;<i> sophisticated way than WebVTT -- see
</I>&gt;&gt;&gt;&gt;<i> <A HREF="http://en.wikipedia.org/wiki/CEA-708#Word_wrap.">http://en.wikipedia.org/wiki/CEA-708#Word_wrap.</A>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> In our experience with YouTube we have found that in certain
</I>&gt;&gt;&gt;&gt;<i> situations this type of automatic line wrapping is very useful.
</I>&gt;&gt;&gt;&gt;<i> Captions that were authored for display in a full-screen video may
</I>&gt;&gt;&gt;&gt;<i> contain too many words to be displayed fully within the actual video
</I>&gt;&gt;&gt;&gt;<i> presentation (note that mobile / desktop / internet TV devices may
</I>&gt;&gt;&gt;&gt;<i> each have a different amount of space available, and embedded videos
</I>&gt;&gt;&gt;&gt;<i> may be of arbitrary sizes). Furthermore, user-selected fonts or font
</I>&gt;&gt;&gt;&gt;<i> sizes may be larger than expected, especially for viewers who need
</I>&gt;&gt;&gt;&gt;<i> larger print.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> WebVTT as currently specified wraps text at the edge of their
</I>&gt;&gt;&gt;&gt;<i> containing blocks, regardless of the value of the 'white-space'
</I>&gt;&gt;&gt;&gt;<i> property, even if doing so requires splitting a word where there is no
</I>&gt;&gt;&gt;&gt;<i> line breaking opportunity. This will tend to create poor quality
</I>&gt;&gt;&gt;&gt;<i> captions. &#160;For languages where it makes sense, line wrapping should
</I>&gt;&gt;&gt;&gt;<i> only be possible at carriage return, space, or hyphen characters, but
</I>&gt;&gt;&gt;&gt;<i> not on &nbsp; characters. &#160;(Note that CEA-708 also contains
</I>&gt;&gt;&gt;&gt;<i> non-breaking space and non-breaking transparent space characters to
</I>&gt;&gt;&gt;&gt;<i> help control wrapping.)However, this algorithm will not necessarily
</I>&gt;&gt;&gt;&gt;<i> work for all languages.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> We therefore suggest that a better solution for line wrapping would be
</I>&gt;&gt;&gt;&gt;<i> to use the existing line wrapping algorithms of browsers, which are
</I>&gt;&gt;&gt;&gt;<i> presumably already language-sensitive.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> [Note: the YouTube line wrapping algorithm goes even further by
</I>&gt;&gt;&gt;&gt;<i> splitting single caption cues into multiple cues if there is too much
</I>&gt;&gt;&gt;&gt;<i> text to reasonably fit within the area. YouTube then adjusts the times
</I>&gt;&gt;&gt;&gt;<i> of these caption cues so they appear sequentially. &#160;Perhaps this could
</I>&gt;&gt;&gt;&gt;<i> be mentioned as another option for server-side tools.]
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Yeah, with SRT people are manually line-wrapping when authoring the
</I>&gt;&gt;&gt;<i> captions
</I>&gt;&gt;&gt;<i> and often enough the end result is that you get something rendered:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> - Who could have guessed that not all fonts are the same
</I>&gt;&gt;&gt;<i> size?
</I>&gt;&gt;&gt;<i> - That's news to me, so I get four lines of text where I
</I>&gt;&gt;&gt;<i> wanted two!
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I'm inclined to say that we should normalize all whitespace during
</I>&gt;&gt;&gt;<i> parsing
</I>&gt;&gt;&gt;<i> and not have explicit line breaks at all. If people really want two
</I>&gt;&gt;&gt;<i> lines,
</I>&gt;&gt;&gt;<i> they should use two cues. In practice, I don't know how well that would
</I>&gt;&gt;&gt;<i> fare, though. What other solutions are there?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I don't think I would go that far. The concern has mostly been with
</I>&gt;&gt;<i> the line wrapping of lines that are too long and the possibility of
</I>&gt;&gt;<i> splitting words that way. The particular concern was with this
</I>&gt;&gt;<i> paragraph:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &quot;Text runs must be wrapped at the edge of their containing blocks,
</I>&gt;&gt;<i> regardless of the value of the 'white-space' property, even if doing
</I>&gt;&gt;<i> so requires splitting a word where there is no line breaking
</I>&gt;&gt;<i> opportunity.&quot;
</I>&gt;&gt;<i> see
</I>&gt;&gt;<i> <A HREF="http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#timed-text-tracks-0">http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#timed-text-tracks-0</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So we want to avoid splitting mid-word and we suggest introducing the
</I>&gt;&gt;<i> ability to have non-breaking spaces.
</I>&gt;<i>
</I>&gt;<i> I think splitting in the middle of words would only happen for words that
</I>&gt;<i> are longer than the whole line.
</I>
Ah ok - I guess you can interpret the sentence above in this way as
in&quot;splitting a word ONLY where there is no line breaking opportunity&quot;.
Then it's probably ok. It would still make sense to accept
non-breaking spaces.


&gt;<i> There's still plenty of room for improvements in line wrapping, though. It
</I>&gt;<i> seems to me that the main reason that people line wrap captions manually is
</I>&gt;<i> to avoid getting two lines of very different length, as that looks quite
</I>&gt;<i> unbalanced. There's no way to make that happen with CSS, and AFAIK it's not
</I>&gt;<i> done by the WebVTT rendering spec either.
</I>
People split manually when they want quality captions and can visually
test what it will look like.

This endeavor has one big problem: when you change the video size,
e.g. go to full screen, your optimisation for the previous size is
likely to not be optimal for the new size any more. There, an
automatic line balancing that makes use of commas and &quot;and&quot;s for
choosing likely good line break positions would be nice.

A completely different situation appears when the captions are not
manually created, as is the case in YouTube. Even when you submit a
perfect transcript and time-align it through speech recognition, you
will only do the line breaks as you have to render cues. To achieve a
better quality there, a better line-break algorithm would help
massively.

So, I agree with you about improving the line wrapping. I also think
it is likely something that we have to leave to the browsers - at
least for now.


&gt;&gt;&gt;&gt;<i> B. Feedback on the &lt;track&gt; element
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> 1. Pop-on/paint-on/roll-up support
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Three different types of captions are common on TV: pop-on, roll-up
</I>&gt;&gt;&gt;&gt;<i> and paint-on. Captions according to CEA-608/708 need to support
</I>&gt;&gt;&gt;&gt;<i> captions of all three of these types. We believe they are already
</I>&gt;&gt;&gt;&gt;<i> supported in WebVTT, but see a need to re-confirm.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The underlying use case here is live captioning, right? Just copying the
</I>&gt;&gt;&gt;<i> styling used on broadcast TV seems like it wouldn't be enough, you also
</I>&gt;&gt;&gt;<i> need
</I>&gt;&gt;&gt;<i> the ability to erase typos, right? Are there any existing captioning
</I>&gt;&gt;&gt;<i> formats
</I>&gt;&gt;&gt;<i> that handle live captioning well from which one could draw inspiration?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Yes, CEA-608/609 do these things and we have analysed them for these
</I>&gt;&gt;<i> features. They have control characters for backspace (only within
</I>&gt;&gt;<i> row), delete to end of row, erase displayed memory and erase
</I>&gt;&gt;<i> non-displayed memory. Further there is the concept of a cursor and
</I>&gt;&gt;<i> there are means to move the cursor to other screen locations.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I don't think we really need the concept of a cursor or display memory
</I>&gt;&gt;<i> and we don't need backspace and delete etc. because we have the
</I>&gt;&gt;<i> concept of mutableTimedTrack. So, a live captioning application can
</I>&gt;&gt;<i> always remove an existing TimedTrackCue and replace it with a new one
</I>&gt;&gt;<i> where the errors are fixed. At Google we came to the conclusion that
</I>&gt;&gt;<i> this was sufficient and therefore did not see a need to request
</I>&gt;&gt;<i> features for this type of application.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> However, the three types of captions are actually not just used in
</I>&gt;&gt;<i> live captioning, but they are three different captioning styles that
</I>&gt;&gt;<i> could all be created by live or &quot;canned&quot; captions. We think they can
</I>&gt;&gt;<i> be supported, so this is good news.
</I>&gt;<i>
</I>&gt;<i> If you have to rely on scripting to fix errors, I think you could rely on
</I>&gt;<i> scripts for achieving whatever other effects you need as well, in particular
</I>&gt;<i> the scrolling style.
</I>
I don't even think that's necessary, but you are right, that's another option.


&gt;&gt;&gt;&gt;<i> 4. Addressing individual cues through CSS
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> As far as we understand, you can currently address all cues through
</I>&gt;&gt;&gt;&gt;<i> ::cue and you can address a cue part through ::cue-part(&lt;voice&gt; ||
</I>&gt;&gt;&gt;&gt;<i> &lt;part&gt; || &lt;position&gt; || &lt;future-compatibility&gt;). However, if we
</I>&gt;&gt;&gt;&gt;<i> understand correctly, it doesn&#8217;t seem to be possible to address an
</I>&gt;&gt;&gt;&gt;<i> individual cue through CSS, even though cues have individual
</I>&gt;&gt;&gt;&gt;<i> identifiers. This is either an oversight or a misunderstanding on our
</I>&gt;&gt;&gt;&gt;<i> parts. Can you please clarify how it is possible to address an
</I>&gt;&gt;&gt;&gt;<i> individual cue through CSS?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Since I've been arguing against the id's in WebVTT, I'm curious about the
</I>&gt;&gt;&gt;<i> use case here. Isn't using a unique class good enough?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This links in with the discussion above on CSS styling and classes.
</I>&gt;&gt;<i> Rather than define classes of cue settings and reference them from the
</I>&gt;&gt;<i> cues, this allows them to be applied to individual cues in style
</I>&gt;&gt;<i> sheets. I thought the whole reason of cue identifiers was to have this
</I>&gt;&gt;<i> addressing functionality, so this would just close the loop.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For example:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Style sheet of the Web page:
</I>&gt;&gt;<i> &lt;style&gt;
</I>&gt;&gt;<i> video track#t1 ::cue(cue10) {
</I>&gt;&gt;<i> &#160;text-decoration: blink;
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i> &lt;/style&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The Web page (extract):
</I>&gt;&gt;<i> &lt;video src=&quot;video.webm&quot; controls&gt;
</I>&gt;&gt;<i> &#160;&lt;track id=&quot;t1&quot; label=&quot;captions&quot; kind=&quot;captions&quot; srclang=&quot;en-US&quot;
</I>&gt;&gt;<i> src=&quot;cap1.vtt&quot;/&gt;
</I>&gt;&gt;<i> &lt;/video&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The caption file cap1.vtt:
</I>&gt;&gt;<i> WEBVTT
</I>&gt;&gt;<i> Language=en-US
</I>&gt;&gt;<i> Kind=Captions
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> cue1
</I>&gt;&gt;<i> 0.000-5.000
</I>&gt;&gt;<i> blab blah
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> cue10
</I>&gt;&gt;<i> 40.000-60.000
</I>&gt;&gt;<i> ALERT: Your basement is flooding - evacuate!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Cue10 is addressed through CSS and turned into a blinking text without
</I>&gt;&gt;<i> a need to change the markup at all.
</I>&gt;<i>
</I>&gt;<i> My point was that you could just as well do this:
</I>&gt;<i>
</I>&gt;<i> 0.000-5.000
</I>&gt;<i> &lt;c.cue1&gt;blab blah&lt;/c&gt;
</I>&gt;<i>
</I>&gt;<i> In my view of things, id's in HTML are primarily for addressing via
</I>&gt;<i> #fragments and as hooks for scripts, for styling class is quite sufficient,
</I>&gt;<i> so I'm thinking it would be for WebVTT as well.
</I>
I quite like the idea of using the identifiers for named media
fragment URIs: e.g. <A HREF="http://example.org/video.webm#cue10">http://example.org/video.webm#cue10</A> . We need
identifiers for this. Also, I find them less intrusive in the text
than &lt;c.cue1&gt; which defines a class that is only every used on this
single cue.


&gt;&gt;&gt;&gt;<i> 5. Ability to move captions out of the way
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Our experience with automated caption creation and positioning on
</I>&gt;&gt;&gt;&gt;<i> YouTube indicates that it is almost impossible to always place the
</I>&gt;&gt;&gt;&gt;<i> captions out of the way of where a user may be interested to look at.
</I>&gt;&gt;&gt;&gt;<i> We therefore allow users to dynamically move the caption rendering
</I>&gt;&gt;&gt;&gt;<i> area to a different viewport position to reveal what is underneath. We
</I>&gt;&gt;&gt;&gt;<i> recommend such drag-and-drop functionality also be made available for
</I>&gt;&gt;&gt;&gt;<i> TimedTrack captions on the Web, especially when no specific
</I>&gt;&gt;&gt;&gt;<i> positioning information is provided.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> This would indeed be rather nice, but wouldn't it interfere with text
</I>&gt;&gt;&gt;<i> selection? Detaching the captions into a floating, draggable window via
</I>&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;<i> context menu would be a theoretically possible solution, but that's
</I>&gt;&gt;&gt;<i> getting
</I>&gt;&gt;&gt;<i> rather far ahead of ourselves before we have basic captioning support.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On YouTube you can only move them within the video viewport. You
</I>&gt;&gt;<i> should try it - it's really awesome actually.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> When you say &quot;interfere with text selection&quot; are you suggesting that
</I>&gt;&gt;<i> the text of captions/subtitles should be able to be cut and pasted? I
</I>&gt;&gt;<i> wonder what copyright holders think about that.
</I>&gt;<i>
</I>&gt;<i> Being able to select the captions just like any other text is a great thing
</I>&gt;<i> that I wouldn't want to disable. It's very useful if you want to pause and
</I>&gt;<i> look up the definition of a word or to report a typo in the captions without
</I>&gt;<i> having to retype the whole text.
</I>
I guess you can have all of that as you can have it on Web pages, too.
If you click and hold, it will be grabbing for moving. If you double
click it is text selection for cut and paste. So, I don't think there
would be a problem.

&gt;<i> Premium Captions can be protected using the same tricks that are used to
</I>&gt;<i> prevent Premium DOM Text Nodes from being copied.
</I>
Agreed.


Cheers,
Silvia.
</PRE>





































































<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030466.html">[whatwg] Google Feedback on the HTML5 media a11y specifications
</A></li>
	<LI>Next message: <A HREF="030501.html">[whatwg] Google Feedback on the HTML5 media a11y specifications
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30493">[ date ]</a>
              <a href="thread.html#30493">[ thread ]</a>
              <a href="subject.html#30493">[ subject ]</a>
              <a href="author.html#30493">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
