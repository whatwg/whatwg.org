<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [whatwg] Link rot is not dangerous
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Link%20rot%20is%20not%20dangerous&In-Reply-To=%3Cdd0fbad0905152131nf053252v200c018991d7bff6%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="062042.html">
   <LINK REL="Next"  HREF="062056.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[whatwg] Link rot is not dangerous</H1>
<!--htdig_noindex-->
    <B>Tab Atkins Jr.</B> 
    <A HREF="mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Link%20rot%20is%20not%20dangerous&In-Reply-To=%3Cdd0fbad0905152131nf053252v200c018991d7bff6%40mail.gmail.com%3E"
       TITLE="[whatwg] Link rot is not dangerous">jackalmage at gmail.com
       </A><BR>
    <I>Fri May 15 21:31:15 PDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="062042.html">[whatwg] Link rot is not dangerous
</A></li>
        <LI>Next message: <A HREF="062056.html">[whatwg] Link rot is not dangerous
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#62048">[ date ]</a>
              <a href="thread.html#62048">[ thread ]</a>
              <a href="subject.html#62048">[ subject ]</a>
              <a href="author.html#62048">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--/htdig_noindex-->
<!--beginarticle-->
<PRE>2009/5/15 Laurens Holst &lt;<A HREF="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">laurens.nospam at grauw.nl</A>&gt;:
&gt;<i> Tab Atkins Jr. schreef:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Assume a page that uses both foaf and another vocab that subclasses
</I>&gt;&gt;<i> many foaf properties. &#160;Given working lookups for both, the rdf parser
</I>&gt;&gt;<i> can determine that two entries with different properties are really
</I>&gt;&gt;<i> 'the same', and hopefully act on that knowledge.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If the second vocab 404s, that information is lost. &#160;The parser will
</I>&gt;&gt;<i> then treat any use of that second vocab completely separately from the
</I>&gt;&gt;<i> foaf, losing valuable semantic information.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> If the subclass-vocabulary is public, then it is most likely already well
</I>&gt;<i> taken care of by the owner and also archived in several places, and thus
</I>&gt;<i> hard to get lost. If the subclass-vocabulary is one custom-built for a
</I>&gt;<i> specific site, then it is likely already stored in the same location.
</I>&gt;<i>
</I>&gt;<i> But even if you had RDF data without ontology, it is still far from useless.
</I>&gt;<i> In fact, I&#8217;d say most RDF consumers today do not really do any kind of
</I>&gt;<i> reasoning, which is what you primarily need an ontology for, especially not
</I>&gt;<i> the large consumers. Without ontology you can still determine types, query
</I>&gt;<i> their properties whose names are often self-explanatory, compare resources
</I>&gt;<i> for equality, etc.
</I>&gt;<i>
</I>&gt;<i> Knowledge of the ontology will be embedded in documentation and existing
</I>&gt;<i> software that consumes the data. Let me remark that when you end up in this
</I>&gt;<i> scenario, you still basically got the same as what microformats have to work
</I>&gt;<i> with. And if need be, you could even manually construct a schema.
</I>&gt;<i>
</I>&gt;<i> But yes, if everything goes awry, then data can get lost. That is the nature
</I>&gt;<i> of the web. It is like, if snap.com goes out of business, all sites using
</I>&gt;<i> those annoying popups will cease to show them (hurray!). A question you
</I>&gt;<i> could pose is, if &#8216;the web&#8217; allowed the data to get lost, whether that data
</I>&gt;<i> is really important anyway.
</I>&gt;<i>
</I>&gt;<i> Maybe it would ease your mind if people set up a bunch of servers which
</I>&gt;<i> spider the web of data for ontology schemas, archives them and provides a
</I>&gt;<i> querying mechanism? If such a thing does not exist already.
</I>&gt;<i>
</I>&gt;<i> Either way, I guess kind of the basic idea is that, dereferencibility of RDF
</I>&gt;<i> URIs is a convenient bonus, not a necessity, RDF can work completely
</I>&gt;<i> offline. There is no requirement that ontologies must be retrieved from the
</I>&gt;<i> ontology&#8217;s URIs or that there must be an ontology at all.
</I>
Believe me, Laurens, *I* know this.  I know that public vocabs will be
publicly known and consumable, and private vocabs don't need to be
(because the few people using them know them and can consume them).
But the automated discoverability of RDF has been touted as a major
reason why RDFa specifically has to be supported in HTML5 (certainly
not the only major reason, but it's been harped on plenty), and link
rot *does* significantly affect that, *especially* for the small
vocabs that aren't likely to be widely reproduced.  It's a common
thing that *will* happen, as Philip's data shows, and as anyone
familiar with web history is aware of.  The web rots over time, no
matter what you do, and there's no way to form canonical identifiers
that will stand the test of time.

Automated discovery is a benny in RDF's favor.  It's probably not a
*downside*, after all (though there were some negative scenarios
brought up concerning this a few months ago, such as a domain falling
into new hands who maliciously modify the schema).  But I think it's a
very minor point, and the fact that few if any major consumers of RDF
actually use this ability supports this thought.  There's little to no
in-the-wild use cases for this sort of ability, which means that it is
very low priority when determining what solution will be specced.

Once you remove discovery as a strong requirement, then you remove the
need for large urls, and that removes the need for CURIEs, or any
other form of prefixing.  You still want to uniquify your identifiers
to avoid accidental clashes, but that's not that hard, nor is it
absolutely necessary.  The system can be robust and usable even with a
bit of potential ambiguity if small authors design their private
vocabs badly.  As a bonus, everything gets simpler.  Essentially it
devolves into something relatively close to Ian's microdata proposal,
perhaps with datatype added in (though I do question how necessary
that is, given a half-intelligent parser can recognize things as
numbers or dates).

~TJ

</PRE>

<!--endarticle-->
<!--htdig_noindex-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="062042.html">[whatwg] Link rot is not dangerous
</A></li>
	<LI>Next message: <A HREF="062056.html">[whatwg] Link rot is not dangerous
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#62048">[ date ]</a>
              <a href="thread.html#62048">[ thread ]</a>
              <a href="subject.html#62048">[ subject ]</a>
              <a href="author.html#62048">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">More information about the whatwg
mailing list</a><br>
<!--/htdig_noindex-->
</body></html>
