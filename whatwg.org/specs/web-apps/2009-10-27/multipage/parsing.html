<!DOCTYPE html>
<!DOCTYPE html><html class="split chapter" lang="en-US-x-hixie"><title>9.2 Parsing HTML documents &mdash; HTML5</title><link href="/style/specification" rel="stylesheet"><link href="/images/icon" rel="icon"><style>
   .proposal { border: blue solid; padding: 1em; }
   .bad, .bad *:not(.XXX) { color: gray; border-color: gray; background: transparent; }
   #updatesStatus { display: none; }
   #updatesStatus.relevant { display: block; position: fixed; right: 1em; top: 1em; padding: 0.5em; font: bold small sans-serif; min-width: 25em; width: 30%; max-width: 40em; height: auto; border: ridge 4px gray; background: #EEEEEE; color: black; }
   div.head .logo { width: 11em; margin-bottom: 20em; }
   #configUI { position: absolute; z-index: 20; top: 10em; right: 1em; width: 11em; font-size: small; }
   #configUI p { margin: 0.5em 0; padding: 0.3em; background: #EEEEEE; color: black; border: inset thin; }
   #configUI p label { display: block; }
   #configUI #updateUI, #configUI .loginUI { text-align: center; }
   #configUI input[type=button] { display: block; margin: auto; }
   #reviewer { position: fixed; bottom: 0; right: 0; white-space: nowrap; border: thin; border-style: inset none none inset; background: #EEEEEE; color: black; overflow: hidden; z-index: 30; }
   #reviewer * { font-size: small; }
   #reviewer.off > :not(:first-child) { display: none; }
   @media print { #configUI { display: none; } }
   .rfc2119 { font-variant: small-caps; text-shadow: 0 0 0.5em yellow; position: static; }
   .rfc2119::after { position: absolute; left: 0; width: 25px; text-align: center; color: yellow; text-shadow: 0.075em 0.075em 0.2em black; }
   .rfc2119.m\ust::after { content: '\2605'; }
   .rfc2119.s\hould::after { content: '\2606'; }
   [hidden] { display: none; }
  </style><style type="text/css">

   .applies thead th > * { display: block; }
   .applies thead code { display: block; }
   .applies tbody th { whitespace: nowrap; }
   .applies td { text-align: center; }
   .applies .yes { background: yellow; }

   .matrix, .matrix td { border: none; text-align: right; }
   .matrix { margin-left: 2em; }

   .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
   .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
   .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

   #table-example-1 { border: solid thin; border-collapse: collapse; margin-left: 3em; }
   #table-example-1 * { font-family: "Essays1743", serif; line-height: 1.01em; }
   #table-example-1 caption { padding-bottom: 0.5em; }
   #table-example-1 thead, #table-example-1 tbody { border: none; }
   #table-example-1 th, #table-example-1 td { border: solid thin; }
   #table-example-1 th { font-weight: normal; }
   #table-example-1 td { border-style: none solid; vertical-align: top; }
   #table-example-1 th { padding: 0.5em; vertical-align: middle; text-align: center; }
   #table-example-1 tbody tr:first-child td { padding-top: 0.5em; }
   #table-example-1 tbody tr:last-child td { padding-bottom: 1.5em; }
   #table-example-1 tbody td:first-child { padding-left: 2.5em; padding-right: 0; width: 9em; }
   #table-example-1 tbody td:first-child::after { content: leader(". "); }
   #table-example-1 tbody td { padding-left: 2em; padding-right: 2em; }
   #table-example-1 tbody td:first-child + td { width: 10em; }
   #table-example-1 tbody td:first-child + td ~ td { width: 2.5em; }
   #table-example-1 tbody td:first-child + td + td + td ~ td { width: 1.25em; }

   .apple-table-examples { border: none; border-collapse: separate; border-spacing: 1.5em 0em; width: 40em; margin-left: 3em; }
   .apple-table-examples * { font-family: "Times", serif; }
   .apple-table-examples td, .apple-table-examples th { border: none; white-space: nowrap; padding-top: 0; padding-bottom: 0; }
   .apple-table-examples tbody th:first-child { border-left: none; width: 100%; }
   .apple-table-examples thead th:first-child ~ th { font-size: smaller; font-weight: bolder; border-bottom: solid 2px; text-align: center; }
   .apple-table-examples tbody th::after, .apple-table-examples tfoot th::after { content: leader(". ") }
   .apple-table-examples tbody th, .apple-table-examples tfoot th { font: inherit; text-align: left; }
   .apple-table-examples td { text-align: right; vertical-align: top; }
   .apple-table-examples.e1 tbody tr:last-child td { border-bottom: solid 1px; }
   .apple-table-examples.e1 tbody + tbody tr:last-child td { border-bottom: double 3px; }
   .apple-table-examples.e2 th[scope=row] { padding-left: 1em; }
   .apple-table-examples sup { line-height: 0; }

  </style><link href="data:text/css," id="complete" rel="stylesheet" title="Complete specification"><link href="data:text/css,.impl%20{%20display:%20none;%20}" id="author" rel="alternate stylesheet" title="Author documentation only"><link href="data:text/css,.impl%20{%20background:%20%23FFEEEE;%20}" id="highlight" rel="alternate stylesheet" title="Highlight implementation requirements"><script>
   var loadTimer = new Date();
   var current_revision = "r" + "$Revision: 4372 $".substr(11);
   current_revision = current_revision.substr(0, current_revision.length - 2);
   var last_known_revision = current_revision;
   function getCookie(name) {
     var params = location.search.substr(1).split("&");
     for (var index = 0; index < params.length; index++) {
       if (params[index] == name)
         return "1";
       var data = params[index].split("=");
       if (data[0] == name)
         return unescape(data[1]);
     }
     var cookies = document.cookie.split("; ");
     for (var index = 0; index < cookies.length; index++) {
       var data = cookies[index].split("=");
       if (data[0] == name)
         return unescape(data[1]);
     }
     return null;
   }
   function load(script) {
     var e = document.createElement('script');
     e.setAttribute('src', script);
     document.body.appendChild(e);
   }
   function init() {
     if (location.search == '?slow-browser')
       return;
     var configUI = document.createElement('div');
     configUI.id = 'configUI';
     document.body.appendChild(configUI);
     if (document.documentElement.className == "" || document.documentElement.className == "split index")
       load('toc.js');
     load('styler.js');
     if (document.documentElement.className == "")
       load('dfn.js');
     if (getCookie('profile') == '1')
       document.getElementsByTagName('h2')[0].textContent += '; load: ' + (new Date() - loadTimer) + 'ms';
   }
  </script>
  <script src="link-fixup.js"></script>
  <link href="syntax.html" rel="prev" title="9 The HTML syntax">
  <link href="index.html#contents" rel="index" title="Table of contents">
  <link href="tokenization.html" rel="next" title="9.2.4 Tokenization">
  <body class="cfc" onload="fixBrokenLink(); init()">
  <style scoped>
   * { color: gray ! important; background: none ! important; border-color: silver ! important; }
   img, object, iframe { filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale"); -webkit-filter: grayscale(100%); }
   .obsolete { border: double thick red ! important; background: yellow ! important; margin: 4em auto 0 auto; max-width: 50em; width: 70%; text-align: center; position: fixed;  z-index: 10000; top: 0; left: 0; right: 0; }
   .obsolete a { color: blue ! important; }
   .obsolete p { font: 900 2em sans-serif; color: red ! important; margin: 1em 1.5em ! important; }
  </style>
  <div class=obsolete>
   <p>This is a snapshot of an early working draft and has therefore
   been superseded by the <a href="http://whatwg.org/html">HTML
   standard</a>.</p>
   <p>This document will not be further updated.</p>
  </div>
<header class="head"><p><a class="logo" href="http://www.whatwg.org/" rel="home"><img alt="WHATWG" src="/images/logo"></a></p>
   <hgroup><h1>HTML5</h1>
    <h2 class="no-num no-toc">Draft Standard &mdash; Call For Comments &mdash; 27 October 2009</h2>
   </hgroup></header><nav>
   <a href="syntax.html">&larr; 9 The HTML syntax</a> &ndash;
   <a href="index.html#contents">Table of contents</a> &ndash;
   <a href="tokenization.html">9.2.4 Tokenization &rarr;</a>
  <ol class="toc"><li><ol><li><a href="parsing.html#parsing"><span class="secno">9.2 </span>Parsing HTML documents</a>
    <ol><li><a href="parsing.html#overview-of-the-parsing-model"><span class="secno">9.2.1 </span>Overview of the parsing model</a><li><a href="parsing.html#the-input-stream"><span class="secno">9.2.2 </span>The input stream</a>
      <ol><li><a href="parsing.html#determining-the-character-encoding"><span class="secno">9.2.2.1 </span>Determining the character encoding</a><li><a href="parsing.html#character-encodings-0"><span class="secno">9.2.2.2 </span>Character encodings</a><li><a href="parsing.html#preprocessing-the-input-stream"><span class="secno">9.2.2.3 </span>Preprocessing the input stream</a><li><a href="parsing.html#changing-the-encoding-while-parsing"><span class="secno">9.2.2.4 </span>Changing the encoding while parsing</a></ol><li><a href="parsing.html#parse-state"><span class="secno">9.2.3 </span>Parse state</a>
      <ol><li><a href="parsing.html#the-insertion-mode"><span class="secno">9.2.3.1 </span>The insertion mode</a><li><a href="parsing.html#the-stack-of-open-elements"><span class="secno">9.2.3.2 </span>The stack of open elements</a><li><a href="parsing.html#the-list-of-active-formatting-elements"><span class="secno">9.2.3.3 </span>The list of active formatting elements</a><li><a href="parsing.html#the-element-pointers"><span class="secno">9.2.3.4 </span>The element pointers</a><li><a href="parsing.html#other-parsing-state-flags"><span class="secno">9.2.3.5 </span>Other parsing state flags</a></ol></ol></ol></ol></nav>

  <div class="impl">

  <h3 id="parsing"><span class="secno">9.2 </span>Parsing HTML documents</h3>

  <p><i>This section only applies to user agents, data mining tools,
  and conformance checkers.</i></p>

  <p class="note">The rules for parsing XML documents into DOM trees
  are covered by the next section, entitled "<a href="the-xhtml-syntax.html#the-xhtml-syntax">The XHTML
  syntax</a>".</p>

  <p>For <a href="dom.html#html-documents">HTML documents</a>, user agents must use the parsing
  rules described in this section to generate the DOM trees. Together,
  these rules define what is referred to as the <dfn id="html-parser">HTML
  parser</dfn>.</p>

  <div class="note">

   <p>While the HTML syntax described in this specification bears a
   close resemblance to SGML and XML, it is a separate language with
   its own parsing rules.</p>

   <p>Some earlier versions of HTML (in particular from HTML2 to
   HTML4) were based on SGML and used SGML parsing rules. However, few
   (if any) web browsers ever implemented true SGML parsing for HTML
   documents; the only user agents to strictly handle HTML as an SGML
   application have historically been validators. The resulting
   confusion &mdash; with validators claiming documents to have one
   representation while widely deployed Web browsers interoperably
   implemented a different representation &mdash; has wasted decades
   of productivity. This version of HTML thus returns to a non-SGML
   basis.</p>

   <p>Authors interested in using SGML tools in their authoring
   pipeline are encouraged to use XML tools and the XML serialization
   of HTML.</p>

  </div>

  <p>This specification defines the parsing rules for HTML documents,
  whether they are syntactically correct or not. Certain points in the
  parsing algorithm are said to be <dfn id="parse-error" title="parse error">parse
  errors</dfn>. The error handling for parse errors is well-defined:
  user agents must either act as described below when encountering
  such problems, or must abort processing at the first error that they
  encounter for which they do not wish to apply the rules described
  below.</p>

  <p>Conformance checkers must report at least one parse error
  condition to the user if one or more parse error conditions exist in
  the document and must not report parse error conditions if none
  exist in the document. Conformance checkers may report more than one
  parse error condition if more than one parse error condition exists
  in the document. Conformance checkers are not required to recover
  from parse errors.</p>

  <p class="note">Parse errors are only errors with the
  <em>syntax</em> of HTML. In addition to checking for parse errors,
  conformance checkers will also verify that the document obeys all
  the other conformance requirements described in this
  specification.</p>

  <p>For the purposes of conformance checkers, if a resource is
  determined to be in <a href="syntax.html#syntax">the HTML syntax</a>, then it is an
  <a href="dom.html#html-documents" title="HTML documents">HTML document</a>.</p>

  </div>


  <div class="impl">

  <h4 id="overview-of-the-parsing-model"><span class="secno">9.2.1 </span>Overview of the parsing model</h4>

  <p>The input to the HTML parsing process consists of a stream of
  Unicode characters, which is passed through a
  <a href="tokenization.html#tokenization">tokenization</a> stage followed by a <a href="tokenization.html#tree-construction">tree
  construction</a> stage. The output is a <code>Document</code>
  object.</p>

  <p class="note">Implementations that <a href="infrastructure.html#non-scripted">do not
  support scripting</a> do not have to actually create a DOM
  <code>Document</code> object, but the DOM tree in such cases is
  still used as the model for the rest of the specification.</p>

  <p>In the common case, the data handled by the tokenization stage
  comes from the network, but <a href="apis-in-html-documents.html#dynamic-markup-insertion" title="dynamic markup
  insertion">it can also come from script</a>, e.g. using the <code title="dom-document-write"><a href="apis-in-html-documents.html#dom-document-write">document.write()</a></code> API.</p>

  <p><img alt="" src="images/parsing-model-overview.png"></p>

  <p id="nestedParsing">There is only one set of states for the
  tokenizer stage and the tree construction stage, but the tree
  construction stage is reentrant, meaning that while the tree
  construction stage is handling one token, the tokenizer might be
  resumed, causing further tokens to be emitted and processed before
  the first token's processing is complete.</p>

  <div class="example">

   <p>In the following example, the tree construction stage will be
   called upon to handle a "p" start tag token while handling the
   "script" start tag token:</p>

   <pre>...
&lt;script&gt;
 document.write('&lt;p&gt;');
&lt;/script&gt;
...</pre>

  </div>

  <p>To handle these cases, parsers have a <dfn id="script-nesting-level">script nesting
  level</dfn>, which must be initially set to zero, and a <dfn id="parser-pause-flag">parser
  pause flag</dfn>, which must be initially set to false.</p>

  </div>


  <div class="impl">

  <h4 id="the-input-stream"><span class="secno">9.2.2 </span>The <dfn>input stream</dfn></h4>

  <p>The stream of Unicode characters that comprises the input to the
  tokenization stage will be initially seen by the user agent as a
  stream of bytes (typically coming over the network or from the local
  file system). The bytes encode the actual characters according to a
  particular <em>character encoding</em>, which the user agent must
  use to decode the bytes into characters.</p>

  <p class="note">For XML documents, the algorithm user agents must
  use to determine the character encoding is given by the XML
  specification. This section does not apply to XML documents. <a href="references.html#refsXML">[XML]</a></p>


  <h5 id="determining-the-character-encoding"><span class="secno">9.2.2.1 </span>Determining the character encoding</h5>

  <p>In some cases, it might be impractical to unambiguously determine
  the encoding before parsing the document. Because of this, this
  specification provides for a two-pass mechanism with an optional
  pre-scan. Implementations are allowed, as described below, to apply
  a simplified parsing algorithm to whatever bytes they have available
  before beginning to parse the document. Then, the real parser is
  started, using a tentative encoding derived from this pre-parse and
  other out-of-band metadata. If, while the document is being loaded,
  the user agent discovers an encoding declaration that conflicts with
  this information, then the parser can get reinvoked to perform a
  parse of the document with the real encoding.</p>

  <p id="documentEncoding">User agents must use the following
  algorithm (the <dfn id="encoding-sniffing-algorithm">encoding sniffing algorithm</dfn>) to determine
  the character encoding to use when decoding a document in the first
  pass. This algorithm takes as input any out-of-band metadata
  available to the user agent (e.g. the <a href="urls.html#content-type" title="Content-Type">Content-Type metadata</a> of the document)
  and all the bytes available so far, and returns an encoding and a
  <dfn id="concept-encoding-confidence" title="concept-encoding-confidence">confidence</dfn>. The
  confidence is either <i>tentative</i>, <i>certain</i>, or
  <i>irrelevant</i>. The encoding used, and whether the confidence in
  that encoding is <i>tentative</i> or <i>certain</i>, is <a href="tokenization.html#meta-charset-during-parse">used during the parsing</a> to
  determine whether to <a href="#change-the-encoding">change the encoding</a>. If no
  encoding is necessary, e.g. because the parser is operating on a
  stream of Unicode characters and doesn't have to use an encoding at
  all, then the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a> is
  <i>irrelevant</i>.</p>

  <ol><li><p>If the transport layer specifies an encoding, and it is
   supported, return that encoding with the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a>
   <i>certain</i>, and abort these steps.</li>

   <li><p>The user agent may wait for more bytes of the resource to be
   available, either in this step or at any later step in this
   algorithm. For instance, a user agent might wait 500ms or 512
   bytes, whichever came first. In general preparsing the source to
   find the encoding improves performance, as it reduces the need to
   throw away the data structures used when parsing upon finding the
   encoding information. However, if the user agent delays too long to
   obtain data to determine the encoding, then the cost of the delay
   could outweigh any performance improvements from the
   preparse.</li>

   <li><p>For each of the rows in the following table, starting with
   the first one and going down, if there are as many or more bytes
   available than the number of bytes in the first column, and the
   first bytes of the file match the bytes given in the first column,
   then return the encoding given in the cell in the second column of
   that row, with the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a>
   <i>certain</i>, and abort these steps:</p>

    <!-- this table is present in several forms in this file; keep them in sync -->
    <table><thead><tr><th>Bytes in Hexadecimal
       <th>Encoding
     <tbody><!-- nobody uses this
      <tr>
       <td>00 00 FE FF
       <td>UTF-32BE
      <tr>
       <td>FF FE 00 00
       <td>UTF-32LE
--><tr><td>FE FF
       <td>UTF-16BE
      <tr><td>FF FE
       <td>UTF-16LE
      <tr><td>EF BB BF
       <td>UTF-8
<!-- nobody uses this
      <tr>
       <td>DD 73 66 73
       <td>UTF-EBCDIC
-->
    </table><p class="note">This step looks for Unicode Byte Order Marks
   (BOMs).</li>

   <li><p>Otherwise, the user agent will have to search for explicit
   character encoding information in the file itself. This should
   proceed as follows:

    <p>Let <var title="">position</var> be a pointer to a byte in the
    input stream, initially pointing at the first byte. If at any
    point during these substeps the user agent either runs out of
    bytes or decides that scanning further bytes would not be
    efficient, then skip to the next step of the overall character
    encoding detection algorithm. User agents may decide that scanning
    <em>any</em> bytes is not efficient, in which case these substeps
    are entirely skipped.</p>

    <p>Now, repeat the following "two" steps until the algorithm
    aborts (either because user agent aborts, as described above, or
    because a character encoding is found):</p>

    <ol><li><p>If <var title="">position</var> points to:</p>

      <dl class="switch"><dt>A sequence of bytes starting with: 0x3C 0x21 0x2D 0x2D (ASCII '&lt;!--')</dt>
       <dd>

        <p>Advance the <var title="">position</var> pointer so that it
        points at the first 0x3E byte which is preceded by two 0x2D
        bytes (i.e. at the end of an ASCII '--&gt;' sequence) and comes
        after the 0x3C byte that was found. (The two 0x2D bytes can be
        the same as the those in the '&lt;!--' sequence.)</p>

       </dd>

       <dt>A sequence of bytes starting with: 0x3C, 0x4D or 0x6D, 0x45 or 0x65, 0x54 or 0x74, 0x41 or 0x61, and finally one of 0x09, 0x0A, 0x0C, 0x0D, 0x20, 0x2F (case-insensitive ASCII '&lt;meta' followed by a space or slash)</dt>
       <dd>

        <ol><li><p>Advance the <var title="">position</var> pointer so
         that it points at the next 0x09, 0x0A, 0x0C, 0x0D, 0x20, or
         0x2F byte (the one in sequence of characters matched
         above).</li>

         <li><p><a href="#concept-get-attributes-when-sniffing" title="concept-get-attributes-when-sniffing">Get
         an attribute</a> and its value. If no attribute was
         sniffed, then skip this inner set of steps, and jump to the
         second step in the overall "two step" algorithm.</li>

         <li><p>If the attribute's name is neither "<code title="">charset</code>" nor "<code title="">content</code>",
         then return to step 2 in these inner steps.</li>

         <li><p>If the attribute's name is "<code title="">charset</code>", let <var title="">charset</var> be
         the attribute's value, interpreted as a character
         encoding.</li>

         <li><p>Otherwise, the attribute's name is "<code title="">content</code>": apply the <a href="urls.html#algorithm-for-extracting-an-encoding-from-a-content-type">algorithm for
         extracting an encoding from a Content-Type</a>, giving the
         attribute's value as the string to parse. If an encoding is
         returned, let <var title="">charset</var> be that
         encoding. Otherwise, return to step 2 in these inner
         steps.</li>

         <li><p>If <var title="">charset</var> is a UTF-16 encoding,
         change the value of <var title="">charset</var> to
         UTF-8.</li>

         <li><p>If <var title="">charset</var> is a supported
         character encoding, then return the given encoding, with
         <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a>
         <i>tentative</i>, and abort all these steps.</li>

         <li><p>Otherwise, return to step 2 in these inner
         steps.</li>

        </ol></dd>

       <dt>A sequence of bytes starting with a 0x3C byte (ASCII &lt;), optionally a 0x2F byte (ASCII /), and finally a byte in the range 0x41-0x5A or 0x61-0x7A (an ASCII letter)</dt>
       <dd>

        <ol><li><p>Advance the <var title="">position</var> pointer so
         that it points at the next 0x09 (ASCII TAB), 0x0A (ASCII LF),
         0x0C (ASCII FF), 0x0D (ASCII CR), 0x20 (ASCII space), or 0x3E
         (ASCII &gt;) byte.</li>

         <li><p>Repeatedly <a href="#concept-get-attributes-when-sniffing" title="concept-get-attributes-when-sniffing">get an
         attribute</a> until no further attributes can be found,
         then jump to the second step in the overall "two step"
         algorithm.</li>

        </ol></dd>

       <dt>A sequence of bytes starting with: 0x3C 0x21 (ASCII '&lt;!')</dt>
       <dt>A sequence of bytes starting with: 0x3C 0x2F (ASCII '&lt;/')</dt>
       <dt>A sequence of bytes starting with: 0x3C 0x3F (ASCII '&lt;?')</dt>
       <dd>

        <p>Advance the <var title="">position</var> pointer so that it
        points at the first 0x3E byte (ASCII &gt;) that comes after the
        0x3C byte that was found.</p>

       </dd>

       <dt>Any other byte</dt>
       <dd>

        <p>Do nothing with that byte.</p>

       </dd>

      </dl></li>

     <li>Move <var title="">position</var> so it points at the next
     byte in the input stream, and return to the first step of this
     "two step" algorithm.</li>

    </ol><p>When the above "two step" algorithm says to <dfn id="concept-get-attributes-when-sniffing" title="concept-get-attributes-when-sniffing">get an
    attribute</dfn>, it means doing this:</p>

    <ol><li><p>If the byte at <var title="">position</var> is one of 0x09
     (ASCII TAB), 0x0A (ASCII LF), 0x0C (ASCII FF), 0x0D (ASCII CR),
     0x20 (ASCII space), or 0x2F (ASCII /) then advance <var title="">position</var> to the next byte and redo this
     substep.</li>

     <li><p>If the byte at <var title="">position</var> is 0x3E (ASCII
     &gt;), then abort the "get an attribute" algorithm. There isn't
     one.</li>

     <li><p>Otherwise, the byte at <var title="">position</var> is the
     start of the attribute name. Let <var title="">attribute
     name</var> and <var title="">attribute value</var> be the empty
     string.</li>

     <li><p><i>Attribute name</i>: Process the byte at <var title="">position</var> as follows:</p>

      <dl class="switch"><dt>If it is 0x3D (ASCII =), and the <var title="">attribute
       name</var> is longer than the empty string</dt>

       <dd>Advance <var title="">position</var> to the next byte and
       jump to the step below labeled <i>value</i>.</dd>

       <dt>If it is 0x09 (ASCII TAB), 0x0A (ASCII LF), 0x0C (ASCII
       FF), 0x0D (ASCII CR), or 0x20 (ASCII space)</dt>

       <dd>Jump to the step below labeled <i>spaces</i>.</dd>

       <dt>If it is 0x2F (ASCII /) or 0x3E (ASCII &gt;)</dt>

       <dd>Abort the "get an attribute" algorithm. The attribute's
       name is the value of <var title="">attribute name</var>, its
       value is the empty string.</dd>

       <dt>If it is in the range 0x41 (ASCII A) to 0x5A (ASCII
       Z)</dt>

       <dd>Append the Unicode character with code point <span title=""><var title="">b</var>+0x20</span> to <var title="">attribute
       name</var> (where <var title="">b</var> is the value of the
       byte at <var title="">position</var>).</dd>

       <dt>Anything else</dt>

       <dd>Append the Unicode character with the same code point as the
       value of the byte at <var title="">position</var>) to <var title="">attribute name</var>. (It doesn't actually matter how
       bytes outside the ASCII range are handled here, since only
       ASCII characters can contribute to the detection of a character
       encoding.)</dd>

      </dl></li>

     <li><p>Advance <var title="">position</var> to the next byte and
     return to the previous step.</li>

     <li><p><i>Spaces</i>: If the byte at <var title="">position</var> is one of 0x09 (ASCII TAB), 0x0A (ASCII
     LF), 0x0C (ASCII FF), 0x0D (ASCII CR), or 0x20 (ASCII space) then
     advance <var title="">position</var> to the next byte, then,
     repeat this step.</li>

     <li><p>If the byte at <var title="">position</var> is
     <em>not</em> 0x3D (ASCII =), abort the "get an attribute"
     algorithm. The attribute's name is the value of <var title="">attribute name</var>, its value is the empty
     string.</li>

     <li><p>Advance <var title="">position</var> past the 0x3D (ASCII
     =) byte.</li>

     <li><p><i>Value:</i> If the byte at <var title="">position</var> is one of 0x09 (ASCII TAB), 0x0A (ASCII
     LF), 0x0C (ASCII FF), 0x0D (ASCII CR), or 0x20 (ASCII space) then
     advance <var title="">position</var> to the next byte, then,
     repeat this step.</li>

     <li><p>Process the byte at <var title="">position</var> as
     follows:</p>

      <dl class="switch"><dt>If it is 0x22 (ASCII ") or 0x27 (ASCII ')</dt>

       <dd>

        <ol><li>Let <var title="">b</var> be the value of the byte at
         <var title="">position</var>.</li>

         <li>Advance <var title="">position</var> to the next
         byte.</li>

         <li>If the value of the byte at <var title="">position</var>
         is the value of <var title="">b</var>, then advance <var title="">position</var> to the next byte and abort the "get
         an attribute" algorithm. The attribute's name is the value of
         <var title="">attribute name</var>, and its value is the
         value of <var title="">attribute value</var>.</li>

         <li>Otherwise, if the value of the byte at <var title="">position</var> is in the range 0x41 (ASCII A) to
         0x5A (ASCII Z), then append a Unicode character to <var title="">attribute value</var> whose code point is 0x20 more
         than the value of the byte at <var title="">position</var>.</li>

         <li>Otherwise, append a Unicode character to <var title="">attribute value</var> whose code point is the same as
         the value of the byte at <var title="">position</var>.</li>

         <li>Return to the second step in these substeps.</li>

        </ol></dd>

       <dt>If it is 0x3E (ASCII &gt;)</dt>

       <dd>Abort the "get an attribute" algorithm. The attribute's
       name is the value of <var title="">attribute name</var>, its
       value is the empty string.</dd>


       <dt>If it is in the range 0x41 (ASCII A) to 0x5A (ASCII
       Z)</dt>

       <dd>Append the Unicode character with code point <span title=""><var title="">b</var>+0x20</span> to <var title="">attribute
       value</var> (where <var title="">b</var> is the value of the
       byte at <var title="">position</var>). Advance <var title="">position</var> to the next byte.</dd>

       <dt>Anything else</dt>

       <dd>Append the Unicode character with the same code point as the
       value of the byte at <var title="">position</var>) to <var title="">attribute value</var>. Advance <var title="">position</var> to the next byte.</dd>

      </dl></li>

     <li><p>Process the byte at <var title="">position</var> as
     follows:</p>

      <dl class="switch"><dt>If it is 0x09 (ASCII TAB), 0x0A (ASCII LF), 0x0C (ASCII
       FF), 0x0D (ASCII CR), 0x20 (ASCII space), or 0x3E (ASCII
       &gt;)</dt>

       <dd>Abort the "get an attribute" algorithm. The attribute's
       name is the value of <var title="">attribute name</var> and its
       value is the value of <var title="">attribute value</var>.</dd>

       <dt>If it is in the range 0x41 (ASCII A) to 0x5A (ASCII
       Z)</dt>

       <dd>Append the Unicode character with code point <span title=""><var title="">b</var>+0x20</span> to <var title="">attribute
       value</var> (where <var title="">b</var> is the value of the
       byte at <var title="">position</var>).</dd>

       <dt>Anything else</dt>

       <dd>Append the Unicode character with the same code point as the
       value of the byte at <var title="">position</var>) to <var title="">attribute value</var>.</dd>

      </dl></li>

     <li><p>Advance <var title="">position</var> to the next byte and
     return to the previous step.</li>

    </ol><p>For the sake of interoperability, user agents should not use a
    pre-scan algorithm that returns different results than the one
    described above. (But, if you do, please at least let us know, so
    that we can improve this algorithm and benefit everyone...)</p>

   </li>

   <li><p>If the user agent has information on the likely encoding for
   this page, e.g. based on the encoding of the page when it was last
   visited, then return that encoding, with the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a>
   <i>tentative</i>, and abort these steps.</li>

   <li>

    <p>The user agent may attempt to autodetect the character encoding
    from applying frequency analysis or other algorithms to the data
    stream. Such algorithms may use information about the resource
    other than the resource's contents, including the address of the
    resource. If autodetection succeeds in determining a character
    encoding, then return that encoding, with the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a>
    <i>tentative</i>, and abort these steps. <a href="references.html#refsUNIVCHARDET">[UNIVCHARDET]</a></p>

    <p class="note">The UTF-8 encoding has a highly detectable bit
    pattern. Documents that contain bytes with values greater than
    0x7F which match the UTF-8 pattern are very likely to be UTF-8,
    while documents with byte sequences that do not match it are very
    likely not. User-agents are therefore encouraged to search for
    this common encoding. <a href="references.html#refsPPUTF8">[PPUTF8]</a> <a href="references.html#refsUTF8DET">[UTF8DET]</a></p>

   </li>

   <li>

    <p>Otherwise, return an implementation-defined or user-specified
    default character encoding, with the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a>
    <i>tentative</i>.</p>

    <p>In controlled environments or in environments where the
    encoding of documents can be prescribed (for example, for user
    agents intended for dedicated use in new networks), the
    comprehensive <code title="">UTF-8</code> encoding is
    suggested.</p>

    <p>In other environments, the default encoding is typically
    dependent on the user's locale (an approximation of the languages,
    and thus typically encodings, of the pages that the user is likely
    to frequent). The following table gives suggested defaults based
    on the user's locale, for compatibility with legacy
    content. Locales are identified by BCP 47 language codes. <a href="references.html#refsBCP47">[BCP47]</a></p>

    <!-- based on mozilla 1.9.1 localizations: 
         http://mxr.mozilla.org/l10n-mozilla1.9.1/find?string=global%2Fintl.properties&tree=l10n-mozilla1.9.1&hint= -->

    <table><thead><tr><th>Locale language
       <th>Suggested default encoding
     <tbody><tr><td>ar
       <td>UTF-8

      <tr><td>be
       <td>ISO-8859-5

      <tr><td>bg
       <td>windows-1251

      <tr><td>cs<!-- -CZ -->
       <td>ISO-8859-2

      <tr><td>cy
       <td>UTF-8

      <tr><td>fa<!-- -IR -->
       <td>UTF-8

      <tr><td>he<!-- -IL -->
       <td>windows-1255

      <tr><td>hr
       <td>UTF-8

      <tr><td>hu<!-- -HU -->
       <td>ISO-8859-2

      <tr><td>ja <!-- and ja-JP-mac -->
       <td>windows-31J <!-- Shift_JIS -->

      <tr><td>kk
       <td>UTF-8

      <tr><td>ko<!-- -KR -->
       <td>windows-949 <!-- EUC-KR -->

      <tr><td>ku
       <td>windows-1254 <!-- ISO-8859-9 -->

      <tr><td>lt
       <td>windows-1257

      <tr><td>lv<!-- -LV -->
       <td>ISO-8859-13

      <tr><td>mk<!-- -MK -->
       <td>UTF-8

      <tr><td>or
       <td>UTF-8

      <tr><td>pl<!-- -PL -->
       <td>ISO-8859-2

      <tr><td>ro
       <td>UTF-8

      <tr><td>ru
       <td>windows-1251

      <tr><td>sk
       <td>windows-1250

      <tr><td>sl
       <td>ISO-8859-2

      <tr><td>sr
       <td>UTF-8

      <tr><td>th
       <td>windows-874 <!-- TIS-620 -->

      <tr><td>tr<!-- -TR -->
       <td>windows-1254 <!-- ISO-8859-9 -->

      <tr><td>uk
       <td>windows-1251

      <tr><td>vi
       <td>UTF-8

      <tr><td>zh-CN
       <td>GB18030

      <tr><td>zh-TW
       <td>Big5

      <tr><td>All other locales
       <td>windows-1252

    </table></li>

  </ol><p>The <a href="dom.html#document's-character-encoding">document's character encoding</a> must immediately
  be set to the value returned from this algorithm, at the same time
  as the user agent uses the returned value to select the decoder to
  use for the input stream.</p>

  <p class="note">This algorithm is a <a href="introduction.html#willful-violation">willful violation</a>
  of the HTTP specification, which requires that the encoding be
  assumed to be ISO-8859-1 in the absence of a <a href="semantics.html#character-encoding-declaration">character
  encoding declaration</a> to the contrary, and of RFC 2046,
  which requires that the encoding be assumed to be US-ASCII in the
  absence of a <a href="semantics.html#character-encoding-declaration">character encoding declaration</a> to the
  contrary. This specification's third approach is motivated by a
  desire to be maximally compatible with legacy content. <a href="references.html#refsHTTP">[HTTP]</a> <a href="references.html#refsRFC2046">[RFC2046]</a></p>


  <h5 id="character-encodings-0"><span class="secno">9.2.2.2 </span>Character encodings</h5>

  <p>User agents must at a minimum support the UTF-8 and Windows-1252
  encodings, but may support more.</p>

  <p class="note">It is not unusual for Web browsers to support dozens
  if not upwards of a hundred distinct character encodings.</p>

  <p>User agents must support the <a href="infrastructure.html#preferred-mime-name">preferred MIME name</a> of
  every character encoding they support, and should support all the
  IANA-registered names and aliases of every character encoding they
  support. <a href="references.html#refsIANACHARSET">[IANACHARSET]</a></p>

  <p>When comparing a string specifying a character encoding with the
  name or alias of a character encoding to determine if they are
  equal, user agents must remove any leading or trailing <a href="common-microsyntaxes.html#space-character" title="space character">space characters</a> in both names, and
  then perform the comparison in an <a href="infrastructure.html#ascii-case-insensitive">ASCII
  case-insensitive</a> manner.</p>

  <hr><p>When a user agent would otherwise use an encoding given in the
  first column of the following table to either convert content to
  Unicode characters or convert Unicode characters to bytes, it must
  instead use the encoding given in the cell in the second column of
  the same row. When a byte or sequence of bytes is treated
  differently due to this encoding aliasing, it is said to have been
  <dfn id="misinterpreted-for-compatibility">misinterpreted for compatibility</dfn>.</p>

  <table><caption>Character encoding overrides</caption>
   <thead><tr><th> Input encoding <th> Replacement encoding <th> References
   <tbody><!-- how about EUC-JP? --><tr><td> EUC-KR <td> windows-949 <td>
         <a href="references.html#refsEUCKR">[EUCKR]</a>
         <a href="references.html#refsWIN949">[WIN949]</a>
    <tr><td> GB2312 <td> GBK <td>
         <a href="references.html#refsRFC1345">[RFC1345]</a>
         <a href="references.html#refsGBK">[GBK]</a>
    <tr><td> GB_2312-80 <td> GBK <td>
         <a href="references.html#refsRFC1345">[RFC1345]</a>
         <a href="references.html#refsGBK">[GBK]</a>
    <tr><td> ISO-8859-1 <td> windows-1252 <td>
         <a href="references.html#refsRFC1345">[RFC1345]</a>
         <a href="references.html#refsWIN1252">[WIN1252]</a>
    <tr><td> ISO-8859-9 <td> windows-1254 <td>
         <a href="references.html#refsRFC1345">[RFC1345]</a>
         <a href="references.html#refsWIN1254">[WIN1254]</a>
    <tr><td> ISO-8859-11 <td> windows-874 <td>
         <a href="references.html#refsISO885911">[ISO885911]</a>
         <a href="references.html#refsWIN874">[WIN874]</a>
    <tr><td> KS_C_5601-1987 <td> windows-949 <td>
         <a href="references.html#refsRFC1345">[RFC1345]</a>
         <a href="references.html#refsWIN949">[WIN949]</a>
    <tr><td> Shift_JIS <td> windows-31J <td>
         <a href="references.html#refsSHIFTJIS">[SHIFTJIS]</a>
         <a href="references.html#refsWIN31J">[WIN31J]</a>
    <tr><td> TIS-620 <td> windows-874 <td>
         <a href="references.html#refsTIS620">[TIS620]</a>
         <a href="references.html#refsWIN874">[WIN874]</a>
    <tr><td> US-ASCII <td> windows-1252 <td>
         <a href="references.html#refsRFC1345">[RFC1345]</a>
         <a href="references.html#refsWIN1252">[WIN1252]</a>
   </table><p class="note">The requirement to treat certain encodings as other
  encodings according to the table above is a <a href="introduction.html#willful-violation">willful
  violation</a> of the W3C Character Model specification, motivated
  by a desire for compatibility with legacy content. <a href="references.html#refsCHARMOD">[CHARMOD]</a></p>

  <p>When a user agent is to use the UTF-16 encoding but no BOM has
  been found, user agents must default to UTF-16LE.</p>

  <p class="note">The requirement to default UTF-16 to LE rather than
  BE is a <a href="introduction.html#willful-violation">willful violation</a> of RFC 2781, motivated by a
  desire for compatibility with legacy content. <a href="references.html#refsRFC2781">[RFC2781]</a></p>

  <hr><p>User agents must not support the CESU-8, UTF-7, BOCU-1 and SCSU
  encodings. <a href="references.html#refsCESU8">[CESU8]</a> <a href="references.html#refsUTF7">[UTF7]</a> <a href="references.html#refsBOCU1">[BOCU1]</a> <a href="references.html#refsSCSU">[SCSU]</a></p>

  <p>Support for encodings based on EBCDIC is not recommended. This
  encoding is rarely used for publicly-facing Web content.</p>

  <p>Support for UTF-32 is not recommended. This encoding is rarely
  used, and frequently implemented incorrectly.</p>

  <p class="note">This specification does not make any attempt to
  support EBCDIC-based encodings and UTF-32 in its algorithms; support
  and use of these encodings can thus lead to unexpected behavior in
  implementations of this specification.</p>



  <h5 id="preprocessing-the-input-stream"><span class="secno">9.2.2.3 </span>Preprocessing the input stream</h5>

  <p>Given an encoding, the bytes in the input stream must be
  converted to Unicode characters for the tokenizer, as described by
  the rules for that encoding, except that the leading U+FEFF BYTE
  ORDER MARK character, if any, must not be stripped by the encoding
  layer (it is stripped by the rule below).</p> <!-- this is to
  prevent two leading BOMs from being both stripped, once by the
  decoder, and once by the parser -->

  <p>Bytes or sequences of bytes in the original byte stream that
  could not be converted to Unicode code points must be converted to
  U+FFFD REPLACEMENT CHARACTERs.</p>

  <p class="note">Bytes or sequences of bytes in the original byte
  stream that did not conform to the encoding specification
  (e.g. invalid UTF-8 byte sequences in a UTF-8 input stream) are
  errors that conformance checkers are expected to report.</p>

  <p>Any byte or sequence of bytes in the original byte stream that is
  <a href="#misinterpreted-for-compatibility">misinterpreted for compatibility</a> is a <a href="#parse-error">parse
  error</a>.</p>

  <p>One leading U+FEFF BYTE ORDER MARK character must be ignored if
  any are present.</p>

  <p class="note">The requirement to strip a U+FEFF BYTE ORDER MARK
  character regardless of whether that character was used to determine
  the byte order is a <a href="introduction.html#willful-violation">willful violation</a> of Unicode,
  motivated by a desire to increase the resilience of user agents in
  the face of na&iuml;ve transcoders.</p>

  <p>All U+0000 NULL characters and code points in the range U+D800 to
  U+DFFF<!-- surrogates not allowed e.g. in UTF-8, and we don't want
  them to suddenly turn into codepoints when they go through a UTF-16
  pipe --> in the input must be replaced by U+FFFD REPLACEMENT
  CHARACTERs. Any occurrences of such characters and code points are
  <a href="#parse-error" title="parse error">parse errors</a>.</p>

  <p>Any occurrences of any characters in the ranges U+0001 to U+0008,
  <!-- HT, LF allowed --> <!-- U+000B is in the next list --> <!-- FF,
  CR allowed --> U+000E to U+001F, <!-- ASCII allowed --> U+007F
  <!--to U+0084, (U+0085 NEL not allowed), U+0086--> to U+009F, U+FDD0
  to U+FDEF, and characters U+000B, U+FFFE, U+FFFF, U+1FFFE, U+1FFFF,
  U+2FFFE, U+2FFFF, U+3FFFE, U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE,
  U+5FFFF, U+6FFFE, U+6FFFF, U+7FFFE, U+7FFFF, U+8FFFE, U+8FFFF,
  U+9FFFE, U+9FFFF, U+AFFFE, U+AFFFF, U+BFFFE, U+BFFFF, U+CFFFE,
  U+CFFFF, U+DFFFE, U+DFFFF, U+EFFFE, U+EFFFF, U+FFFFE, U+FFFFF,
  U+10FFFE, and U+10FFFF are <a href="#parse-error" title="parse error">parse
  errors</a>. These are all control characters or permanently
  undefined Unicode characters (noncharacters).</p>

  <p>U+000D CARRIAGE RETURN (CR) characters and U+000A LINE FEED (LF)
  characters are treated specially. Any CR characters that are
  followed by LF characters must be removed, and any CR characters not
  followed by LF characters must be converted to LF characters. Thus,
  newlines in HTML DOMs are represented by LF characters, and there
  are never any CR characters in the input to the
  <a href="tokenization.html#tokenization">tokenization</a> stage.</p>

  <p>The <dfn id="next-input-character">next input character</dfn> is the first character in the
  input stream that has not yet been <dfn id="consumed">consumed</dfn>. Initially,
  the <i><a href="#next-input-character">next input character</a></i> is the first character in the
  input. The <dfn id="current-input-character">current input character</dfn> is the last character
  to have been <i><a href="#consumed">consumed</a></i>.</p>

  <p>The <dfn id="insertion-point">insertion point</dfn> is the position (just before a
  character or just before the end of the input stream) where content
  inserted using <code title="dom-document-write"><a href="apis-in-html-documents.html#dom-document-write">document.write()</a></code> is actually
  inserted. The insertion point is relative to the position of the
  character immediately after it, it is not an absolute offset into
  the input stream. Initially, the insertion point is
  undefined.</p>

  <p>The "EOF" character in the tables below is a conceptual character
  representing the end of the <a href="#the-input-stream">input stream</a>. If the parser
  is a <a href="apis-in-html-documents.html#script-created-parser">script-created parser</a>, then the end of the
  <a href="#the-input-stream">input stream</a> is reached when an <dfn id="explicit-eof-character">explicit "EOF"
  character</dfn> (inserted by the <code title="dom-document-close"><a href="apis-in-html-documents.html#dom-document-close">document.close()</a></code> method) is
  consumed. Otherwise, the "EOF" character is not a real character in
  the stream, but rather the lack of any further characters.</p>


  <h5 id="changing-the-encoding-while-parsing"><span class="secno">9.2.2.4 </span>Changing the encoding while parsing</h5>

  <p>When the parser requires the user agent to <dfn id="change-the-encoding">change the
  encoding</dfn>, it must run the following steps. This might happen
  if the <a href="#encoding-sniffing-algorithm">encoding sniffing algorithm</a> described above
  failed to find an encoding, or if it found an encoding that was not
  the actual encoding of the file.</p>

  <ol><li>If the new encoding is identical or equivalent to the encoding
   that is already being used to interpret the input stream, then set
   the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a> to
   <i>certain</i> and abort these steps. This happens when the
   encoding information found in the file matches what the
   <a href="#encoding-sniffing-algorithm">encoding sniffing algorithm</a> determined to be the
   encoding, and in the second pass through the parser if the first
   pass found that the encoding sniffing algorithm described in the
   earlier section failed to find the right encoding.</li>

   <li>If the encoding that is already being used to interpret the
   input stream is a UTF-16 encoding, then set the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a> to
   <i>certain</i> and abort these steps. The new encoding is ignored;
   if it was anything but the same encoding, then it would be clearly
   incorrect.</li>

   <li>If the new encoding is a UTF-16 encoding, change it to
   UTF-8.</li>

   <li>If all the bytes up to the last byte converted by the current
   decoder have the same Unicode interpretations in both the current
   encoding and the new encoding, and if the user agent supports
   changing the converter on the fly, then the user agent may change
   to the new converter for the encoding on the fly. Set the
   <a href="dom.html#document's-character-encoding">document's character encoding</a> and the encoding used to
   convert the input stream to the new encoding, set the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a> to
   <i>certain</i>, and abort these steps.</li>

   <li>Otherwise, <a href="history.html#navigate">navigate</a> to the document again, with
   <a href="history.html#replacement-enabled">replacement enabled</a>, and using the same <a href="history.html#source-browsing-context">source
   browsing context</a>, but this time skip the <a href="#encoding-sniffing-algorithm">encoding
   sniffing algorithm</a> and instead just set the encoding to the
   new encoding and the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a> to
   <i>certain</i>. Whenever possible, this should be done without
   actually contacting the network layer (the bytes should be
   re-parsed from memory), even if, e.g., the document is marked as
   not being cacheable. If this is not possible and contacting the
   network layer would involve repeating a request that uses a method
   other than HTTP GET (<a href="urls.html#concept-http-equivalent-get" title="concept-http-equivalent-get">or
   equivalent</a> for non-HTTP URLs), then instead set the <a href="#concept-encoding-confidence" title="concept-encoding-confidence">confidence</a> to
   <i>certain</i> and ignore the new encoding. The resource will be
   misinterpreted. User agents may notify the user of the situation,
   to aid in application development.</li>

  </ol></div>


  <div class="impl">

  <h4 id="parse-state"><span class="secno">9.2.3 </span>Parse state</h4>

  <h5 id="the-insertion-mode"><span class="secno">9.2.3.1 </span>The insertion mode</h5>

  <p>The <dfn id="insertion-mode">insertion mode</dfn> is a state variable that controls
  the primary operation of the tree construction stage.</p>

  <p>Initially, the <a href="#insertion-mode">insertion mode</a> is "<a href="tokenization.html#the-initial-insertion-mode" title="insertion mode: initial">initial</a>". It can change to
  "<a href="tokenization.html#the-before-html-insertion-mode" title="insertion mode: before html">before html</a>",
  "<a href="tokenization.html#the-before-head-insertion-mode" title="insertion mode: before head">before head</a>",
  "<a href="tokenization.html#parsing-main-inhead" title="insertion mode: in head">in head</a>", "<a href="tokenization.html#parsing-main-inheadnoscript" title="insertion mode: in head noscript">in head noscript</a>",
  "<a href="tokenization.html#the-after-head-insertion-mode" title="insertion mode: after head">after head</a>", "<a href="tokenization.html#parsing-main-inbody" title="insertion mode: in body">in body</a>", "<a href="tokenization.html#parsing-main-incdata" title="insertion mode: text">text</a>",
  "<a href="tokenization.html#parsing-main-intable" title="insertion mode: in table">in table</a>", "<a href="tokenization.html#parsing-main-intabletext" title="insertion mode: in table text">in table text</a>", "<a href="tokenization.html#parsing-main-incaption" title="insertion mode: in caption">in caption</a>", "<a href="tokenization.html#parsing-main-incolgroup" title="insertion mode: in column group">in column group</a>",
  "<a href="tokenization.html#parsing-main-intbody" title="insertion mode: in table body">in table body</a>",
  "<a href="tokenization.html#parsing-main-intr" title="insertion mode: in row">in row</a>", "<a href="tokenization.html#parsing-main-intd" title="insertion mode: in cell">in cell</a>", "<a href="tokenization.html#parsing-main-inselect" title="insertion mode: in select">in select</a>", "<a href="tokenization.html#parsing-main-inselectintable" title="insertion mode: in select in table">in select in
  table</a>", "<a href="tokenization.html#parsing-main-inforeign" title="insertion mode: in foreign content">in
  foreign content</a>", "<a href="tokenization.html#parsing-main-afterbody" title="insertion mode: after
  body">after body</a>", "<a href="tokenization.html#parsing-main-inframeset" title="insertion mode: in
  frameset">in frameset</a>", "<a href="tokenization.html#parsing-main-afterframeset" title="insertion mode: after
  frameset">after frameset</a>", "<a href="tokenization.html#the-after-after-body-insertion-mode" title="insertion mode:
  after after body">after after body</a>", and "<a href="tokenization.html#the-after-after-frameset-insertion-mode" title="insertion mode: after after frameset">after after
  frameset</a>" during the course of the parsing, as described in
  the <a href="tokenization.html#tree-construction">tree construction</a> stage. The insertion mode affects
  how tokens are processed and whether CDATA sections are
  supported.</p>

  <p>Seven of these modes, namely "<a href="tokenization.html#parsing-main-inhead" title="insertion mode: in
  head">in head</a>", "<a href="tokenization.html#parsing-main-inbody" title="insertion mode: in body">in
  body</a>", "<a href="tokenization.html#parsing-main-intable" title="insertion mode: in table">in
  table</a>", "<a href="tokenization.html#parsing-main-intbody" title="insertion mode: in table body">in table
  body</a>", "<a href="tokenization.html#parsing-main-intr" title="insertion mode: in row">in row</a>",
  "<a href="tokenization.html#parsing-main-intd" title="insertion mode: in cell">in cell</a>", and "<a href="tokenization.html#parsing-main-inselect" title="insertion mode: in select">in select</a>", are special, in
  that the other modes defer to them at various times. When the
  algorithm below says that the user agent is to do something
  "<dfn id="using-the-rules-for">using the rules for</dfn> the <var title="">m</var> insertion
  mode", where <var title="">m</var> is one of these modes, the user
  agent must use the rules described under the <var title="">m</var>
  <a href="#insertion-mode">insertion mode</a>'s section, but must leave the
  <a href="#insertion-mode">insertion mode</a> unchanged unless the rules in <var title="">m</var> themselves switch the <a href="#insertion-mode">insertion mode</a>
  to a new value.</p>

  <p>When the insertion mode is switched to "<a href="tokenization.html#parsing-main-incdata" title="insertion
  mode: text">text</a>" or "<a href="tokenization.html#parsing-main-intabletext" title="insertion mode: in table
  text">in table text</a>", the <dfn id="original-insertion-mode">original insertion mode</dfn>
  is also set. This is the insertion mode to which the tree
  construction stage will return.</p>

  <p>When the insertion mode is switched to "<a href="tokenization.html#parsing-main-inforeign" title="insertion
  mode: in foreign content">in foreign content</a>", the
  <dfn id="secondary-insertion-mode">secondary insertion mode</dfn> is also set. This secondary mode
  is used within the rules for the "<a href="tokenization.html#parsing-main-inforeign" title="insertion mode: in
  foreign content">in foreign content</a>" mode to handle HTML
  (i.e. not foreign) content.</p>

  <hr><p>When the steps below require the UA to <dfn id="reset-the-insertion-mode-appropriately">reset the insertion
  mode appropriately</dfn>, it means the UA must follow these
  steps:</p>

  <ol><li>Let <var title="">last</var> be false.</li>

   <li>Let <var title="">foreign</var> be false.</li>

   <li>Let <var title="">node</var> be the last node in the
   <a href="#stack-of-open-elements">stack of open elements</a>.</li>

   <li><i>Loop</i>: If <var title="">node</var> is the first node in
   the stack of open elements, then set <var title="">last</var> to
   true and set <var title="">node</var> to the <var title="">context</var> element. (<a href="the-end.html#fragment-case">fragment case</a>)</li>

   <li>If <var title="">node</var> is a <code><a href="the-button-element.html#the-select-element">select</a></code> element,
   then switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-inselect" title="insertion mode: in select">in select</a>" and jump to the
   step marked <i title="">end</i>. (<a href="the-end.html#fragment-case">fragment case</a>)</li>

   <li>If <var title="">node</var> is a <code><a href="tabular-data.html#the-td-element">td</a></code> or
   <code><a href="tabular-data.html#the-th-element">th</a></code> element and <var title="">last</var> is false, then
   switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-intd" title="insertion
   mode: in cell">in cell</a>" and jump to the step marked <i title="">end</i>.</li>

   <li>If <var title="">node</var> is a <code><a href="tabular-data.html#the-tr-element">tr</a></code> element, then
   switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-intr" title="insertion
   mode: in row">in row</a>" and jump to the step marked <i title="">end</i>.</li>

   <li>If <var title="">node</var> is a <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>,
   <code><a href="tabular-data.html#the-thead-element">thead</a></code>, or <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code> element, then switch the
   <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-intbody" title="insertion mode: in
   table body">in table body</a>" and jump to the step marked <i title="">end</i>.</li>

   <li>If <var title="">node</var> is a <code><a href="tabular-data.html#the-caption-element">caption</a></code> element,
   then switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-incaption" title="insertion mode: in caption">in caption</a>" and jump to
   the step marked <i title="">end</i>.</li>

   <li>If <var title="">node</var> is a <code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code> element,
   then switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-incolgroup" title="insertion mode: in column group">in column group</a>" and
   jump to the step marked <i title="">end</i>. (<a href="the-end.html#fragment-case">fragment
   case</a>)</li>

   <li>If <var title="">node</var> is a <code><a href="tabular-data.html#the-table-element">table</a></code> element,
   then switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-intable" title="insertion mode: in table">in table</a>" and jump to the
   step marked <i title="">end</i>.</li>

   <li>If <var title="">node</var> is a <code><a href="semantics.html#the-head-element-0">head</a></code> element,
   then switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-inbody" title="insertion mode: in body">in body</a>" ("<a href="tokenization.html#parsing-main-inbody" title="insertion mode: in body">in body</a>"! <em> not "<a href="tokenization.html#parsing-main-inhead" title="insertion mode: in head">in head</a>"</em>!) and jump to
   the step marked <i title="">end</i>. (<a href="the-end.html#fragment-case">fragment
   case</a>)</li> <!-- This is only here for now in case people
   think that the spec accidentally omitted it and try to "fix"
   it. Note that noscript-in-head is also handled this way. This is
   all intentional. The only thing it doesn't handle is the
   scripting-disabled fragment parsing case for a <head> element
   containing a <noscript> which itself contains something other than
   a <link> or a <style> element; you'd expect that to break out of
   the <noscript> but it doesn't. This is an edge case that doesn't
   affect the spec, since the algorithm for fragment parsing is only
   used for innerHTML/outerHTML/insertAdjacentHTML(), where we know
   scripting is enabled. -->

   <li>If <var title="">node</var> is a <code><a href="sections.html#the-body-element-0">body</a></code> element,
   then switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-inbody" title="insertion mode: in body">in body</a>" and jump to the
   step marked <i title="">end</i>.</li>

   <li>If <var title="">node</var> is a <code><a href="obsolete.html#frameset">frameset</a></code> element,
   then switch the <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-inframeset" title="insertion mode: in frameset">in frameset</a>" and jump to
   the step marked <i title="">end</i>. (<a href="the-end.html#fragment-case">fragment
   case</a>)</li>

   <li>If <var title="">node</var> is an <code><a href="semantics.html#the-html-element-0">html</a></code> element,
   then <!--: if the <span><code title="">head</code> element
   pointer</span> is null,--> switch the <a href="#insertion-mode">insertion mode</a>
   to "<a href="tokenization.html#the-before-head-insertion-mode" title="insertion mode: before head">before
   head</a>"<!--, otherwise, switch the <span>insertion mode</span>
   to "<span title="insertion mode: after head">after head</span>".-->
   Then, <!-- in either case, --> jump to the step marked <i title="">end</i>. (<a href="the-end.html#fragment-case">fragment case</a>)</li> <!-- if the
   head element pointer can ever be non-null when we're going through
   these steps, we'll need to uncomment out the commented-out bits -->

   <li>If <var title="">node</var> is an element from the <a href="the-end.html#mathml-namespace">MathML
   namespace</a> or the <a href="the-end.html#svg-namespace">SVG namespace</a>, then set the
   <var title="">foreign</var> flag to true.</li>

   <li>If <var title="">last</var> is true, then switch the
   <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-inbody" title="insertion mode: in
   body">in body</a>" and jump to the step marked <i title="">end</i>. (<a href="the-end.html#fragment-case">fragment case</a>)</li>

   <li>Let <var title="">node</var> now be the node before <var title="">node</var> in the <a href="#stack-of-open-elements">stack of open
   elements</a>.</li>

   <li>Return to the step marked <i>loop</i>.</li>

   <li><i>End</i>: If <var title="">foreign</var> is true, switch the
   <a href="#secondary-insertion-mode">secondary insertion mode</a> to whatever the
   <a href="#insertion-mode">insertion mode</a> is set to, and switch the
   <a href="#insertion-mode">insertion mode</a> to "<a href="tokenization.html#parsing-main-inforeign" title="insertion mode: in
   foreign content">in foreign content</a>".</li>

  </ol><h5 id="the-stack-of-open-elements"><span class="secno">9.2.3.2 </span>The stack of open elements</h5>

  <p>Initially, the <dfn id="stack-of-open-elements">stack of open elements</dfn> is empty. The
  stack grows downwards; the topmost node on the stack is the first
  one added to the stack, and the bottommost node of the stack is the
  most recently added node in the stack (notwithstanding when the
  stack is manipulated in a random access fashion as part of <a href="tokenization.html#adoptionAgency">the handling for misnested tags</a>).</p>

  <p>The "<a href="tokenization.html#the-before-html-insertion-mode" title="insertion mode: before html">before
  html</a>" <a href="#insertion-mode">insertion mode</a> creates the
  <code><a href="semantics.html#the-html-element-0">html</a></code> root element node, which is then added to the
  stack.</p>

  <p>In the <a href="the-end.html#fragment-case">fragment case</a>, the <a href="#stack-of-open-elements">stack of open
  elements</a> is initialized to contain an <code><a href="semantics.html#the-html-element-0">html</a></code>
  element that is created as part of <a href="the-end.html#html-fragment-parsing-algorithm" title="html fragment
  parsing algorithm">that algorithm</a>. (The <a href="the-end.html#fragment-case">fragment
  case</a> skips the "<a href="tokenization.html#the-before-html-insertion-mode" title="insertion mode: before
  html">before html</a>" <a href="#insertion-mode">insertion mode</a>.)</p>

  <p>The <code><a href="semantics.html#the-html-element-0">html</a></code> node, however it is created, is the topmost
  node of the stack. It never gets popped off the stack.</p>

  <p>The <dfn id="current-node">current node</dfn> is the bottommost node in this
  stack.</p>

  <p>The <dfn id="current-table">current table</dfn> is the last <code><a href="tabular-data.html#the-table-element">table</a></code>
  element in the <a href="#stack-of-open-elements">stack of open elements</a>, if there is
  one. If there is no <code><a href="tabular-data.html#the-table-element">table</a></code> element in the <a href="#stack-of-open-elements">stack of
  open elements</a> (<a href="the-end.html#fragment-case">fragment case</a>), then the
  <a href="#current-table">current table</a> is the first element in the <a href="#stack-of-open-elements">stack
  of open elements</a> (the <code><a href="semantics.html#the-html-element-0">html</a></code> element).</p>

  <p>Elements in the stack fall into the following categories:</p>

  <dl><dt><dfn id="special">Special</dfn></dt>

   <dd><p>The following HTML elements have varying levels of special
   parsing rules: <code><a href="sections.html#the-address-element">address</a></code>, <code><a href="the-map-element.html#the-area-element">area</a></code>,
   <code><a href="sections.html#the-article-element">article</a></code>, <code><a href="sections.html#the-aside-element">aside</a></code>, <code><a href="semantics.html#the-base-element">base</a></code>,
   <code><a href="obsolete.html#basefont">basefont</a></code>, <code>bgsound</code>,
   <code><a href="grouping-content.html#the-blockquote-element">blockquote</a></code>, <code><a href="sections.html#the-body-element-0">body</a></code>, <code><a href="grouping-content.html#the-br-element">br</a></code>,
   <code><a href="obsolete.html#center">center</a></code>, <code><a href="tabular-data.html#the-col-element">col</a></code>, <code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code>,
   <code><a href="interactive-elements.html#the-command">command</a></code>, <!--v2DDATAGRID--><code>datagrid</code>,
   <code><a href="grouping-content.html#the-dd-element">dd</a></code>, <code><a href="interactive-elements.html#the-details-element">details</a></code>, <code><a href="obsolete.html#dir">dir</a></code>,
   <code><a href="grouping-content.html#the-div-element">div</a></code>, <code><a href="grouping-content.html#the-dl-element">dl</a></code>, <code><a href="grouping-content.html#the-dt-element">dt</a></code>,
   <code><a href="the-iframe-element.html#the-embed-element">embed</a></code>, <code><a href="forms.html#the-fieldset-element">fieldset</a></code>, <code><a href="embedded-content-1.html#the-figure-element">figure</a></code>,
   <code><a href="sections.html#the-footer-element">footer</a></code>, <code><a href="forms.html#the-form-element">form</a></code>, <code><a href="obsolete.html#frame">frame</a></code>,
   <code><a href="obsolete.html#frameset">frameset</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h1</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h2</a></code>,
   <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h3</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h4</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h5</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h6</a></code>,
   <code><a href="semantics.html#the-head-element-0">head</a></code>, <code><a href="sections.html#the-header-element">header</a></code>, <code><a href="sections.html#the-hgroup-element">hgroup</a></code>,
   <code><a href="grouping-content.html#the-hr-element">hr</a></code>, <code><a href="the-iframe-element.html#the-iframe-element">iframe</a></code>, <!-- <code>image</code>,
   (commented out because this isn't an element that can end up on the
   stack, so it doesn't matter) --> <code><a href="embedded-content-1.html#the-img-element">img</a></code>,
   <code><a href="the-input-element.html#the-input-element">input</a></code>, <code><a href="obsolete.html#isindex-0">isindex</a></code>, <code><a href="grouping-content.html#the-li-element">li</a></code>,
   <code><a href="semantics.html#the-link-element">link</a></code>, <code><a href="obsolete.html#listing">listing</a></code>, <code><a href="interactive-elements.html#menus">menu</a></code>,
   <code><a href="semantics.html#meta">meta</a></code>, <code><a href="sections.html#the-nav-element">nav</a></code>, <code><a href="obsolete.html#noembed">noembed</a></code>,
   <code><a href="obsolete.html#noframes">noframes</a></code>, <code><a href="scripting-1.html#the-noscript-element">noscript</a></code>, <code><a href="grouping-content.html#the-ol-element">ol</a></code>,
   <code><a href="grouping-content.html#the-p-element">p</a></code>, <code><a href="the-iframe-element.html#the-param-element">param</a></code>, <code><a href="obsolete.html#plaintext">plaintext</a></code>,
   <code><a href="grouping-content.html#the-pre-element">pre</a></code>, <code><a href="scripting-1.html#script">script</a></code>, <code><a href="sections.html#the-section-element">section</a></code>,
   <code><a href="the-button-element.html#the-select-element">select</a></code>, <code><a href="semantics.html#the-style-element">style</a></code>, <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>,
   <code><a href="the-button-element.html#the-textarea-element">textarea</a></code>, <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>, <code><a href="tabular-data.html#the-thead-element">thead</a></code>,
   <code><a href="semantics.html#the-title-element-0">title</a></code>, <code><a href="tabular-data.html#the-tr-element">tr</a></code>, <code><a href="grouping-content.html#the-ul-element">ul</a></code>,
   <code>wbr</code>, and <code><a href="obsolete.html#xmp">xmp</a></code>.</dd>

   <dt><dfn id="scoping">Scoping</dfn></dt>
   <dd><p>The following HTML elements introduce new <a href="#has-an-element-in-scope" title="has
   an element in scope">scopes</a> for various parts of the
   parsing: <code><a href="obsolete.html#the-applet-element">applet</a></code>, <code><a href="the-button-element.html#the-button-element">button</a></code>,
   <code><a href="tabular-data.html#the-caption-element">caption</a></code>, <code><a href="semantics.html#the-html-element-0">html</a></code>, <code><a href="obsolete.html#the-marquee-element">marquee</a></code>,
   <code><a href="the-iframe-element.html#the-object-element">object</a></code>, <code><a href="tabular-data.html#the-table-element">table</a></code>, <code><a href="tabular-data.html#the-td-element">td</a></code>,
   <code><a href="tabular-data.html#the-th-element">th</a></code>, and SVG's <code>foreignObject</code>.</dd>

   <dt><dfn id="formatting">Formatting</dfn></dt>
   <dd><p>The following HTML elements are those that end up in the
   <a href="#list-of-active-formatting-elements">list of active formatting elements</a>: <code><a href="text-level-semantics.html#the-a-element">a</a></code>,
   <code><a href="text-level-semantics.html#the-b-element">b</a></code>, <code><a href="obsolete.html#big">big</a></code>, <code><a href="text-level-semantics.html#the-code-element">code</a></code>,
   <code><a href="text-level-semantics.html#the-em-element">em</a></code>, <code><a href="obsolete.html#font">font</a></code>, <code><a href="text-level-semantics.html#the-i-element">i</a></code>,
   <code>nobr</code>, <code><a href="obsolete.html#s">s</a></code>, <code><a href="text-level-semantics.html#the-small-element">small</a></code>,
   <code><a href="obsolete.html#strike">strike</a></code>, <code><a href="text-level-semantics.html#the-strong-element">strong</a></code>, <code><a href="obsolete.html#tt">tt</a></code>, and
   <code><a href="obsolete.html#u">u</a></code>.</dd>

   <dt><dfn id="phrasing">Phrasing</dfn></dt>
   <dd><p>All other elements found while parsing an HTML
   document.</dd>

  </dl><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn id="has-an-element-in-the-specific-scope" title="has an element in the specific scope">have an element in a
  specific scope</dfn> consisting of a list of element types <var title="">list</var> when the following algorithm terminates in a
  match state:</p>

  <ol><li><p>Initialize <var title="">node</var> to be the <a href="#current-node">current
   node</a> (the bottommost node of the stack).</li>

   <li><p>If <var title="">node</var> is the target node, terminate in
   a match state.</li>

   <li><p>Otherwise, if <var title="">node</var> is one of the element
   types in <var title="">list</var>, terminate in a failure
   state.</li>

   <li><p>Otherwise, set <var title="">node</var> to the previous
   entry in the <a href="#stack-of-open-elements">stack of open elements</a> and return to step
   2. (This will never fail, since the loop will always terminate in
   the previous step if the top of the stack &mdash; an
   <code><a href="semantics.html#the-html-element-0">html</a></code> element &mdash; is reached.)</li>

  </ol><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn id="has-an-element-in-scope" title="has an element in scope">have an element in scope</dfn> when
  it <a href="#has-an-element-in-the-specific-scope">has an element in the specific scope</a> consisting
  of the following element types:</p>

  <ul class="brief"><li><code><a href="obsolete.html#the-applet-element">applet</a></code> in the HTML namespace</li>
   <li><code><a href="tabular-data.html#the-caption-element">caption</a></code> in the HTML namespace</li>
   <li><code><a href="semantics.html#the-html-element-0">html</a></code> in the HTML namespace</li> <!-- (This can only happen if the <var title="">node</var> is the topmost node of the <span>stack of open elements</span>, and prevents the next step from being invoked if there are no more elements in the stack.) -->
   <li><code><a href="tabular-data.html#the-table-element">table</a></code> in the HTML namespace</li>
   <li><code><a href="tabular-data.html#the-td-element">td</a></code> in the HTML namespace</li>
   <li><code><a href="tabular-data.html#the-th-element">th</a></code> in the HTML namespace</li>
   <li><code><a href="the-button-element.html#the-button-element">button</a></code> in the HTML namespace</li>
   <li><code><a href="obsolete.html#the-marquee-element">marquee</a></code> in the HTML namespace</li>
   <li><code><a href="the-iframe-element.html#the-object-element">object</a></code> in the HTML namespace</li>
   <li><code title="">foreignObject</code> in the SVG namespace</li>
  </ul><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn id="has-an-element-in-list-item-scope" title="has an element in list item scope">have an element in list
  item scope</dfn> when it <a href="#has-an-element-in-the-specific-scope">has an element in the specific
  scope</a> consisting of the following element types:</p>

  <ul class="brief"><li>All the element types listed above for the <i><a href="#has-an-element-in-scope">has an element
   in scope</a></i> algorithm.</li>
   <li><code><a href="grouping-content.html#the-ol-element">ol</a></code> in the HTML namespace</li>
   <li><code><a href="grouping-content.html#the-ul-element">ul</a></code> in the HTML namespace</li>
  </ul><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn id="has-an-element-in-table-scope" title="has an element in table scope">have an element in <em>table
  scope</em></dfn> when it <a href="#has-an-element-in-the-specific-scope">has an element in the specific
  scope</a> consisting of the following element types:</p>

  <ul class="brief"><li><code><a href="semantics.html#the-html-element-0">html</a></code> in the HTML namespace</li> <!-- (This can only happen if the <var title="">node</var> is the topmost node of the <span>stack of open elements</span>, and prevents the next step from being invoked if there are no more elements in the stack.) -->
   <li><code><a href="tabular-data.html#the-table-element">table</a></code> in the HTML namespace</li>
  </ul><p>Nothing happens if at any time any of the elements in the
  <a href="#stack-of-open-elements">stack of open elements</a> are moved to a new location in,
  or removed from, the <code>Document</code> tree. In particular, the
  stack is not changed in this situation. This can cause, amongst
  other strange effects, content to be appended to nodes that are no
  longer in the DOM.</p>

  <p class="note">In some cases (namely, when <a href="tokenization.html#adoptionAgency">closing misnested formatting elements</a>),
  the stack is manipulated in a random-access fashion.</p>


  <h5 id="the-list-of-active-formatting-elements"><span class="secno">9.2.3.3 </span>The list of active formatting elements</h5>

  <p>Initially, the <dfn id="list-of-active-formatting-elements">list of active formatting elements</dfn> is
  empty. It is used to handle mis-nested <a href="#formatting" title="formatting">formatting element tags</a>.</p>

  <p>The list contains elements in the <a href="#formatting">formatting</a>
  category, and scope markers. The scope markers are inserted when
  entering <code><a href="obsolete.html#the-applet-element">applet</a></code> elements, buttons, <code><a href="the-iframe-element.html#the-object-element">object</a></code>
  elements, marquees, table cells, and table captions, and are used to
  prevent formatting from "leaking" <em>into</em> <code><a href="obsolete.html#the-applet-element">applet</a></code>
  elements, buttons, <code><a href="the-iframe-element.html#the-object-element">object</a></code> elements, marquees, and
  tables.</p>

  <p class="note">The scope markers are unrelated to the concept of an
  element being <a href="#has-an-element-in-scope" title="has an element in scope">in
  scope</a>.</p>

  <p>In addition, each element in the <a href="#list-of-active-formatting-elements">list of active formatting
  elements</a> is associated with the token for which it was
  created, so that further elements can be created for that token if
  necessary.</p>

  <p>When the steps below require the UA to <dfn id="reconstruct-the-active-formatting-elements">reconstruct the
  active formatting elements</dfn>, the UA must perform the following
  steps:</p>

  <ol><li>If there are no entries in the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a>, then there is nothing to reconstruct; stop this
   algorithm.</li>

   <li>If the last (most recently added) entry in the <a href="#list-of-active-formatting-elements">list of
   active formatting elements</a> is a marker, or if it is an
   element that is in the <a href="#stack-of-open-elements">stack of open elements</a>, then
   there is nothing to reconstruct; stop this algorithm.</li>

   <li>Let <var title="">entry</var> be the last (most recently added)
   element in the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a>.</li>

   <li>If there are no entries before <var title="">entry</var> in the
   <a href="#list-of-active-formatting-elements">list of active formatting elements</a>, then jump to step
   8.</li>

   <li>Let <var title="">entry</var> be the entry one earlier than
   <var title="">entry</var> in the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a>.</li>

   <li>If <var title="">entry</var> is neither a marker nor an element
   that is also in the <a href="#stack-of-open-elements">stack of open elements</a>, go to step
   4.</li>

   <li>Let <var title="">entry</var> be the element one later than
   <var title="">entry</var> in the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a>.</li>

   <li><a href="tokenization.html#create-an-element-for-the-token">Create an element for the token</a> for which the
   element <var title="">entry</var> was created, to obtain <var title="">new element</var>.</li>

   <li>Append <var title="">new element</var> to the <a href="#current-node">current
   node</a> and push it onto the <a href="#stack-of-open-elements">stack of open
   elements</a> so that it is the new <a href="#current-node">current
   node</a>.</li>

   <li>Replace the entry for <var title="">entry</var> in the list
   with an entry for <var title="">new element</var>.</li>

   <li>If the entry for <var title="">new element</var> in the
   <a href="#list-of-active-formatting-elements">list of active formatting elements</a> is not the last
   entry in the list, return to step 7.</li>

  </ol><p>This has the effect of reopening all the formatting elements that
  were opened in the current body, cell, or caption (whichever is
  youngest) that haven't been explicitly closed.</p>

  <p class="note">The way this specification is written, the
  <a href="#list-of-active-formatting-elements">list of active formatting elements</a> always consists of
  elements in chronological order with the least recently added
  element first and the most recently added element last (except for
  while steps 8 to 11 of the above algorithm are being executed, of
  course).</p>

  <p>When the steps below require the UA to <dfn id="clear-the-list-of-active-formatting-elements-up-to-the-last-marker">clear the list of
  active formatting elements up to the last marker</dfn>, the UA must
  perform the following steps:</p>

  <ol><li>Let <var title="">entry</var> be the last (most recently added)
   entry in the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</li>

   <li>Remove <var title="">entry</var> from the <a href="#list-of-active-formatting-elements">list of active
   formatting elements</a>.</li>

   <li>If <var title="">entry</var> was a marker, then stop the
   algorithm at this point. The list has been cleared up to the last
   marker.</li>

   <li>Go to step 1.</li>

  </ol><h5 id="the-element-pointers"><span class="secno">9.2.3.4 </span>The element pointers</h5>

  <p>Initially, the <dfn id="head-element-pointer"><code title="">head</code> element
  pointer</dfn> and the <dfn id="form-element-pointer"><code title="">form</code> element
  pointer</dfn> are both null.</p>

  <p>Once a <code><a href="semantics.html#the-head-element-0">head</a></code> element has been parsed (whether
  implicitly or explicitly) the <a href="#head-element-pointer"><code title="">head</code>
  element pointer</a> gets set to point to this node.</p>

  <p>The <a href="#form-element-pointer"><code title="">form</code> element pointer</a>
  points to the last <code><a href="forms.html#the-form-element">form</a></code> element that was opened and
  whose end tag has not yet been seen. It is used to make form
  controls associate with forms in the face of dramatically bad
  markup, for historical reasons.</p>


  <h5 id="other-parsing-state-flags"><span class="secno">9.2.3.5 </span>Other parsing state flags</h5>

  <p>The <dfn id="scripting-flag">scripting flag</dfn> is set to "enabled" if <a href="origin-0.html#concept-n-script" title="concept-n-script">scripting was enabled</a> for the
  <code>Document</code> with which the parser is associated when the
  parser was created, and "disabled" otherwise.</p>

  <p class="note">The <a href="#scripting-flag">scripting flag</a> can be enabled even
  when the parser was originally created for the <a href="the-end.html#html-fragment-parsing-algorithm">HTML fragment
  parsing algorithm</a>, even though <code><a href="scripting-1.html#script">script</a></code> elements
  don't execute in that case.</p>

  <p>The <dfn id="frameset-ok-flag">frameset-ok flag</dfn> is set to "ok" when the parser is
  created. It is set to "not ok" after certain tokens are seen.</p>

  </div>


  
