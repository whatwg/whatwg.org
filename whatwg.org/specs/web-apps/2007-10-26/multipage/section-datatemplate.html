<!DOCTYPE HTML>


<html lang="en-GB-hixie">
 <head>
  <title>HTML 5</title>
  <link href="/style/specification" type="text/css" rel="stylesheet">
  <link href="/images/icon" rel="icon">

  <style type="text/css">
   h4 + .element { margin-top: -2.5em; padding-top: 2em; }
   h4 + p + .element { margin-top: -5em; padding-top: 4em; }
   .element { background: #EEFFEE; color: black; margin: 0 0 1em -1em; padding: 0 1em 0.25em 0.75em; border-left: solid #99FF99 0.25em; -padding: 0; /* that last decl is for IE6. Try removing it, it's hilarious! */ }
   .proposal { border: blue solid; padding: 1em; }
   table.matrix, table.matrix td { border: none; text-align: right; }
   table.matrix { margin-left: 2em; }
  </style>

 <link href="section-the-command.html#nav-bar" rel="prev" title="3.18.3. The command element"><link href="index.html#contents" rel="index" title="Table of contents"><link href="section-miscellaneous.html#nav-bar" rel="next" title="3.20. Miscellaneous elements"></head><body class="cfc">
  <style scoped>
   * { color: gray ! important; background: none ! important; border-color: silver ! important; }
   img, object, iframe { filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale"); -webkit-filter: grayscale(100%); }
   .obsolete { border: double thick red ! important; background: yellow ! important; margin: 4em auto 0 auto; max-width: 50em; width: 70%; text-align: center; position: fixed;  z-index: 10000; top: 0; left: 0; right: 0; }
   .obsolete a { color: blue ! important; }
   .obsolete p { font: 900 2em sans-serif; color: red ! important; margin: 1em 1.5em ! important; }
  </style>
  <div class=obsolete>
   <p>This is a snapshot of an early working draft and has therefore
   been superseded by the <a href="http://whatwg.org/html">HTML
   standard</a>.</p>
   <p>This document will not be further updated.</p>
  </div>
<div class="head">
   <p><a href="http://www.whatwg.org/" class="logo" rel="home"><img src="/images/logo" alt="WHATWG"></a></p>

   <h1 id="html-5">HTML 5</h1>

   <h2 id="working" class="no-num no-toc">Call For Comments — 27 October 2007</h2></div><nav id="nav-bar"><a href="section-the-command.html#nav-bar">&lt; 3.18.3. The command element</a> – <a href="index.html#contents">Table of contents</a> – <a href="section-miscellaneous.html#nav-bar">3.20. Miscellaneous elements &gt;</a></nav><h3 id="datatemplate"><span class="secno">3.19. </span>Data Templates</h3>

  <h4 id="introduction0"><span class="secno">3.19.1. </span>Introduction</h4>

  <p class="big-issue">...examples...

  </p><h4 id="the-datatemplate"><span class="secno">3.19.2. </span>The <dfn id="datatemplate0"><code>datatemplate</code></dfn> element</h4>

  <p><a href="section-documents0.html#block-level0" title="block-level elements">Block-level
   element</a> and <a href="section-document.html#metadata" title="metadata elements">metadata
   element</a>.

  </p><dl class="element">
   <dt>Contexts in which this element may be used:

   </dt><dd>As the root element of an <a href="section-documents.html#xml-documents" title="xml
    documents">XML document</a>.

   </dd><dd>Where <a href="section-document.html#metadata">metadata elements</a> are expected.

   </dd><dd>Where <a href="section-documents0.html#block-level0">block-level elements</a> are expected.

   </dd><dt>Content model:

   </dt><dd>Zero or more <code><a href="#rule">rule</a></code> elements.

   </dd><dt>Element-specific attributes:

   </dt><dd>None.

   </dd><dt>DOM interface:

   </dt><dd>No difference from <code><a href="section-elements.html#htmlelement">HTMLElement</a></code>.
  </dd></dl>

  <p>The <code><a href="#datatemplate0">datatemplate</a></code> element
   brings together the various rules that form a data template. The element
   doesn't itself do anything exciting.

  </p><h4 id="the-rule"><span class="secno">3.19.3. </span>The <dfn id="rule"><code>rule</code></dfn> element</h4>
  <!-- element has no special category -->

  <dl class="element">
   <dt>Contexts in which this element may be used:

   </dt><dd>As a child of a <code><a href="#datatemplate0">datatemplate</a></code>
    element.

   </dd><dt>Content model:

   </dt><dd>Anything, regardless of the children's required contexts (but see
    prose).

   </dd><dt>Element-specific attributes:

   </dt><dd><code title="attr-rule-condition"><a href="#condition">condition</a></code>

   </dd><dd><code title="attr-rule-mode"><a href="#mode">mode</a></code>

   </dd><dt>DOM interface:

   </dt><dd>
    <pre class="idl">interface <dfn id="htmlruleelement">HTMLRuleElement</dfn> : <a href="section-elements.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a href="#condition0" title="dom-rule-condition">condition</a>;
           attribute DOMString <a href="#mode0" title="dom-rule-mode">mode</a>;
  readonly attribute DOMTokenString <a href="#modelist" title="dom-rule-modeList">modeList</a>;
};</pre>
  </dd></dl>

  <p>The <code><a href="#rule">rule</a></code> element represents a template
   of content that is to be used for elements when <a href="#update" title="datatemplate-regen">updating an element's generated content</a>.

  </p><p>The <dfn id="condition" title="attr-rule-condition"><code>condition</code></dfn> attribute, if
   specified, must contain a valid selector. It specifies which nodes in the
   data tree will have the condition's template applied. <a href="#refsSELECTORS">[SELECTORS]</a>

  </p><p>If the <code title="attr-rule-condition"><a href="#condition">condition</a></code> attribute is not specified, then
   the condition applies to all elements, text nodes, CDATA nodes, and
   processing instructions.

  </p><p>The <dfn id="mode" title="attr-rule-mode"><code>mode</code></dfn> attribute,
   if specified, must have a value that is an <a href="section-common1.html#unordered">unordered
   set of space-separated tokens</a> representing the various modes for which
   the rule applies. When, and only when, the <code title="attr-rule-mode"><a href="#mode">mode</a></code> attribute is omitted, the rule applies if and
   only if the mode is the empty string. A mode is invoked by the <code><a href="#nest">nest</a></code> element; for the first node (the root node)
   of the data tree, the mode is the empty string.

  </p><p>The contents of <code><a href="#rule">rule</a></code> elements form a
   template, and may be anything that, when the parent <code><a href="#datatemplate0">datatemplate</a></code> is applied to some
   conforming data, results in a conforming DOM tree.</p>
  <!-- XXX examples of conforming and non-conforming rules
  -->

  <p>The <dfn id="condition0" title="dom-rule-condition"><code>condition</code></dfn> DOM attribute must
   reflect the <code title="attr-rule-condition"><a href="#condition">condition</a></code> content attribute.

  </p><p>The <dfn id="mode0" title="dom-rule-mode"><code>mode</code></dfn> and <dfn id="modelist" title="dom-rule-modeList"><code>modeList</code></dfn> DOM
   attributes must reflect the <code title="attr-rule-mode"><a href="#mode">mode</a></code> content attribute.

  </p><h4 id="the-nest"><span class="secno">3.19.4. </span>The <dfn id="nest"><code>nest</code></dfn> element</h4>
  <!-- element has no special category -->

  <dl class="element">
   <dt>Contexts in which this element may be used:

   </dt><dd>As a descendant of a <code><a href="#rule">rule</a></code> element,
    regardless of the parent element's content model.

   </dd><dt>Content model:

   </dt><dd>Empty.

   </dd><dt>Element-specific attributes:

   </dt><dd><code title="attr-nest-filter"><a href="#filter">filter</a></code>

   </dd><dd><code title="attr-nest-mode"><a href="#mode1">mode</a></code>

   </dd><dt>DOM interface:

   </dt><dd>
    <pre class="idl">interface <dfn id="htmlnestelement">HTMLNestElement</dfn> : <a href="section-elements.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a href="#filter0" title="dom-nest-filter">filter</a>;
           attribute DOMString <a href="#mode2" title="dom-nest-mode">mode</a>;
};</pre>
  </dd></dl>

  <p>The <code><a href="#nest">nest</a></code> element represents a point in
   a template where the user agent should recurse and start inserting the
   children of the data node that matches the <code><a href="#rule">rule</a></code> in which the <code><a href="#nest">nest</a></code> element finds itself.

  </p><p>The <dfn id="filter" title="attr-nest-filter"><code>filter</code></dfn>
   attribute, if specified, must contain a valid selector. It specifies which
   of the child nodes in the data tree will be examined for further
   processing at this point. <a href="#refsSELECTORS">[SELECTORS]</a>

  </p><p>If the <code title="attr-nest-filter"><a href="#filter">filter</a></code>
   attribute is not specified, then all elements, text nodes, CDATA nodes,
   and processing instructions are processed.

  </p><p>The <dfn id="mode1" title="attr-nest-mode"><code>mode</code></dfn>
   attribute, if specified, must have a value that is a word token consisting
   of one or more characters, none of which are <a href="section-common1.html#space" title="space
   character">space characters</a>. It gives the mode which will be in effect
   when looking at the rules in the data template.

  </p><p>The <dfn id="filter0" title="dom-nest-filter"><code>filter</code></dfn> DOM
   attribute must reflect the <code title="attr-nest-filter"><a href="#filter">filter</a></code> content attribute.

  </p><p>The <dfn id="mode2" title="dom-nest-mode"><code>mode</code></dfn> DOM
   attribute must reflect the <code title="attr-nest-mode"><a href="#mode1">mode</a></code> content attribute.

  </p><h4 id="global0"><span class="secno">3.19.5. </span>Global attributes for data
   templates</h4>
  <!-- authoring side, with DOM reflections -->

  <p>The <dfn id="template" title="attr-template"><code>template</code></dfn>
   attribute may be added to an element to indicate that the template
   processing model is to be applied to that element.

  </p><p>The <code title="attr-template"><a href="#template">template</a></code>
   attribute, when specified, must be a URI to an XML or HTML document, or a
   fragment identifier pointing at another part of the document. If there is
   a fragment identifier present, then the element with that ID in the target
   document must be a <code><a href="#datatemplate0">datatemplate</a></code>
   element, otherwise, the root element must be a <code><a href="#datatemplate0">datatemplate</a></code> element.

  </p><p>The <dfn id="template0" title="dom-template"><code>template</code></dfn> DOM
   attribute must reflect the <code title="attr-template"><a href="#template">template</a></code> content attribute.

  </p><p>The <dfn id="ref" title="attr-ref"><code>ref</code></dfn> attribute may be
   specified on any element on which the <code title="attr-template"><a href="#template">template</a></code> attribute is specified. If it is
   specified, it must be a URI to an XML or HTML document, or a fragment
   identifier pointing at another part of the document.

  </p><p>When an element has a <code title="attr-template"><a href="#template">template</a></code> attribute but no <code title="attr-ref"><a href="#ref">ref</a></code> attribute, the element may,
   instead of its usual content model, have a single element of any kind.
   That element is then used as the root node of the data for the template.

  </p><p>The <dfn id="ref0" title="dom-ref"><code>ref</code></dfn> DOM attribute must
   reflect the <code title="attr-ref"><a href="#ref">ref</a></code> content
   attribute.

  </p><p>The <dfn id="registrationmark" title="attr-registrationmark"><code>registrationmark</code></dfn> attribute
   may be specified on any element that is a descendant of a <code><a href="#rule">rule</a></code> element, except <code><a href="#nest">nest</a></code> elements. Its value may be any string,
   including the empty string (which is the value that is assumed if the
   attribute is omitted). This attribute performs a role similar to
   registration marks in printing presses: when the generated content is
   regenerated, elements with the same <code title="attr-registrationmark"><a href="#registrationmark">registrationmark</a></code> are lined up. This
   allows the author to disambiguate how elements should be moved around when
   generated content is regenerated in the face of changes to the data tree.

  </p><p>The <dfn id="registrationmark0" title="dom-registrationMark"><code>registrationMark</code></dfn> DOM
   attribute must reflect the <code title="attr-registrationmark"><a href="#registrationmark">registrationmark</a></code> content attribute.

  </p><h4 id="processing1"><span class="secno">3.19.6. </span>Processing model</h4>
  <!-- ua side -->

  <h5 id="the-originalcontent"><span class="secno">3.19.6.1. </span>The <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code> DOM attribute</h5>

  <p>The <dfn id="originalcontent" title="dom-originalContent"><code>originalContent</code></dfn> is set to a
   <code>DocumentFragment</code> to hold the original children of an element
   that has been replaced by content generated for a data template.
   Initially, it must be null. Its value is set when the <code title="attr-template"><a href="#template">template</a></code> attribute is
   set to a usable value, and is unset when the attribute is removed.

  </p><p class="note">The <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code> DOM attribute can thus
   be used as an indicator of whether a template is currently being applied,
   just as the <code title="dom-templateElement"><a href="#templateelement">templateElement</a></code> DOM attribute can.

  </p><h5 id="the-template"><span class="secno">3.19.6.2. </span>The <code title="attr-template"><a href="#template">template</a></code> attribute</h5>

  <p><dfn id="setting" title="datatemplate-template-set">Setting</dfn>: When an
   <span>HTML element</span> without a <code title="attr-template"><a href="#template">template</a></code> attribute has its <code title="attr-template"><a href="#template">template</a></code> attribute set,
   the user agent must fetch the specified
   file<!-- XXX or queue it up to be fetched,
  or something --> and parse it
   (without a <a href="section-windows.html#browsing0">browsing context</a>, and with
   <span>scripting disabled</span><!-- XXX
  xref -->) to obtain a DOM. If
   the URI is the same as the URI of the current document<!-- XXX xref -->,
   then the current document's DOM must be assumed to be that parsed DOM.
   While this loading and parsing is in progress, the element is said to be
   <em>busy loading the template rules or data</em>.

  </p><p>If the resource specified by the <code title="attr-template"><a href="#template">template</a></code> attribute is not the current
   document<!-- XXX xref --> and does not have an XML MIME type, or if an XML
   parse error is found while parsing the resource, then the resource cannot
   be successfully parsed, and the user agent must jump to the <a href="#failed" title="datatemplate-template-failed">failed to parse</a>
   steps below.

  </p><p>Once the DOM in question has been parsed, assuming that it indeed can be
   parsed and does so successfully, the user agent must wait for no scripts
   to be executing, and as soon as that opportunity
   arises<!-- XXX xref to a strict definition of this -->, run the following
   algorithm:

  </p><ol><!-- precondition: the originalContent is null and the element
        contains its original content. -->

   <li>
    <p>If the <code title="attr-template"><a href="#template">template</a></code> attribute's value has a fragment
     identifier, and, in the DOM in question, it identifies<!-- XXX how --> a
     <code><a href="#datatemplate0">datatemplate</a></code> element, then set
     the <code title="dom-templateElement"><a href="#templateelement">templateElement</a></code> DOM attribute to that
     element.</p>

    <p>Otherwise, if the <code title="attr-template"><a href="#template">template</a></code> attribute value does not have a
     fragment identifier, and the root element of the DOM in question is a
     <code><a href="#datatemplate0">datatemplate</a></code> element, then set
     the <code title="dom-templateElement"><a href="#templateelement">templateElement</a></code> DOM attribute to that
     element.</p>

    <p>Otherwise, jump to the <a href="#failed" title="datatemplate-template-failed">failed to parse</a> steps below.</p>

   </li><li>
    <p>Create a new <code>DocumentFragment</code> and move all the nodes that
     are children of the element to that <code>DocumentFragment</code>
     object. Set the <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code> DOM attribute on the
     element to this new <code>DocumentFragment</code> object.

   </p></li><li>
    <p>Jump to the steps below for <a href="#update" title="datatemplate-regen">updating the generated content</a>.
  </p></li></ol>

  <p>If the resource has <dfn id="failed" title="datatemplate-template-failed">failed to parse</dfn>, the user agent
   must <a href="section-scripting.html#firing2">fire a simple event</a> with the name <code title="event-error"><a href="section-video.html#error1">error</a></code> at the element on
   which the <code title="attr-template"><a href="#template">template</a></code> attribute was found.

  </p><p><dfn id="unsetting" title="datatemplate-template-unset">Unsetting</dfn>:
   When an <span>HTML element</span> with a <code title="attr-template"><a href="#template">template</a></code> attribute has its <code title="attr-template"><a href="#template">template</a></code> attribute
   removed or dynamically changed from one value to another, the user agent
   must run the following algorithm:

  </p><ol>
   <li>
    <p>Set the <code title="dom-templateElement"><a href="#templateelement">templateElement</a></code> DOM attribute to
     null.

   </p></li><li>
    <p>If the <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code> DOM attribute of the
     element is not null, run these substeps:</p>

    <ol>
     <li>
      <p>Remove all the nodes that are children of the element.

     </p></li><li>
      <p>Append the nodes in the <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code>
       <code>DocumentFragment</code> to the element.

     </p></li><li>
      <p>Set <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code> to null.
    </p></li></ol>

    <p>(If the <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code> DOM attribute of the
     element is null, then either there was an error loading or parsing the
     previous template, or the previous template never finished loading; in
     either case, there is nothing to undo.)</p>

   </li><li>
    <p>If the <code title="attr-template"><a href="#template">template</a></code> attribute was changed (as opposed
     to simply removed), then <a href="#setting" title="datatemplate-template-set">act as if it was now set to its new
     value</a> (fetching the specified page, etc, as described above).
  </p></li></ol>

  <p>The <dfn id="templateelement" title="dom-templateElement"><code>templateElement</code></dfn> DOM attribute
   is updated by the above algorithm to point to the currently active
   <code><a href="#datatemplate0">datatemplate</a></code> element. Initially,
   the attribute must have the value null.

  </p><h5 id="the-ref"><span class="secno">3.19.6.3. </span>The <code title="attr-ref"><a href="#ref">ref</a></code> attribute</h5>

  <p><dfn id="setting0" title="datatemplate-ref-set">Setting</dfn>: When an
   <span>HTML element</span> without a <code title="attr-ref"><a href="#ref">ref</a></code> attribute has its <code title="attr-ref"><a href="#ref">ref</a></code> attribute set, the user agent must fetch the
   specified file<!-- XXX or queue it up to be fetched, or
  something -->
   and parse it (without a <a href="section-windows.html#browsing0">browsing context</a>, and
   with <span>scripting disabled</span><!-- XXX xref -->) to obtain a DOM. If
   the URI is the same as the URI of the current document<!--
  XXX xref -->,
   then the current document's DOM is assumed to be that parsed DOM. While
   this loading and parsing is in progress, the element is said to be
   <em>busy loading the template rules or data</em>.

  </p><p>If the resource specified by the <code title="attr-ref"><a href="#ref">ref</a></code> attribute is not the current
   document<!-- XXX xref --> and does not have an XML MIME type, or if an XML
   parse error is found while parsing the resource, then the resource cannot
   be successfully parsed, and the user agent must jump to the <a href="#failed0" title="datatemplate-ref-failed">failed to parse</a> steps
   below.

  </p><p>Once the DOM in question has been parsed, assuming that it indeed can be
   parsed and does so successfully, the user agent must wait for no scripts
   to be executing, and as soon as that opportunity
   arises<!-- XXX xref to a strict definition of this -->, run the following
   algorithm:

  </p><ol>
   <li>
    <p>If the <code title="attr-ref"><a href="#ref">ref</a></code> attribute
     value does not have a fragment identifier, then set the <code title="dom-refNode"><a href="#refnode">refNode</a></code> DOM attribute to
     the <code>Document</code> node of that DOM.</p>

    <p>Otherwise, if the <code title="attr-ref"><a href="#ref">ref</a></code>
     attribute's value has a fragment identifier, and, in the DOM in
     question, that fragment identifier identifies an element, then set the
     <code title="dom-refNode"><a href="#refnode">refNode</a></code> DOM
     attribute to that element.</p>

    <p>Otherwise, jump to the <a href="#failed0" title="datatemplate-ref-failed">failed to parse</a> steps below.</p>

   </li><li>
    <p>Jump to the steps below for <a href="#update" title="datatemplate-regen">updating the generated content</a>.
  </p></li></ol>

  <p>If the resource has <dfn id="failed0" title="datatemplate-ref-failed">failed
   to parse</dfn>, the user agent must <a href="section-scripting.html#firing2">fire a simple
   event</a> with the name <code title="event-error"><a href="section-video.html#error1">error</a></code> at the element on which the <code title="attr-ref"><a href="#ref">ref</a></code> attribute was found, and must
   then jump to the steps below for <a href="#update" title="datatemplate-regen">updating the generated content</a> (the contents
   of the element will be used instead of the specified resource).

  </p><p><dfn id="unsetting0" title="datatemplate-ref-unset">Unsetting</dfn>: When an
   <span>HTML element</span> with a <code title="attr-ref"><a href="#ref">ref</a></code> attribute has its <code title="attr-ref"><a href="#ref">ref</a></code> attribute removed or dynamically changed from
   one value to another, the user agent must run the following algorithm:

  </p><ol>
   <li>
    <p>Set the <code title="dom-refNode"><a href="#refnode">refNode</a></code>
     DOM attribute to null.

   </p></li><li>
    <p>If the <code title="attr-ref"><a href="#ref">ref</a></code> attribute
     was changed (as opposed to simply removed), then <a href="#setting0" title="datatemplate-ref-set">act as if it was now set to its new value</a>
     (fetching the specified page, etc, as described above). Otherwise, jump
     to the steps below for <a href="#update" title="datatemplate-regen">updating the generated content</a>.
  </p></li></ol>

  <p>The <dfn id="refnode" title="dom-refNode"><code>refNode</code></dfn> DOM
   attribute is updated by the above algorithm to point to the current data
   tree, if one is specified explicitly. If it is null, then the data tree is
   given by the <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code> DOM attribute, unless
   that is also null, in which case no template is currently being applied.
   Initially, the attribute must have the value null.

  </p><h5 id="the-nodedatatemplate"><span class="secno">3.19.6.4. </span>The <code><a href="#nodedatatemplate">NodeDataTemplate</a></code> interface</h5>

  <p>All objects that implement the <code>Node</code> interface must also
   implement the <code><a href="#nodedatatemplate">NodeDataTemplate</a></code> interface, whose
   members must be accessible using binding-specific casting mechanisms.

  </p><pre class="idl">interface <dfn id="nodedatatemplate">NodeDataTemplate</dfn> {
  readonly attribute Node <a href="#datanode" title="dom-dataNode">dataNode</a>;
};</pre>

  <p>The <dfn id="datanode" title="dom-dataNode"><code>dataNode</code></dfn> DOM
   attribute returns the node for which <em>this</em> node was generated. It
   must initially be null. It is set on the nodes that form the content
   generated during the <a href="#update" title="datatemplate-regen">algorithm
   for updating the generated content</a> of elements that are using the data
   template feature.

  </p><h5 id="mutations"><span class="secno">3.19.6.5. </span>Mutations</h5>

  <p>An element with a non-null <code title="dom-templateElement"><a href="#templateelement">templateElement</a></code> is said to be a <dfn id="data-tree">data tree user</dfn> of the node identified by the element's
   <code title="dom-refNode"><a href="#refnode">refNode</a></code> attribute,
   as well as all of that node's children, or, if that attribute is null, of
   the node identified by the element's <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code>, as well as all
   <em>that</em> node's children.

  </p><p>Nodes that have one or more <a href="#data-tree" title="data tree
   user">data tree users</a> associated with them (as per the previous
   paragraph) are themselves termed <dfn id="data-tree0" title="data tree
   component node">data tree component nodes</dfn>.

  </p><p>Whenever a <a href="#data-tree0">data tree component node</a> changes
   its name or value, or has one of its attributes change name or value, or
   has an attribute added or removed, or has a child added or removed, the
   user agent must <span>update the generated content</span> of all of that
   node's <a href="#data-tree" title="data tree user">data tree users</a>.

  </p><p>An element with a non-null <code title="dom-templateElement"><a href="#templateelement">templateElement</a></code> is also said to be a
   <dfn id="template1">template tree user</dfn> of the node identified by the
   element's <code title="dom-templateElement"><a href="#templateelement">templateElement</a></code> attribute, as well as
   all of that node's children.

  </p><p>Nodes that have one or more <a href="#template1" title="template tree
   user">template tree users</a> associated with them (as per the previous
   paragraph) are themselves termed <dfn id="template2" title="template tree
   component node">template tree component nodes</dfn>.

  </p><p>Whenever a <a href="#template2">template tree component node</a> changes
   its name or value, or has one of its attributes change name or value, or
   has an attribute added or removed, or has a child added or removed, the
   user agent must <span>update the generated content</span> of all of that
   node's <a href="#template1" title="template tree user">template tree
   users</a>.

  </p><p class="note">In other words, user agents update the content generated from
   a template whenever either the backing data changes or the template itself
   changes.

  </p><h5 id="updating0"><span class="secno">3.19.6.6. </span>Updating the generated
   content</h5>

  <p>When the user agent is to <dfn id="update" title="datatemplate-regen">update
   the generated content</dfn> of an element that uses a template, the user
   agent must run the following steps:

  </p><ol>
   <li>
    <p>Let <var title="">destination</var> be the element whose generated
     content is being updated.

   </p></li><li>
    <p>If the <var title="">destination</var> element is <em>busy loading the
     template rules or data</em>, then abort these steps. Either the steps
     will be invoked again once the loading has completed, or the loading
     will fail and the generated content will be removed at that point.

   </p></li><li>
    <p>Let <var title="">template tree</var> be the element given by <var title="">destination</var>'s <code title="dom-templateElement"><a href="#templateelement">templateElement</a></code> DOM attribute. If it
     is null, then abort these steps. There are no rules to apply.

   </p></li><li>
    <p>Let <var title="">data tree</var> be the node given by <var title="">destination</var>'s <code title="dom-refNode"><a href="#refnode">refNode</a></code> DOM attribute. If it is null, then
     let <var title="">data tree</var> be the node given by the <code title="dom-originalContent"><a href="#originalcontent">originalContent</a></code> DOM node.

   </p></li><li>
    <p>Let <var title="">existing nodes</var> be a set of ordered lists of
     nodes, each list being identified by a tuple consisting of a node, a
     node type and name, and a <a href="#registrationmark" title="attr-registrationmark">registration mark</a> (a string).

   </p></li><li>
    <p>For each node <var title="">node</var> that is a descendant of <var title="">destination</var>, if any, add <var title="">node</var> to the
     list identified by the tuple given by: <var title="">node</var>'s <code title="dom-dataNode"><a href="#datanode">dataNode</a></code> DOM
     attribute; the <var title="">node</var>'s node type and, if it's an
     element, its qualified name (that is, its namespace and local name), or,
     if it's a processing instruction, its target name<!-- we're basically
   indexing on nodeName here -->,
     and the value of the <var title="">node</var>'s <code title="attr-registrationmark"><a href="#registrationmark">registrationmark</a></code> attribute, if it
     has one, or the empty string otherwise.
   </p></li>
   <!-- XXX should
   non-element nodes inherit the registration marks of their parent?
   or have it set via a PI? -->

   <li>
    <p>Remove all the child nodes of <var title="">destination</var>, so that
     its child node list is empty.

   </p></li><li>
    <p>Run the <a href="#levenberg">Levenberg data node algorithm</a>
     (described below) using <var title="">destination</var> as the
     destination node, <var title="">data tree</var> as the source node, <var title="">template tree</var> as the rule container, the empty string as
     the mode, and the <var title="">existing nodes</var> lists as the lists
     of existing nodes.
   </p></li>
   <!--(for now, since we can't guarentee that we'll reset the dataNode
attribute of nodes that are dynamically moved around between regens,
we'll just act as if the dataNode attribute is set on creation and
never reset. This is nice and consistent.)

   <li><p>Set the <code title="dom-dataNode">dataNode</code> DOM
   attribute of every node in the <var title="">existing nodes</var>
   lists to null.</p></li>
-->
  </ol>
  <!--<h6 class="notoc">The Levenberg algorithm</h6>-->

  <p>The Levenberg algorithm consists of two algorithms that invoke each
   other recursively, the <a href="#levenberg">Levenberg data node
   algorithm</a> and the <a href="#levenberg0">Levenberg template node
   algorithm</a>. These algorithms use the data structures initialised by the
   set of steps described above.

  </p><p>The <dfn id="levenberg">Levenberg data node algorithm</dfn> is as follows.
   It is always invoked with three DOM nodes, one string, and a set of lists
   as arguments: the <var title="">destination node</var>, the <var title="">source node</var>, the <var title="">rule container</var>, the
   <var title="">mode string</var>, and the <var title="">existing nodes
   lists</var> respectively.

  </p><ol>
   <li>
    <p>Let <var title="">condition</var> be the first <code><a href="#rule">rule</a></code> element child of the <var title="">rule
     container</var> element, or null if there aren't any.</p>

   </li><li>
    <p>If <var title="">condition</var> is null, follow these substeps:</p>

    <ol>
     <li>
      <p>If the <var title="">source node</var> is an element, then, for each
       child <var title="">child node</var> of the <var title="">source
       node</var> element, in tree order, invoke the <a href="#levenberg">Levenberg data node algorithm</a> recursively, with
       <var title="">destination node</var>, <var title="">child node</var>,
       <var title="">rule container</var>, the empty string, and <var title="">existing nodes lists</var> as the five arguments
       respectively.

     </p></li><li>
      <p>Abort the current instance of the <a href="#levenberg">Levenberg
       data node algorithm</a>, returning to whatever algorithm invoked it.
    </p></li></ol>

   </li><li>
    <p>Let <var title="">matches</var> be a boolean with the value true.

   </p></li><li>
    <p>If the <var title="">condition</var> element has a <code title="attr-rule-mode"><a href="#mode">mode</a></code> attribute, but the
     value of that attribute is not a <span>mode match</span> for the current
     <span>mode string</span>, then let <var title="">matches</var> be false.

   </p></li><li>
    <p>If the <var title="">condition</var> element has a <code title="attr-rule-condition"><a href="#condition">condition</a></code>
     attribute, and the attribute's value, when <a href="#evaluated">evaluated as a selector</a>, does not match the
     current <var title="">source node</var>, then let <var title="">matches</var> be false.

   </p></li><li>
    <p>If <var title="">matches</var> is true, then follow these substeps:</p>

    <ol>
     <li>
      <p>For each child <var title="">child node</var> of the <var title="">condition</var> element, in tree order, invoke the <a href="#levenberg0">Levenberg template node algorithm</a> recursively,
       with the five arguments being <var title="">destination node</var>,
       <var title="">source node</var>, <var title="">rule container</var>,
       <var title="">child node</var>, and <var title="">existing nodes
       lists</var> respectively.

     </p></li><li>
      <p>Abort the current instance of the <a href="#levenberg">Levenberg
       data node algorithm</a>, returning to whatever algorithm invoked it.
    </p></li></ol>

   </li><li>
    <p>Let <var title="">condition</var> be the next <code><a href="#rule">rule</a></code> element that is a child of the <var title="">rule container</var> element, after the <var title="">condition</var> element itself, or null if there are no more
     <code><a href="#rule">rule</a></code> elements.

   </p></li><li>
    <p>Jump to step 2 in this set of steps.
  </p></li></ol>

  <p>The <dfn id="levenberg0">Levenberg template node algorithm</dfn> is as
   follows. It is always invoked with four DOM nodes and a set of lists as
   arguments: the <var title="">destination node</var>, the <var title="">source node</var>, the <var title="">rule container</var>, the
   <var title="">template node</var>, and the <var title="">existing nodes
   lists</var> respectively.

  </p><ol>
   <li>
    <p>If <var title="">template node</var> is a comment node, abort the
     current instance of the <a href="#levenberg0">Levenberg template node
     algorithm</a>, returning to whatever algorithm invoked it.

   </p></li><li>
    <p>If <var title="">template node</var> is a <code><a href="#nest">nest</a></code> element, then run these substeps:</p>

    <ol>
     <li>
      <p>If <var title="">source node</var> is not an element, then abort the
       current instance of the <a href="#levenberg0">Levenberg template node
       algorithm</a>, returning to whatever algorithm invoked it.

     </p></li><li>
      <p>If the <var title="">template node</var> has a <code title="attr-nest-mode"><a href="#mode1">mode</a></code> attribute, then
       let <var title="">mode</var> be the value of that attribute;
       otherwise, let <var title="">mode</var> be the empty string.

     </p></li><li>
      <p>Let <var title="">child node</var> be the first child of the <var title="">source node</var> element, or null if <var title="">source
       node</var> has no children.

     </p></li><li>
      <p>If <var title="">child node</var> is null, abort the current
       instance of the <a href="#levenberg0">Levenberg template node
       algorithm</a>, returning to whatever algorithm invoked it.

     </p></li><li>
      <p>If the <var title="">template node</var> element has a <code title="attr-nest-filter"><a href="#filter">filter</a></code> attribute,
       and the attribute's value, when <a href="#evaluated">evaluated as a
       selector</a>, matches <var title="">child node</var>, then invoke the
       <a href="#levenberg">Levenberg data node algorithm</a> recursively,
       with <var title="">destination node</var>, <var title="">child
       node</var>, <var title="">rule container</var>, <var title="">mode</var>, and <var title="">existing nodes lists</var> as
       the five arguments respectively.

     </p></li><li>
      <p>Let <var title="">child node</var> be <var title="">child
       node</var>'s next sibling, or null if <var title="">child node</var>
       was the last node of <var title="">source node</var>.

     </p></li><li>
      <p>Return to step 4 in this set of substeps.
    </p></li></ol>

   </li><li>
    <p>If <var title="">template node</var> is an element, and that element
     has a <code title="attr-registrationmark"><a href="#registrationmark">registrationmark</a></code> attribute, then let
     <var title="">registration mark</var> have the value of that attribute.
     Otherwise, let <var title="">registration mark</var> be the empty
     string.

   </p></li><li>
    <p>If there is a list in the <var title="">existing nodes lists</var>
     corresponding to the tuple (<var title="">source node</var>, the node
     type and name of <var title="">template node</var>, <var title="">registration mark</var>), and that list is not empty, then run
     the following substeps. (For an element node, the name of the node is
     its qualified tag name, i.e. its namespace and local name. For a
     processing instruction, its name is the target. For other types of
     nodes, there is no name.)</p>

    <ol>
     <li>
      <p>Let <var title="">new node</var> be the first node in that list.

     </p></li><li>
      <p>Remove <var title="">new node</var> from that list.

     </p></li><li>
      <p>If <var title="">new node</var> is an element, remove all the child
       nodes of <var title="">new node</var>, so that its child node list is
       empty.
    </p></li></ol>

    <p>Otherwise, if there is no matching list, or there was, but it is now
     empty, then run these steps instead:</p>

    <ol>
     <li>
      <p>Let <var title="">new node</var> be a shallow clone of <var title="">template node</var>.

     </p></li><li>
      <p>Let <var title="">new node</var>'s <code title="dom-dataNode"><a href="#datanode">dataNode</a></code> DOM attribute be <var title="">source node</var>.
    </p></li></ol>

   </li><li>
    <p>If <var title="">new node</var> is an element, run these substeps:</p>

    <ol>
     <li>
      <p>For each attribute on <var title="">new node</var>, if an attribute
       with the same qualified name is not present on <var title="">template
       node</var>, remove that attribute.</p>

     </li><li>
      <p>For each attribute <var title="">attribute</var> on <var title="">template node</var>, run these substeps:</p>

      <ol>
       <li>
        <p>Let <var title="">expanded</var> be the result of passing the
         value of <var title="">attribute</var> to the <a href="#text-expansion">text expansion algorithm for templates</a>
         along with <var title="">source node</var>.

       </p></li><li>
        <p>If an attribute with the same qualified name as <var title="">attribute</var> is already present on <var title="">new
         node</var>, then: if its value is different from <var title="">expanded</var>, replace its value with <var title="">expanded</var>.

       </p></li><li>
        <p>Otherwise, if there is no attribute with the same qualified name
         as <var title="">attribute</var> on <var title="">new node</var>,
         then add an attribute with the same namespace, prefix, and local
         name as <var title="">attribute</var>, with its value set to <var title="">expanded</var>'s.
      </p></li></ol>
    </li></ol>

    <p>Otherwise, the <var title="">new node</var> is a text node, CDATA
     block, or PI. Run these substeps instead:</p>

    <ol>
     <li>
      <p>Let <var title="">expanded</var> be the result of passing the node
       value of <var title="">template node</var> (the content of the text
       node, CDATA block, or PI) to the <a href="#text-expansion">text
       expansion algorithm for templates</a> along with <var title="">source
       node</var>.

     </p></li><li>
      <p>If the value of the <var title="">new node</var> is different from
       <var title="">expanded</var>, then set the value of <var title="">new
       node</var> to <var title="">expanded</var>.
    </p></li></ol>

   </li><li>
    <p>Append <var title="">new node</var> to <var title="">destination</var>.

   </p></li><li>
    <p>If <var title="">template node</var> is an element, then, for each
     child <var title="">child node</var> of the <var title="">template
     node</var> element, in tree order, invoke the <a href="#levenberg0">Levenberg template node algorithm</a> recursively,
     with the five arguments being <var title="">new child</var>, <var title="">source node</var>, <var title="">rule container</var>, <var title="">child node</var>, and <var title="">existing nodes lists</var>
     respectively.
  </p></li></ol>

  <p class="big-issue">Define: <dfn id="evaluated">evaluated as a selector</dfn>

  </p><p class="big-issue">Define: <dfn id="text-expansion">text expansion algorithm
   for templates</dfn></p>
  <!-- this is basically used for expanding
  nodeValue values -->

  <script src="http://status.whatwg.org/annotate-web-apps.js" type="text/javascript"></script></body></html>
