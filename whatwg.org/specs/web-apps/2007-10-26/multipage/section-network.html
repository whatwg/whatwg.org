<!DOCTYPE HTML>


<html lang="en-GB-hixie">
 <head>
  <title>HTML 5</title>
  <link href="/style/specification" type="text/css" rel="stylesheet">
  <link href="/images/icon" rel="icon">

  <style type="text/css">
   h4 + .element { margin-top: -2.5em; padding-top: 2em; }
   h4 + p + .element { margin-top: -5em; padding-top: 4em; }
   .element { background: #EEFFEE; color: black; margin: 0 0 1em -1em; padding: 0 1em 0.25em 0.75em; border-left: solid #99FF99 0.25em; -padding: 0; /* that last decl is for IE6. Try removing it, it's hilarious! */ }
   .proposal { border: blue solid; padding: 1em; }
   table.matrix, table.matrix td { border: none; text-align: right; }
   table.matrix { margin-left: 2em; }
  </style>

 <link href="section-server-sent-events.html#nav-bar" rel="prev" title="6.2. Server-sent DOM events"><link href="index.html#contents" rel="index" title="Table of contents"><link href="section-crossDocumentMessages.html#nav-bar" rel="next" title="6.4. Cross-document messaging"></head><body class="cfc">
  <style scoped>
   * { color: gray ! important; background: none ! important; border-color: silver ! important; }
   img, object, iframe { filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale"); -webkit-filter: grayscale(100%); }
   .obsolete { border: double thick red ! important; background: yellow ! important; margin: 4em auto 0 auto; max-width: 50em; width: 70%; text-align: center; position: fixed;  z-index: 10000; top: 0; left: 0; right: 0; }
   .obsolete a { color: blue ! important; }
   .obsolete p { font: 900 2em sans-serif; color: red ! important; margin: 1em 1.5em ! important; }
  </style>
  <div class=obsolete>
   <p>This is a snapshot of an early working draft and has therefore
   been superseded by the <a href="http://whatwg.org/html">HTML
   standard</a>.</p>
   <p>This document will not be further updated.</p>
  </div>
<div class="head">
   <p><a href="http://www.whatwg.org/" class="logo" rel="home"><img src="/images/logo" alt="WHATWG"></a></p>

   <h1 id="html-5">HTML 5</h1>

   <h2 id="working" class="no-num no-toc">Call For Comments — 27 October 2007</h2></div><nav id="nav-bar"><a href="section-server-sent-events.html#nav-bar">&lt; 6.2. Server-sent DOM events</a> – <a href="index.html#contents">Table of contents</a> – <a href="section-crossDocumentMessages.html#nav-bar">6.4. Cross-document messaging &gt;</a></nav><h3 id="network"><span class="secno">6.3. </span>Network connections</h3>

  <p>To enable Web applications to communicate with each other in local area
   networks, and to maintain bidirectional communications with their
   originating server, this specification introduces the <code><a href="#connection0">Connection</a></code> interface.

  </p><p>The <code><a href="section-the-default0.html#window">Window</a></code> interface provides three
   constructors for creating <code><a href="#connection0">Connection</a></code> objects: <code title="dom-TCPConnection"><a href="#tcpconnection">TCPConnection()</a></code>, for creating a direct
   (possibly encrypted) link to another node on the Internet using TCP/IP;
   <code title="dom-LocalBroadcastConnection"><a href="#localbroadcastconnection">LocalBroadcastConnection()</a></code>,
   for creating a connection to any listening peer on a local network (which
   could be a local TCP/IP subnet using UDP, a Bluetooth PAN, or another kind
   of network infrastructure); and <code title="dom-PeerToPeerConnection"><a href="#peertopeerconnection">PeerToPeerConnection()</a></code>, for a
   direct peer-to-peer connection (which could again be over TCP/IP,
   Bluetooth, IrDA, or some other type of network).

  </p><p class="note">This interface does not allow for raw access to the
   underlying network. For example, this interface could not be used to
   implement an IRC client without proxying messages through a custom server.

  </p><h4 id="network-intro"><span class="secno">6.3.1. </span>Introduction</h4>

  <p><em>This section is non-normative.</em>

  </p><p class="big-issue">An introduction to the client-side and server-side of
   using the direct connection APIs.

  </p><p class="big-issue">An example of a party-line implementation of a broadcast
   service, and direct peer-to-peer chat for direct local connections.</p>
  <!--
    <div class="example">
     <p>The following script creates a connection to a local party
     line:</p>
     <pre>var a = new LocalBroadcastConnection();
  a.onread = function(e) { alert(e.source + ' wrote ' + e.data); }
  a.send('hello');</pre>
    </div>
-->
  <!--XXX
   Explain why we don't use HTTP instead of our own protocol: wouldn't
   work for peer-to-peer, too much work to implement server if you
   have to implement a compliant HTTP server as well, etc
  -->

  <h4 id="the-connection"><span class="secno">6.3.2. </span>The <code><a href="#connection0">Connection</a></code> interface</h4>

  <pre class="idl">interface <dfn id="connection0">Connection</dfn> {
  readonly attribute DOMString <a href="#network1" title="dom-Connection-network">network</a>;
  readonly attribute DOMString <a href="#peer" title="dom-Connection-peer">peer</a>;
  readonly attribute int <a href="#readystate0" title="dom-Connection-readyState">readyState</a>;
           attribute EventListener <a href="#onopen" title="dom-Connection-onopen">onopen</a>;
           attribute EventListener <a href="#onread" title="dom-Connection-onread">onread</a>;
           attribute EventListener <a href="#onclose" title="dom-Connection-onclose">onclose</a>;
  void <a href="#send" title="dom-Connection-send">send</a>(in DOMString data);
  void <a href="#disconnect" title="dom-Connection-disconnect">disconnect</a>();
};</pre>

  <p><code><a href="#connection0">Connection</a></code> objects must also
   implement the <code>EventTarget</code> interface. <a href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  </p><p>When a <code><a href="#connection0">Connection</a></code> object is
   created, the UA must try to establish a connection, as described in the
   sections below describing each connection type.

  </p><p>The <dfn id="network1" title="dom-Connection-network"><code>network</code></dfn> attribute
   represents the name of the network connection (the value depends on the
   kind of connection being established). The <dfn id="peer" title="dom-Connection-peer"><code>peer</code></dfn> attribute identifies the
   remote host for direct (non-broadcast) connections.

  </p><p>The <code title="dom-Connection-network"><a href="#network1">network</a></code> attribute must be set as soon as the
   <code><a href="#connection0">Connection</a></code> object is created, and
   keeps the same value for the lifetime of the object. The <code title="dom-Connection-peer"><a href="#peer">peer</a></code> attribute must
   initially be set to the empty string and must be updated once, when the
   connection is established, after which point it must keep the same value
   for the lifetime of the object.

  </p><p>The <dfn id="readystate0" title="dom-Connection-readyState"><code>readyState</code></dfn> attribute
   represents the state of the connection. When the object is created it must
   be set to 0. It can have the following values:

  </p><dl>
   <dt>0 Connecting

   </dt><dd>The connection has not yet been established.

   </dd><dt>1 Connected

   </dt><dd>The connection is established and communication is possible.

   </dd><dt>2 Closed

   </dt><dd>The connection has been closed.
  </dd></dl>

  <p id="openConnection">Once a connection is established, the <code title="dom-Connection-readyState"><a href="#readystate0">readyState</a></code> attribute's value must be
   changed to 1, and the <code title="event-connection-open"><a href="#open3">open</a></code> event must be fired on the <code><a href="#connection0">Connection</a></code> object.

  </p><p>When data is received, the <code title="event-connection-read"><a href="#read">read</a></code> event will be fired on the <code><a href="#connection0">Connection</a></code> object.</p>
  <!-- conf crit for this
  statement is in the various protocol-specific sections below. -->

  <p id="closeConnection">When the connection is closed, the <code title="dom-Connection-readyState"><a href="#readystate0">readyState</a></code> attribute's value must be
   changed to 2, and the <code title="event-connection-close"><a href="#close0">close</a></code> event must be fired on the <code><a href="#connection0">Connection</a></code> object.

  </p><p>The <dfn id="onopen" title="dom-Connection-onopen"><code>onopen</code></dfn>, <dfn id="onread" title="dom-Connection-onread"><code>onread</code></dfn>, and <dfn id="onclose" title="dom-Connection-onclose"><code>onclose</code></dfn> attributes must,
   when set, register their new value as an event listener for their
   respective events (namely <code title="event-connection-open"><a href="#open3">open</a></code>, <code title="event-connection-read"><a href="#read">read</a></code>, and <code title="event-connection-close"><a href="#close0">close</a></code>), and unregister their previous value if
   any.

  </p><p>The <dfn id="send" title="dom-Connection-send"><code>send()</code></dfn>
   method transmits data using the connection. If the connection is not yet
   established, it must raise an <code>INVALID_STATE_ERR</code> exception. If
   the connection <em>is</em> established, then the behaviour depends on the
   connection type, as described below.

  </p><p>The <dfn id="disconnect" title="dom-Connection-disconnect"><code>disconnect()</code></dfn> method
   must close the connection, if it is open. If the connection is already
   closed, it must do nothing. Closing the connection causes a <code title="event-connection-close"><a href="#close0">close</a></code> event to
   be fired and the <code title="dom-Connection-readyState"><a href="#readystate0">readyState</a></code> attribute's value to change, as
   <a href="#closeConnection">described above</a>.

  </p><h4 id="connection"><span class="secno">6.3.3. </span>Connection Events</h4>

  <p>All the events described in this section are events in no namespace,
   which do not bubble, are not cancelable, and have no default action.

  </p><p>The <dfn id="open3" title="event-connection-open"><code>open</code></dfn>
   event is fired when the connection is established. UAs must use the normal
   <code>Event</code> interface when firing this event.

  </p><p>The <dfn id="close0" title="event-connection-close"><code>close</code></dfn>
   event is fired when the connection is closed (whether by the author,
   calling the <code title="dom-Connection-disconnect"><a href="#disconnect">disconnect()</a></code> method, or by the server, or by
   a network error). UAs must use the normal <code>Event</code> interface
   when firing this event as well.

  </p><p class="note">No information regarding why the connection was closed is
   passed to the application in this version of this specification.

  </p><p>The <dfn id="read" title="event-connection-read"><code>read</code></dfn>
   event is fired when when data is received for a connection. UAs must use
   the <code><a href="#connectionreadevent">ConnectionReadEvent</a></code>
   interface for this event.

  </p><pre class="idl">interface <dfn id="connectionreadevent">ConnectionReadEvent</dfn> : Event {
  readonly attribute DOMString <a href="#data5" title="dom-ConnectionReadEvent-data">data</a>;
  readonly attribute DOMString <a href="#source2" title="dom-ConnectionReadEvent-source">source</a>;
  void <a href="#initconnectionreadevent" title="dom-ConnectionReadEvent-initConnectionReadEvent">initConnectionReadEvent</a>(in DOMString typeArg, in boolean canBubbleArg, in boolean cancelableArg, in DOMString dataArg);
  void <a href="#initconnectionreadeventns" title="dom-ConnectionReadEvent-initConnectionReadEventNS">initConnectionReadEventNS</a>(in DOMString namespaceURI, in DOMString typeArg, in boolean canBubbleArg, in boolean cancelableArg, in DOMString dataArg);
};
</pre>

  <p>The <dfn id="initconnectionreadevent" title="dom-ConnectionReadEvent-initConnectionReadEvent"><code>initConnectionReadEvent()</code></dfn>
   and <dfn id="initconnectionreadeventns" title="dom-ConnectionReadEvent-initConnectionReadEventNS"><code>initConnectionReadEventNS()</code></dfn>
   methods must initialise the event in a manner analogous to the
   similarly-named methods in the DOM3 Events interfaces. <a href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  </p><p>The <dfn id="data5" title="dom-ConnectionReadEvent-data"><code>data</code></dfn> attribute
   represents the data that was transmitted from the peer.

  </p><p>The <dfn id="source2" title="dom-ConnectionReadEvent-source"><code>source</code></dfn> attribute
   represents the name of the peer. This is primarily useful on broadcast
   connections; on direct connections it is equal to the <code title="dom-Connection-peer"><a href="#peer">peer</a></code> attribute on the
   <code><a href="#connection0">Connection</a></code> object.</p>
  <!-- XXX check that the following three sections define "the data
  that was transmitted" and "the name of the peer" in terms that mean
  they fit into the above definitions ("for the purposes of the
  ConnectionReadEvent"), and check they say that they MUST be set
  correctly. -->
  <!-- XXX should we have a Connection attribute on the event? -->

  <p>Events that would be fired during script execution (e.g. between the
   connection object being created — and thus the connection being
   established — and the current script completing; or, during the
   execution of a <code title="event-connection-read"><a href="#read">read</a></code> event handler) must be buffered, and those
   events queued up and each one individually fired after the script has
   completed.</p>
  <!-- XXX make this more generic -->

  <h4 id="tcp-connections"><span class="secno">6.3.4. </span>TCP connections</h4>

  <p>The <dfn id="tcpconnection" title="dom-TCPConnection"><code>TCPConnection(<var title="">subdomain</var>,
   <var title="">port</var>, <var title="">secure</var>)</code></dfn>
   constructor on the <code><a href="section-the-default0.html#window">Window</a></code> interface
   returns a new object implementing the <code><a href="#connection0">Connection</a></code> interface, set up for a direct
   connection to a specified host on the page's domain.

  </p><p>When this constructor is invoked, the following steps must be followed.

  </p><p>First, if the domain part of the script's <a href="section-scripting.html#origin0">origin</a>
   is not a host name (e.g. it is an IP address) then the UA must raise a <a href="section-scripting.html#security8">security exception</a>. <span class="issue">We currently
   don't allow connections to be set up back to an originating IP address,
   but we could, if the subdomain is the empty string.</span>

  </p><p>Then, if the <var title="">subdomain</var> argument is null or the empty
   string, the target host is the domain part of the script's <a href="section-scripting.html#origin0">origin</a>. Otherwise, the <var title="">subdomain</var>
   argument is prepended to the domain part of the script's origin with a dot
   separating the two strings, and that is the target host.

  </p><p>If either:

  </p><ul>
   <li>the target host is not a valid host name, or

   </li><li>the <var title="">port</var> argument is neither equal to 80, nor
    equal to 443, nor greater than or equal to 1024 and less than or equal to
    65535,
  </li></ul>

  <p>...then the UA must raise a <a href="section-scripting.html#security8">security exception</a>.</p>
  <!-- XXX we should have our own port for this too, e.g. 980 -->

  <p>Otherwise, the user agent must verify that the <a href="section-scripting.html#the-string">the
   string representing the script's domain in IDNA format</a> can be obtained
   without errors. If it cannot, then the user agent must raise a <a href="section-scripting.html#security8">security exception</a>.

  </p><p>The user agent may also raise a <a href="section-scripting.html#security8">security
   exception</a> at this time if, for some reason, permission to create a
   direct TCP connection to the relevant host is denied. Reasons could
   include the UA being instructed by the user to not allow direct
   connections, or the UA establishing (for instance using UPnP) that the
   network topology will cause connections on the specified port to be
   directed at the wrong host.

  </p><p>If no exceptions are raised by the previous steps, then a new <code><a href="#connection0">Connection</a></code> object must be created, its
   <code title="dom-Connection-peer"><a href="#peer">peer</a></code> attribute
   must be set to a string consisting of the name of the target host, a colon
   (U+003A COLON), and the port number as decimal digits, and its <code title="dom-Connection-network"><a href="#network1">network</a></code>
   attribute must be set to the same value as the <code title="dom-Connection-peer"><a href="#peer">peer</a></code> attribute.

  </p><p>This object must then be returned.

  </p><p>The user agent must then begin trying to establish a connection with the
   target host and specified port. (This typically would begin in the
   backgound, while the script continues to execute.)

  </p><p>If the <var title="">secure</var> boolean argument is set to true, then
   the user agent must establish a secure connection with the target host and
   specified port using TLS or another protocol, negotiated with the server.
   <a href="#refsRFC2246">[RFC2246]</a> If this fails the user agent must act
   as if it had <a href="#closeConnection">closed the connection</a>.

  </p><p>Once a secure connection is established, or if the <var title="">secure</var> boolean argument is not set to true, then the user
   agent must continue to connect to the server using the protocol described
   in the section entitled <a href="#clients0">clients connecting over
   TCP</a>. All data on connections made using TLS must be sent as
   &quot;application data&quot;.

  </p><p>Once the connection is established, the UA must act as described in the
   section entitled <a href="#sending0">sending and receiving data over
   TCP</a>.

  </p><p>User agents should allow multiple TCP connections to be established per
   host. In particular, user agents should not apply per-host HTTP connection
   limits to connections established with the <code title="dom-TCPConnection"><a href="#tcpconnection">TCPConnection</a></code>
   constructor.

  </p><h4 id="broadcast"><span class="secno">6.3.5. </span>Broadcast connections</h4>

  <p>The <dfn id="localbroadcastconnection" title="dom-LocalBroadcastConnection"><code>LocalBroadcastConnection()</code></dfn>
   constructor on the <code><a href="section-the-default0.html#window">Window</a></code> interface
   returns a new object implementing the <code><a href="#connection0">Connection</a></code> interface, set up to broadcast
   on the local network.

  </p><p>When this constructor is invoked, a new <code><a href="#connection0">Connection</a></code> object must be created.

  </p><p>The <code title="dom-Connection-network"><a href="#network1">network</a></code> attribute of the object must be set to
   <a href="section-scripting.html#the-string">the string representing the script's domain in IDNA
   format</a>. If this string cannot be obtained, then the user agent must
   raise a <a href="section-scripting.html#security8">security exception</a> exception when the
   constructor is called.

  </p><p>The <code title="dom-Connection-peer"><a href="#peer">peer</a></code>
   attribute must be set to the empty string.

  </p><p>The object must then be returned, unless, for some reason, permission to
   broadcast on the local network is to be denied. In the latter case, a <a href="section-scripting.html#security8">security exception</a> must be raised instead. User
   agents may deny such permission for any reason, for example a user
   preference.

  </p><p>If the object is returned (i.e. if no exception is raised), the user
   agent must the begin broadcasting and listening on the local network, in
   the background, as described below. The user agent may define &quot;the local
   network&quot; in any way it considers appropriate and safe; for instance the
   user agent may ask the user which network (e.g. Bluetooth, IrDA, Ethernet,
   etc) the user would like to broadcast on before beginning broadcasting.

  </p><p>UAs may broadcast and listen on multiple networks at once. For example,
   the UA could broadcast on both Bluetooth and Wifi at the same time.</p>
  <!-- XXX bridging? how do we handle one UA not seeing
  the same hosts as another UA? -->

  <p>As soon as the object is returned, the connection <a href="#openConnection">has been established</a>, which implies that the
   <code title="event-connection-open"><a href="#open3">open</a></code> event
   must be fired. Broadcast connections are never closed.

  </p><h5 id="broadcasting"><span class="secno">6.3.5.1. </span>Broadcasting over
   TCP/IP</h5>

  <p class="big-issue">Should we drop this altogether? Letting people fill the
   local network with garbage seems unwise.

  </p><p class="big-issue">We need to register a UDP port for this. For now this
   spec refers to port 18080/udp.

  </p><p class="note">Since this feature requires that the user agent listen to a
   particular port, some platforms might prevent more than one user agent per
   IP address from using this feature at any one time.

  </p><p>On TCP/IP networks, broadcast connections transmit data using UDP over
   port 18080.

  </p><p>When the <code title="dom-Connection-send"><a href="#send">send(<var title="">data</var>)</a></code> method is invoked on a <code><a href="#connection0">Connection</a></code> object that was created by the
   <code title="dom-LocalBroadcastConnection"><a href="#localbroadcastconnection">LocalBroadcastConnection()</a></code>
   constructor, the user agent must follow these steps:

  </p><ol>
   <li>Create a string consisting of the value of the <code title="dom-Connection-network"><a href="#network1">network</a></code>
    attribute of the <code><a href="#connection0">Connection</a></code>
    object, a U+0020 SPACE character, a U+0002 START OF TEXT character, and
    the <var title="">data</var> argument.

   </li><li>Encode the string as UTF-8.

   </li><li>If the resulting byte stream is longer than 65487 bytes, raise an
    <code>INDEX_SIZE_ERR</code> DOM exception and stop.

   </li><li>Create a UDP packet whose data is the byte stream, with the source and
    destination ports being 18080, and with appropriate length and checksum
    fields. Transmit this packet to IPv4 address 255.255.255.255 or IPv6
    address ff02::1, as appropriate. <span class="note">IPv6 applications will
    also have to enable reception from this address.</span>
  </li></ol>

  <p>When a broadcast connection is opened on a TCP/IP network, the user
   agent should listen for UDP packets on port 18080.

  </p><p>When the user agent receives a packet on port 18080, the user agent must
   attempt to decode that packet's data as UTF-8. If the data is not fully
   correct UTF-8 (i.e. if there are decoding errors) then the packet must be
   ignored. Otherwise, the user agent must check to see if the decoded string
   contains a U+0020 SPACE character. If it does not, then the packet must
   again be ignored (it might be a peer discovery packet from a <code title="dom-PeerToPeerConnection"><a href="#peertopeerconnection">PeerToPeerConnection()</a></code>
   constructor). If it does then the user agent must split the string at the
   first space character. All the characters before the space are then known
   as <var title="">d</var>, and all the characters after the space are known
   as <var title="">s</var>. If <var title="">s</var> is not at least one
   character long, or if the first character of <var title="">s</var> is not
   a U+0002 START OF TEXT character, then the packet must be ignored. (This
   allows for future extension of this protocol.)

  </p><p>Otherwise, for each <code><a href="#connection0">Connection</a></code>
   object that was created by the <code title="dom-LocalBroadcastConnection"><a href="#localbroadcastconnection">LocalBroadcastConnection()</a></code>
   constructor and whose <code title="dom-Connection-network"><a href="#network1">network</a></code> attribute exactly matches <var title="">d</var>, a <code title="event-connection-read"><a href="#read">read</a></code> event must be fired on the <code><a href="#connection0">Connection</a></code> object. The string <var title="">s</var>, with the first character removed, must be used as the
   <code title="dom-ConnectionReadEvent-data"><a href="#data5">data</a></code>,
   and the source IP address of the packet as the <code title="dom-ConnectionReadEvent-source"><a href="#source2">source</a></code>.

  </p><p class="big-issue">Making the source IP available means that if two or more
   machines in a private network can be made to go to a hostile page
   simultaneously, the hostile page can determine the IP addresses used
   locally (i.e. on the other side of any NAT router). Is there some way we
   can keep link-local IP addresses secret while still allowing for
   applications to distinguish between multiple participants?

  </p><h5 id="bluetooth-broadcast"><span class="secno">6.3.5.2. </span>Broadcasting
   over Bluetooth</h5>

  <p class="big-issue">Does anyone know enough about Bluetooth to write this
   section?

  </p><h5 id="irda-broadcast"><span class="secno">6.3.5.3. </span>Broadcasting over
   IrDA</h5>

  <p class="big-issue">Does anyone know enough about IrDA to write this
   section?

  </p><h4 id="peer-to-peer"><span class="secno">6.3.6. </span>Peer-to-peer
   connections</h4>

  <p>The <dfn id="peertopeerconnection" title="dom-PeerToPeerConnection"><code>PeerToPeerConnection()</code></dfn>
   constructor on the <code><a href="section-the-default0.html#window">Window</a></code> interface
   returns a new object implementing the <code><a href="#connection0">Connection</a></code> interface, set up for a direct
   connection to a user-specified host.

  </p><p>When this constructor is invoked, a new <code><a href="#connection0">Connection</a></code> object must be created.

  </p><p>The <code title="dom-Connection-network"><a href="#network1">network</a></code> attribute of the object must be set to
   <a href="section-scripting.html#the-string">the string representing the script's domain in IDNA
   format</a>. If this string cannot be obtained, then the user agent must
   raise a <a href="section-scripting.html#security8">security exception</a> exception when the
   constructor is called.

  </p><p>The <code title="dom-Connection-peer"><a href="#peer">peer</a></code>
   attribute must be set to the empty string.

  </p><p>The object must then be returned, unless, for some reason, permission to
   establish peer-to-peer connections is generally disallowed, for example
   due to administrator settings. In the latter case, a <a href="section-scripting.html#security8">security exception</a> must be raised instead.

  </p><p>The user agent must then, typically while the script resumes execution,
   find a remote host to establish a connection to. To do this it must start
   broadcasting and listening for peer discovery messages and listening for
   incoming connection requests on all the supported networks. How this is
   performed depends on the type of network and is described below.

  </p><p>The UA should inform the user of the clients that are detected, and
   allow the user to select one to connect to. UAs may also allow users to
   explicit specify hosts that were not detected, e.g. by having the user
   enter an IP address.

  </p><p>If an incoming connection is detected before the user specifies a target
   host, the user agent should ask the user to confirm that this is the host
   they wish to connect to. If it is, the connection should be accepted and
   the UA will act as the <em>server</em> in this connection. (Which UA acts
   as the server and which acts as the client is not discernible at the DOM
   API level.)

  </p><p>If no incoming connection is detected and if the user specifies a
   particular target host, a connection should be established to that host,
   with the UA acting as the <em>client</em> in the connection.

  </p><p>No more than one connection must be established per <code><a href="#connection0">Connection</a></code> object, so once a connection has
   been established, the user agent must stop listening for further
   connections (unless, or until such time as, another <code><a href="#connection0">Connection</a></code> object is being created).

  </p><p>If at any point the user cancels the connection process or the remote
   host refuses the connection, then the user agent must act as if it had <a href="#closeConnection">closed the connection</a>, and stop trying to
   connect.

  </p><h5 id="peer-to-peer0"><span class="secno">6.3.6.1. </span>Peer-to-peer
   connections over TCP/IP</h5>

  <p class="big-issue">Should we replace this section with something that uses
   Rendez-vous/zeroconf or equivalent?

  </p><p class="big-issue">We need to register ports for this. For now this spec
   refers to port 18080/udp and 18080/tcp.

  </p><p class="note">Since this feature requires that the user agent listen to a
   particular port, some platforms might prevent more than one user agent per
   IP address from using this feature at any one time.

  </p><p>When using TCP/IP, broadcasting peer discovery messages must be done by
   creating UDP packets every few seconds containing as their data the value
   of the connection's <code title="dom-Connection-network"><a href="#network1">network</a></code> attribute, encoded as UTF-8, with the
   source and destination ports being set to 18080 and appropriate length and
   checksum fields, and sending these packets to address (in IPv4)
   255.255.255.255 or (in IPv6) ff02::1, as appropriate.

  </p><p>Listening for peer discovery messages must be done by examining incoming
   UDP packets on port 18080. <span class="note">IPv6 applications will also
   have to enable reception from the ff02::1 address.</span> If their payload
   is exactly byte-for-byte equal to a UTF-8 encoded version of the value of
   the connection's <code title="dom-Connection-network"><a href="#network1">network</a></code> attribute, then the source address of
   that packet represents the address of a host that is ready to accept a
   peer-to-peer connection, and it should therefore be offered to the user.

  </p><p>Incoming connection requests must be listened for on TCP port 18080. If
   an incoming connection is received, the UA must act as a <em>server</em>,
   as described in the section entitled <a href="#servers0">servers accepting
   connections over TCP</a>.

  </p><p>If no incoming connection requests are accepted and the user instead
   specifies a target host to connect to, the UA acts as a <em>client</em>:
   the user agent must attempt to connect to the user-specified host on port
   18080, as described in the section entitled <a href="#clients0">clients
   connecting over TCP</a>.

  </p><p>Once the connection is established, the UA must act as described in the
   section entitled <a href="#sending0">sending and receiving data over
   TCP</a>.

  </p><p class="note">This specification does not include a way to establish
   <em>secure</em> (encrypted) peer-to-peer connections at this time. <span class="big-issue">If you can see a good way to do this, let me know.</span>

  </p><h5 id="bluetooth-peer"><span class="secno">6.3.6.2. </span>Peer-to-peer
   connections over Bluetooth</h5>

  <p class="big-issue">Does anyone know enough about Bluetooth to write this
   section?

  </p><h5 id="irda-peer"><span class="secno">6.3.6.3. </span>Peer-to-peer connections
   over IrDA</h5>

  <p class="big-issue">Does anyone know enough about IrDA to write this
   section?</p>
  <!--XXX
    <p>Prompts the user to select a connection to make, which could
    look like this:</p>

<pre>|:: New Connection :::::::::::::::::::::::::::::::::::::::::|
|                                                           |
|  Select the peer to connect to:                           |
|                                                           |
|    JohnSmith_Series60   via Bluetooth      (( Connect ))  |
|    Patrick's Phone      via Bluetooth       ( Connect )   |
|    John Smith           via UDP             ( Connect )   |
|                                                           |
|                                               ( Cancel )  |
|___________________________________________________________|
</pre>

    <p>While the prompt is displayed, the UA should broadcast on all
    supported networks, as described <span title="announcing peer
    connections">below</span>.</p>

    <p>Returns null if the prompt was canceled. Otherwise, returns a
    <code>Connection</code> object with its <code>network</code>
    attribute set to <var title="">topic</var> and its <code>peer</code>
    attribute set to a string uniquely identifying the selected peer,
    and opens a connection to that peer. (See: <span>peer connection
    formats</span>.)</p>


   |:: New Connection :::::::::::::::::::::::::::::::::::::::::|
   |                                                           |
   |  Would you like to open a connection called "Chess" for   |
   |  this Web site?:                                          |
   |                                                           |
   |    example.org                                            |
   |                                                           |
   |  Select connection to use: [ Bluetooth      | v ]         |
   |                                                           |
   |                        (( Open connection ))  ( Cancel )  |
   |___________________________________________________________|

  c = new LocalBroadcastConnection("Chess");
  c.onread = function(s, f) { alert("got message " + s + " from " + f); }
  c.send("hello, anybody there?");


   |:: New Connection :::::::::::::::::::::::::::::::::::::::::|
   |                                                           |
   |  Select the peer to connect to:                           |
   |                                                           |
   |    JohnSmith_Series60   via Bluetooth      (( Connect ))  |
   |    Patrick's Phone      via Bluetooth       ( Connect )   |
   |    John Smith           via UDP             ( Connect )   |
   |                                                           |
   |                                               ( Cancel )  |
   |___________________________________________________________|

  c = new LocalPeerConnection("Chess");
  // c.peer contains peer's name
  c.onread = function(s) { alert("got message " + s); } // second argument is c.peer
  c.send("hello");

  c = new TCPConnection("chess.example.com", 8089, false);
  // c.peer contains 'chess.example.com:8089'
  c.onread = function(s) { alert("got message " + s); } // second argument is c.peer
  c.send("hello");

> > Again, what else should we support? Should this have an HTML Element
> > backing it for more declarative authoring? What error handling do we need?
> > Should it automatically use bluetooth, TCP/IP broadcast, infrared, or
> > should it be under the control of the author or user?
-->

  <h4 id="the-common"><span class="secno">6.3.7. </span>The common protocol for
   TCP-based connections</h4>

  <p>The same protocol is used for <code title="dom-TCPConnection"><a href="#tcpconnection">TCPConnection</a></code> and <code title="dom-PeerToPeerConnection"><a href="#peertopeerconnection">PeerToPeerConnection</a></code> connection
   types. This section describes how such connections are established from
   the client and server sides, and then describes how data is sent and
   received over such connections (which is the same for both clients and
   servers).

  </p><h5 id="clients"><span class="secno">6.3.7.1. </span><dfn id="clients0">Clients
   connecting over TCP</dfn></h5>

  <p>This section defines the client-side requirements of the protocol used
   by the <code title="dom-TCPConnection"><a href="#tcpconnection">TCPConnection</a></code> and <code title="dom-PeerToPeerConnection"><a href="#peertopeerconnection">PeerToPeerConnection</a></code> connection
   types.

  </p><p>If a TCP connection to the specified target host and port cannot be
   established, for example because the target host is a domain name that
   cannot be resolved to an IP address, or because packets cannot be routed
   to the host, the user agent should retry creating the connection. If the
   user agent gives up trying to connect, the user agent must act as if it
   had <a href="#closeConnection">closed the connection</a>.

  </p><p class="note">No information regarding the state of the connection is
   passed to the application while the connection is being established in
   this version of this specification.

  </p><p>Once a TCP/IP connection to the remote host is established, the user
   agent must transmit the following sequence of bytes, represented here in
   hexadecimal form:

  </p><pre>0x48 0x65 0x6C 0x6C 0x6F 0x0A</pre>

  <p class="note">This represents the string &quot;Hello&quot; followed by a newline,
   encoded in UTF-8.

  </p><p>The user agent must then read all the bytes sent from the remote host,
   up to the first 0x0A byte (inclusive). That string of bytes is then
   compared byte-for-byte to the following string of bytes:

  </p><pre>0x57 0x65 0x6C 0x63 0x6F 0x6E 0x65 0x0A</pre>

  <p class="note">This says &quot;Welcome&quot;.

  </p><p>If the server sent back a string in any way different to this, then the
   user agent must <a href="#closeConnection">close the connection</a> and
   give up trying to connect.

  </p><p>Otherwise, the user agent must then take <a href="section-scripting.html#the-string">the
   string representing the script's domain in IDNA format</a>, encode it as
   UTF-8, and send that to the remote host, followed by a 0x0A byte (a U+000A
   LINE FEED in UTF-8).

  </p><p>The user agent must then read all the bytes sent from the remote host,
   up to the first 0x0A byte (inclusive). That string of bytes must then be
   compared byte-for-byte to the string that was just sent to the server (the
   one with the IDNA domain name and ending with a newline character). If the
   server sent back a string in any way different to this, then the user
   agent must <a href="#closeConnection">close the connection</a> and give up
   trying to connect.

  </p><p>Otherwise, the connection <a href="#openConnection">has been
   established</a> (and events and so forth get fired, as described above).

  </p><p>If at any point during this process the connection is closed
   prematurely, then the user agent must <a href="#closeConnection">close the
   connection</a> and give up trying to connect.</p>
  <!-- XXX we should support automatic reconnect -->

  <h5 id="servers"><span class="secno">6.3.7.2. </span><dfn id="servers0">Servers
   accepting connections over TCP</dfn></h5>

  <p>This section defines the server side of the protocol described in the
   previous section. For authors, it should be used as a guide for how to
   implement servers that can communicate with Web pages over TCP. For UAs
   these are the requirements for the server part of <code title="dom-PeerToPeerConnection"><a href="#peertopeerconnection">PeerToPeerConnection</a></code>s.

  </p><p>Once a TCP/IP connection from a remote host is established, the user
   agent must transmit the following sequence of bytes, represented here in
   hexadecimal form:

  </p><pre>0x57 0x65 0x6C 0x63 0x6F 0x6E 0x65 0x0A</pre>

  <p class="note">This says &quot;Welcome&quot; and a newline in UTF-8.

  </p><p>The user agent must then read all the bytes sent from the remote host,
   up to the first 0x0A byte (inclusive). That string of bytes is then
   compared byte-for-byte to the following string of bytes:

  </p><pre>0x48 0x65 0x6C 0x6C 0x6F 0x0A</pre>

  <p class="note">&quot;Hello&quot; and a newline.

  </p><p>If the remote host sent back a string in any way different to this, then
   the user agent must <a href="#closeConnection">close the connection</a>
   and give up trying to connect.

  </p><p>Otherwise, the user agent must then take <a href="section-scripting.html#the-string">the
   string representing the script's domain in IDNA format</a>, encode it as
   UTF-8, and send that to the remote host, followed by a 0x0A byte (a U+000A
   LINE FEED in UTF-8).

  </p><p>The user agent must then read all the bytes sent from the remote host,
   up to the first 0x0A byte (inclusive). That string of bytes must then be
   compared byte-for-byte to the string that was just sent to that host (the
   one with the IDNA domain name and ending with a newline character). If the
   remote host sent back a string in any way different to this, then the user
   agent must <a href="#closeConnection">close the connection</a> and give up
   trying to connect.

  </p><p>Otherwise, the connection <a href="#openConnection">has been
   established</a> (and events and so forth get fired, as described above).

  </p><p class="note">For author-written servers (as opposed to the server side of
   a peer-to-peer connection), the script's domain would be replaced by the
   hostname of the server. Alternatively, such servers might instead wait for
   the client to send its domain string, and then simply echo it back. This
   would allow connections from pages on any domain, instead of just pages
   originating from the same host. The client compares the two strings to
   ensure they are the same before allowing the connection to be used by
   author script.

  </p><p>If at any point during this process the connection is closed
   prematurely, then the user agent must <a href="#closeConnection">close the
   connection</a> and give up trying to connect.</p>
  <!-- XXX we should support automatic reconnect -->

  <h5 id="sending"><span class="secno">6.3.7.3. </span><dfn id="sending0">Sending
   and receiving data over TCP</dfn></h5>

  <p>When the <code title="dom-Connection-send"><a href="#send">send(<var title="">data</var>)</a></code> method is invoked on the connection's
   corresponding <code><a href="#connection0">Connection</a></code> object,
   the user agent must take the <var title="">data</var> argument, replace
   any U+0000 NULL and U+0017 END OF TRANSMISSION BLOCK characters in it with
   U+FFFD REPLACEMENT CHARACTER characters, then transmit a U+0002 START OF
   TEXT character, this new <var title="">data</var> string and a single
   U+0017 END OF TRANSMISSION BLOCK character (in that order) to the remote
   host, all encoded as UTF-8.

  </p><p>When the user agent receives bytes on the connection, the user agent
   must buffer received bytes until it receives a 0x17 byte (a U+0017 END OF
   TRANSMISSION BLOCK character). If the first buffered byte is not a 0x02
   byte (a U+0002 START OF TEXT character encoded as UTF-8) then all the data
   up to the 0x17 byte, inclusive, must be dropped. (This allows for future
   extension of this protocol.) Otherwise, all the data from (but not
   including) the 0x02 byte and up to (but not including) the 0x17 byte must
   be taken, interpreted as a UTF-8 string, and a <code title="event-connection-read"><a href="#read">read</a></code> event must be
   fired on the <code><a href="#connection0">Connection</a></code> object
   with that string as the <code title="dom-ConnectionReadEvent-data"><a href="#data5">data</a></code>. If that string cannot be decoded as UTF-8
   without errors, the packet should be ignored.

  </p><p class="note">This protocol does not yet allow binary data (e.g. an image
   or <a href="section-video.html#media7">media data</a>) to be efficiently transmitted. A
   future version of this protocol might allow this by using the prefix
   character U+001F INFORMATION SEPARATOR ONE, followed by binary data which
   uses a particular byte (e.g. 0xFF) to encode byte 0x17 somehow (since
   otherwise 0x17 would be treated as transmission end by down-level UAs).</p>
  <!--
    Specifically, replace all occurrences of 0xFF with 0xFF 0xFF and
    all occurrences of 0x17 with 0xFF 0x00, or similar.
   -->

  <h4 id="network-security"><span class="secno">6.3.8. </span>Security</h4>

  <p class="big-issue">Need to write this section.

  </p><p class="big-issue">If you have an unencrypted page that is (through a
   man-in-the-middle attack) changed, it can access a secure service that is
   using IP authentication and then send that data back to the attacker. Ergo
   we should probably stop unencrypted pages from accessing encrypted
   services, on the principle that the actual level of security is zero. Then
   again, if we do that, we prevent insecure sites from using SSL as a
   tunneling mechanism.

  </p><p class="big-issue">Should consider dropping the subdomain-only restriction.
   It doesn't seem to add anything, and prevents cross-domain chatter.

  </p><h4 id="network-other-specs"><span class="secno">6.3.9. </span>Relationship to
   other standards</h4>

  <p class="big-issue">Should have a section talking about the fact that we
   blithely ignoring IANA's port assignments here.

  </p><p class="big-issue">Should explain why we are not reusing HTTP for this.
   (HTTP is too heavy-weight for such a simple need; requiring authors to
   implement an HTTP server just to have a party line is too much of a
   barrier to entry; cannot rely on prebuilt components; having a simple
   protocol makes it much easier to do RAD; HTTP doesn't fit the needs and
   doesn't have the security model needed; etc)

  </p><script src="http://status.whatwg.org/annotate-web-apps.js" type="text/javascript"></script></body></html>
