<!DOCTYPE HTML>


<html lang="en-GB-hixie">
 <head>
  <title>HTML 5</title>
  <link href="/style/specification" type="text/css" rel="stylesheet">
  <link href="/images/icon" rel="icon">

  <style type="text/css">
   h4 + .element { margin-top: -2.5em; padding-top: 2em; }
   h4 + p + .element { margin-top: -5em; padding-top: 4em; }
   .element { background: #EEFFEE; color: black; margin: 0 0 1em -1em; padding: 0 1em 0.25em 0.75em; border-left: solid #99FF99 0.25em; -padding: 0; /* that last decl is for IE6. Try removing it, it's hilarious! */ }
   .proposal { border: blue solid; padding: 1em; }
   table.matrix, table.matrix td { border: none; text-align: right; }
   table.matrix { margin-left: 2em; }
  </style>

 <link href="section-semantics-intro.html#nav-bar" rel="prev" title="3.1. Introduction"><link href="index.html#contents" rel="index" title="Table of contents"><link href="section-documents0.html#nav-bar" rel="next" title="3.3. Documents and document
   fragments"></head><body class="cfc">
  <style scoped>
   * { color: gray ! important; background: none ! important; border-color: silver ! important; }
   img, object, iframe { filter: url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'grayscale\'><feColorMatrix type=\'matrix\' values=\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\'/></filter></svg>#grayscale"); -webkit-filter: grayscale(100%); }
   .obsolete { border: double thick red ! important; background: yellow ! important; margin: 4em auto 0 auto; max-width: 50em; width: 70%; text-align: center; position: fixed;  z-index: 10000; top: 0; left: 0; right: 0; }
   .obsolete a { color: blue ! important; }
   .obsolete p { font: 900 2em sans-serif; color: red ! important; margin: 1em 1.5em ! important; }
  </style>
  <div class=obsolete>
   <p>This is a snapshot of an early working draft and has therefore
   been superseded by the <a href="http://whatwg.org/html">HTML
   standard</a>.</p>
   <p>This document will not be further updated.</p>
  </div>
<div class="head">
   <p><a href="http://www.whatwg.org/" class="logo" rel="home"><img src="/images/logo" alt="WHATWG"></a></p>

   <h1 id="html-5">HTML 5</h1>

   <h2 id="working" class="no-num no-toc">Call For Comments — 27 October 2007</h2></div><nav id="nav-bar"><a href="section-semantics-intro.html#nav-bar">&lt; 3.1. Introduction</a> – <a href="index.html#contents">Table of contents</a> – <a href="section-documents0.html#nav-bar">3.3. Documents and document
   fragments &gt;</a></nav><h3 id="common1"><span class="secno">3.2. </span>Common microsyntaxes</h3>

  <p>There are various places in HTML that accept particular data types, such
   as dates or numbers. This section describes what the conformance criteria
   for content in those formats is, and how to parse them.</p>
  <!-- XXX need to define how to handle U+000A LINE FEED and U+000D
  CARRIAGE RETURN in attributes (for HTML) -->

  <p class="big-issue">Need to go through the whole spec and make sure all the
   attribute values are clearly defined either in terms of microsyntaxes or
   in terms of other specs, or as &quot;Text&quot; or some such.

  </p><h4 id="common2"><span class="secno">3.2.1. </span>Common parser idioms</h4>

  <p>The <dfn id="space" title="space character">space characters</dfn>, for
   the purposes of this specification, are U+0020 SPACE, U+0009 CHARACTER
   TABULATION (tab), U+000A LINE FEED (LF), U+000B LINE TABULATION, U+000C
   FORM FEED (FF), and U+000D CARRIAGE RETURN (CR).

  </p><p>Some of the micro-parsers described below follow the pattern of having
   an <var title="">input</var> variable that holds the string being parsed,
   and having a <var title="">position</var> variable pointing at the next
   character to parse in <var title="">input</var>.

  </p><p>For parsers based on this pattern, a step that requires the user agent
   to <dfn id="collect">collect a sequence of characters</dfn> means that the
   following algorithm must be run, with <var title="">characters</var> being
   the set of characters that can be collected:

  </p><ol>
   <li>
    <p>Let <var title="">input</var> and <var title="">position</var> be the
     same variables as those of the same name in the algorithm that invoked
     these steps.

   </p></li><li>
    <p>Let <var title="">result</var> be the empty string.

   </p></li><li>
    <p>While <var title="">position</var> doesn't point past the end of <var title="">input</var> and the character at <var title="">position</var>
     is one of the <var title="">characters</var>, append that character to
     the end of <var title="">result</var> and advance <var title="">position</var> to the next character in <var title="">input</var>.

   </p></li><li>
    <p>Return <var title="">result</var>.
  </p></li></ol>

  <p>The step <dfn id="skip-whitespace">skip whitespace</dfn> means that the
   user agent must <a href="#collect">collect a sequence of characters</a>
   that are <a href="#space" title="space character">space characters</a>.
   The step <dfn id="skip-">skip Zs characters</dfn> means that the user agent
   must <a href="#collect">collect a sequence of characters</a> that are in
   the Unicode character class Zs. In both cases, the collected characters
   are not used. <a href="#refsUNICODE">[UNICODE]</a>

  </p><h4 id="boolean"><span class="secno">3.2.2. </span>Boolean attributes</h4>

  <p>A number of attributes in HTML5 are <dfn id="boolean0" title="boolean
   attribute">boolean attributes</dfn>. The presence of a boolean attribute
   on an element represents the true value, and the absence of the attribute
   represents the false value.

  </p><p>If the attribute is present, its value must either be the empty string
   or the attribute's canonical name, exactly, with no leading or trailing
   whitespace, and in lowercase.

  </p><h4 id="numbers"><span class="secno">3.2.3. </span>Numbers</h4>

  <h5 id="unsigned"><span class="secno">3.2.3.1. </span>Unsigned integers</h5>

  <p>A string is a <dfn id="valid">valid non-negative integer</dfn> if it
   consists of one of more characters in the range U+0030 DIGIT ZERO (0) to
   U+0039 DIGIT NINE (9).

  </p><p>The <dfn id="rules">rules for parsing non-negative integers</dfn> are as
   given in the following algorithm. When invoked, the steps must be followed
   in the order given, aborting at the first step that returns a value. This
   algorithm will either return zero, a positive integer, or an error.
   Leading spaces are ignored. Trailing spaces and indeed any trailing
   garbage characters are ignored.

  </p><ol>
   <li>
    <p>Let <var title="">input</var> be the string being parsed.

   </p></li><li>
    <p>Let <var title="">position</var> be a pointer into <var title="">input</var>, initially pointing at the start of the string.

   </p></li><li>
    <p>Let <var title="">value</var> have the value 0.

   </p></li><li>
    <p><a href="#skip-whitespace">Skip whitespace.</a>

   </p></li><li>
    <p>If <var title="">position</var> is past the end of <var title="">input</var>, return an error.

   </p></li><li>
    <p>If the next character is not one of U+0030 DIGIT ZERO (0) .. U+0039
     DIGIT NINE (9), then return an error.
   </p></li>
   <!-- Ok. At this point we know we have a number. It might have
   trailing garbage which we'll ignore, but it's a number, and we
   won't return an error. -->

   <li>
    <p>If the next character is one of U+0030 DIGIT ZERO (0) .. U+0039 DIGIT
     NINE (9):</p>

    <ol>
     <li>Multiply <var title="">value</var> by ten.

     </li><li>Add the value of the current character (0..9) to <var title="">value</var>.

     </li><li>Advance <var title="">position</var> to the next character.

     </li><li>If <var title="">position</var> is not past the end of <var title="">input</var>, return to the top of step 7 in the overall
      algorithm (that's the step within which these substeps find
      themselves).
    </li></ol>

   </li><li>
    <p>Return <var title="">value</var>.
  </p></li></ol>

  <h5 id="signed"><span class="secno">3.2.3.2. </span>Signed integers</h5>

  <p>A string is a <dfn id="valid0">valid integer</dfn> if it consists of one
   of more characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE
   (9), optionally prefixed with a U+002D HYPHEN-MINUS (&quot;-&quot;) character.

  </p><p>The <dfn id="rules0">rules for parsing integers</dfn> are similar to the
   rules for non-negative integers, and are as given in the following
   algorithm. When invoked, the steps must be followed in the order given,
   aborting at the first step that returns a value. This algorithm will
   either return an integer or an error. Leading spaces are ignored. Trailing
   spaces and trailing garbage characters are ignored.

  </p><ol>
   <li>
    <p>Let <var title="">input</var> be the string being parsed.

   </p></li><li>
    <p>Let <var title="">position</var> be a pointer into <var title="">input</var>, initially pointing at the start of the string.

   </p></li><li>
    <p>Let <var title="">value</var> have the value 0.

   </p></li><li>
    <p>Let <var title="">sign</var> have the value &quot;positive&quot;.

   </p></li><li>
    <p><a href="#skip-whitespace">Skip whitespace.</a>

   </p></li><li>
    <p>If <var title="">position</var> is past the end of <var title="">input</var>, return an error.

   </p></li><li>
    <p>If the character indicated by <var title="">position</var> (the first
     character) is a U+002D HYPHEN-MINUS (&quot;-&quot;) character:</p>

    <ol>
     <li>Let <var title="">sign</var> be &quot;negative&quot;.

     </li><li>Advance <var title="">position</var> to the next character.

     </li><li>If <var title="">position</var> is past the end of <var title="">input</var>, return an error.
    </li></ol>

   </li><li>
    <p>If the next character is not one of U+0030 DIGIT ZERO (0) .. U+0039
     DIGIT NINE (9), then return an error.
   </p></li>
   <!-- Ok. At this point we know we have a number. It might have
   trailing garbage which we'll ignore, but it's a number, and we
   won't return an error. -->

   <li>
    <p>If the next character is one of U+0030 DIGIT ZERO (0) .. U+0039 DIGIT
     NINE (9):</p>

    <ol>
     <li>Multiply <var title="">value</var> by ten.

     </li><li>Add the value of the current character (0..9) to <var title="">value</var>.

     </li><li>Advance <var title="">position</var> to the next character.

     </li><li>If <var title="">position</var> is not past the end of <var title="">input</var>, return to the top of step 9 in the overall
      algorithm (that's the step within which these substeps find
      themselves).
    </li></ol>

   </li><li>
    <p>If <var title="">sign</var> is &quot;positive&quot;, return <var title="">value</var>, otherwise return 0-<var title="">value</var>.
  </p></li></ol>

  <h5 id="real-numbers"><span class="secno">3.2.3.3. </span>Real numbers</h5>

  <p>A string is a <dfn id="valid1">valid floating point number</dfn> if it
   consists of one of more characters in the range U+0030 DIGIT ZERO (0) to
   U+0039 DIGIT NINE (9), optionally with a single U+002E FULL STOP (&quot;.&quot;)
   character somewhere (either before these numbers, in between two numbers,
   or after the numbers), all optionally prefixed with a U+002D HYPHEN-MINUS
   (&quot;-&quot;) character.

  </p><p>The <dfn id="rules1">rules for parsing floating point number values</dfn>
   are as given in the following algorithm. As with the previous algorithms,
   when this one is invoked, the steps must be followed in the order given,
   aborting at the first step that returns a value. This algorithm will
   either return a number or an error. Leading spaces are ignored. Trailing
   spaces and garbage characters are ignored.

  </p><ol>
   <li>
    <p>Let <var title="">input</var> be the string being parsed.

   </p></li><li>
    <p>Let <var title="">position</var> be a pointer into <var title="">input</var>, initially pointing at the start of the string.

   </p></li><li>
    <p>Let <var title="">value</var> have the value 0.

   </p></li><li>
    <p>Let <var title="">sign</var> have the value &quot;positive&quot;.

   </p></li><li>
    <p><a href="#skip-whitespace">Skip whitespace.</a>

   </p></li><li>
    <p>If <var title="">position</var> is past the end of <var title="">input</var>, return an error.

   </p></li><li>
    <p>If the character indicated by <var title="">position</var> (the first
     character) is a U+002D HYPHEN-MINUS (&quot;-&quot;) character:</p>

    <ol>
     <li>Let <var title="">sign</var> be &quot;negative&quot;.

     </li><li>Advance <var title="">position</var> to the next character.

     </li><li>If <var title="">position</var> is past the end of <var title="">input</var>, return an error.
    </li></ol>

   </li><li>
    <p>If the next character is not one of U+0030 DIGIT ZERO (0) .. U+0039
     DIGIT NINE (9) or U+002E FULL STOP (&quot;.&quot;), then return an error.

   </p></li><li>
    <p>If the next character is U+002E FULL STOP (&quot;.&quot;), but either that is
     the last character or the character after that one is not one of U+0030
     DIGIT ZERO (0) .. U+0039 DIGIT NINE (9), then return an error.
   </p></li>
   <!-- Ok. At this point we know we have a number. It might have
   trailing garbage which we'll ignore, but it's a number, and we
   won't return an error. -->

   <li>
    <p>If the next character is one of U+0030 DIGIT ZERO (0) .. U+0039 DIGIT
     NINE (9):</p>

    <ol>
     <li>Multiply <var title="">value</var> by ten.

     </li><li>Add the value of the current character (0..9) to <var title="">value</var>.

     </li><li>Advance <var title="">position</var> to the next character.

     </li><li>If <var title="">position</var> is past the end of <var title="">input</var>, then if <var title="">sign</var> is &quot;positive&quot;,
      return <var title="">value</var>, otherwise return 0-<var title="">value</var>.

     </li><li>Otherwise return to the top of step 10 in the overall algorithm
      (that's the step within which these substeps find themselves).
    </li></ol>

   </li><li>
    <p>Otherwise, if the next character is not a U+002E FULL STOP (&quot;.&quot;), then
     if <var title="">sign</var> is &quot;positive&quot;, return <var title="">value</var>, otherwise return 0-<var title="">value</var>.

   </p></li><li>
    <p>The next character is a U+002E FULL STOP (&quot;.&quot;). Advance <var title="">position</var> to the character after that.

   </p></li><li>
    <p>Let <var title="">divisor</var> be 1.

   </p></li><li>
    <p>If the next character is one of U+0030 DIGIT ZERO (0) .. U+0039 DIGIT
     NINE (9):</p>

    <ol>
     <li>Multiply <var title="">divisor</var> by ten.

     </li><li>Add the value of the current character (0..9) divided by <var title="">divisor</var>, to <var title="">value</var>.

     </li><li>Advance <var title="">position</var> to the next character.

     </li><li>If <var title="">position</var> is past the end of <var title="">input</var>, then if <var title="">sign</var> is &quot;positive&quot;,
      return <var title="">value</var>, otherwise return 0-<var title="">value</var>.

     </li><li>Otherwise return to the top of step 14 in the overall algorithm
      (that's the step within which these substeps find themselves).
    </li></ol>

   </li><li>
    <p>Otherwise, if <var title="">sign</var> is &quot;positive&quot;, return <var title="">value</var>, otherwise return 0-<var title="">value</var>.
  </p></li></ol>

  <h5 id="ratios"><span class="secno">3.2.3.4. </span>Ratios</h5>

  <p class="note">The algorithms described in this section are used by the
   <code><a href="section-phrase.html#progress">progress</a></code> and <code><a href="section-phrase.html#meter">meter</a></code> elements.

  </p><p>A <dfn id="valid2">valid denominator punctuation character</dfn> is one of
   the characters from the table below. There is <dfn id="a-value" title="values associated with denominator punctuation characters">a value
   associated with each denominator punctuation character</dfn>, as shown in
   the table below.

  </p><table>
   <thead>
    <tr>
     <th colspan="2">Denominator Punctuation Character

     </th><th>Value

   </th></tr></thead><tbody>
    <tr>
     <td>U+0025 PERCENT SIGN

     </td><td>%

     </td><td>100

    </td></tr><tr>
     <td>U+066A ARABIC PERCENT SIGN

     </td><td>٪

     </td><td>100

    </td></tr><tr>
     <td>U+FE6A SMALL PERCENT SIGN

     </td><td>﹪

     </td><td>100

    </td></tr><tr>
     <td>U+FF05 FULLWIDTH PERCENT SIGN

     </td><td>％

     </td><td>100

    </td></tr><tr>
     <td>U+2030 PER MILLE SIGN

     </td><td>‰

     </td><td>1000

    </td></tr><tr>
     <td>U+2031 PER TEN THOUSAND SIGN

     </td><td>‱

     </td><td>10000
  </td></tr></tbody></table>

  <p>The <dfn id="steps">steps for finding one or two numbers of a ratio in a
   string</dfn> are as follows:

  </p><ol>
   <li>If the string is empty, then return nothing and abort these steps.

   </li><li><a href="#find-a">Find a number</a> in the string according to the
    algorithm below, starting at the start of the string.

   </li><li>If the sub-algorithm in step 2 returned nothing or returned an error
    condition, return nothing and abort these steps.

   </li><li>Set <var title="">number1</var> to the number returned by the
    sub-algorithm in step 2.

   </li><li>Starting with the character immediately after the last one examined by
    the sub-algorithm in step 2, skip any characters in the string that are
    in the Unicode character class Zs (this might match zero characters). <a href="#refsUNICODE">[UNICODE]</a>

   </li><li>If there are still further characters in the string, and the next
    character in the string is a <a href="#valid2">valid denominator
    punctuation character</a>, set <var title="">denominator</var> to that
    character.

   </li><li>If the string contains any other characters in the range U+0030 DIGIT
    ZERO to U+0039 DIGIT NINE, but <var title="">denominator</var> was given
    a value in the step 6, return nothing and abort these steps.

   </li><li>Otherwise, if <var title="">denominator</var> was given a value in
    step 6, return <var title="">number1</var> and <var title="">denominator</var> and abort these steps.

   </li><li><a href="#find-a">Find a number</a> in the string again, starting
    immediately after the last character that was examined by the
    sub-algorithm in step 2.

   </li><li>If the sub-algorithm in step 9 returned nothing or an error condition,
    return nothing and abort these steps.

   </li><li>Set <var title="">number2</var> to the number returned by the
    sub-algorithm in step 9.

   </li><li>If there are still further characters in the string, and the next
    character in the string is a <a href="#valid2">valid denominator
    punctuation character</a>, return nothing and abort these steps.

   </li><li>If the string contains any other characters in the range U+0030 DIGIT
    ZERO to U+0039 DIGIT NINE, return nothing and abort these steps.

   </li><li>Otherwise, return <var title="">number1</var> and <var title="">number2</var>.
  </li></ol>
  <!-- XXX again, this should say "positive number" -->

  <p>The algorithm to <dfn id="find-a">find a number</dfn> is as follows. It is
   given a string and a starting position, and returns either nothing, a
   number, or an error condition.

  </p><ol>
   <li>Starting at the given starting position, ignore all characters in the
    given string until the first character that is either a U+002E FULL STOP
    or one of the ten characters in the range U+0030 DIGIT ZERO to U+0039
    DIGIT NINE.

   </li><li>If there are no such characters, return nothing and abort these steps.

   </li><li>Starting with the character matched in step 1, collect all the
    consecutive characters that are either a U+002E FULL STOP or one of the
    ten characters in the range U+0030 DIGIT ZERO to U+0039 DIGIT NINE, and
    assign this string of one or more characters to <var title="">string</var>.

   </li><li>If <var title="">string</var> contains more than one U+002E FULL STOP
    character then return an error condition and abort these steps.

   </li><li>Parse <var title="">string</var> according to the <a href="#rules1">rules for parsing floating point number values</a>, to
    obtain <var title="">number</var>. This step cannot fail (<var title="">string</var> is guarenteed to be a <a href="#valid1">valid
    floating point number</a>).

   </li><li>Return <var title="">number</var>.
  </li></ol>

  <h5 id="percentages-and-dimensions"><span class="secno">3.2.3.5.
   </span>Percentages and dimensions</h5>

  <p class="big-issue"><dfn id="valid3">valid positive non-zero integers</dfn>
   <dfn id="rules2">rules for parsing dimension values</dfn> (only used by
   height/width on img, embed, object — lengths in css pixels or
   percentages)

  </p><h5 id="lists"><span class="secno">3.2.3.6. </span>Lists of integers</h5>

  <p>A <dfn id="valid4">valid list of integers</dfn> is a number of <a href="#valid0" title="valid integer">valid integers</a> separated by
   U+002C COMMA characters, with no other characters (e.g. no <a href="#space" title="space character">space characters</a>). In addition,
   there might be restrictions on the number of integers that can be given,
   or on the range of values allowed.

  </p><p>The <dfn id="rules3">rules for parsing a list of integers</dfn> are as
   follows:

  </p><ol>
   <li>
    <p>Let <var title="">input</var> be the string being parsed.

   </p></li><li>
    <p>Let <var title="">position</var> be a pointer into <var title="">input</var>, initially pointing at the start of the string.

   </p></li><li>
    <p>Let <var title="">numbers</var> be an initially empty list of
     integers. This list will be the result of this algorithm.

   </p></li><li>
    <p>If there is a character in the string <var title="">input</var> at
     position <var title="">position</var>, and it is either U+002C COMMA
     character or a U+0020 SPACE character, then advance <var title="">position</var> to the next character in <var title="">input</var>, or to beyond the end of the string if there are no
     more characters.

   </p></li><li>
    <p>If <var title="">position</var> points to beyond the end of <var title="">input</var>, return <var title="">numbers</var> and abort.

   </p></li><li>
    <p>If the character in the string <var title="">input</var> at position
     <var title="">position</var> is a U+002C COMMA character or a U+0020
     SPACE character, return to step 4.

   </p></li><li>
    <p>Let <var title="">negated</var> be false.

   </p></li><li>
    <p>Let <var title="">value</var> be 0.

   </p></li><li>
    <p>Let <var title="">multiple</var> be 1.

   </p></li><li>
    <p>Let <var title="">started</var> be false.

   </p></li><li>
    <p>Let <var title="">finished</var> be false.

   </p></li><li>
    <p>Let <var title="">bogus</var> be false.

   </p></li><li>
    <p><em>Parser:</em> If the character in the string <var title="">input</var> at position <var title="">position</var> is:</p>

    <dl class="switch"><!-- XXX this doesn't quite match what IE does: http://www.hixie.ch/tests/adhoc/html/flow/image-maps/004-demo.html
          I couldn't work out a pattern to IE's results. Let me know if you can see one. -->

     <dt>A U+002D HYPHEN-MINUS character

     </dt><dd>
      <p>Follow these substeps:</p>

      <ol>
       <li>If <var title="">finished</var> is true, skip to the next step in
        the overall set of steps.

       </li><li>If <var title="">started</var> is true or if <var title="">bogus</var> is true, let <var title="">negated</var> be
        false.

       </li><li>Otherwise, if <var title="">started</var> is false and if <var title="">bogus</var> is false, let <var title="">negated</var> be
        true.

       </li><li>Let <var title="">started</var> be true.
      </li></ol>

     </dd><dt>A character in the range U+0030 DIGIT ZERO .. U+0039 DIGIT NINE

     </dt><dd>
      <p>Follow these substeps:</p>

      <ol>
       <li>If <var title="">finished</var> is true, skip to the next step in
        the overall set of steps.

       </li><li>Let <var title="">n</var> be the value of the digit, interpreted
        in base ten, multiplied by <var title="">multiple</var>.

       </li><li>Add <var title="">n</var> to <var title="">value</var>.

       </li><li>If <var title="">value</var> is greater than zero, multiply <var title="">multiple</var> by ten.

       </li><li>Let <var title="">started</var> be true.
      </li></ol>

     </dd><dt>A U+002C COMMA character

     </dt><dt>A U+0020 SPACE character

     </dt><dd>
      <p>Follow these substeps:</p>

      <ol>
       <li>If <var title="">started</var> is false, return the <var title="">numbers</var> list and abort.

       </li><li>If <var title="">negated</var> is true, then negate <var title="">value</var>.

       </li><li>Append <var title="">value</var> to the <var title="">numbers</var> list.

       </li><li>Jump to step 4 in the overall set of steps.
      </li></ol>

     </dd><dt>A U+002E FULL STOP character

     </dt><dd>
      <p>Follow these substeps:</p>

      <ol>
       <li>Let <var title="">finished</var> be true.
      </li></ol>

     </dd><dt>Any other character

     </dt><dd>
      <p>Follow these substeps:</p>

      <ol>
       <li>If <var title="">finished</var> is true, skip to the next step in
        the overall set of steps.

       </li><li>Let <var title="">negated</var> be false.

       </li><li>Let <var title="">bogus</var> be true.

       </li><li>If <var title="">started</var> is true, then return the <var title="">numbers</var> list, and abort. (The value in <var title="">value</var> is not appended to the list first; it is
        dropped.)
      </li></ol>
    </dd></dl>

   </li><li>
    <p>Advance <var title="">position</var> to the next character in <var title="">input</var>, or to beyond the end of the string if there are no
     more characters.

   </p></li><li>
    <p>If <var title="">position</var> points to a character (and not to
     beyond the end of <var title="">input</var>), jump to the big
     <em>Parser</em> step above.

   </p></li><li>
    <p>If <var title="">negated</var> is true, then negate <var title="">value</var>.

   </p></li><li>
    <p>If <var title="">started</var> is true, then append <var title="">value</var> to the <var title="">numbers</var> list, return
     that list, and abort.

   </p></li><li>
    <p>Return the <var title="">numbers</var> list and abort.
  </p></li></ol>

  <h4 id="dates"><span class="secno">3.2.4. </span>Dates and times</h4>

  <p>In the algorithms below, the <dfn id="number">number of days in month <var title="">month</var> of year <var title="">year</var></dfn> is:
   <em>31</em> if <var title="">month</var> is 1, 3, 5, 7, 8, 10, or 12;
   <em>30</em> if <var title="">month</var> is 4, 6, 9, or 11; <em>29</em> if
   <var title="">month</var> is 2 and <var title="">year</var> is a number
   divisible by 400, or if <var title="">year</var> is a number divisible by
   4 but not by 100; and <em>28</em> otherwise. This takes into account leap
   years in the Gregorian calendar. <a href="#refsGREGORIAN">[GREGORIAN]</a>

  </p><h5 id="specific"><span class="secno">3.2.4.1. </span>Specific moments in time</h5>

  <p>A string is a <dfn id="valid5">valid datetime</dfn> if it has four digits
   (representing the year), a literal hyphen, two digits (representing the
   month), a literal hyphen, two digits (representing the day), optionally
   some spaces, either a literal T or a space, optionally some more spaces,
   two digits (for the hour), a colon, two digits (the minutes), optionally
   the seconds (which, if included, must consist of another colon, two digits
   (the integer part of the seconds), and optionally a decimal point followed
   by one or more digits (for the fractional part of the seconds)),
   optionally some spaces, and finally either a literal Z (indicating the
   time zone is UTC), or, a plus sign or a minus sign followed by two digits,
   a colon, and two digits (for the sign, the hours and minutes of the
   timezone offset respectively); with the month-day combination being a
   valid date in the given year according to the Gregorian calendar, the hour
   values (<var title="">h</var>) being in the range 0 ≤ <var title="">h</var> ≤ 23, the minute values (<var title="">m</var>) in the range 0 ≤ <var title="">m</var> ≤ 59, and the second value (<var title="">s</var>) being in the range 0 ≤ <var title="">h</var> &lt; 60. <a href="#refsGREGORIAN">[GREGORIAN]</a></p>
  <!--XXX [GREGORIAN] should point to
  <dd id="refsGREGORIAN">[GREGORIAN]</dd>
  <dd>(Non-normative) <cite>Inter Gravissimas</cite>, A. Lilius, C. Clavius. Gregory XIII Papal Bulls, February 1582.</dd>
  -->

  <p>The digits must be characters in the range U+0030 DIGIT ZERO (0) to
   U+0039 DIGIT NINE (9), the hyphens must be a U+002D HYPHEN-MINUS
   characters, the T must be a U+0054 LATIN CAPITAL LETTER T, the colons must
   be U+003A COLON characters, the decimal point must be a U+002E FULL STOP,
   the Z must be a U+005A LATIN CAPITAL LETTER Z, the plus sign must be a
   U+002B PLUS SIGN, and the minus U+002D (same as the hyphen).

  </p><div class="example">
   <p>The following are some examples of dates written as <a href="#valid5" title="valid datetime">valid datetimes</a>.</p>

   <dl>
    <dt>&quot;<code>0037-12-13 00:00 Z</code>&quot;

    </dt><dd>Midnight UTC on the birthday of Nero (the Roman Emperor).

    </dd><dt>&quot;<code>1979-10-14T12:00:00.001-04:00</code>&quot;

    </dt><dd>One millisecond after noon on October 14th 1979, in the time zone in
     use on the east coast of North America during daylight saving time.

    </dd><dt>&quot;<code>8592-01-01 T 02:09 +02:09</code>&quot;

    </dt><dd>Midnight UTC on the 1st of January, 8592. The time zone associated
     with that time is two hours and nine minutes ahead of UTC.
   </dd></dl>

   <p>Several things are notable about these dates:</p>

   <ul>
    <li>Years with fewer than four digits have to be zero-padded. The date
     &quot;37-12-13&quot; would not be a valid date.

    </li><li>To unambiguously identify a moment in time prior to the introduction
     of the Gregorian calendar, the date has to be first converted to the
     Gregorian calendar from the calendar in use at the time (e.g. from the
     Julian calendar). The date of Nero's birth is the 15th of December 37,
     in the Julian Calendar, which is the 13th of December 37 in the
     Gregorian Calendar.</li>
    <!--
    XXX this might not be true. I can't find a reference that gives
    his birthday with an explicit statement about the calendar being
    used. However, it seems unlikely that it would be given in the
    Gregorian calendar, so I assume sites use the Julian one. -->

    <li>The time and timezone components are not optional.

    </li><li>Dates before the year 0 or after the year 9999 can't be represented
     as a datetime in this version of HTML.

    </li><li>Time zones differ based on daylight savings time.
   </li></ul>
  </div>

  <p class="note">Conformance checkers can use the algorithm below to determine
   if a datetime is a valid datetime or not.

  </p><p>To <dfn id="datetime-parser">parse a string as a datetime value</dfn>, a
   user agent must apply the following algorithm to the string. This will
   either return a time in UTC, with associated timezone information for
   round tripping or display purposes, or nothing, indicating the value is
   not a <a href="#valid5">valid datetime</a>. If at any point the algorithm
   says that it &quot;fails&quot;, this means that it returns nothing.

  </p><ol>
   <li>
    <p>Let <var title="">input</var> be the string being parsed.

   </p></li><li>
    <p>Let <var title="">position</var> be a pointer into <var title="">input</var>, initially pointing at the start of the string.

   </p></li><li>
    <p><a href="#collect">Collect a sequence of characters</a> in the range
     U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
     sequence is not exactly four characters long, then fail. Otherwise,
     interpret the resulting sequence as a base ten integer. Let that number
     be the <var title="">year</var>.

   </p></li><li>
    <p>If <var title="">position</var> is beyond the end of <var title="">input</var> or if the character at <var title="">position</var>
     is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move <var title="">position</var> forwards one character.

   </p></li><li>
    <p><a href="#collect">Collect a sequence of characters</a> in the range
     U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
     sequence is not exactly two characters long, then fail. Otherwise,
     interpret the resulting sequence as a base ten integer. Let that number
     be the <var title="">month</var>.

   </p></li><li>If <var title="">month</var> is not a number in the range
    1 ≤ <var title="">month</var> ≤ 12, then fail.

   </li><li>
    <p>Let <var title="">maxday</var> be the <a href="#number">number of days
     in month <var title="">month</var> of year <var title="">year</var></a>.

   </p></li><li>
    <p>If <var title="">position</var> is beyond the end of <var title="">input</var> or if the character at <var title="">position</var>
     is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move <var title="">position</var> forwards one character.

   </p></li><li>
    <p><a href="#collect">Collect a sequence of characters</a> in the range
     U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
     sequence is not exactly two characters long, then fail. Otherwise,
     interpret the resulting sequence as a base ten integer. Let that number
     be the <var title="">day</var>.

   </p></li><li>
    <p>If <var title="">day</var> is not a number in the range
     1 ≤ <var title="">month</var> ≤ <var title="">maxday</var>, then fail.

   </p></li><li>
    <p><a href="#collect">Collect a sequence of characters</a> that are
     either U+0054 LATIN CAPITAL LETTER T characters or <a href="#space" title="space character">space characters</a>. If the collected sequence
     is zero characters long, or if it contains more than one U+0054 LATIN
     CAPITAL LETTER T character, then fail.

   </p></li><li>
    <p><a href="#collect">Collect a sequence of characters</a> in the range
     U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
     sequence is not exactly two characters long, then fail. Otherwise,
     interpret the resulting sequence as a base ten integer. Let that number
     be the <var title="">hour</var>.

   </p></li><li>If <var title="">hour</var> is not a number in the range
    0 ≤ <var title="">hour</var> ≤ 23, then fail.

   </li><li>
    <p>If <var title="">position</var> is beyond the end of <var title="">input</var> or if the character at <var title="">position</var>
     is not a U+003A COLON character, then fail. Otherwise, move <var title="">position</var> forwards one character.

   </p></li><li>
    <p><a href="#collect">Collect a sequence of characters</a> in the range
     U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
     sequence is not exactly two characters long, then fail. Otherwise,
     interpret the resulting sequence as a base ten integer. Let that number
     be the <var title="">minute</var>.

   </p></li><li>If <var title="">minute</var> is not a number in the range
    0 ≤ <var title="">minute</var> ≤ 59, then fail.

   </li><li>
    <p>Let <var title="">second</var> be a string with the value &quot;0&quot;.

   </p></li><li>
    <p>If <var title="">position</var> is beyond the end of <var title="">input</var>, then fail.

   </p></li><li>
    <p>If the character at <var title="">position</var> is a U+003A COLON,
     then:</p>

    <ol>
     <li>
      <p>Advance <var title="">position</var> to the next character in <var title="">input</var>.

     </p></li><li>
      <p>If <var title="">position</var> is beyond the end of <var title="">input</var>, or at the last character in <var title="">input</var>, or if the next <em>two</em> characters in <var title="">input</var> starting at <var title="">position</var> are not
       two characters both in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT
       NINE (9), then fail.

     </p></li><li>
      <p><a href="#collect">Collect a sequence of characters</a> that are
       either characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT
       NINE (9) or U+002E FULL STOP characters. If the collected sequence has
       more than one U+002E FULL STOP characters, or if the last character in
       the sequence is a U+002E FULL STOP character, then fail. Otherwise,
       let the collected string be <var title="">second</var> instead of its
       previous value.
    </p></li></ol>

   </li><li>
    <p>Interpret <var title="">second</var> as a base ten number (possibly
     with a fractional part). Let that number be <var title="">second</var>
     instead of the string version.

   </p></li><li>If <var title="">second</var> is not a number in the range
    0 ≤ <var title="">hour</var> &lt; 60, then fail.
    (The values 60 and 61 are not allowed: leap seconds cannot be represented
    by datetime values.)

   </li><li>
    <p>If <var title="">position</var> is beyond the end of <var title="">input</var>, then fail.

   </p></li><li>
    <p><a href="#skip-whitespace">Skip whitespace.</a>

   </p></li><li>
    <p>If the character at <var title="">position</var> is a U+005A LATIN
     CAPITAL LETTER Z, then:</p>

    <ol>
     <li>
      <p>Let <var title="">timezone<sub title="">hours</sub></var> be 0.

     </p></li><li>
      <p>Let <var title="">timezone<sub title="">minutes</sub></var> be 0.

     </p></li><li>
      <p>Advance <var title="">position</var> to the next character in <var title="">input</var>.
    </p></li></ol>

   </li><li>
    <p>Otherwise, if the character at <var title="">position</var> is either
     a U+002B PLUS SIGN (&quot;+&quot;) or a U+002D HYPHEN-MINUS (&quot;-&quot;), then:</p>

    <ol>
     <li>
      <p>If the character at <var title="">position</var> is a U+002B PLUS
       SIGN (&quot;+&quot;), let <var title="">sign</var> be &quot;positive&quot;. Otherwise,
       it's a U+002D HYPHEN-MINUS (&quot;-&quot;); let <var title="">sign</var> be
       &quot;negative&quot;.

     </p></li><li>
      <p>Advance <var title="">position</var> to the next character in <var title="">input</var>.

     </p></li><li>
      <p><a href="#collect">Collect a sequence of characters</a> in the range
       U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
       sequence is not exactly two characters long, then fail. Otherwise,
       interpret the resulting sequence as a base ten integer. Let that
       number be the <var title="">timezone<sub title="">hours</sub></var>.

     </p></li><li>If <var title="">timezone<sub title="">hours</sub></var> is not a
      number in the range 0 ≤ <var title="">timezone<sub title="">hours</sub></var> ≤ 23, then fail.

     </li><li>If <var title="">sign</var> is &quot;negative&quot;, then negate <var title="">timezone<sub title="">hours</sub></var>.

     </li><li>
      <p>If <var title="">position</var> is beyond the end of <var title="">input</var> or if the character at <var title="">position</var> is not a U+003A COLON character, then fail.
       Otherwise, move <var title="">position</var> forwards one character.

     </p></li><li>
      <p><a href="#collect">Collect a sequence of characters</a> in the range
       U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
       sequence is not exactly two characters long, then fail. Otherwise,
       interpret the resulting sequence as a base ten integer. Let that
       number be the <var title="">timezone<sub title="">minutes</sub></var>.

     </p></li><li>If <var title="">timezone<sub title="">minutes</sub></var> is not a
      number in the range 0 ≤ <var title="">timezone<sub title="">minutes</sub></var> ≤ 59, then fail.

     </li><li>If <var title="">sign</var> is &quot;negative&quot;, then negate <var title="">timezone<sub title="">minutes</sub></var>.
    </li></ol>

   </li><li>
    <p>If <var title="">position</var> is <em>not</em> beyond the end of <var title="">input</var>, then fail.

   </p></li><li>
    <p>Let <var title="">time</var> be the moment in time at year <var title="">year</var>, month <var title="">month</var>, day <var title="">day</var>, hours <var title="">hour</var>, minute <var title="">minute</var>, second <var title="">second</var>, subtracting
     <var title="">timezone<sub title="">hours</sub></var> hours and <var title="">timezone<sub title="">minutes</sub></var> minutes. That moment
     in time is a moment in the UTC timezone.

   </p></li><li>
    <p>Let <var title="">timezone</var> be <var title="">timezone<sub title="">hours</sub></var> hours and <var title="">timezone<sub title="">minutes</sub></var> minutes from UTC.

   </p></li><li>
    <p>Return <var title="">time</var> and <var title="">timezone</var>.
  </p></li></ol>

  <h5 id="vaguer"><span class="secno">3.2.4.2. </span>Vaguer moments in time</h5>

  <p>This section defines <dfn id="date-or" title="date or time string">date or
   time strings</dfn>. There are two kinds, <dfn id="date-or0" title="date or
   time string in content">date or time strings in content</dfn>, and <dfn id="date-or1" title="date or time string in attributes">date or time strings
   in attributes</dfn>. The only difference is in the handling of whitespace
   characters.

  </p><p>To parse a <a href="#date-or">date or time string</a>, user agents must
   use the following algorithm. A <a href="#date-or">date or time string</a>
   is a <em>valid</em> date or time string if the following algorithm, when
   run on the string, doesn't say the string is invalid.

  </p><p>The algorithm may return nothing (in which case the string will be
   invalid), or it may return a date, a time, a date and a time, or a date
   and a time and and a timezone. Even if the algorithm returns one or more
   values, the string can still be invalid.

  </p><ol><!-- INIT -->

   <li>
    <p>Let <var title="">input</var> be the string being parsed.

   </p></li><li>
    <p>Let <var title="">position</var> be a pointer into <var title="">input</var>, initially pointing at the start of the string.

   </p></li><li>
    <p>Let <var title="">results</var> be the collection of results that are
     to be returned (one or more of a date, a time, and a timezone),
     initially empty. If the algorithm aborts at any point, then whatever is
     currently in <var title="">results</var> must be returned as the result
     of the algorithm.
   </p></li>
   <!-- LEADING WHITESPACE -->

   <li>
    <p>For the &quot;in content&quot; variant: <a href="#skip-">skip Zs characters</a>;
     for the &quot;in attributes&quot; variant: <a href="#skip-whitespace">skip
     whitespace</a>.
   </p></li>
   <!-- XXX skip whitespace in attribute?
   really? -->
   <!-- YEAR or HOUR -->

   <li>
    <p><a href="#collect">Collect a sequence of characters</a> in the range
     U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
     sequence is empty, then the string is invalid; abort these steps.

   </p></li><li>
    <p>Let the sequence of characters collected in the last step be <var title="">s</var>.

   </p></li><li>
    <p>If <var title="">position</var> is past the end of <var title="">input</var>, the string is invalid; abort these steps.

   </p></li><li>
    <p>If the character at <var title="">position</var> is <em>not</em> a
     U+003A COLON character, then:</p>
    <!-- DATE -->
    <ol>
     <li>
      <p>If the character at <var title="">position</var> is not a U+002D
       HYPHEN-MINUS (&quot;-&quot;) character either, then the string is invalid, abort
       these steps.
     </p></li>
     <!-- YEAR -->

     <li>
      <p>If the sequence <var title="">s</var> is not exactly four digits
       long, then the string is invalid. (This does not stop the algorithm,
       however.)

     </p></li><li>
      <p>Interpret the sequence of characters collected in step 5 as a base
       ten integer, and let that number be <var title="">year</var>.

     </p></li><li>
      <p>Advance <var title="">position</var> past the U+002D HYPHEN-MINUS
       (&quot;-&quot;) character.
     </p></li>
     <!-- MONTH -->

     <li>
      <p><a href="#collect">Collect a sequence of characters</a> in the range
       U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
       sequence is empty, then the string is invalid; abort these steps.

     </p></li><li>
      <p>If the sequence collected in the last step is not exactly two digits
       long, then the string is invalid.

     </p></li><li>
      <p>Interpret the sequence of characters collected two steps ago as a
       base ten integer, and let that number be <var title="">month</var>.

     </p></li><li>If <var title="">month</var> is not a number in the range
      1 ≤ <var title="">month</var> ≤ 12, then the
      string is invalid, abort these steps.

     </li><li>
      <p>Let <var title="">maxday</var> be the <a href="#number">number of
       days in month <var title="">month</var> of year <var title="">year</var></a>.

     </p></li><li>
      <p>If <var title="">position</var> is past the end of <var title="">input</var>, or if the character at <var title="">position</var> is <em>not</em> a U+002D HYPHEN-MINUS (&quot;-&quot;)
       character, then the string is invalid, abort these steps. Otherwise,
       advance <var title="">position</var> to the next character.
     </p></li>
     <!-- DAY -->

     <li>
      <p><a href="#collect">Collect a sequence of characters</a> in the range
       U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
       sequence is empty, then the string is invalid; abort these steps.

     </p></li><li>
      <p>If the sequence collected in the last step is not exactly two digits
       long, then the string is invalid.

     </p></li><li>
      <p>Interpret the sequence of characters collected two steps ago as a
       base ten integer, and let that number be <var title="">day</var>.

     </p></li><li>
      <p>If <var title="">day</var> is not a number in the range
       1 ≤ <var title="">day</var> ≤ <var title="">maxday</var>, then the string is invalid, abort these steps.

     </p></li><li>
      <p>Add the date represented by <var title="">year</var>, <var title="">month</var>, and <var title="">day</var> to the <var title="">results</var>.
     </p></li>
     <!-- WHITESPACE -->

     <li>
      <p>For the &quot;in content&quot; variant: <a href="#skip-">skip Zs
       characters</a>; for the &quot;in attributes&quot; variant: <a href="#skip-whitespace">skip whitespace</a>.

     </p></li><li>
      <p>If the character at <var title="">position</var> is a U+0054 LATIN
       CAPITAL LETTER T, then move <var title="">position</var> forwards one
       character.

     </p></li><li>
      <p>For the &quot;in content&quot; variant: <a href="#skip-">skip Zs
       characters</a>; for the &quot;in attributes&quot; variant: <a href="#skip-whitespace">skip whitespace</a>.
     </p></li>
     <!-- at this point, if <var title="">position</var> points to a
     number, we know that we passed at least one space or a T, because
     otherwise the number would have been slurped up in the last
     "collect" step. -->
     <!-- HOUR -->

     <li>
      <p><a href="#collect">Collect a sequence of characters</a> in the range
       U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
       sequence is empty, then the string is invalid; abort these steps.

     </p></li><li>
      <p>Let <var title="">s</var> be the sequence of characters collected in
       the last step.
    </p></li></ol>
   </li>
   <!-- TIME -->

   <li>
    <p>If <var title="">s</var> is not exactly two digits long, then the
     string is invalid.

   </p></li><li>
    <p>Interpret the sequence of characters collected two steps ago as a base
     ten integer, and let that number be <var title="">hour</var>.

   </p></li><li>
    <p>If <var title="">hour</var> is not a number in the range
     0 ≤ <var title="">hour</var> ≤ 23, then the
     string is invalid, abort these steps.

   </p></li><li>
    <p>If <var title="">position</var> is past the end of <var title="">input</var>, or if the character at <var title="">position</var> is <em>not</em> a U+003A COLON character, then
     the string is invalid, abort these steps. Otherwise, advance <var title="">position</var> to the next character.
   </p></li>
   <!-- MINUTE -->

   <li>
    <p><a href="#collect">Collect a sequence of characters</a> in the range
     U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the collected
     sequence is empty, then the string is invalid; abort these steps.

   </p></li><li>
    <p>If the sequence collected in the last step is not exactly two digits
     long, then the string is invalid.

   </p></li><li>
    <p>Interpret the sequence of characters collected two steps ago as a base
     ten integer, and let that number be <var title="">minute</var>.

   </p></li><li>
    <p>If <var title="">minute</var> is not a number in the range
     0 ≤ <var title="">minute</var> ≤ 59, then the
     string is invalid, abort these steps.
   </p></li>
   <!-- SECOND -->

   <li>
    <p>Let <var title="">second</var> be 0. It may be changed to another
     value in the next step.

   </p></li><li>
    <p>If <var title="">position</var> is not past the end of <var title="">input</var> and the character at <var title="">position</var>
     is a U+003A COLON character, then:</p>

    <ol>
     <li>
      <p><a href="#collect">Collect a sequence of characters</a> that are
       either characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT
       NINE (9) or are U+002E FULL STOP. If the collected sequence is empty,
       or contains more than one U+002E FULL STOP character, then the string
       is invalid; abort these steps.

     </p></li><li>
      <p>If the first character in the sequence collected in the last step is
       not in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9), then
       the string is invalid.

     </p></li><li>
      <p>Interpret the sequence of characters collected two steps ago as a
       base ten number (possibly with a fractional part), and let that number
       be <var title="">second</var>.

     </p></li><li>
      <p>If <var title="">second</var> is not a number in the range
       0 ≤ <var title="">minute</var> &lt; 60, then
       the string is invalid, abort these steps.
    </p></li></ol>

   </li><li>
    <p>Add the time represented by <var title="">hour</var>, <var title="">minute</var>, and <var title="">second</var> to the <var title="">results</var>.
   </p></li>
   <!-- TIME ZONE -->

   <li>
    <p>If <var title="">results</var> has both a date and a time, then:</p>

    <ol>
     <li>
      <p>For the &quot;in content&quot; variant: <a href="#skip-">skip Zs
       characters</a>; for the &quot;in attributes&quot; variant: <a href="#skip-whitespace">skip whitespace</a>.

     </p></li><li>
      <p>If <var title="">position</var> is past the end of <var title="">input</var>, then skip to the next step in the overall set of
       steps.</p>
      <!-- UTC -->

     </li><li>
      <p>Otherwise, if the character at <var title="">position</var> is a
       U+005A LATIN CAPITAL LETTER Z, then:</p>

      <ol>
       <li>
        <p>Add the timezone corresponding to UTC (zero offset) to the <var title="">results</var>.

       </p></li><li>
        <p>Advance <var title="">position</var> to the next character in <var title="">input</var>.

       </p></li><li>
        <p>Skip to the next step in the overall set of steps.
      </p></li></ol>
     </li>
     <!-- EXPLICIT TIMEZONE OFFSET -->

     <li>
      <p>Otherwise, if the character at <var title="">position</var> is
       either a U+002B PLUS SIGN (&quot;+&quot;) or a U+002D HYPHEN-MINUS (&quot;-&quot;), then:</p>

      <ol><!-- SIGN -->

       <li>
        <p>If the character at <var title="">position</var> is a U+002B PLUS
         SIGN (&quot;+&quot;), let <var title="">sign</var> be &quot;positive&quot;. Otherwise,
         it's a U+002D HYPHEN-MINUS (&quot;-&quot;); let <var title="">sign</var> be
         &quot;negative&quot;.
       </p></li>
       <!-- HOURS -->

       <li>
        <p>Advance <var title="">position</var> to the next character in <var title="">input</var>.

       </p></li><li>
        <p><a href="#collect">Collect a sequence of characters</a> in the
         range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the
         collected sequence is not exactly two characters long, then the
         string is invalid.

       </p></li><li>
        <p>Interpret the sequence collected in the last step as a base ten
         number, and let that number be <var title="">timezone<sub title="">hours</sub></var>.

       </p></li><li>If <var title="">timezone<sub title="">hours</sub></var> is not a
        number in the range 0 ≤ <var title="">timezone<sub title="">hours</sub></var> ≤ 23, then the string is
        invalid; abort these steps.

       </li><li>If <var title="">sign</var> is &quot;negative&quot;, then negate <var title="">timezone<sub title="">hours</sub></var>.

       </li><li>
        <p>If <var title="">position</var> is beyond the end of <var title="">input</var> or if the character at <var title="">position</var> is not a U+003A COLON character, then the
         string is invalid; abort these steps. Otherwise, move <var title="">position</var> forwards one character.
       </p></li>
       <!-- MINUTES -->

       <li>
        <p><a href="#collect">Collect a sequence of characters</a> in the
         range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9). If the
         collected sequence is not exactly two characters long, then the
         string is invalid.

       </p></li><li>
        <p>Interpret the sequence collected in the last step as a base ten
         number, and let that number be <var title="">timezone<sub title="">minutes</sub></var>.

       </p></li><li>If <var title="">timezone<sub title="">minutes</sub></var> is not
        a number in the range 0 ≤ <var title="">timezone<sub title="">minutes</sub></var> ≤ 59, then the string is
        invalid; abort these steps.

       </li><li>
        <p>Add the timezone corresponding to an offset of <var title="">timezone<sub title="">hours</sub></var> hours and <var title="">timezone<sub title="">minutes</sub></var> minutes to the
         <var title="">results</var>.

       </p></li><li>
        <p>Skip to the next step in the overall set of steps.
      </p></li></ol>

     </li><li>
      <p>Otherwise, the string is invalid; abort these steps.
    </p></li></ol>

   </li><li>
    <p>For the &quot;in content&quot; variant: <a href="#skip-">skip Zs characters</a>;
     for the &quot;in attributes&quot; variant: <a href="#skip-whitespace">skip
     whitespace</a>.

   </p></li><li>
    <p>If <var title="">position</var> is <em>not</em> past the end of <var title="">input</var>, then the string is invalid.</p>

   </li><li>
    <p>Abort these steps (the string is parsed).
  </p></li></ol>

  <h4 id="time-offsets"><span class="secno">3.2.5. </span>Time offsets</h4>

  <p class="big-issue"><dfn id="valid6">valid time offset</dfn>, <dfn id="rules4">rules for parsing time offsets</dfn>, <dfn id="time-offset">time
   offset serialisation rules</dfn>; in the format &quot;5d4h3m2s1ms&quot; or &quot;3m 9.2s&quot;
   or &quot;00:00:00.00&quot; or similar.

  </p><h4 id="tokens"><span class="secno">3.2.6. </span>Tokens</h4>

  <p>A <dfn id="set-of">set of space-separated tokens</dfn> is a set of zero or
   more words separated by one or more <a href="#space" title="space
   character">space characters</a>, where words consist of any string of one
   or more characters, none of which are <a href="#space" title="space
   character">space characters</a>.

  </p><p>A string containing a <a href="#set-of">set of space-separated
   tokens</a> may have leading or trailing <a href="#space" title="space
   character">space characters</a>.

  </p><p>An <dfn id="unordered">unordered set of space-separated tokens</dfn> is a
   <a href="#set-of">set of space-separated tokens</a> where none of the
   words are duplicated.

  </p><p>An <dfn id="ordered">ordered set of unique space-separated tokens</dfn> is
   a <a href="#set-of">set of space-separated tokens</a> where none of the
   words are duplicated but where the order of the tokens is meaningful.

  </p><p>When a user agent has to <dfn id="split">split a string on spaces</dfn>,
   it must use the following algorithm:

  </p><ol>
   <li>
    <p>Let <var title="">input</var> be the string being parsed.

   </p></li><li>
    <p>Let <var title="">position</var> be a pointer into <var title="">input</var>, initially pointing at the start of the string.

   </p></li><li>
    <p>Let <var title="">tokens</var> be a list of tokens, initially empty.

   </p></li><li>
    <p><a href="#skip-whitespace">Skip whitespace</a>

   </p></li><li>
    <p>While <var title="">position</var> is not past the end of <var title="">input</var>:</p>

    <ol>
     <li>
      <p><a href="#collect">Collect a sequence of characters</a> that are not
       <a href="#space" title="space character">space characters</a>.

     </p></li><li>
      <p>Add the string collected in the previous step to <var title="">tokens</var>.

     </p></li><li>
      <p><a href="#skip-whitespace">Skip whitespace</a>
    </p></li></ol>

   </li><li>
    <p>Return <var title="">tokens</var>.
  </p></li></ol>

  <p>When a user agent has to <dfn id="remove0">remove a token from a
   string</dfn>, it must use the following algorithm:

  </p><ol>
   <li>
    <p>Let <var title="">input</var> be the string being modified.

   </p></li><li>
    <p>Let <var title="">token</var> be the token being removed. It will not
     contain any <a href="#space" title="space character">space
     characters</a>.

   </p></li><li>
    <p>Let <var title="">output</var> be the output string, initially empty.

   </p></li><li>
    <p>Let <var title="">position</var> be a pointer into <var title="">input</var>, initially pointing at the start of the string.

   </p></li><li>
    <p>If <var title="">position</var> is beyond the end of <var title="">input</var>, set the string being modified to <var title="">output</var>, and abort these steps.

   </p></li><li>
    <p>If the character at <var title="">position</var> is a <a href="#space">space character</a>:

    </p><ol>
     <li>
      <p>Append the character at <var title="">position</var> to the end of
       <var title="">output</var>.

     </p></li><li>
      <p>Increment <var title="">position</var> so it points at the next
       character in <var title="">input</var>.

     </p></li><li>
      <p>Return to step 5 in the overall set of steps.
    </p></li></ol>

   </li><li>
    <p>Otherwise, the character at <var title="">position</var> is the first
     character of a token. <a href="#collect">Collect a sequence of
     characters</a> that are not <a href="#space" title="space
     character">space characters</a>, and let that be <var title="">s</var>.

   </p></li><li>
    <p>If <var title="">s</var> is exactly equal to <var title="">token</var>, then:</p>

    <ol>
     <li>
      <p><a href="#skip-whitespace">Skip whitespace</a> (in <var title="">input</var>).

     </p></li><li>
      <p>Remove any <a href="#space" title="space character">space
       characters</a> currently at the end of <var title="">output</var>.

     </p></li><li>
      <p>If <var title="">position</var> is not past the end of <var title="">input</var>, and <var title="">output</var> is not the empty
       string, append a single U+0020 SPACE character at the end of <var title="">output</var>.
    </p></li></ol>

   </li><li>
    <p>Otherwise, append <var title="">s</var> to the end of <var title="">output</var>.

   </p></li><li>
    <p>Return to step 6 in the overall set of steps.
  </p></li></ol>

  <p class="note">This causes any occurrences of the token to be removed from
   the string, and any spaces that were surrounding the token to be collapsed
   to a single space, except at the start and end of the string, where such
   spaces are removed.

  </p><h4 id="keywords"><span class="secno">3.2.7. </span>Keywords and enumerated
   attributes</h4>

  <p>Some attributes are defined as taking one of a finite set of keywords.
   Such attributes are called <dfn id="enumerated" title="enumerated
   attribute">enumerated attributes</dfn>. The keywords are each defined to
   map to a particular <em>state</em> (several keywords might map to the same
   state, in which case some of the keywords are synonyms of each other;
   additionally, some of the keywords can be said to be non-conforming, and
   are only in the specification for historical reasons). In addition, two
   default states can be given. The first is the <em>invalid value
   default</em>, the second is the <em>missing value default</em>.

  </p><p>If an enumerated attribute is specified, the attribute's value must be
   one of the given keywords that are not said to be non-conforming, with no
   leading or trailing whitespace. The keyword may use any mix of uppercase
   and lowercase letters.<!-- XXX should
  say "uppercase and lowercase ASCII letters" or some such -->

  </p><p>When the attribute is specified, if its value
   <span>case-insensitively</span><!-- XXX ascii case folding --> matches one
   of the given keywords then that keyword's state is the state that the
   attribute represents. If the attribute value matches none of the given
   keywords, but the attribute has an <em>invalid value default</em>, then
   the attribute represents that state. Otherwise, if the attribute value
   matches none of the keywords but there is a <em>missing value default</em>
   state defined, then <em>that</em> is the state represented by the
   attribute. Otherwise, there is no default, and invalid values must simply
   be ignored.

  </p><p>When the attribute is <em>not</em> specified, if there is a <em>missing
   value default</em> state defined, then that is the state represented by
   the (missing) attribute. Otherwise, the absence of the attribute means
   that there is no state represented.

  </p><p class="note">The empty string can be one of the keywords in some cases.
   For example the <code title="attr-contenteditable"><a href="section-contenteditable.html#contenteditable0">contenteditable</a></code> attribute has two
   states: <em>true</em>, matching the <code title="">true</code> keyword and
   the empty string, <em>false</em>, matching <code title="">false</code> and
   all other keywords (it's the <em>invalid value default</em>). It could
   further be thought of as having a third state <em>inherit</em>, which
   would be the default when the attribute is not specified at all (the
   <em>missing value default</em>), but for various reasons that isn't the
   way this specification actually defines it.

  </p><h4 id="syntax-references"><span class="secno">3.2.8. </span>References</h4>

  <p>A <dfn id="valid7">valid hashed ID reference</dfn> to an element of type
   <var title="">type</var> is a string consisting of a U+0023 NUMBER SIGN
   (<code title="">#</code>) character followed by a string which exactly
   matches the value of the <code title="attr-id"><a href="section-global.html#id">id</a></code>
   attribute of an element in the document with type <var title="">type</var>.

  </p><p>The <dfn id="rules5">rules for parsing a hashed ID reference</dfn> to an
   element of type <var title="">type</var> are as follows:

  </p><ol>
   <li>
    <p>If the string being parsed does not contain a U+0023 NUMBER SIGN
     character, or if the first such character in the string is the last
     character in the string, then return null and abort these steps.

   </p></li><li>
    <p>Let <var title="">s</var> be the string from the character immediately
     after the first U+0023 NUMBER SIGN character in the string being parsed
     up to the end of that string.

   </p></li><li>
    <p>Return the first element of type <var title="">type</var> that has an
     <code title="attr-id"><a href="section-global.html#id">id</a></code> or <code title="">name</code> attribute whose value <!-- Unicode,
   apparently: <annevk> seems IE might be Unicode case-insensitive for
   ID [and name] values (related to <map> anyway, and at least for the
   character &euml; -->
     case-insensitively matches <var title="">s</var>.
  </p></li></ol>

  <script src="http://status.whatwg.org/annotate-web-apps.js" type="text/javascript"></script></body></html>
